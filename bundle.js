/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _animations = __webpack_require__(1);
	
	var _animations2 = _interopRequireDefault(_animations);
	
	var _start = __webpack_require__(9);
	
	var _start2 = _interopRequireDefault(_start);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	__webpack_require__(10);
	
	
	document.addEventListener("DOMContentLoaded", function () {
	  var canvas = document.getElementById('canvas');
	  var ctx = canvas.getContext('2d');
	  ctx.canvas.width = window.innerWidth;
	  ctx.canvas.height = window.innerHeight;
	
	  (0, _start2.default)(ctx, canvas);
	  (0, _animations2.default)(ctx, canvas);
	
	  var modal = document.getElementById('myModal');
	
	  document.addEventListener('keydown', function (e) {
	    e.preventDefault();
	    $('#myModal').addClass('fadeOut');
	
	    var footer = document.getElementById('footer');
	    footer.style.zIndex = '1';
	  });
	
	  window.onclick = function (e) {
	    e.preventDefault();
	    if (e.target === modal) {
	      $('#myModal').addClass('fadeOut');
	      var footer = document.getElementById('footer');
	      footer.style.zIndex = '1';
	    }
	  };
	});

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _animejs = __webpack_require__(2);
	
	var _animejs2 = _interopRequireDefault(_animejs);
	
	var _sound_set_ = __webpack_require__(3);
	
	var _sound_set_2 = __webpack_require__(4);
	
	var _sound_set_3 = __webpack_require__(5);
	
	var _sound_set_4 = __webpack_require__(6);
	
	var _howlerMin = __webpack_require__(7);
	
	var _howlerMin2 = _interopRequireDefault(_howlerMin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Animations = function Animations(ctx, canvas) {
	
	  //Set default state;
	  var numOfCircles = 25;
	  var distance = 300;
	  var actions = [];
	  var sound = void 0;
	
	  var colorSets = [
	  //colorset1
	  ["#f8ffe5", "#06D6A0", "#1B9AAA", "#EF476F", "#FFC43D"],
	  //colorset2
	  ["#5b507a", "#5B618A", "#9EADC8", "#B9E28C", "#D6D84F"],
	  //colorset3
	  ["#5bc0eb", "#f9c80e", "#41ead4", "#fdfffc", "#b91372"],
	  //colorset4
	  ["#f6e8ea", "#ef626c", "#de1a1a", "#acbed8", "#84dccf"]];
	
	  var fillSets = ["#312f2f", "#181819", "#0b111c", "#010e23"];
	
	  var soundSets = [_sound_set_.soundSet1, _sound_set_2.soundSet2, _sound_set_3.soundSet3, _sound_set_4.soundSet4];
	
	  var fontSize = function fontSize() {
	    return parseFloat(getComputedStyle(document.documentElement).fontSize);
	  };
	
	  var resizeCanvas = function resizeCanvas() {
	    canvas.width = window.innerWidth;
	    canvas.height = window.innerHeight;
	  };
	
	  var removeAction = function removeAction(action) {
	    var idx = actions.indexOf(action);
	    if (idx > -1) actions.splice(idx, 1);
	  };
	
	  var changeColorSet = function changeColorSet() {
	    var temp = colorSets.shift();
	    colorSets.push(temp);
	  };
	
	  var changeSoundSet = function changeSoundSet() {
	    var temp = soundSets.shift();
	    soundSets.push(temp);
	  };
	
	  var drawRipple = function drawRipple(x, y) {
	    //Choose a random colorset
	    var colorSet = colorSets[0];
	    var ripple = {};
	
	    ripple.x = x;
	    ripple.y = y;
	    ripple.color = colorSet[_animejs2.default.random(0, colorSet.length - 1)];
	    ripple.radius = 0;
	    ripple.alpha = 1;
	    ripple.lineWidth = 5;
	
	    ripple.draw = function () {
	      ctx.globalAlpha = ripple.alpha;
	      ctx.beginPath();
	      ctx.arc(ripple.x, ripple.y, ripple.radius, 2 * Math.PI, false);
	      ctx.lineWidth = ripple.lineWidth;
	      ctx.strokeStyle = ripple.color;
	      ctx.stroke();
	      ctx.globalAlpha = 1;
	    };
	
	    return ripple;
	  };
	
	  var drawCircle = function drawCircle(x, y) {
	    //Choose a random colorset
	    var colorSet = colorSets[0];
	    var circle = {};
	    circle.x = x;
	    circle.y = y;
	    circle.color = colorSet[_animejs2.default.random(0, colorSet.length - 1)];
	    circle.radius = _animejs2.default.random(fontSize(), fontSize() * 2);
	
	    circle.draw = function () {
	      ctx.beginPath();
	      ctx.arc(circle.x, circle.y, circle.radius, 2 * Math.PI, false);
	      ctx.fillStyle = circle.color;
	      ctx.fill();
	    };
	
	    return circle;
	  };
	
	  var drawCircles = function drawCircles(x, y) {
	    var circles = [];
	    for (var i = 0; i < numOfCircles; i++) {
	      var circle = drawCircle(x, y);
	      circles.push(circle);
	    }
	    return circles;
	  };
	
	  var animateRipple = function animateRipple(ripple, size) {
	    return (0, _animejs2.default)({
	      targets: ripple,
	      radius: function radius() {
	        return _animejs2.default.random(fontSize() * size, fontSize() * (size + 2));
	      },
	      lineWidth: 0,
	      alpha: {
	        value: 0,
	        easing: 'linear',
	        duration: function duration() {
	          return _animejs2.default.random(300, 500);
	        }
	      },
	      duration: function duration() {
	        return _animejs2.default.random(1000, 1300);
	      },
	      easing: 'easeOutExpo',
	      complete: removeAction
	    });
	  };
	
	  var animateCircles = function animateCircles(x, y) {
	    resizeCanvas();
	
	    //Draw shapes
	    var circles = drawCircles(x, y);
	    var ripple1 = drawRipple(x, y);
	    var ripple2 = drawRipple(x, y);
	    var ripple3 = drawRipple(x, y);
	
	    //Animate shapes
	    var circleAnimation = (0, _animejs2.default)({
	      targets: circles,
	      x: function x(circle) {
	        return circle.x + _animejs2.default.random(-distance, distance);
	      },
	      y: function y(circle) {
	        return circle.y + _animejs2.default.random(-distance, distance);
	      },
	      radius: 0,
	      duration: function duration() {
	        return _animejs2.default.random(1000, 1300);
	      },
	      easing: 'easeOutExpo',
	      complete: removeAction
	    });
	
	    //Animate ripples
	    var ripple1Animation = animateRipple(ripple1, 5);
	    var ripple2Animation = animateRipple(ripple2, 7);
	    var ripple3Animation = animateRipple(ripple3, 9);
	
	    actions.push(circleAnimation);
	    actions.push(ripple1Animation);
	    actions.push(ripple2Animation);
	    actions.push(ripple3Animation);
	  };
	
	  var animate = (0, _animejs2.default)({
	    duration: Infinity,
	    update: function update() {
	      ctx.clearRect(0, 0, canvas.width, canvas.height);
	      actions.forEach(function (action) {
	        action.animatables.forEach(function (animatable) {
	          animatable.target.draw();
	        });
	      });
	    }
	  });
	
	  //Update coordinates after animation
	  var x = void 0,
	      y = void 0;
	
	  var updateCoords = function updateCoords() {
	    x = Math.random() * canvas.width;
	    y = Math.random() * canvas.height;
	  };
	
	  var removeContainer = function removeContainer() {
	    $('#title').removeClass('pulse');
	    $('#description').removeClass('pulse');
	  };
	
	  var pulseContainer = function pulseContainer() {
	    $('#title').addClass('pulse');
	    $('#description').addClass('pulse');
	    setTimeout(removeContainer, 300);
	  };
	
	  var removeLogo = function removeLogo() {
	    $('#logo').removeClass('pulse');
	  };
	
	  var pulseLogo = function pulseLogo() {
	    $('#logo').addClass('pulse');
	    setTimeout(removeLogo, 300);
	  };
	
	  document.addEventListener('keydown', function (e) {
	    e.preventDefault();
	
	    //Spacebar to change colorset and soundset
	    if (e.keyCode === 32) {
	      changeColorSet();
	      changeSoundSet();
	
	      var el = $('#logo');
	      var offset = el.offset();
	      animateCircles(offset.left + 25, offset.top + 25);
	      pulseLogo();
	
	      sound = new Howl({
	        src: soundSets[0][e.keyCode]
	      });
	      sound.play();
	    }
	
	    //Number and letter key to play sound
	    if (e.keyCode >= 65 && e.keyCode <= 90) {
	      updateCoords();
	      animateCircles(x, y);
	      pulseContainer();
	
	      sound = new Howl({
	        src: soundSets[0][e.keyCode]
	      });
	      sound.play();
	    }
	  });
	
	  window.addEventListener('resize', resizeCanvas);
	};
	
	exports.default = Animations;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Anime v1.1.3
	 * http://anime-js.com
	 * JavaScript animation engine
	 * Copyright (c) 2016 Julian Garnier
	 * http://juliangarnier.com
	 * Released under the MIT license
	 */
	
	(function (root, factory) {
	  if (true) {
	    // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof module === 'object' && module.exports) {
	    // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory();
	  } else {
	    // Browser globals (root is window)
	    root.anime = factory();
	  }
	}(this, function () {
	
	  var version = '1.1.3';
	
	  // Defaults
	
	  var defaultSettings = {
	    duration: 1000,
	    delay: 0,
	    loop: false,
	    autoplay: true,
	    direction: 'normal',
	    easing: 'easeOutElastic',
	    elasticity: 400,
	    round: false,
	    begin: undefined,
	    update: undefined,
	    complete: undefined
	  }
	
	  // Transforms
	
	  var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY'];
	  var transform, transformStr = 'transform';
	
	  // Utils
	
	  var is = {
	    arr: function(a) { return Array.isArray(a) },
	    obj: function(a) { return Object.prototype.toString.call(a).indexOf('Object') > -1 },
	    svg: function(a) { return a instanceof SVGElement },
	    dom: function(a) { return a.nodeType || is.svg(a) },
	    num: function(a) { return !isNaN(parseInt(a)) },
	    str: function(a) { return typeof a === 'string' },
	    fnc: function(a) { return typeof a === 'function' },
	    und: function(a) { return typeof a === 'undefined' },
	    nul: function(a) { return typeof a === 'null' },
	    hex: function(a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a) },
	    rgb: function(a) { return /^rgb/.test(a) },
	    hsl: function(a) { return /^hsl/.test(a) },
	    col: function(a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)) }
	  }
	
	  // Easings functions adapted from http://jqueryui.com/
	
	  var easings = (function() {
	    var eases = {};
	    var names = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
	    var functions = {
	      Sine: function(t) { return 1 + Math.sin(Math.PI / 2 * t - Math.PI / 2); },
	      Circ: function(t) { return 1 - Math.sqrt( 1 - t * t ); },
	      Elastic: function(t, m) {
	        if( t === 0 || t === 1 ) return t;
	        var p = (1 - Math.min(m, 998) / 1000), st = t / 1, st1 = st - 1, s = p / ( 2 * Math.PI ) * Math.asin( 1 );
	        return -( Math.pow( 2, 10 * st1 ) * Math.sin( ( st1 - s ) * ( 2 * Math.PI ) / p ) );
	      },
	      Back: function(t) { return t * t * ( 3 * t - 2 ); },
	      Bounce: function(t) {
	        var pow2, bounce = 4;
	        while ( t < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
	        return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - t, 2 );
	      }
	    }
	    names.forEach(function(name, i) {
	      functions[name] = function(t) {
	        return Math.pow( t, i + 2 );
	      }
	    });
	    Object.keys(functions).forEach(function(name) {
	      var easeIn = functions[name];
	      eases['easeIn' + name] = easeIn;
	      eases['easeOut' + name] = function(t, m) { return 1 - easeIn(1 - t, m); };
	      eases['easeInOut' + name] = function(t, m) { return t < 0.5 ? easeIn(t * 2, m) / 2 : 1 - easeIn(t * -2 + 2, m) / 2; };
	      eases['easeOutIn' + name] = function(t, m) { return t < 0.5 ? (1 - easeIn(1 - 2 * t, m)) / 2 : (easeIn(t * 2 - 1, m) + 1) / 2; };
	    });
	    eases.linear = function(t) { return t; };
	    return eases;
	  })();
	
	  // Strings
	
	  var numberToString = function(val) {
	    return (is.str(val)) ? val : val + '';
	  }
	
	  var stringToHyphens = function(str) {
	    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	  }
	
	  var selectString = function(str) {
	    if (is.col(str)) return false;
	    try {
	      var nodes = document.querySelectorAll(str);
	      return nodes;
	    } catch(e) {
	      return false;
	    }
	  }
	
	  // Numbers
	
	  var random = function(min, max) {
	    return Math.floor(Math.random() * (max - min + 1)) + min;
	  }
	
	  // Arrays
	
	  var flattenArray = function(arr) {
	    return arr.reduce(function(a, b) {
	      return a.concat(is.arr(b) ? flattenArray(b) : b);
	    }, []);
	  }
	
	  var toArray = function(o) {
	    if (is.arr(o)) return o;
	    if (is.str(o)) o = selectString(o) || o;
	    if (o instanceof NodeList || o instanceof HTMLCollection) return [].slice.call(o);
	    return [o];
	  }
	
	  var arrayContains = function(arr, val) {
	    return arr.some(function(a) { return a === val; });
	  }
	
	  var groupArrayByProps = function(arr, propsArr) {
	    var groups = {};
	    arr.forEach(function(o) {
	      var group = JSON.stringify(propsArr.map(function(p) { return o[p]; }));
	      groups[group] = groups[group] || [];
	      groups[group].push(o);
	    });
	    return Object.keys(groups).map(function(group) {
	      return groups[group];
	    });
	  }
	
	  var removeArrayDuplicates = function(arr) {
	    return arr.filter(function(item, pos, self) {
	      return self.indexOf(item) === pos;
	    });
	  }
	
	  // Objects
	
	  var cloneObject = function(o) {
	    var newObject = {};
	    for (var p in o) newObject[p] = o[p];
	    return newObject;
	  }
	
	  var mergeObjects = function(o1, o2) {
	    for (var p in o2) o1[p] = !is.und(o1[p]) ? o1[p] : o2[p];
	    return o1;
	  }
	
	  // Colors
	
	  var hexToRgb = function(hex) {
	    var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	    var hex = hex.replace(rgx, function(m, r, g, b) { return r + r + g + g + b + b; });
	    var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	    var r = parseInt(rgb[1], 16);
	    var g = parseInt(rgb[2], 16);
	    var b = parseInt(rgb[3], 16);
	    return 'rgb(' + r + ',' + g + ',' + b + ')';
	  }
	
	  var hslToRgb = function(hsl) {
	    var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hsl);
	    var h = parseInt(hsl[1]) / 360;
	    var s = parseInt(hsl[2]) / 100;
	    var l = parseInt(hsl[3]) / 100;
	    var hue2rgb = function(p, q, t) {
	      if (t < 0) t += 1;
	      if (t > 1) t -= 1;
	      if (t < 1/6) return p + (q - p) * 6 * t;
	      if (t < 1/2) return q;
	      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	      return p;
	    }
	    var r, g, b;
	    if (s == 0) {
	      r = g = b = l;
	    } else {
	      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	      var p = 2 * l - q;
	      r = hue2rgb(p, q, h + 1/3);
	      g = hue2rgb(p, q, h);
	      b = hue2rgb(p, q, h - 1/3);
	    }
	    return 'rgb(' + r * 255 + ',' + g * 255 + ',' + b * 255 + ')';
	  }
	
	  var colorToRgb = function(val) {
	    if (is.rgb(val)) return val;
	    if (is.hex(val)) return hexToRgb(val);
	    if (is.hsl(val)) return hslToRgb(val);
	  }
	
	  // Units
	
	  var getUnit = function(val) {
	    return /([\+\-]?[0-9|auto\.]+)(%|px|pt|em|rem|in|cm|mm|ex|pc|vw|vh|deg)?/.exec(val)[2];
	  }
	
	  var addDefaultTransformUnit = function(prop, val, intialVal) {
	    if (getUnit(val)) return val;
	    if (prop.indexOf('translate') > -1) return getUnit(intialVal) ? val + getUnit(intialVal) : val + 'px';
	    if (prop.indexOf('rotate') > -1 || prop.indexOf('skew') > -1) return val + 'deg';
	    return val;
	  }
	
	  // Values
	
	  var getCSSValue = function(el, prop) {
	    // First check if prop is a valid CSS property
	    if (prop in el.style) {
	      // Then return the property value or fallback to '0' when getPropertyValue fails
	      return getComputedStyle(el).getPropertyValue(stringToHyphens(prop)) || '0';
	    }
	  }
	
	  var getTransformValue = function(el, prop) {
	    var defaultVal = prop.indexOf('scale') > -1 ? 1 : 0;
	    var str = el.style.transform;
	    if (!str) return defaultVal;
	    var rgx = /(\w+)\((.+?)\)/g;
	    var match = [];
	    var props = [];
	    var values = [];
	    while (match = rgx.exec(str)) {
	      props.push(match[1]);
	      values.push(match[2]);
	    }
	    var val = values.filter(function(f, i) { return props[i] === prop; });
	    return val.length ? val[0] : defaultVal;
	  }
	
	  var getAnimationType = function(el, prop) {
	    if ( is.dom(el) && arrayContains(validTransforms, prop)) return 'transform';
	    if ( is.dom(el) && (el.getAttribute(prop) || (is.svg(el) && el[prop]))) return 'attribute';
	    if ( is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) return 'css';
	    if (!is.nul(el[prop]) && !is.und(el[prop])) return 'object';
	  }
	
	  var getInitialTargetValue = function(target, prop) {
	    switch (getAnimationType(target, prop)) {
	      case 'transform': return getTransformValue(target, prop);
	      case 'css': return getCSSValue(target, prop);
	      case 'attribute': return target.getAttribute(prop);
	    }
	    return target[prop] || 0;
	  }
	
	  var getValidValue = function(values, val, originalCSS) {
	    if (is.col(val)) return colorToRgb(val);
	    if (getUnit(val)) return val;
	    var unit = getUnit(values.to) ? getUnit(values.to) : getUnit(values.from);
	    if (!unit && originalCSS) unit = getUnit(originalCSS);
	    return unit ? val + unit : val;
	  }
	
	  var decomposeValue = function(val) {
	    var rgx = /-?\d*\.?\d+/g;
	    return {
	      original: val,
	      numbers: numberToString(val).match(rgx) ? numberToString(val).match(rgx).map(Number) : [0],
	      strings: numberToString(val).split(rgx)
	    }
	  }
	
	  var recomposeValue = function(numbers, strings, initialStrings) {
	    return strings.reduce(function(a, b, i) {
	      var b = (b ? b : initialStrings[i - 1]);
	      return a + numbers[i - 1] + b;
	    });
	  }
	
	  // Animatables
	
	  var getAnimatables = function(targets) {
	    var targets = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
	    return targets.map(function(t, i) {
	      return { target: t, id: i };
	    });
	  }
	
	  // Properties
	
	  var getProperties = function(params, settings) {
	    var props = [];
	    for (var p in params) {
	      if (!defaultSettings.hasOwnProperty(p) && p !== 'targets') {
	        var prop = is.obj(params[p]) ? cloneObject(params[p]) : {value: params[p]};
	        prop.name = p;
	        props.push(mergeObjects(prop, settings));
	      }
	    }
	    return props;
	  }
	
	  var getPropertiesValues = function(target, prop, value, i) {
	    var values = toArray( is.fnc(value) ? value(target, i) : value);
	    return {
	      from: (values.length > 1) ? values[0] : getInitialTargetValue(target, prop),
	      to: (values.length > 1) ? values[1] : values[0]
	    }
	  }
	
	  // Tweens
	
	  var getTweenValues = function(prop, values, type, target) {
	    var valid = {};
	    if (type === 'transform') {
	      valid.from = prop + '(' + addDefaultTransformUnit(prop, values.from, values.to) + ')';
	      valid.to = prop + '(' + addDefaultTransformUnit(prop, values.to) + ')';
	    } else {
	      var originalCSS = (type === 'css') ? getCSSValue(target, prop) : undefined;
	      valid.from = getValidValue(values, values.from, originalCSS);
	      valid.to = getValidValue(values, values.to, originalCSS);
	    }
	    return { from: decomposeValue(valid.from), to: decomposeValue(valid.to) };
	  }
	
	  var getTweensProps = function(animatables, props) {
	    var tweensProps = [];
	    animatables.forEach(function(animatable, i) {
	      var target = animatable.target;
	      return props.forEach(function(prop) {
	        var animType = getAnimationType(target, prop.name);
	        if (animType) {
	          var values = getPropertiesValues(target, prop.name, prop.value, i);
	          var tween = cloneObject(prop);
	          tween.animatables = animatable;
	          tween.type = animType;
	          tween.from = getTweenValues(prop.name, values, tween.type, target).from;
	          tween.to = getTweenValues(prop.name, values, tween.type, target).to;
	          tween.round = (is.col(values.from) || tween.round) ? 1 : 0;
	          tween.delay = (is.fnc(tween.delay) ? tween.delay(target, i, animatables.length) : tween.delay) / animation.speed;
	          tween.duration = (is.fnc(tween.duration) ? tween.duration(target, i, animatables.length) : tween.duration) / animation.speed;
	          tweensProps.push(tween);
	        }
	      });
	    });
	    return tweensProps;
	  }
	
	  var getTweens = function(animatables, props) {
	    var tweensProps = getTweensProps(animatables, props);
	    var splittedProps = groupArrayByProps(tweensProps, ['name', 'from', 'to', 'delay', 'duration']);
	    return splittedProps.map(function(tweenProps) {
	      var tween = cloneObject(tweenProps[0]);
	      tween.animatables = tweenProps.map(function(p) { return p.animatables });
	      tween.totalDuration = tween.delay + tween.duration;
	      return tween;
	    });
	  }
	
	  var reverseTweens = function(anim, delays) {
	    anim.tweens.forEach(function(tween) {
	      var toVal = tween.to;
	      var fromVal = tween.from;
	      var delayVal = anim.duration - (tween.delay + tween.duration);
	      tween.from = toVal;
	      tween.to = fromVal;
	      if (delays) tween.delay = delayVal;
	    });
	    anim.reversed = anim.reversed ? false : true;
	  }
	
	  var getTweensDuration = function(tweens) {
	    return Math.max.apply(Math, tweens.map(function(tween){ return tween.totalDuration; }));
	  }
	
	  var getTweensDelay = function(tweens) {
	    return Math.min.apply(Math, tweens.map(function(tween){ return tween.delay; }));
	  }
	
	  // will-change
	
	  var getWillChange = function(anim) {
	    var props = [];
	    var els = [];
	    anim.tweens.forEach(function(tween) {
	      if (tween.type === 'css' || tween.type === 'transform' ) {
	        props.push(tween.type === 'css' ? stringToHyphens(tween.name) : 'transform');
	        tween.animatables.forEach(function(animatable) { els.push(animatable.target); });
	      }
	    });
	    return {
	      properties: removeArrayDuplicates(props).join(', '),
	      elements: removeArrayDuplicates(els)
	    }
	  }
	
	  var setWillChange = function(anim) {
	    var willChange = getWillChange(anim);
	    willChange.elements.forEach(function(element) {
	      element.style.willChange = willChange.properties;
	    });
	  }
	
	  var removeWillChange = function(anim) {
	    var willChange = getWillChange(anim);
	    willChange.elements.forEach(function(element) {
	      element.style.removeProperty('will-change');
	    });
	  }
	
	  /* Svg path */
	
	  var getPathProps = function(path) {
	    var el = is.str(path) ? selectString(path)[0] : path;
	    return {
	      path: el,
	      value: el.getTotalLength()
	    }
	  }
	
	  var snapProgressToPath = function(tween, progress) {
	    var pathEl = tween.path;
	    var pathProgress = tween.value * progress;
	    var point = function(offset) {
	      var o = offset || 0;
	      var p = progress > 1 ? tween.value + o : pathProgress + o;
	      return pathEl.getPointAtLength(p);
	    }
	    var p = point();
	    var p0 = point(-1);
	    var p1 = point(+1);
	    switch (tween.name) {
	      case 'translateX': return p.x;
	      case 'translateY': return p.y;
	      case 'rotate': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
	    }
	  }
	
	  // Progress
	
	  var getTweenProgress = function(tween, time) {
	    var elapsed = Math.min(Math.max(time - tween.delay, 0), tween.duration);
	    var percent = elapsed / tween.duration;
	    var progress = tween.to.numbers.map(function(number, p) {
	      var start = tween.from.numbers[p];
	      var eased = easings[tween.easing](percent, tween.elasticity);
	      var val = tween.path ? snapProgressToPath(tween, eased) : start + eased * (number - start);
	      val = tween.round ? Math.round(val * tween.round) / tween.round : val;
	      return val;
	    });
	    return recomposeValue(progress, tween.to.strings, tween.from.strings);
	  }
	
	  var setAnimationProgress = function(anim, time) {
	    var transforms;
	    anim.currentTime = time;
	    anim.progress = (time / anim.duration) * 100;
	    for (var t = 0; t < anim.tweens.length; t++) {
	      var tween = anim.tweens[t];
	      tween.currentValue = getTweenProgress(tween, time);
	      var progress = tween.currentValue;
	      for (var a = 0; a < tween.animatables.length; a++) {
	        var animatable = tween.animatables[a];
	        var id = animatable.id;
	        var target = animatable.target;
	        var name = tween.name;
	        switch (tween.type) {
	          case 'css': target.style[name] = progress; break;
	          case 'attribute': target.setAttribute(name, progress); break;
	          case 'object': target[name] = progress; break;
	          case 'transform':
	          if (!transforms) transforms = {};
	          if (!transforms[id]) transforms[id] = [];
	          transforms[id].push(progress);
	          break;
	        }
	      }
	    }
	    if (transforms) {
	      if (!transform) transform = (getCSSValue(document.body, transformStr) ? '' : '-webkit-') + transformStr;
	      for (var t in transforms) {
	        anim.animatables[t].target.style[transform] = transforms[t].join(' ');
	      }
	    }
	  }
	
	  // Animation
	
	  var createAnimation = function(params) {
	    var anim = {};
	    anim.animatables = getAnimatables(params.targets);
	    anim.settings = mergeObjects(params, defaultSettings);
	    anim.properties = getProperties(params, anim.settings);
	    anim.tweens = getTweens(anim.animatables, anim.properties);
	    anim.duration = anim.tweens.length ? getTweensDuration(anim.tweens) : params.duration;
	    anim.delay = anim.tweens.length ? getTweensDelay(anim.tweens) : params.delay;
	    anim.currentTime = 0;
	    anim.progress = 0;
	    anim.ended = false;
	    return anim;
	  }
	
	  // Public
	
	  var animations = [];
	  var raf = 0;
	
	  var engine = (function() {
	    var play = function() { raf = requestAnimationFrame(step); };
	    var step = function(t) {
	      if (animations.length) {
	        for (var i = 0; i < animations.length; i++) animations[i].tick(t);
	        play();
	      } else {
	        cancelAnimationFrame(raf);
	        raf = 0;
	      }
	    }
	    return play;
	  })();
	
	  var animation = function(params) {
	
	    var anim = createAnimation(params);
	    var time = {};
	
	    anim.tick = function(now) {
	      anim.ended = false;
	      if (!time.start) time.start = now;
	      time.current = Math.min(Math.max(time.last + now - time.start, 0), anim.duration);
	      setAnimationProgress(anim, time.current);
	      var s = anim.settings;
	      if (time.current >= anim.delay) {
	        if (s.begin) s.begin(anim); s.begin = undefined;
	        if (s.update) s.update(anim);
	      }
	      if (time.current >= anim.duration) {
	        if (s.loop) {
	          time.start = now;
	          if (s.direction === 'alternate') reverseTweens(anim, true);
	          if (is.num(s.loop)) s.loop--;
	        } else {
	          anim.ended = true;
	          anim.pause();
	          if (s.complete) s.complete(anim);
	        }
	        time.last = 0;
	      }
	    }
	
	    anim.seek = function(progress) {
	      setAnimationProgress(anim, (progress / 100) * anim.duration);
	    }
	
	    anim.pause = function() {
	      removeWillChange(anim);
	      var i = animations.indexOf(anim);
	      if (i > -1) animations.splice(i, 1);
	    }
	
	    anim.play = function(params) {
	      anim.pause();
	      if (params) anim = mergeObjects(createAnimation(mergeObjects(params, anim.settings)), anim);
	      time.start = 0;
	      time.last = anim.ended ? 0 : anim.currentTime;
	      var s = anim.settings;
	      if (s.direction === 'reverse') reverseTweens(anim);
	      if (s.direction === 'alternate' && !s.loop) s.loop = 1;
	      setWillChange(anim);
	      animations.push(anim);
	      if (!raf) engine();
	    }
	
	    anim.restart = function() {
	      if (anim.reversed) reverseTweens(anim);
	      anim.pause();
	      anim.seek(0);
	      anim.play();
	    }
	
	    if (anim.settings.autoplay) anim.play();
	
	    return anim;
	
	  }
	
	  // Remove one or multiple targets from all active animations.
	
	  var remove = function(elements) {
	    var targets = flattenArray(is.arr(elements) ? elements.map(toArray) : toArray(elements));
	    for (var i = animations.length-1; i >= 0; i--) {
	      var animation = animations[i];
	      var tweens = animation.tweens;
	      for (var t = tweens.length-1; t >= 0; t--) {
	        var animatables = tweens[t].animatables;
	        for (var a = animatables.length-1; a >= 0; a--) {
	          if (arrayContains(targets, animatables[a].target)) {
	            animatables.splice(a, 1);
	            if (!animatables.length) tweens.splice(t, 1);
	            if (!tweens.length) animation.pause();
	          }
	        }
	      }
	    }
	  }
	
	  animation.version = version;
	  animation.speed = 1;
	  animation.list = animations;
	  animation.remove = remove;
	  animation.easings = easings;
	  animation.getValue = getInitialTargetValue;
	  animation.path = getPathProps;
	  animation.random = random;
	
	  return animation;
	
	}));


/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var soundSet1 = exports.soundSet1 = {
	  32: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485317545/clap_ussscf.wav'],
	  65: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304441/1_xctwu8.mp3'],
	  66: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304445/2_ew0ciq.mp3'],
	  67: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304447/3_fvupmh.mp3'],
	  68: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304439/4_vmc6iv.mp3'],
	  69: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304451/5_dicr5q.mp3'],
	  70: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304444/6_w6kndp.mp3'],
	  71: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304442/7_fdvwdy.mp3'],
	  72: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304447/8_f5szkh.mp3'],
	  73: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304447/9_ddy3fb.mp3'],
	  74: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304450/10_zjbmnr.mp3'],
	  75: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304458/11_l0kj2j.mp3'],
	  76: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304449/12_hekw7o.mp3'],
	  77: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304452/13_ac0yri.mp3'],
	  78: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304448/14_mm6pxe.mp3'],
	  79: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304451/15_r8tapy.mp3'],
	  80: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304457/16_z3jqm7.mp3'],
	  81: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304463/17_zxtm4k.mp3'],
	  82: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304454/18_eaveqc.mp3'],
	  83: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304459/19_fuw8dd.mp3'],
	  84: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304457/20_bs9a8d.mp3'],
	  85: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304472/21_rqp5qt.mp3'],
	  86: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304471/22_j4kmta.mp3'],
	  87: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304470/23_yagbun.mp3'],
	  88: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304462/24_ze4ghc.mp3'],
	  89: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304468/25_tx4b4v.mp3'],
	  90: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304470/26_lnxzlb.mp3']
	};

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var soundSet2 = exports.soundSet2 = {
	  32: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485317545/clap_ussscf.wav'],
	  65: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305281/27_hyqs6f.mp3'],
	  66: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305284/28_a1xtxt.mp3'],
	  67: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305280/29_mhwpyu.mp3'],
	  68: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305288/30_iadkv9.mp3'],
	  69: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305286/31_udsesn.mp3'],
	  70: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305289/32_kovkgj.mp3'],
	  71: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305287/33_skjuep.mp3'],
	  72: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305283/34_lfodfp.mp3'],
	  73: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305286/35_nrcg0v.mp3'],
	  74: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305290/36_cey42w.mp3'],
	  75: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305288/37_lbptfv.mp3'],
	  76: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305290/38_o8gkzb.mp3'],
	  77: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305290/39_fr4ynq.mp3'],
	  78: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305295/40_uq5ksg.mp3'],
	  79: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305293/41_qberkg.mp3'],
	  80: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305293/42_apphhd.mp3'],
	  81: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305298/43_j8e8j8.mp3'],
	  82: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305298/44_aiakw0.mp3'],
	  83: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305299/45_msqxca.mp3'],
	  84: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305295/46_bkwvxn.mp3'],
	  85: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305296/47_d3rqhn.mp3'],
	  86: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305300/48_ft4tsc.mp3'],
	  87: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305300/49_dj3yeb.mp3'],
	  88: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305300/50_jkg6xg.mp3'],
	  89: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305301/51_yassg5.mp3'],
	  90: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305301/52_evxhyz.mp3']
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var soundSet3 = exports.soundSet3 = {
	  32: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485317545/clap_ussscf.wav'],
	  65: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306205/53_aweced.mp3'],
	  66: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306203/54_ybc8rq.mp3'],
	  67: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306203/55_fjox4o.mp3'],
	  68: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306209/56_bcecx7.mp3'],
	  69: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306212/57_iqzppi.mp3'],
	  70: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306205/58_edqghd.mp3'],
	  71: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306204/59_y19nub.mp3'],
	  72: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306207/60_fgtoai.mp3'],
	  73: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306208/61_tumyui.mp3'],
	  74: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306207/62_o5as3j.mp3'],
	  75: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306210/63_tzfy4v.mp3'],
	  76: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306208/64_p1lnfg.mp3'],
	  77: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306208/65_cemr0u.mp3'],
	  78: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306211/66_glvnjx.mp3'],
	  79: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306213/67_n1whl0.mp3'],
	  80: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306213/68_otaywp.mp3'],
	  81: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306212/69_pjnkdj.mp3'],
	  82: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306212/70_wrj9zu.mp3'],
	  83: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306216/71_alqewv.mp3'],
	  84: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306216/72_fc7au3.mp3'],
	  85: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306217/73_nf1wme.mp3'],
	  86: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306217/74_rislgn.mp3'],
	  87: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306219/75_papkff.mp3'],
	  88: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306217/76_xt1d0b.mp3'],
	  89: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306216/77_gskhyv.mp3'],
	  90: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306218/78_xrm1de.mp3']
	};

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var soundSet4 = exports.soundSet4 = {
	  32: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485317545/clap_ussscf.wav'],
	  65: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306306/79_qrx0gf.mp3'],
	  66: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306303/80_rneo7i.mp3'],
	  67: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306307/81_ueyfqz.mp3'],
	  68: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306306/82_nlepoo.mp3'],
	  69: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306314/83_l43vul.mp3'],
	  70: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306305/84_kanfri.mp3'],
	  71: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306305/85_hd93dy.mp3'],
	  72: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306306/86_v8ojzj.mp3'],
	  73: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306306/87_ciwyuf.mp3'],
	  74: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306307/88_s55fss.mp3'],
	  75: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306310/89_u34pa7.mp3'],
	  76: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306308/90_ewmsft.mp3'],
	  77: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306308/91_nslkjq.mp3'],
	  78: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306309/92_vvnwjn.mp3'],
	  79: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306312/93_lqj18n.mp3'],
	  80: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306310/94_dgalal.mp3'],
	  81: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306312/95_dpuxdg.mp3'],
	  82: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306315/96_a3rsno.mp3'],
	  83: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306315/97_meiv5c.mp3'],
	  84: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306312/98_zcijsy.mp3'],
	  85: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306315/99_gs8d3u.mp3'],
	  86: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306316/100_xmevws.mp3'],
	  87: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306316/101_cgeizj.mp3'],
	  88: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306318/102_cfkuny.mp3'],
	  89: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306319/103_hlrafb.mp3'],
	  90: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306318/104_s18lw0.mp3']
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*! howler.js v2.0.2 | (c) 2013-2016, James Simpson of GoldFire Studios | MIT License | howlerjs.com */
	!function () {
	  "use strict";
	  var e = function e() {
	    this.init();
	  };e.prototype = { init: function init() {
	      var e = this || n;return e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.mobileAutoEnable = !0, e._setup(), e;
	    }, volume: function volume(e) {
	      var t = this || n;if (e = parseFloat(e), t.ctx || _(), "undefined" != typeof e && e >= 0 && e <= 1) {
	        if (t._volume = e, t._muted) return t;t.usingWebAudio && (t.masterGain.gain.value = e);for (var o = 0; o < t._howls.length; o++) {
	          if (!t._howls[o]._webAudio) for (var r = t._howls[o]._getSoundIds(), u = 0; u < r.length; u++) {
	            var a = t._howls[o]._soundById(r[u]);a && a._node && (a._node.volume = a._volume * e);
	          }
	        }return t;
	      }return t._volume;
	    }, mute: function mute(e) {
	      var t = this || n;t.ctx || _(), t._muted = e, t.usingWebAudio && (t.masterGain.gain.value = e ? 0 : t._volume);for (var o = 0; o < t._howls.length; o++) {
	        if (!t._howls[o]._webAudio) for (var r = t._howls[o]._getSoundIds(), u = 0; u < r.length; u++) {
	          var a = t._howls[o]._soundById(r[u]);a && a._node && (a._node.muted = !!e || a._muted);
	        }
	      }return t;
	    }, unload: function unload() {
	      for (var e = this || n, t = e._howls.length - 1; t >= 0; t--) {
	        e._howls[t].unload();
	      }return e.usingWebAudio && e.ctx && "undefined" != typeof e.ctx.close && (e.ctx.close(), e.ctx = null, _()), e;
	    }, codecs: function codecs(e) {
	      return (this || n)._codecs[e.replace(/^x-/, "")];
	    }, _setup: function _setup() {
	      var e = this || n;if (e.state = e.ctx ? e.ctx.state || "running" : "running", e._autoSuspend(), !e.usingWebAudio) if ("undefined" != typeof Audio) try {
	        var t = new Audio();"undefined" == typeof t.oncanplaythrough && (e._canPlayEvent = "canplay");
	      } catch (n) {
	        e.noAudio = !0;
	      } else e.noAudio = !0;try {
	        var t = new Audio();t.muted && (e.noAudio = !0);
	      } catch (e) {}return e.noAudio || e._setupCodecs(), e;
	    }, _setupCodecs: function _setupCodecs() {
	      var e = this || n,
	          t = null;try {
	        t = "undefined" != typeof Audio ? new Audio() : null;
	      } catch (n) {
	        return e;
	      }if (!t || "function" != typeof t.canPlayType) return e;var o = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
	          r = e._navigator && e._navigator.userAgent.match(/OPR\/([0-6].)/g),
	          u = r && parseInt(r[0].split("/")[1], 10) < 33;return e._codecs = { mp3: !(u || !o && !t.canPlayType("audio/mp3;").replace(/^no$/, "")), mpeg: !!o, opus: !!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""), aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/m4a;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(t.canPlayType("audio/x-mp4;") || t.canPlayType("audio/mp4;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""), webm: !!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""), dolby: !!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")).replace(/^no$/, "") }, e;
	    }, _enableMobileAudio: function _enableMobileAudio() {
	      var e = this || n,
	          t = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(e._navigator && e._navigator.userAgent),
	          o = !!("ontouchend" in window || e._navigator && e._navigator.maxTouchPoints > 0 || e._navigator && e._navigator.msMaxTouchPoints > 0);if (!e._mobileEnabled && e.ctx && (t || o)) {
	        e._mobileEnabled = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);var r = function r() {
	          var n = e.ctx.createBufferSource();n.buffer = e._scratchBuffer, n.connect(e.ctx.destination), "undefined" == typeof n.start ? n.noteOn(0) : n.start(0), n.onended = function () {
	            n.disconnect(0), e._mobileEnabled = !0, e.mobileAutoEnable = !1, document.removeEventListener("touchend", r, !0);
	          };
	        };return document.addEventListener("touchend", r, !0), e;
	      }
	    }, _autoSuspend: function _autoSuspend() {
	      var e = this;if (e.autoSuspend && e.ctx && "undefined" != typeof e.ctx.suspend && n.usingWebAudio) {
	        for (var t = 0; t < e._howls.length; t++) {
	          if (e._howls[t]._webAudio) for (var o = 0; o < e._howls[t]._sounds.length; o++) {
	            if (!e._howls[t]._sounds[o]._paused) return e;
	          }
	        }return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout(function () {
	          e.autoSuspend && (e._suspendTimer = null, e.state = "suspending", e.ctx.suspend().then(function () {
	            e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume());
	          }));
	        }, 3e4), e;
	      }
	    }, _autoResume: function _autoResume() {
	      var e = this;if (e.ctx && "undefined" != typeof e.ctx.resume && n.usingWebAudio) return "running" === e.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state ? (e.state = "resuming", e.ctx.resume().then(function () {
	        e.state = "running";for (var n = 0; n < e._howls.length; n++) {
	          e._howls[n]._emit("resume");
	        }
	      }), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e;
	    } };var n = new e(),
	      t = function t(e) {
	    var n = this;return e.src && 0 !== e.src.length ? void n.init(e) : void console.error("An array of source files must be passed with any new Howl.");
	  };t.prototype = { init: function init(e) {
	      var t = this;return n.ctx || _(), t._autoplay = e.autoplay || !1, t._format = "string" != typeof e.format ? e.format : [e.format], t._html5 = e.html5 || !1, t._muted = e.mute || !1, t._loop = e.loop || !1, t._pool = e.pool || 5, t._preload = "boolean" != typeof e.preload || e.preload, t._rate = e.rate || 1, t._sprite = e.sprite || {}, t._src = "string" != typeof e.src ? e.src : [e.src], t._volume = void 0 !== e.volume ? e.volume : 1, t._duration = 0, t._state = "unloaded", t._sounds = [], t._endTimers = {}, t._queue = [], t._onend = e.onend ? [{ fn: e.onend }] : [], t._onfade = e.onfade ? [{ fn: e.onfade }] : [], t._onload = e.onload ? [{ fn: e.onload }] : [], t._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : [], t._onpause = e.onpause ? [{ fn: e.onpause }] : [], t._onplay = e.onplay ? [{ fn: e.onplay }] : [], t._onstop = e.onstop ? [{ fn: e.onstop }] : [], t._onmute = e.onmute ? [{ fn: e.onmute }] : [], t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : [], t._onrate = e.onrate ? [{ fn: e.onrate }] : [], t._onseek = e.onseek ? [{ fn: e.onseek }] : [], t._onresume = [], t._webAudio = n.usingWebAudio && !t._html5, "undefined" != typeof n.ctx && n.ctx && n.mobileAutoEnable && n._enableMobileAudio(), n._howls.push(t), t._autoplay && t._queue.push({ event: "play", action: function action() {
	          t.play();
	        } }), t._preload && t.load(), t;
	    }, load: function load() {
	      var e = this,
	          t = null;if (n.noAudio) return void e._emit("loaderror", null, "No audio support.");"string" == typeof e._src && (e._src = [e._src]);for (var r = 0; r < e._src.length; r++) {
	        var a, d;if (e._format && e._format[r]) a = e._format[r];else {
	          if (d = e._src[r], "string" != typeof d) {
	            e._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");continue;
	          }a = /^data:audio\/([^;,]+);/i.exec(d), a || (a = /\.([^.]+)$/.exec(d.split("?", 1)[0])), a && (a = a[1].toLowerCase());
	        }if (n.codecs(a)) {
	          t = e._src[r];break;
	        }
	      }return t ? (e._src = t, e._state = "loading", "https:" === window.location.protocol && "http:" === t.slice(0, 5) && (e._html5 = !0, e._webAudio = !1), new o(e), e._webAudio && u(e), e) : void e._emit("loaderror", null, "No codec support for selected audio sources.");
	    }, play: function play(e, t) {
	      var o = this,
	          r = null;if ("number" == typeof e) r = e, e = null;else {
	        if ("string" == typeof e && "loaded" === o._state && !o._sprite[e]) return null;if ("undefined" == typeof e) {
	          e = "__default";for (var u = 0, a = 0; a < o._sounds.length; a++) {
	            o._sounds[a]._paused && !o._sounds[a]._ended && (u++, r = o._sounds[a]._id);
	          }1 === u ? e = null : r = null;
	        }
	      }var d = r ? o._soundById(r) : o._inactiveSound();if (!d) return null;if (r && !e && (e = d._sprite || "__default"), "loaded" !== o._state && !o._sprite[e]) return o._queue.push({ event: "play", action: function action() {
	          o.play(o._soundById(d._id) ? d._id : void 0);
	        } }), d._id;if (r && !d._paused) return t || setTimeout(function () {
	        o._emit("play", d._id);
	      }, 0), d._id;o._webAudio && n._autoResume();var i = Math.max(0, d._seek > 0 ? d._seek : o._sprite[e][0] / 1e3),
	          _ = Math.max(0, (o._sprite[e][0] + o._sprite[e][1]) / 1e3 - i),
	          s = 1e3 * _ / Math.abs(d._rate);d._paused = !1, d._ended = !1, d._sprite = e, d._seek = i, d._start = o._sprite[e][0] / 1e3, d._stop = (o._sprite[e][0] + o._sprite[e][1]) / 1e3, d._loop = !(!d._loop && !o._sprite[e][2]);var l = d._node;if (o._webAudio) {
	        var f = function f() {
	          o._refreshBuffer(d);var e = d._muted || o._muted ? 0 : d._volume;l.gain.setValueAtTime(e, n.ctx.currentTime), d._playStart = n.ctx.currentTime, "undefined" == typeof l.bufferSource.start ? d._loop ? l.bufferSource.noteGrainOn(0, i, 86400) : l.bufferSource.noteGrainOn(0, i, _) : d._loop ? l.bufferSource.start(0, i, 86400) : l.bufferSource.start(0, i, _), s !== 1 / 0 && (o._endTimers[d._id] = setTimeout(o._ended.bind(o, d), s)), t || setTimeout(function () {
	            o._emit("play", d._id);
	          }, 0);
	        },
	            c = "running" === n.state;"loaded" === o._state && c ? f() : (o.once(c ? "load" : "resume", f, c ? d._id : null), o._clearTimer(d._id));
	      } else {
	        var p = function p() {
	          l.currentTime = i, l.muted = d._muted || o._muted || n._muted || l.muted, l.volume = d._volume * n.volume(), l.playbackRate = d._rate, setTimeout(function () {
	            l.play(), s !== 1 / 0 && (o._endTimers[d._id] = setTimeout(o._ended.bind(o, d), s)), t || o._emit("play", d._id);
	          }, 0);
	        },
	            m = "loaded" === o._state && (window && window.ejecta || !l.readyState && n._navigator.isCocoonJS);if (4 === l.readyState || m) p();else {
	          var v = function v() {
	            p(), l.removeEventListener(n._canPlayEvent, v, !1);
	          };l.addEventListener(n._canPlayEvent, v, !1), o._clearTimer(d._id);
	        }
	      }return d._id;
	    }, pause: function pause(e) {
	      var n = this;if ("loaded" !== n._state) return n._queue.push({ event: "pause", action: function action() {
	          n.pause(e);
	        } }), n;for (var t = n._getSoundIds(e), o = 0; o < t.length; o++) {
	        n._clearTimer(t[o]);var r = n._soundById(t[o]);if (r && !r._paused && (r._seek = n.seek(t[o]), r._rateSeek = 0, r._paused = !0, n._stopFade(t[o]), r._node)) if (n._webAudio) {
	          if (!r._node.bufferSource) return n;"undefined" == typeof r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), n._cleanBuffer(r._node);
	        } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();arguments[1] || n._emit("pause", r ? r._id : null);
	      }return n;
	    }, stop: function stop(e, n) {
	      var t = this;if ("loaded" !== t._state) return t._queue.push({ event: "stop", action: function action() {
	          t.stop(e);
	        } }), t;for (var o = t._getSoundIds(e), r = 0; r < o.length; r++) {
	        t._clearTimer(o[r]);var u = t._soundById(o[r]);if (u && (u._seek = u._start || 0, u._rateSeek = 0, u._paused = !0, u._ended = !0, t._stopFade(o[r]), u._node)) if (t._webAudio) {
	          if (!u._node.bufferSource) return n || t._emit("stop", u._id), t;"undefined" == typeof u._node.bufferSource.stop ? u._node.bufferSource.noteOff(0) : u._node.bufferSource.stop(0), t._cleanBuffer(u._node);
	        } else isNaN(u._node.duration) && u._node.duration !== 1 / 0 || (u._node.currentTime = u._start || 0, u._node.pause());u && !n && t._emit("stop", u._id);
	      }return t;
	    }, mute: function mute(e, t) {
	      var o = this;if ("loaded" !== o._state) return o._queue.push({ event: "mute", action: function action() {
	          o.mute(e, t);
	        } }), o;if ("undefined" == typeof t) {
	        if ("boolean" != typeof e) return o._muted;o._muted = e;
	      }for (var r = o._getSoundIds(t), u = 0; u < r.length; u++) {
	        var a = o._soundById(r[u]);a && (a._muted = e, o._webAudio && a._node ? a._node.gain.setValueAtTime(e ? 0 : a._volume, n.ctx.currentTime) : a._node && (a._node.muted = !!n._muted || e), o._emit("mute", a._id));
	      }return o;
	    }, volume: function volume() {
	      var e,
	          t,
	          o = this,
	          r = arguments;if (0 === r.length) return o._volume;if (1 === r.length || 2 === r.length && "undefined" == typeof r[1]) {
	        var u = o._getSoundIds(),
	            a = u.indexOf(r[0]);a >= 0 ? t = parseInt(r[0], 10) : e = parseFloat(r[0]);
	      } else r.length >= 2 && (e = parseFloat(r[0]), t = parseInt(r[1], 10));var d;if (!("undefined" != typeof e && e >= 0 && e <= 1)) return d = t ? o._soundById(t) : o._sounds[0], d ? d._volume : 0;if ("loaded" !== o._state) return o._queue.push({ event: "volume", action: function action() {
	          o.volume.apply(o, r);
	        } }), o;"undefined" == typeof t && (o._volume = e), t = o._getSoundIds(t);for (var i = 0; i < t.length; i++) {
	        d = o._soundById(t[i]), d && (d._volume = e, r[2] || o._stopFade(t[i]), o._webAudio && d._node && !d._muted ? d._node.gain.setValueAtTime(e, n.ctx.currentTime) : d._node && !d._muted && (d._node.volume = e * n.volume()), o._emit("volume", d._id));
	      }return o;
	    }, fade: function fade(e, t, o, r) {
	      var u = this,
	          a = Math.abs(e - t),
	          d = e > t ? "out" : "in",
	          i = a / .01,
	          _ = i > 0 ? o / i : o;if (_ < 4 && (i = Math.ceil(i / (4 / _)), _ = 4), "loaded" !== u._state) return u._queue.push({ event: "fade", action: function action() {
	          u.fade(e, t, o, r);
	        } }), u;u.volume(e, r);for (var s = u._getSoundIds(r), l = 0; l < s.length; l++) {
	        var f = u._soundById(s[l]);if (f) {
	          if (r || u._stopFade(s[l]), u._webAudio && !f._muted) {
	            var c = n.ctx.currentTime,
	                p = c + o / 1e3;f._volume = e, f._node.gain.setValueAtTime(e, c), f._node.gain.linearRampToValueAtTime(t, p);
	          }var m = e;f._interval = setInterval(function (e, n) {
	            i > 0 && (m += "in" === d ? .01 : -.01), m = Math.max(0, m), m = Math.min(1, m), m = Math.round(100 * m) / 100, u._webAudio ? ("undefined" == typeof r && (u._volume = m), n._volume = m) : u.volume(m, e, !0), m === t && (clearInterval(n._interval), n._interval = null, u.volume(m, e), u._emit("fade", e));
	          }.bind(u, s[l], f), _);
	        }
	      }return u;
	    }, _stopFade: function _stopFade(e) {
	      var t = this,
	          o = t._soundById(e);return o && o._interval && (t._webAudio && o._node.gain.cancelScheduledValues(n.ctx.currentTime), clearInterval(o._interval), o._interval = null, t._emit("fade", e)), t;
	    }, loop: function loop() {
	      var e,
	          n,
	          t,
	          o = this,
	          r = arguments;if (0 === r.length) return o._loop;if (1 === r.length) {
	        if ("boolean" != typeof r[0]) return t = o._soundById(parseInt(r[0], 10)), !!t && t._loop;e = r[0], o._loop = e;
	      } else 2 === r.length && (e = r[0], n = parseInt(r[1], 10));for (var u = o._getSoundIds(n), a = 0; a < u.length; a++) {
	        t = o._soundById(u[a]), t && (t._loop = e, o._webAudio && t._node && t._node.bufferSource && (t._node.bufferSource.loop = e, e && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop)));
	      }return o;
	    }, rate: function rate() {
	      var e,
	          t,
	          o = this,
	          r = arguments;if (0 === r.length) t = o._sounds[0]._id;else if (1 === r.length) {
	        var u = o._getSoundIds(),
	            a = u.indexOf(r[0]);a >= 0 ? t = parseInt(r[0], 10) : e = parseFloat(r[0]);
	      } else 2 === r.length && (e = parseFloat(r[0]), t = parseInt(r[1], 10));var d;if ("number" != typeof e) return d = o._soundById(t), d ? d._rate : o._rate;if ("loaded" !== o._state) return o._queue.push({ event: "rate", action: function action() {
	          o.rate.apply(o, r);
	        } }), o;"undefined" == typeof t && (o._rate = e), t = o._getSoundIds(t);for (var i = 0; i < t.length; i++) {
	        if (d = o._soundById(t[i])) {
	          d._rateSeek = o.seek(t[i]), d._playStart = o._webAudio ? n.ctx.currentTime : d._playStart, d._rate = e, o._webAudio && d._node && d._node.bufferSource ? d._node.bufferSource.playbackRate.value = e : d._node && (d._node.playbackRate = e);var _ = o.seek(t[i]),
	              s = (o._sprite[d._sprite][0] + o._sprite[d._sprite][1]) / 1e3 - _,
	              l = 1e3 * s / Math.abs(d._rate);!o._endTimers[t[i]] && d._paused || (o._clearTimer(t[i]), o._endTimers[t[i]] = setTimeout(o._ended.bind(o, d), l)), o._emit("rate", d._id);
	        }
	      }return o;
	    }, seek: function seek() {
	      var e,
	          t,
	          o = this,
	          r = arguments;if (0 === r.length) t = o._sounds[0]._id;else if (1 === r.length) {
	        var u = o._getSoundIds(),
	            a = u.indexOf(r[0]);a >= 0 ? t = parseInt(r[0], 10) : (t = o._sounds[0]._id, e = parseFloat(r[0]));
	      } else 2 === r.length && (e = parseFloat(r[0]), t = parseInt(r[1], 10));if ("undefined" == typeof t) return o;if ("loaded" !== o._state) return o._queue.push({ event: "seek", action: function action() {
	          o.seek.apply(o, r);
	        } }), o;var d = o._soundById(t);if (d) {
	        if (!("number" == typeof e && e >= 0)) {
	          if (o._webAudio) {
	            var i = o.playing(t) ? n.ctx.currentTime - d._playStart : 0,
	                _ = d._rateSeek ? d._rateSeek - d._seek : 0;return d._seek + (_ + i * Math.abs(d._rate));
	          }return d._node.currentTime;
	        }var s = o.playing(t);s && o.pause(t, !0), d._seek = e, d._ended = !1, o._clearTimer(t), s && o.play(t, !0), !o._webAudio && d._node && (d._node.currentTime = e), o._emit("seek", t);
	      }return o;
	    }, playing: function playing(e) {
	      var n = this;if ("number" == typeof e) {
	        var t = n._soundById(e);return !!t && !t._paused;
	      }for (var o = 0; o < n._sounds.length; o++) {
	        if (!n._sounds[o]._paused) return !0;
	      }return !1;
	    }, duration: function duration(e) {
	      var n = this,
	          t = n._duration,
	          o = n._soundById(e);return o && (t = n._sprite[o._sprite][1] / 1e3), t;
	    }, state: function state() {
	      return this._state;
	    }, unload: function unload() {
	      for (var e = this, t = e._sounds, o = 0; o < t.length; o++) {
	        t[o]._paused || (e.stop(t[o]._id), e._emit("end", t[o]._id)), e._webAudio || (t[o]._node.src = "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=", t[o]._node.removeEventListener("error", t[o]._errorFn, !1), t[o]._node.removeEventListener(n._canPlayEvent, t[o]._loadFn, !1)), delete t[o]._node, e._clearTimer(t[o]._id);var u = n._howls.indexOf(e);u >= 0 && n._howls.splice(u, 1);
	      }var a = !0;for (o = 0; o < n._howls.length; o++) {
	        if (n._howls[o]._src === e._src) {
	          a = !1;break;
	        }
	      }return r && a && delete r[e._src], n.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null;
	    }, on: function on(e, n, t, o) {
	      var r = this,
	          u = r["_on" + e];return "function" == typeof n && u.push(o ? { id: t, fn: n, once: o } : { id: t, fn: n }), r;
	    }, off: function off(e, n, t) {
	      var o = this,
	          r = o["_on" + e],
	          u = 0;if (n) {
	        for (u = 0; u < r.length; u++) {
	          if (n === r[u].fn && t === r[u].id) {
	            r.splice(u, 1);break;
	          }
	        }
	      } else if (e) o["_on" + e] = [];else {
	        var a = Object.keys(o);for (u = 0; u < a.length; u++) {
	          0 === a[u].indexOf("_on") && Array.isArray(o[a[u]]) && (o[a[u]] = []);
	        }
	      }return o;
	    }, once: function once(e, n, t) {
	      var o = this;return o.on(e, n, t, 1), o;
	    }, _emit: function _emit(e, n, t) {
	      for (var o = this, r = o["_on" + e], u = r.length - 1; u >= 0; u--) {
	        r[u].id && r[u].id !== n && "load" !== e || (setTimeout(function (e) {
	          e.call(this, n, t);
	        }.bind(o, r[u].fn), 0), r[u].once && o.off(e, r[u].fn, r[u].id));
	      }return o;
	    }, _loadQueue: function _loadQueue() {
	      var e = this;if (e._queue.length > 0) {
	        var n = e._queue[0];e.once(n.event, function () {
	          e._queue.shift(), e._loadQueue();
	        }), n.action();
	      }return e;
	    }, _ended: function _ended(e) {
	      var t = this,
	          o = e._sprite,
	          r = !(!e._loop && !t._sprite[o][2]);if (t._emit("end", e._id), !t._webAudio && r && t.stop(e._id, !0).play(e._id), t._webAudio && r) {
	        t._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = n.ctx.currentTime;var u = 1e3 * (e._stop - e._start) / Math.abs(e._rate);t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), u);
	      }return t._webAudio && !r && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, t._clearTimer(e._id), t._cleanBuffer(e._node), n._autoSuspend()), t._webAudio || r || t.stop(e._id), t;
	    }, _clearTimer: function _clearTimer(e) {
	      var n = this;return n._endTimers[e] && (clearTimeout(n._endTimers[e]), delete n._endTimers[e]), n;
	    }, _soundById: function _soundById(e) {
	      for (var n = this, t = 0; t < n._sounds.length; t++) {
	        if (e === n._sounds[t]._id) return n._sounds[t];
	      }return null;
	    }, _inactiveSound: function _inactiveSound() {
	      var e = this;e._drain();for (var n = 0; n < e._sounds.length; n++) {
	        if (e._sounds[n]._ended) return e._sounds[n].reset();
	      }return new o(e);
	    }, _drain: function _drain() {
	      var e = this,
	          n = e._pool,
	          t = 0,
	          o = 0;if (!(e._sounds.length < n)) {
	        for (o = 0; o < e._sounds.length; o++) {
	          e._sounds[o]._ended && t++;
	        }for (o = e._sounds.length - 1; o >= 0; o--) {
	          if (t <= n) return;e._sounds[o]._ended && (e._webAudio && e._sounds[o]._node && e._sounds[o]._node.disconnect(0), e._sounds.splice(o, 1), t--);
	        }
	      }
	    }, _getSoundIds: function _getSoundIds(e) {
	      var n = this;if ("undefined" == typeof e) {
	        for (var t = [], o = 0; o < n._sounds.length; o++) {
	          t.push(n._sounds[o]._id);
	        }return t;
	      }return [e];
	    }, _refreshBuffer: function _refreshBuffer(e) {
	      var t = this;return e._node.bufferSource = n.ctx.createBufferSource(), e._node.bufferSource.buffer = r[t._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop), e._node.bufferSource.playbackRate.value = e._rate, t;
	    }, _cleanBuffer: function _cleanBuffer(e) {
	      var n = this;if (n._scratchBuffer) {
	        e.bufferSource.onended = null, e.bufferSource.disconnect(0);try {
	          e.bufferSource.buffer = n._scratchBuffer;
	        } catch (e) {}
	      }return e.bufferSource = null, n;
	    } };var o = function o(e) {
	    this._parent = e, this.init();
	  };o.prototype = { init: function init() {
	      var e = this,
	          n = e._parent;return e._muted = n._muted, e._loop = n._loop, e._volume = n._volume, e._muted = n._muted, e._rate = n._rate, e._seek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = Math.round(Date.now() * Math.random()), n._sounds.push(e), e.create(), e;
	    }, create: function create() {
	      var e = this,
	          t = e._parent,
	          o = n._muted || e._muted || e._parent._muted ? 0 : e._volume;return t._webAudio ? (e._node = "undefined" == typeof n.ctx.createGain ? n.ctx.createGainNode() : n.ctx.createGain(), e._node.gain.setValueAtTime(o, n.ctx.currentTime), e._node.paused = !0, e._node.connect(n.masterGain)) : (e._node = new Audio(), e._errorFn = e._errorListener.bind(e), e._node.addEventListener("error", e._errorFn, !1), e._loadFn = e._loadListener.bind(e), e._node.addEventListener(n._canPlayEvent, e._loadFn, !1), e._node.src = t._src, e._node.preload = "auto", e._node.volume = o * n.volume(), e._node.load()), e;
	    }, reset: function reset() {
	      var e = this,
	          n = e._parent;return e._muted = n._muted, e._loop = n._loop, e._volume = n._volume, e._muted = n._muted, e._rate = n._rate, e._seek = 0, e._rateSeek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = Math.round(Date.now() * Math.random()), e;
	    }, _errorListener: function _errorListener() {
	      var e = this;e._parent._emit("loaderror", e._id, e._node.error ? e._node.error.code : 0), e._node.removeEventListener("error", e._errorListener, !1);
	    }, _loadListener: function _loadListener() {
	      var e = this,
	          t = e._parent;t._duration = Math.ceil(10 * e._node.duration) / 10, 0 === Object.keys(t._sprite).length && (t._sprite = { __default: [0, 1e3 * t._duration] }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue()), e._node.removeEventListener(n._canPlayEvent, e._loadFn, !1);
	    } };var r = {},
	      u = function u(e) {
	    var n = e._src;if (r[n]) return e._duration = r[n].duration, void i(e);if (/^data:[^;]+;base64,/.test(n)) {
	      for (var t = atob(n.split(",")[1]), o = new Uint8Array(t.length), u = 0; u < t.length; ++u) {
	        o[u] = t.charCodeAt(u);
	      }d(o.buffer, e);
	    } else {
	      var _ = new XMLHttpRequest();_.open("GET", n, !0), _.responseType = "arraybuffer", _.onload = function () {
	        var n = (_.status + "")[0];return "0" !== n && "2" !== n && "3" !== n ? void e._emit("loaderror", null, "Failed loading audio file with status: " + _.status + ".") : void d(_.response, e);
	      }, _.onerror = function () {
	        e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete r[n], e.load());
	      }, a(_);
	    }
	  },
	      a = function a(e) {
	    try {
	      e.send();
	    } catch (n) {
	      e.onerror();
	    }
	  },
	      d = function d(e, t) {
	    n.ctx.decodeAudioData(e, function (e) {
	      e && t._sounds.length > 0 && (r[t._src] = e, i(t, e));
	    }, function () {
	      t._emit("loaderror", null, "Decoding audio data failed.");
	    });
	  },
	      i = function i(e, n) {
	    n && !e._duration && (e._duration = n.duration), 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue());
	  },
	      _ = function _() {
	    try {
	      "undefined" != typeof AudioContext ? n.ctx = new AudioContext() : "undefined" != typeof webkitAudioContext ? n.ctx = new webkitAudioContext() : n.usingWebAudio = !1;
	    } catch (e) {
	      n.usingWebAudio = !1;
	    }var e = /iP(hone|od|ad)/.test(n._navigator && n._navigator.platform),
	        t = n._navigator && n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
	        o = t ? parseInt(t[1], 10) : null;if (e && o && o < 9) {
	      var r = /safari/.test(n._navigator && n._navigator.userAgent.toLowerCase());(n._navigator && n._navigator.standalone && !r || n._navigator && !n._navigator.standalone && !r) && (n.usingWebAudio = !1);
	    }n.usingWebAudio && (n.masterGain = "undefined" == typeof n.ctx.createGain ? n.ctx.createGainNode() : n.ctx.createGain(), n.masterGain.gain.value = 1, n.masterGain.connect(n.ctx.destination)), n._setup();
	  };"function" == "function" && __webpack_require__(8) && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return { Howler: n, Howl: t };
	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)), "undefined" != typeof exports && (exports.Howler = n, exports.Howl = t), "undefined" != typeof window ? (window.HowlerGlobal = e, window.Howler = n, window.Howl = t, window.Sound = o) : "undefined" != typeof global && (global.HowlerGlobal = e, global.Howler = n, global.Howl = t, global.Sound = o);
	}();
	/*! Spatial Plugin */
	!function () {
	  "use strict";
	  HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (e) {
	    var n = this;if (!n.ctx || !n.ctx.listener) return n;for (var t = n._howls.length - 1; t >= 0; t--) {
	      n._howls[t].stereo(e);
	    }return n;
	  }, HowlerGlobal.prototype.pos = function (e, n, t) {
	    var o = this;return o.ctx && o.ctx.listener ? (n = "number" != typeof n ? o._pos[1] : n, t = "number" != typeof t ? o._pos[2] : t, "number" != typeof e ? o._pos : (o._pos = [e, n, t], o.ctx.listener.setPosition(o._pos[0], o._pos[1], o._pos[2]), o)) : o;
	  }, HowlerGlobal.prototype.orientation = function (e, n, t, o, r, i) {
	    var a = this;if (!a.ctx || !a.ctx.listener) return a;var p = a._orientation;return n = "number" != typeof n ? p[1] : n, t = "number" != typeof t ? p[2] : t, o = "number" != typeof o ? p[3] : o, r = "number" != typeof r ? p[4] : r, i = "number" != typeof i ? p[5] : i, "number" != typeof e ? p : (a._orientation = [e, n, t, o, r, i], a.ctx.listener.setOrientation(e, n, t, o, r, i), a);
	  }, Howl.prototype.init = function (e) {
	    return function (n) {
	      var t = this;return t._orientation = n.orientation || [1, 0, 0], t._stereo = n.stereo || null, t._pos = n.pos || null, t._pannerAttr = { coneInnerAngle: "undefined" != typeof n.coneInnerAngle ? n.coneInnerAngle : 360, coneOuterAngle: "undefined" != typeof n.coneOuterAngle ? n.coneOuterAngle : 360, coneOuterGain: "undefined" != typeof n.coneOuterGain ? n.coneOuterGain : 0, distanceModel: "undefined" != typeof n.distanceModel ? n.distanceModel : "inverse", maxDistance: "undefined" != typeof n.maxDistance ? n.maxDistance : 1e4, panningModel: "undefined" != typeof n.panningModel ? n.panningModel : "HRTF", refDistance: "undefined" != typeof n.refDistance ? n.refDistance : 1, rolloffFactor: "undefined" != typeof n.rolloffFactor ? n.rolloffFactor : 1 }, t._onstereo = n.onstereo ? [{ fn: n.onstereo }] : [], t._onpos = n.onpos ? [{ fn: n.onpos }] : [], t._onorientation = n.onorientation ? [{ fn: n.onorientation }] : [], e.call(this, n);
	    };
	  }(Howl.prototype.init), Howl.prototype.stereo = function (n, t) {
	    var o = this;if (!o._webAudio) return o;if ("loaded" !== o._state) return o._queue.push({ event: "stereo", action: function action() {
	        o.stereo(n, t);
	      } }), o;var r = "undefined" == typeof Howler.ctx.createStereoPanner ? "spatial" : "stereo";if ("undefined" == typeof t) {
	      if ("number" != typeof n) return o._stereo;o._stereo = n, o._pos = [n, 0, 0];
	    }for (var i = o._getSoundIds(t), a = 0; a < i.length; a++) {
	      var p = o._soundById(i[a]);if (p) {
	        if ("number" != typeof n) return p._stereo;p._stereo = n, p._pos = [n, 0, 0], p._node && (p._pannerAttr.panningModel = "equalpower", p._panner && p._panner.pan || e(p, r), "spatial" === r ? p._panner.setPosition(n, 0, 0) : p._panner.pan.value = n), o._emit("stereo", p._id);
	      }
	    }return o;
	  }, Howl.prototype.pos = function (n, t, o, r) {
	    var i = this;if (!i._webAudio) return i;if ("loaded" !== i._state) return i._queue.push({ event: "pos", action: function action() {
	        i.pos(n, t, o, r);
	      } }), i;if (t = "number" != typeof t ? 0 : t, o = "number" != typeof o ? -.5 : o, "undefined" == typeof r) {
	      if ("number" != typeof n) return i._pos;i._pos = [n, t, o];
	    }for (var a = i._getSoundIds(r), p = 0; p < a.length; p++) {
	      var f = i._soundById(a[p]);if (f) {
	        if ("number" != typeof n) return f._pos;f._pos = [n, t, o], f._node && (f._panner && !f._panner.pan || e(f, "spatial"), f._panner.setPosition(n, t, o)), i._emit("pos", f._id);
	      }
	    }return i;
	  }, Howl.prototype.orientation = function (n, t, o, r) {
	    var i = this;if (!i._webAudio) return i;if ("loaded" !== i._state) return i._queue.push({ event: "orientation", action: function action() {
	        i.orientation(n, t, o, r);
	      } }), i;if (t = "number" != typeof t ? i._orientation[1] : t, o = "number" != typeof o ? i._orientation[2] : o, "undefined" == typeof r) {
	      if ("number" != typeof n) return i._orientation;i._orientation = [n, t, o];
	    }for (var a = i._getSoundIds(r), p = 0; p < a.length; p++) {
	      var f = i._soundById(a[p]);if (f) {
	        if ("number" != typeof n) return f._orientation;f._orientation = [n, t, o], f._node && (f._panner || (f._pos || (f._pos = i._pos || [0, 0, -.5]), e(f, "spatial")), f._panner.setOrientation(n, t, o)), i._emit("orientation", f._id);
	      }
	    }return i;
	  }, Howl.prototype.pannerAttr = function () {
	    var n,
	        t,
	        o,
	        r = this,
	        i = arguments;if (!r._webAudio) return r;if (0 === i.length) return r._pannerAttr;if (1 === i.length) {
	      if ("object" != _typeof(i[0])) return o = r._soundById(parseInt(i[0], 10)), o ? o._pannerAttr : r._pannerAttr;n = i[0], "undefined" == typeof t && (r._pannerAttr = { coneInnerAngle: "undefined" != typeof n.coneInnerAngle ? n.coneInnerAngle : r._coneInnerAngle, coneOuterAngle: "undefined" != typeof n.coneOuterAngle ? n.coneOuterAngle : r._coneOuterAngle, coneOuterGain: "undefined" != typeof n.coneOuterGain ? n.coneOuterGain : r._coneOuterGain, distanceModel: "undefined" != typeof n.distanceModel ? n.distanceModel : r._distanceModel, maxDistance: "undefined" != typeof n.maxDistance ? n.maxDistance : r._maxDistance, panningModel: "undefined" != typeof n.panningModel ? n.panningModel : r._panningModel, refDistance: "undefined" != typeof n.refDistance ? n.refDistance : r._refDistance, rolloffFactor: "undefined" != typeof n.rolloffFactor ? n.rolloffFactor : r._rolloffFactor });
	    } else 2 === i.length && (n = i[0], t = parseInt(i[1], 10));for (var a = r._getSoundIds(t), p = 0; p < a.length; p++) {
	      if (o = r._soundById(a[p])) {
	        var f = o._pannerAttr;f = { coneInnerAngle: "undefined" != typeof n.coneInnerAngle ? n.coneInnerAngle : f.coneInnerAngle, coneOuterAngle: "undefined" != typeof n.coneOuterAngle ? n.coneOuterAngle : f.coneOuterAngle, coneOuterGain: "undefined" != typeof n.coneOuterGain ? n.coneOuterGain : f.coneOuterGain, distanceModel: "undefined" != typeof n.distanceModel ? n.distanceModel : f.distanceModel, maxDistance: "undefined" != typeof n.maxDistance ? n.maxDistance : f.maxDistance, panningModel: "undefined" != typeof n.panningModel ? n.panningModel : f.panningModel, refDistance: "undefined" != typeof n.refDistance ? n.refDistance : f.refDistance, rolloffFactor: "undefined" != typeof n.rolloffFactor ? n.rolloffFactor : f.rolloffFactor };var s = o._panner;s ? (s.coneInnerAngle = f.coneInnerAngle, s.coneOuterAngle = f.coneOuterAngle, s.coneOuterGain = f.coneOuterGain, s.distanceModel = f.distanceModel, s.maxDistance = f.maxDistance, s.panningModel = f.panningModel, s.refDistance = f.refDistance, s.rolloffFactor = f.rolloffFactor) : (o._pos || (o._pos = r._pos || [0, 0, -.5]), e(o, "spatial"));
	      }
	    }return r;
	  }, Sound.prototype.init = function (e) {
	    return function () {
	      var n = this,
	          t = n._parent;n._orientation = t._orientation, n._stereo = t._stereo, n._pos = t._pos, n._pannerAttr = t._pannerAttr, e.call(this), n._stereo ? t.stereo(n._stereo) : n._pos && t.pos(n._pos[0], n._pos[1], n._pos[2], n._id);
	    };
	  }(Sound.prototype.init), Sound.prototype.reset = function (e) {
	    return function () {
	      var n = this,
	          t = n._parent;return n._orientation = t._orientation, n._pos = t._pos, n._pannerAttr = t._pannerAttr, e.call(this);
	    };
	  }(Sound.prototype.reset);var e = function e(_e, n) {
	    n = n || "spatial", "spatial" === n ? (_e._panner = Howler.ctx.createPanner(), _e._panner.coneInnerAngle = _e._pannerAttr.coneInnerAngle, _e._panner.coneOuterAngle = _e._pannerAttr.coneOuterAngle, _e._panner.coneOuterGain = _e._pannerAttr.coneOuterGain, _e._panner.distanceModel = _e._pannerAttr.distanceModel, _e._panner.maxDistance = _e._pannerAttr.maxDistance, _e._panner.panningModel = _e._pannerAttr.panningModel, _e._panner.refDistance = _e._pannerAttr.refDistance, _e._panner.rolloffFactor = _e._pannerAttr.rolloffFactor, _e._panner.setPosition(_e._pos[0], _e._pos[1], _e._pos[2]), _e._panner.setOrientation(_e._orientation[0], _e._orientation[1], _e._orientation[2])) : (_e._panner = Howler.ctx.createStereoPanner(), _e._panner.pan.value = _e._stereo), _e._panner.connect(_e._node), _e._paused || _e._parent.pause(_e._id, !0).play(_e._id);
	  };
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 8 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _animejs = __webpack_require__(2);
	
	var _animejs2 = _interopRequireDefault(_animejs);
	
	var _sound_set_ = __webpack_require__(3);
	
	var _howlerMin = __webpack_require__(7);
	
	var _howlerMin2 = _interopRequireDefault(_howlerMin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Start = function Start(ctx, canvas) {
	
	  var numOfCircles = 25;
	  var distance = 300;
	  var actions = [];
	  var sound = void 0;
	
	  var fontSize = function fontSize() {
	    return parseFloat(getComputedStyle(document.documentElement).fontSize);
	  };
	
	  var resizeCanvas = function resizeCanvas() {
	    canvas.width = window.innerWidth;
	    canvas.height = window.innerHeight;
	  };
	
	  var removeAction = function removeAction(action) {
	    var idx = actions.indexOf(action);
	    if (idx > -1) actions.splice(idx, 1);
	  };
	
	  var drawRipple = function drawRipple(x, y) {
	    //Choose a random colorset
	    var colorSet = ["#f8ffe5", "#06D6A0", "#1B9AAA", "#EF476F", "#FFC43D"];
	    var ripple = {};
	
	    ripple.x = x;
	    ripple.y = y;
	    ripple.color = colorSet[_animejs2.default.random(0, colorSet.length - 1)];
	    ripple.radius = 0;
	    ripple.alpha = 1;
	    ripple.lineWidth = 5;
	
	    ripple.draw = function () {
	      ctx.globalAlpha = ripple.alpha;
	      ctx.beginPath();
	      ctx.arc(ripple.x, ripple.y, ripple.radius, 2 * Math.PI, false);
	      ctx.lineWidth = ripple.lineWidth;
	      ctx.strokeStyle = ripple.color;
	      ctx.stroke();
	      ctx.globalAlpha = 1;
	    };
	
	    return ripple;
	  };
	
	  var drawCircle = function drawCircle(x, y) {
	    var colorSet = ["#f8ffe5", "#06D6A0", "#1B9AAA", "#EF476F", "#FFC43D"];
	    var circle = {};
	    circle.x = x;
	    circle.y = y;
	    circle.color = colorSet[_animejs2.default.random(0, colorSet.length - 1)];
	    circle.radius = _animejs2.default.random(fontSize(), fontSize() * 2);
	
	    circle.draw = function () {
	      ctx.beginPath();
	      ctx.arc(circle.x, circle.y, circle.radius, 2 * Math.PI, false);
	      ctx.fillStyle = circle.color;
	      ctx.fill();
	    };
	
	    return circle;
	  };
	
	  var drawCircles = function drawCircles(x, y) {
	    var circles = [];
	    for (var i = 0; i < numOfCircles; i++) {
	      var circle = drawCircle(x, y);
	      circles.push(circle);
	    }
	    return circles;
	  };
	
	  var animateRipple = function animateRipple(ripple, size) {
	    return (0, _animejs2.default)({
	      targets: ripple,
	      radius: function radius() {
	        return _animejs2.default.random(fontSize() * size, fontSize() * (size + 2));
	      },
	      lineWidth: 0,
	      alpha: {
	        value: 0,
	        easing: 'linear',
	        duration: function duration() {
	          return _animejs2.default.random(300, 500);
	        }
	      },
	      duration: function duration() {
	        return _animejs2.default.random(1000, 1300);
	      },
	      easing: 'easeOutExpo',
	      complete: removeAction
	    });
	  };
	
	  var animateCircles = function animateCircles(x, y) {
	    resizeCanvas();
	
	    //Draw shapes
	    var circles = drawCircles(x, y);
	    var ripple1 = drawRipple(x, y);
	    var ripple2 = drawRipple(x, y);
	    var ripple3 = drawRipple(x, y);
	
	    //Animate shapes
	    var circleAnimation = (0, _animejs2.default)({
	      targets: circles,
	      x: function x(circle) {
	        return circle.x + _animejs2.default.random(-distance, distance);
	      },
	      y: function y(circle) {
	        return circle.y + _animejs2.default.random(-distance, distance);
	      },
	      radius: 0,
	      duration: function duration() {
	        return _animejs2.default.random(1000, 1300);
	      },
	      easing: 'easeOutExpo',
	      complete: removeAction
	    });
	
	    //Animate ripples
	    var ripple1Animation = animateRipple(ripple1, 5);
	    var ripple2Animation = animateRipple(ripple2, 7);
	    var ripple3Animation = animateRipple(ripple3, 9);
	
	    actions.push(circleAnimation);
	    actions.push(ripple1Animation);
	    actions.push(ripple2Animation);
	    actions.push(ripple3Animation);
	  };
	
	  var removeContainer = function removeContainer() {
	    $('#title').removeClass('bounceIn');
	    $('#description').removeClass('bounceIn');
	  };
	
	  var pulseContainer = function pulseContainer() {
	    $('#title').addClass('bounceIn');
	    $('#description').addClass('bounceIn');
	    setTimeout(removeContainer, 300);
	  };
	
	  var removeLogo = function removeLogo() {
	    $('#logo').removeClass('bounceIn');
	  };
	
	  var pulseLogo = function pulseLogo() {
	    $('#logo').addClass('bounceIn');
	
	    var el = $('#logo');
	    var offset = el.offset();
	
	    animateCircles(offset.left, offset.top);
	    var animate = (0, _animejs2.default)({
	      duration: 1000,
	      update: function update() {
	        ctx.clearRect(0, 0, canvas.width, canvas.height);
	        actions.forEach(function (action) {
	          action.animatables.forEach(function (animatable) {
	            animatable.target.draw();
	          });
	        });
	      }
	    });
	
	    sound = new Howl({
	      src: _sound_set_.soundSet1[65]
	    });
	    sound.play();
	
	    setTimeout(removeLogo, 300);
	  };
	
	  var showModal = function showModal() {
	    var modal = document.getElementById('myModal');
	    modal.style.display = 'block';
	    $('#myModal').addClass('fadeIn');
	  };
	
	  setTimeout(pulseContainer, 500);
	  setTimeout(pulseLogo, 800);
	  setTimeout(showModal, 1000);
	};
	
	exports.default = Start;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, __dirname) {'use strict'
	
	var logger = __webpack_require__(12)
	var semver = __webpack_require__(214)
	
	var message
	var agent
	
	var agentVersion = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version
	logger.info(
	  "Using New Relic for Node.js. Agent version: %s; Node version: %s.",
	  agentVersion, process.version
	)
	
	if (__webpack_require__.c.__NR_cache) {
	  logger.warn(
	    'Attempting to load a second copy of newrelic from %s, using cache instead',
	    __dirname
	  )
	  module.exports = __webpack_require__.c.__NR_cache
	} else {
	  initialize()
	}
	
	function initialize() {
	  logger.debug(
	    'Loading agent from %s',
	    __dirname
	  )
	
	  try {
	    logger.debug("Process was running %s seconds before agent was loaded.",
	                 process.uptime())
	    // Technically we run on 0.6, until we verify there are 0 users on 0.6, we
	    // should leave this code doing a check against 0.6, but then advise that
	    // people upgrade to one of our officially supported version (0.8 and higher)
	    if (semver.satisfies(process.version, '<0.6.0')) {
	      message = "New Relic for Node.js requires a version of Node equal to or\n" +
	                "greater than 0.8.0. Not starting!"
	
	      logger.error(message)
	      throw new Error(message)
	    }
	
	    logger.debug("Current working directory at module load is %s.", process.cwd())
	    logger.debug("Process title is %s.", process.title)
	    logger.debug("Application was invoked as %s.", process.argv.join(' '))
	
	    /* Loading the configuration can throw if a configuration file isn't found and
	     * the environment variable NEW_RELIC_NO_CONFIG_FILE isn't set.
	     */
	    var config = __webpack_require__(57).initialize()
	    if (!config.agent_enabled) {
	      logger.info("Module not enabled in configuration; not starting.")
	    } else {
	      /* Only load the rest of the module if configuration is available and the
	       * configurator didn't throw.
	       *
	       * The agent must be a singleton, or else module loading will be patched
	       * multiple times, with undefined results. New Relic's instrumentation
	       * can't be enabled or disabled without an application restart.
	       */
	      var Agent = __webpack_require__(93)
	      agent = new Agent(config)
	      var appNames = agent.config.applications()
	
	      if (config.logging.diagnostics) {
	        logger.warn(
	          'Diagnostics logging is enabled, this may cause significant overhead.'
	        )
	      }
	
	      if (appNames.length < 1) {
	        message = "New Relic requires that you name this application!\n" +
	                  "Set app_name in your newrelic.js file or set environment variable\n" +
	                  "NEW_RELIC_APP_NAME. Not starting!"
	        logger.error(message)
	        throw new Error(message)
	      }
	
	      var shimmer = __webpack_require__(199)
	      shimmer.patchModule(agent)
	      shimmer.bootstrapInstrumentation(agent)
	
	      agent.start(function cb_start(error) {
	        if (!error) {
	          return logger.debug("New Relic for Node.js is connected to New Relic.")
	        }
	
	        var errorMessage = "New Relic for Node.js halted startup due to an error:"
	        logger.error(error, errorMessage)
	
	        console.error(errorMessage)
	        console.error(error.stack)
	      })
	    }
	  } catch (error) {
	    message = "New Relic for Node.js was unable to bootstrap itself due to an error:"
	    logger.error(error, message)
	
	    console.error(message)
	    console.error(error.stack)
	  }
	
	  var API
	  if (agent) {
	    API = __webpack_require__(241)
	  } else {
	    API = __webpack_require__(242)
	  }
	
	  __webpack_require__.c.__NR_cache = module.exports = new API(agent)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), "/"))

/***/ },
/* 11 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var Logger = __webpack_require__(13)
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	// create bootstrapping logger
	module.exports = new Logger({
	  name: 'newrelic_bootstrap',
	  stream: process.stdout,
	  level: 'info'
	})
	
	/**
	 * Don't load config.js until this point, because it requires this
	 * module, and if it gets loaded too early, module.exports will have no
	 * value.
	 */
	var config = __webpack_require__(57).initialize()
	
	var options = {
	  name: 'newrelic',
	  level: config.logging.level,
	  enabled: config.logging.enabled
	}
	
	// create the "real" logger
	module.exports = new Logger(options)
	
	if (config.logging.enabled) {
	  var stream
	  switch (config.logging.filepath) {
	    case 'stdout':
	      stream = process.stdout
	      break
	
	    case 'stderr':
	      stream = process.stderr
	      break
	
	    default:
	      stream = fs.createWriteStream(config.logging.filepath, {flags: 'a+'})
	      stream.on('error', function logStreamOnError(err) {
	        /* eslint-disable no-console */
	        // Since our normal logging didn't work, dump this to stderr.
	        console.error('New Relic failed to open log file ' + config.logging.filepath)
	        console.error(err)
	        /* eslint-enable no-console */
	      })
	  }
	  module.exports.pipe(stream)
	}
	
	// now tell the config module to switch to the real logger
	config.setLogger(module.exports)
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var stringifySync = __webpack_require__(14).stringifySync
	var util = __webpack_require__(16)
	var Readable = __webpack_require__(19)
	var os = __webpack_require__(56)
	
	module.exports = Logger
	
	var LEVELS = {
	  'trace': 10,
	  'debug': 20,
	  'info': 30,
	  'warn': 40,
	  'error': 50,
	  'fatal': 60
	}
	
	util.inherits(Logger, Readable)
	
	function Logger(options, extra) {
	  if (!(this instanceof Logger)) {
	    return new Logger(options, extra)
	  }
	
	  Readable.call(this)
	  var passedInLevel = this.coerce(options.level)
	  this.options = {
	    _level: passedInLevel,
	    enabled: options.enabled === undefined ? true : options.enabled
	  }
	  this.name = options.name
	  this.hostname = options.hostname || os.hostname()
	  this.extra = extra || {}
	  this.buffer = ''
	  this.reading = false
	  if (options.stream) {
	    this.pipe(options.stream)
	  }
	}
	
	var loggingFunctions = {}
	
	Object.keys(LEVELS).forEach(function buildLevel(_level) {
	  function log(extra) {
	    var level = Logger.prototype.coerce(LEVELS[_level])
	    if (!this.options.enabled) return false
	    if (level < this.options._level) return false
	
	    var has_extra = typeof extra === 'object'
	    var args = Array.prototype.slice.call(arguments, has_extra ? 1 : 0)
	    return this.write(level, args, has_extra ? extra : null)
	  }
	
	  loggingFunctions[_level] = function checkLevel() {
	    log.apply(this, arguments)
	  }
	
	  var seenMessages = {}
	  loggingFunctions[_level + 'Once'] = function logOnce(key) {
	    if (typeof key !== 'string') {
	      this.debug('Attempted to key on a non-string in ' + _level + 'Once: ' + key)
	      return
	    }
	
	    var level = Logger.prototype.coerce(LEVELS[_level])
	    if (!this.options.enabled) return false
	    if (level < this.options._level) return false
	
	    if (seenMessages[key] !== true) {
	      var args = Array.prototype.slice.call(arguments, 1)
	      var writeSuccessful = log.apply(this, args)
	
	      if (writeSuccessful) {
	        seenMessages[key] = true
	      }
	    }
	  }
	
	  var seenPerInterval = {}
	  loggingFunctions[_level + 'OncePer'] = function logOncePer(key, interval) {
	    if (typeof key !== 'string') {
	      this.debug('Attempted to key on a non-string in ' + _level + 'Once: ' + key)
	      return
	    }
	
	    var level = Logger.prototype.coerce(LEVELS[_level])
	    if (!this.options.enabled) return false
	    if (level < this.options._level) return false
	
	    if (seenPerInterval[key] !== true) {
	      var args = Array.prototype.slice.call(arguments, 2)
	      var writeSuccessful = log.apply(this, args)
	
	      if (writeSuccessful) {
	        seenPerInterval[key] = true
	
	        var clearSeen = setTimeout(function clearKey() {
	          delete seenPerInterval[key]
	        }, interval)
	
	        if (clearSeen.unref !== undefined) {
	          clearSeen.unref()
	        }
	      }
	    }
	  }
	})
	
	util._extend(Logger.prototype, loggingFunctions)
	
	Logger.prototype.coerce = function coerce(value) {
	  if (!isNaN(parseInt(value, 10)) && isFinite(value)) {
	    // value is numeric
	    if (value < 10) value = 10
	    if (value > 60) value = 60
	
	    return value
	  }
	  return LEVELS[value] || 50
	}
	
	Logger.prototype.child = function child(extra) {
	  var childLogger = Object.create(loggingFunctions)
	
	  childLogger.extra = util._extend({}, this.extra)
	  util._extend(childLogger.extra, extra)
	
	  var parent = this
	  childLogger.options = parent.options
	
	  childLogger.write = function write(level, args, extra) {
	    extra = getPropertiesToLog(extra)
	    var selfExtra = util._extend({}, this.extra)
	
	    extra = util._extend(selfExtra, extra)
	    return parent.write(level, args, extra)
	  }
	
	  childLogger.setEnabled = Logger.prototype.setEnabled
	  childLogger.child = Logger.prototype.child
	
	  return childLogger
	}
	
	Logger.prototype.level = function level(lvl) {
	  this.options._level = this.coerce(lvl)
	}
	
	Logger.prototype.setEnabled = function setEnabled(enabled) {
	  if (typeof enabled === 'boolean') {
	    this.options.enabled = enabled
	  }
	}
	
	Logger.prototype._read = function _read() {
	  if (this.buffer.length !== 0) {
	    this.reading = this.push(this.buffer)
	    this.buffer = ''
	  } else {
	    this.reading = true
	  }
	}
	
	/**
	 * For performance reasons we do not support %j because we will have
	 * already converted the objects to strings.
	 * Returns a boolean representing the status of the write
	 * (success/failure)
	 */
	Logger.prototype.write = function write(level, args, extra) {
	  for (var i = 0, l = args.length; i < l; ++i) {
	    if (typeof args[i] === 'function') {
	      args[i] = args[i].valueOf()
	    } else if (typeof args[i] === 'object') {
	      args[i] = stringifySync(args[i])
	    }
	  }
	
	  var entry = new Entry(this, level, util.format.apply(util, args))
	
	  util._extend(entry, this.extra)
	  util._extend(entry, getPropertiesToLog(extra))
	
	  if (this.reading) {
	    this.reading = this.push(stringifySync(entry) + '\n')
	  } else {
	    this.buffer += stringifySync(entry) + '\n'
	  }
	  return true
	}
	
	function Entry(logger, level, msg) {
	  this.v = 0
	  this.level = level
	  this.name = logger.name
	  this.hostname = logger.hostname
	  this.pid = process.pid
	  this.time = new Date().toISOString()
	  this.msg = msg
	}
	
	function getPropertiesToLog(extra) {
	  var obj = util._extend({}, extra)
	  // Error properties (message, stack) are not enumerable, so getting them directly
	  if (extra instanceof Error) {
	    var names = Object.getOwnPropertyNames(extra)
	    if (names) {
	      for (var i = 0; i < names.length; i++) {
	        obj[names[i]] = extra[names[i]]
	      }
	    }
	  }
	  return obj
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var stringifySafe = __webpack_require__(15)
	
	module.exports = {
	  parse: function parseAsync(str, cb) {
	    try {
	      cb(null, JSON.parse(str))
	    } catch (err) {
	      cb(err, null)
	    }
	  },
	
	  stringify: function stringifyAsync(obj, cb) {
	    try {
	      cb(null, stringifySafe(obj))
	    } catch (err) {
	      cb(err, '[UNPARSABLE OBJECT]')
	    }
	  },
	
	  stringifySync: function stringifySync(obj, returnVal) {
	    try {
	      return stringifySafe(obj)
	    } catch (err) {
	      return returnVal || '[UNPARSABLE OBJECT]'
	    }
	  }
	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	exports = module.exports = stringify
	exports.getSerialize = serializer
	
	function stringify(obj, replacer, spaces, cycleReplacer) {
	  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
	}
	
	function serializer(replacer, cycleReplacer) {
	  var stack = [], keys = []
	
	  if (cycleReplacer == null) cycleReplacer = function(key, value) {
	    if (stack[0] === value) return "[Circular ~]"
	    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
	  }
	
	  return function(key, value) {
	    if (stack.length > 0) {
	      var thisPos = stack.indexOf(this)
	      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
	      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
	      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
	    }
	    else stack.push(value)
	
	    return replacer == null ? value : replacer.call(this, key, value)
	  }
	}


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(17);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(18);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(11)))

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 18 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = __webpack_require__(20);
	exports.Stream = __webpack_require__(27);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(52);
	exports.Duplex = __webpack_require__(51);
	exports.Transform = __webpack_require__(54);
	exports.PassThrough = __webpack_require__(55);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(27);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(21);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(22).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(26).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(27);
	
	/*<replacement>*/
	var util = __webpack_require__(48);
	util.inherits = __webpack_require__(49);
	/*</replacement>*/
	
	var StringDecoder;
	
	
	/*<replacement>*/
	var debug = __webpack_require__(50);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(51);
	
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(53).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  var Duplex = __webpack_require__(51);
	
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      if (!addToFront)
	        state.reading = false;
	
	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);
	
	        if (state.needReadable)
	          emitReadable(stream);
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(53).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }
	
	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);
	
	  if (!util.isNull(ret))
	    this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }
	
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}
	
	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}
	
	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(23)
	var ieee754 = __webpack_require__(24)
	var isArray = __webpack_require__(25)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}
	
	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}
	
	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)
	
	  arr = new Arr(len * 3 / 4 - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ },
/* 24 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 25 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 26 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(26).EventEmitter;
	var inherits = __webpack_require__(28);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(29);
	Stream.Writable = __webpack_require__(44);
	Stream.Duplex = __webpack_require__(45);
	Stream.Transform = __webpack_require__(46);
	Stream.PassThrough = __webpack_require__(47);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 28 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(27); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(30);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(37);
	exports.Duplex = __webpack_require__(36);
	exports.Transform = __webpack_require__(42);
	exports.PassThrough = __webpack_require__(43);
	
	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = Readable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(31);
	/*</replacement>*/
	
	/*<replacement>*/
	var isArray = __webpack_require__(25);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(26).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(27);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(26).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(22).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(32);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(33);
	util.inherits = __webpack_require__(28);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(34);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(35);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(36);
	
	  options = options || {};
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(41).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(36);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options && typeof options.read === 'function') this._read = options.read;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	
	      if (!addToFront) state.reading = false;
	
	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(41).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }
	
	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var buffer = __webpack_require__(22);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 34 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Buffer = __webpack_require__(22).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(32);
	/*</replacement>*/
	
	module.exports = BufferList;
	
	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	
	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	
	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};
	
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(31);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(33);
	util.inherits = __webpack_require__(28);
	/*</replacement>*/
	
	var Readable = __webpack_require__(30);
	var Writable = __webpack_require__(37);
	
	util.inherits(Duplex, Readable);
	
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	module.exports = Writable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(31);
	/*</replacement>*/
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(33);
	util.inherits = __webpack_require__(28);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(40)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(27);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(26).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(22).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(32);
	/*</replacement>*/
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(36);
	
	  options = options || {};
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}
	
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(36);
	
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), __webpack_require__(38).setImmediate))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(39);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(11)))

/***/ },
/* 40 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(22).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(36);
	
	/*<replacement>*/
	var util = __webpack_require__(33);
	util.inherits = __webpack_require__(28);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(this);
	
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  // When the writable side finishes, then flush out anything remaining.
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er, data) {
	      done(stream, er, data);
	    });else done(stream);
	  });
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(42);
	
	/*<replacement>*/
	var util = __webpack_require__(33);
	util.inherits = __webpack_require__(28);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(37)


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(36)


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(42)


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(43)


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 49 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 50 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(48);
	util.inherits = __webpack_require__(49);
	/*</replacement>*/
	
	var Readable = __webpack_require__(20);
	var Writable = __webpack_require__(52);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(22).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(48);
	util.inherits = __webpack_require__(49);
	/*</replacement>*/
	
	var Stream = __webpack_require__(27);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(51);
	
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(51);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (!util.isFunction(cb))
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function() {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function() {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);
	
	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });
	
	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }
	
	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }
	
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(22).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(51);
	
	/*<replacement>*/
	var util = __webpack_require__(48);
	util.inherits = __webpack_require__(49);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (!util.isNullOrUndefined(data))
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(54);
	
	/*<replacement>*/
	var util = __webpack_require__(48);
	util.inherits = __webpack_require__(49);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 56 */
/***/ function(module, exports) {

	exports.endianness = function () { return 'LE' };
	
	exports.hostname = function () {
	    if (typeof location !== 'undefined') {
	        return location.hostname
	    }
	    else return '';
	};
	
	exports.loadavg = function () { return [] };
	
	exports.uptime = function () { return 0 };
	
	exports.freemem = function () {
	    return Number.MAX_VALUE;
	};
	
	exports.totalmem = function () {
	    return Number.MAX_VALUE;
	};
	
	exports.cpus = function () { return [] };
	
	exports.type = function () { return 'Browser' };
	
	exports.release = function () {
	    if (typeof navigator !== 'undefined') {
	        return navigator.appVersion;
	    }
	    return '';
	};
	
	exports.networkInterfaces
	= exports.getNetworkInterfaces
	= function () { return {} };
	
	exports.arch = function () { return 'javascript' };
	
	exports.platform = function () { return 'browser' };
	
	exports.tmpdir = exports.tmpDir = function () {
	    return '/tmp';
	};
	
	exports.EOL = '\n';


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname, process, Buffer) {'use strict'
	
	var util = __webpack_require__(16)
	var path = __webpack_require__(58)
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var EventEmitter = __webpack_require__(26).EventEmitter
	var NAMES = __webpack_require__(59)
	var feature_flag = __webpack_require__(60)
	var flatten = __webpack_require__(61)
	var hashes = __webpack_require__(62)
	var exists = fs.existsSync || path.existsSync
	var safeJSON = __webpack_require__(14)
	var stringifySync = safeJSON.stringifySync
	var parse = safeJSON.parse
	var os = __webpack_require__(56)
	var logger
	
	/**
	 * CONSTANTS -- we gotta lotta 'em
	 */
	var DEFAULT_CONFIG_PATH = path.join(__dirname, 'config.default.js')
	var DEFAULT_CONFIG = __webpack_require__(92)(DEFAULT_CONFIG_PATH).config
	var DEFAULT_FILENAME = 'newrelic.js'
	var AZURE_APP_NAME = 'APP_POOL_ID'
	var CONFIG_FILE_LOCATIONS = [
	  process.env.NEW_RELIC_HOME,
	  process.cwd(),
	  process.env.HOME,
	  path.join(__dirname, '../../..') // above node_modules
	]
	
	// the REPL has no main module
	if (process.mainModule && process.mainModule.filename) {
	  CONFIG_FILE_LOCATIONS.splice(2, 0, path.dirname(process.mainModule.filename))
	}
	
	/*
	 * ENV_MAPPING, LIST_VARS, and BOOLEAN_VARS could probably be unified and
	 * objectified, but this is simple and works.
	 */
	var ENV_MAPPING = {
	  newrelic_home: "NEW_RELIC_HOME",
	  app_name: "NEW_RELIC_APP_NAME",
	  license_key: "NEW_RELIC_LICENSE_KEY",
	  ssl: "NEW_RELIC_USE_SSL",
	  host: "NEW_RELIC_HOST",
	  port: "NEW_RELIC_PORT",
	  proxy: "NEW_RELIC_PROXY_URL",
	  proxy_host: "NEW_RELIC_PROXY_HOST",
	  proxy_port: "NEW_RELIC_PROXY_PORT",
	  proxy_user: "NEW_RELIC_PROXY_USER",
	  proxy_pass: "NEW_RELIC_PROXY_PASS",
	  ignore_server_configuration: "NEW_RELIC_IGNORE_SERVER_CONFIGURATION",
	  agent_enabled: "NEW_RELIC_ENABLED",
	  apdex_t: "NEW_RELIC_APDEX",
	  capture_params: "NEW_RELIC_CAPTURE_PARAMS",
	  ignored_params: "NEW_RELIC_IGNORED_PARAMS",
	  logging: {
	    level: "NEW_RELIC_LOG_LEVEL",
	    filepath: "NEW_RELIC_LOG",
	    enabled: "NEW_RELIC_LOG_ENABLED"
	  },
	  audit_log: {
	    enabled: "NEW_RELIC_AUDIT_LOG_ENABLED",
	    endpoints: "NEW_RELIC_AUDIT_LOG_ENDPOINTS"
	  },
	  error_collector: {
	    enabled: "NEW_RELIC_ERROR_COLLECTOR_ENABLED",
	    ignore_status_codes: "NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES"
	  },
	  transaction_tracer: {
	    enabled: "NEW_RELIC_TRACER_ENABLED",
	    transaction_threshold: "NEW_RELIC_TRACER_THRESHOLD",
	    top_n: "NEW_RELIC_TRACER_TOP_N",
	    record_sql: "NEW_RELIC_RECORD_SQL",
	    explain_threshold: "NEW_RELIC_EXPLAIN_THRESHOLD"
	  },
	  utilization: {
	    detect_aws: "NEW_RELIC_UTILIZATION_DETECT_AWS",
	    detect_docker: "NEW_RELIC_UTILIZATION_DETECT_DOCKER",
	    logical_processors: "NEW_RELIC_UTILIZATION_LOGICAL_PROCESSORS",
	    total_ram_mib: "NEW_RELIC_UTILIZATION_TOTAL_RAM_MIB",
	    billing_hostname: "NEW_RELIC_UTILIZATION_BILLING_HOSTNAME"
	  },
	  debug: {
	    internal_metrics: "NEW_RELIC_DEBUG_METRICS",
	    tracer_tracing: "NEW_RELIC_DEBUG_TRACER"
	  },
	  rules: {
	    name: "NEW_RELIC_NAMING_RULES",
	    ignore: "NEW_RELIC_IGNORING_RULES"
	  },
	  enforce_backstop: "NEW_RELIC_ENFORCE_BACKSTOP",
	  browser_monitoring: {
	    enable: "NEW_RELIC_BROWSER_MONITOR_ENABLE",
	    debug: "NEW_RELIC_BROWSER_MONITOR_DEBUG"
	  },
	  high_security: "NEW_RELIC_HIGH_SECURITY",
	  labels: "NEW_RELIC_LABELS",
	  slow_sql: {
	    enabled: "NEW_RELIC_SLOW_SQL_ENABLED",
	    max_samples: "NEW_RELIC_MAX_SQL_SAMPLES"
	  },
	  process_host: {
	    display_name: "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
	    ipv_preference: "NEW_RELIC_IPV_PREFERENCE"
	  },
	  datastore_tracer: {
	    instance_reporting: {
	      enabled: "NEW_RELIC_DATASTORE_INSTANCE_REPORTING_ENABLED"
	    },
	    database_name_reporting:{
	      enabled: "NEW_RELIC_DATASTORE_DATABASE_NAME_REPORTING_ENABLED"
	    }
	  }
	}
	
	// values in list variables are comma-delimited lists
	var LIST_VARS = [
	  "NEW_RELIC_APP_NAME",
	  "NEW_RELIC_IGNORED_PARAMS",
	  "NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES",
	  "NEW_RELIC_IGNORING_RULES",
	  "NEW_RELIC_AUDIT_LOG_ENDPOINTS"
	]
	
	// values in object lists are comma-delimited object literals
	var OBJECT_LIST_VARS = [
	  "NEW_RELIC_NAMING_RULES"
	]
	
	var HAS_ARBITRARY_KEYS = [
	  'labels'
	]
	
	/*
	 * Values in boolean variables. Is pretty tolerant about values, but
	 * don't get fancy and just use 'true' and 'false', everybody.
	 */
	var BOOLEAN_VARS = [
	  "NEW_RELIC_IGNORE_SERVER_CONFIGURATION",
	  "NEW_RELIC_ENABLED",
	  "NEW_RELIC_CAPTURE_PARAMS",
	  "NEW_RELIC_ERROR_COLLECTOR_ENABLED",
	  "NEW_RELIC_TRACER_ENABLED",
	  "NEW_RELIC_DEBUG_METRICS",
	  "NEW_RELIC_DEBUG_TRACER",
	  "NEW_RELIC_ENFORCE_BACKSTOP",
	  "NEW_RELIC_USE_SSL",
	  "NEW_RELIC_BROWSER_MONITOR_ENABLE",
	  "NEW_RELIC_BROWSER_MONITOR_DEBUG",
	  "NEW_RELIC_HIGH_SECURITY",
	  "NEW_RELIC_SLOW_SQL_ENABLED",
	  "NEW_RELIC_LOG_ENABLED",
	  "NEW_RELIC_AUDIT_LOG_ENABLED",
	  "NEW_RELIC_DATASTORE_DATABASE_NAME_REPORTING_ENABLED",
	  "NEW_RELIC_DATASTORE_INSTANCE_REPORTING_ENABLED"
	]
	
	var FLOAT_VARS = [
	  'NEW_RELIC_APDEX'
	]
	
	var INT_VARS = [
	  'NEW_RELIC_EXPLAIN_THRESHOLD',
	  'NEW_RELIC_MAX_SQL_SAMPLES'
	]
	
	// Config keys that can't be set by the server if high_security === true
	var HIGH_SECURITY_SETTINGS = {
	  ssl: true,
	  capture_params: false,
	  transaction_tracer: {
	    record_sql: 'off'
	  },
	  slow_sql: {
	    enabled: false
	  }
	}
	
	var HIGH_SECURITY_KEYS = Object.keys(flatten({}, '', HIGH_SECURITY_SETTINGS))
	
	// blank out these config values before sending to the collector
	var REDACT_BEFORE_SEND = ['proxy_pass', 'proxy_user', 'proxy']
	
	// process.domain needs to be stripped befeore sending
	var REMOVE_BEFORE_SEND = ['domain']
	
	function isTruthular(setting) {
	  if (setting === undefined || setting === null) return false
	
	  var normalized = setting.toString().toLowerCase()
	  switch (normalized) {
	    case 'false':
	    case 'f':
	    case 'no':
	    case 'n':
	    case 'disabled':
	    case '0':
	      return false
	
	    default:
	      return true
	  }
	}
	
	function fromObjectList(setting) {
	  try {
	    return JSON.parse('[' + setting + ']')
	  } catch (error) {
	    logger.error("New Relic configurator could not deserialize object list:")
	    logger.error(error.stack)
	  }
	}
	
	function _findConfigFile() {
	  var candidate
	  var filepath
	
	
	  for (var i = 0; i < CONFIG_FILE_LOCATIONS.length; i++) {
	    candidate = CONFIG_FILE_LOCATIONS[i]
	    if (!candidate) continue
	
	    filepath = path.join(path.resolve(candidate), DEFAULT_FILENAME)
	    if (!exists(filepath)) continue
	
	    return fs.realpathSync(filepath)
	  }
	}
	
	function _failHard() {
	  var mainpath = path.resolve(path.join(process.cwd(), DEFAULT_FILENAME))
	  var altpath = path.resolve(
	    path.dirname(process.mainModule.filename),
	    DEFAULT_FILENAME
	  )
	
	
	  var locations
	  if (mainpath !== altpath) {
	    locations = mainpath + " or\n" + altpath
	  } else {
	    locations = mainpath
	  }
	
	  throw new Error(
	    "Unable to find New Relic module configuration. A default\n" +
	    "configuration file can be copied from " + DEFAULT_CONFIG_PATH + "\n" +
	    "and put at " + locations + "."
	  )
	}
	
	function Config(config) {
	  EventEmitter.call(this)
	
	  // 1. start by cloning the defaults
	  try {
	    var basis = JSON.parse(stringifySync(DEFAULT_CONFIG))
	    Object.keys(basis).forEach(function cb_forEach(key) {
	      this[key] = basis[key]
	    }, this)
	  } catch (err) {
	    logger.warn('Unable to clone the default config, %s: %s', DEFAULT_CONFIG_PATH, err)
	  }
	
	  if (config &&
	      (process.env[ENV_MAPPING.ssl] === 'false' || config.ssl === false) &&
	      process.env[ENV_MAPPING.port] === undefined && config.port === undefined ) {
	    config.port = 80
	  }
	
	  // 2. initialize undocumented, internal-only default values
	
	  // feature flags are mostly private settings for gating unreleased features
	  // flags are set in the feature_flags.js file
	  this.feature_flag = feature_flag.prerelease
	
	  // set by environment
	  this.newrelic_home = null
	  // set by configuration file loader
	  this.config_file_path = null
	  // set by collector on handshake
	  this.run_id = null
	  this.application_id = null
	  this.web_transactions_apdex = {}
	  this.cross_process_id = null
	  this.encoding_key = null
	  this.obfuscatedId = null
	  this.trusted_account_ids = null
	
	  // how frequently harvester runs
	  this.data_report_period = 60
	
	  // based on max call stack depth
	  this.max_trace_segments = 900
	
	  // feature level of this account
	  this.product_level = 0
	  // product-level related
	  this.collect_traces = true
	  this.collect_errors = true
	
	  // override options for utilization stats
	  this.utilization.logical_processors = null
	  this.utilization.total_ram_mib = null
	  this.utilization.billing_hostname = null
	
	  this.browser_monitoring.loader = 'rum'
	  this.browser_monitoring.loader_version = ''
	
	  // Settings to play nice with DLPs (see NODE-1044).
	  this.compressed_content_encoding = "deflate"  // Deflate or gzip
	  this.simple_compression = false               // Disables subcomponent compression
	  this.put_for_data_send = false                // Changes http verb for harvest
	
	
	  // 3. override defaults with values from the loaded / passed configuration
	  this._fromPassed(config)
	
	  // 3.5. special values (only Azure environment APP_POOL_ID for now)
	  this._fromSpecial()
	
	  // 4. override config with environment variables
	  this._fromEnvironment()
	
	  // 5. clean up anything that requires postprocessing
	  this._canonicalize()
	
	  // 6. put the version in the config
	  this.version = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version
	
	  // 7. apply high security overrides
	  if (this.high_security === true) {
	    this._applyHighSecurity()
	  }
	}
	util.inherits(Config, EventEmitter)
	
	/**
	 * Because this module and logger depend on each other, the logger needs
	 * a way to inject the actual logger instance once it's constructed.
	 * It's kind of a Rube Goldberg device, but it works.
	 *
	 * @param {Logger} bootstrapped The actual, configured logger.
	 */
	Config.prototype.setLogger = function setLogger(bootstrapped) {
	  logger = bootstrapped
	}
	
	/**
	 * Accept any configuration passed back from the server. Will log all
	 * recognized, unsupported, and unknown parameters. Some may not be set,
	 * depending on the setting of ignore_server_configuration.
	 *
	 * @param {object} json The config blob sent by New Relic.
	 */
	Config.prototype.onConnect = function onConnect(json, recursion) {
	  json = json || {}
	  if (this.high_security === true && recursion !== true && json.high_security !== true) {
	    this.agent_enabled = false
	    this.emit('agent_enabled', false)
	    return
	  }
	  if (Object.keys(json).length === 0) return
	
	  Object.keys(json).forEach(function cb_forEach(key) {
	    this._fromServer(json, key)
	  }, this)
	
	  this.emit('change', this)
	}
	
	/**
	 * The guts of the logic about how to deal with server-side configuration.
	 *
	 * @param {object} params A configuration dictionary.
	 * @param {string} key    The particular configuration parameter to set.
	 */
	Config.prototype._fromServer = function _fromServer(params, key) {
	  switch (key) {
	    // handled by the connection
	    case 'messages':
	      break
	
	    // *sigh* Xzibit, etc.
	    case 'agent_config':
	      this.onConnect(params[key], true)
	      break
	
	    // if it's undefined or null, so be it
	    case 'agent_run_id':
	      this.run_id = params.agent_run_id
	      break
	
	    // handled by config.onConnect
	    case 'high_security':
	      break
	
	    // always accept these settings
	    case 'cross_process_id':
	    case 'encoding_key':
	      this._alwaysUpdateIfChanged(params, key)
	      if (this.cross_process_id && this.encoding_key) {
	        this.obfuscatedId = hashes.obfuscateNameUsingKey(this.cross_process_id,
	                                                         this.encoding_key)
	      }
	      break
	
	    // always accept these settings
	    case 'collect_traces':
	    case 'collect_errors':
	    case 'product_level':
	    case 'application_id':
	    case 'trusted_account_ids':
	      this._alwaysUpdateIfChanged(params, key)
	      break
	
	    case 'collect_error_events':
	      if (params.collect_error_events === false) {
	        this._updateNestedIfChanged(
	          params,
	          this.error_collector,
	          key,
	          'capture_events'
	        )
	      }
	      break
	
	    // also accept these settings
	    case 'url_rules':
	    case 'metric_name_rules':
	    case 'transaction_name_rules':
	    case 'transaction_segment_terms':
	      this._emitIfSet(params, key)
	      break
	
	    // setting these can be disabled by ignore_server_configuration
	    case 'ssl':
	    case 'apdex_t':
	    case 'web_transactions_apdex':
	    case 'data_report_period':
	    case 'ignored_params':
	      this._updateIfChanged(params, key)
	      break
	    case 'transaction_tracer.enabled':
	      this._updateNestedIfChanged(
	        params,
	        this.transaction_tracer,
	        'transaction_tracer.enabled',
	        'enabled'
	      )
	      break
	    case 'transaction_tracer.transaction_threshold':
	      this._updateNestedIfChanged(
	        params,
	        this.transaction_tracer,
	        'transaction_tracer.transaction_threshold',
	        'transaction_threshold'
	      )
	      break
	    case 'error_collector.enabled':
	      this._updateNestedIfChanged(
	        params,
	        this.error_collector,
	        'error_collector.enabled',
	        'enabled'
	      )
	      break
	    case 'error_collector.ignore_status_codes':
	      this._updateNestedIfChanged(
	        params,
	        this.error_collector,
	        'error_collector.ignore_status_codes',
	        'ignore_status_codes'
	      )
	      this._canonicalize()
	      break
	
	    case 'error_collector.capture_events':
	      this._updateNestedIfChanged(
	        params,
	        this.error_collector,
	        'error_collector.capture_events',
	        'capture_events'
	      )
	      break
	
	    case 'error_collector.max_event_samples_stored':
	      this._updateNestedIfChanged(
	        params,
	        this.error_collector,
	        'error_collector.max_event_samples_stored',
	        'max_event_samples_stored'
	      )
	      break
	
	    case 'collect_analytics_events':
	      // never enable from server-side
	      // but we allow the server to disable
	      if (params.collect_analytics_events === false)
	        this.transaction_events.enabled = false
	      break
	
	    case 'collect_custom_events':
	      // never enable from server-side
	      // but we allow the server to disable
	      if (params.collect_custom_events === false)
	        this.custom_insights_events.enabled = false
	      break
	
	    case 'transaction_events.max_samples_stored':
	      this._updateNestedIfChanged(
	        params,
	        this.transaction_events,
	        key,
	        'max_samples_stored'
	      )
	      break
	
	    case 'transaction_events.max_samples_per_minute':
	      this._updateNestedIfChanged(
	        params,
	        this.transaction_events,
	        key,
	        'max_samples_per_minute'
	      )
	      break
	
	    case 'transaction_events.enabled':
	      this._updateNestedIfChanged(
	        params,
	        this.transaction_events,
	        key,
	        'enabled'
	      )
	      break
	
	    // these are used by browser_monitoring
	    // and the api.getRUMHeader() method
	    case 'js_agent_file':
	    case 'js_agent_loader_file':
	    case 'beacon':
	    case 'error_beacon':
	    case 'browser_key':
	    case 'js_agent_loader':
	      this._updateNestedIfChangedRaw(
	        params,
	        this.browser_monitoring,
	        key,
	        key
	      )
	      break
	
	    case 'browser_monitoring.loader':
	      this._updateNestedIfChangedRaw(
	        params,
	        this.browser_monitoring,
	        key,
	        'loader'
	      )
	      break
	
	    // After 2015-02, the collector no longer supports the capture_params setting.
	    case 'capture_params':
	      break
	    // these settings aren't supported by the agent (yet)
	    case 'sampling_rate':
	    case 'episodes_file':
	    case 'episodes_url':
	    case 'cross_application_tracing':
	    case 'transaction_tracer.record_sql':
	    case 'slow_sql.enabled':
	    case 'rum.load_episodes_file':
	      this.logUnsupported(params, key)
	      break
	
	    default:
	      this.logUnknown(params, key)
	  }
	}
	
	/**
	 * Change a value sent by the collector if and only if it's different from the
	 * value we already have. Emit an event with the key name and the new value,
	 * and log that the value has changed.
	 *
	 * @param {object} json Config blob sent by collector.
	 * @param {string} key  Value we're looking to set.
	 */
	Config.prototype._alwaysUpdateIfChanged = function _alwaysUpdateIfChanged(json, key) {
	  var value = json[key]
	  if (value !== null && value !== undefined && this[key] !== value) {
	    if (Array.isArray(value) && Array.isArray(this[key])) {
	      value.forEach(function cb_forEach(element) {
	        if (this[key].indexOf(element) === -1) this[key].push(element)
	      }, this)
	    } else {
	      this[key] = value
	    }
	    this.emit(key, value)
	    logger.debug("Configuration of %s was changed to %s by New Relic.", key, value)
	  }
	}
	
	/**
	 * Change a value sent by the collector if and only if it's different from the
	 * value we already have. Emit an event with the key name and the new value,
	 * and log that the value has changed. Parameter will be ignored if
	 * ignore_server_configuration is set.
	 *
	 * @param {object} json Config blob sent by collector.
	 * @param {string} key  Value we're looking to set.
	 */
	Config.prototype._updateIfChanged = function _updateIfChanged(json, key) {
	  this._updateNestedIfChanged(json, this, key, key)
	}
	
	/**
	 * Some parameter values are nested, need a simple way to change them as well.
	 * Will merge local and remote if and only if both are arrays. Parameter will
	 * be ignored if ignore_server_configuration is set.
	 *
	 * @param {object} remote    JSON sent from New Relic.
	 * @param {object} local     A portion of this configuration object.
	 * @param {string} remoteKey The name sent by New Relic.
	 * @param {string} localKey  The local name.
	 */
	Config.prototype._updateNestedIfChanged = _updateNestedIfChanged
	
	function _updateNestedIfChanged(remote, local, remoteKey, localKey) {
	  if (this.ignore_server_configuration) return this.logDisabled(remote, remoteKey)
	  // if high-sec mode is enabled, we do not accept server changes to high-sec
	  if (this.high_security && HIGH_SECURITY_KEYS.indexOf(localKey) !== -1) {
	    return this.logDisabled(remote, remoteKey)
	  }
	  return this._updateNestedIfChangedRaw(remote, local, remoteKey, localKey)
	}
	
	Config.prototype._updateNestedIfChangedRaw = function _updateNestedIfChangedRaw(
	    remote, local, remoteKey, localKey) {
	  var value = remote[remoteKey]
	  if (value !== null && value !== undefined && local[localKey] !== value) {
	    if (Array.isArray(value) && Array.isArray(local[localKey])) {
	      value.forEach(function cb_forEach(element) {
	        if (local[localKey].indexOf(element) === -1) local[localKey].push(element)
	      })
	    } else {
	      local[localKey] = value
	    }
	    this.emit(remoteKey, value)
	    logger.debug("Configuration of %s was changed to %s by New Relic.", remoteKey, value)
	  }
	}
	
	/**
	 * Some parameter values are just to be passed on.
	 *
	 * @param {object} json Config blob sent by collector.
	 * @param {string} key  Value we're looking to set.
	 */
	Config.prototype._emitIfSet = function _emitIfSet(json, key) {
	  var value = json[key]
	  if (value !== null && value !== undefined) this.emit(key, value)
	}
	
	/**
	 * The agent would normally do something with this parameter, but server-side
	 * configuration is disabled via ignore_server_configuration.
	 *
	 * @param {object} json Config blob sent by collector.
	 * @param {string} key  Value the agent won't set.
	 */
	Config.prototype.logDisabled = function logDisabled(json, key) {
	  var value = json[key]
	  if (value !== null && value !== undefined) {
	    logger.debug(
	      "Server-side configuration of %s is currently disabled by local configuration. " +
	      "(Server sent value of %s.)",
	      key,
	      value
	    )
	  }
	}
	
	/**
	 * Help support out by putting in the logs the fact that we don't currently
	 * support the provided configuration key, and including the sent value.
	 *
	 * @param {object} json Config blob sent by collector.
	 * @param {string} key  Value the agent doesn't set.
	 */
	Config.prototype.logUnsupported = function logUnsupported(json, key) {
	  var flavor
	  if (this.ignore_server_configuration) {
	    flavor = "ignored"
	  } else {
	    flavor = "not supported by the Node.js agent"
	  }
	
	  var value = json[key]
	  if (value !== null && value !== undefined) {
	    logger.debug(
	      "Server-side configuration of %s is currently %s. (Server sent value of %s.)",
	      key,
	      flavor,
	      value
	    )
	    this.emit(key, value)
	  }
	}
	
	/**
	 * The agent knows nothing about this parameter.
	 *
	 * @param {object} json Config blob sent by collector.
	 * @param {string} key  Value the agent knows nothing about.
	 */
	Config.prototype.logUnknown = function logUnknown(json, key) {
	  var value = json[key]
	  logger.debug(
	    "New Relic sent unknown configuration parameter %s with value %s.",
	    key,
	    value
	  )
	}
	
	/**
	 * Gets the user set host display name. If not provided, it returns the default value.
	 *
	 * This function is written is this strange way becauase of the use of caching variables.
	 * I wanted to cache the DisplayHost, but if I attached the variable to the config object,
	 * it sends the extra variable to New Relic, which is not desired.
	 *
	 * @return {string} display host name
	 */
	Config.prototype.getDisplayHost = getDisplayHost
	
	Config.prototype.clearDisplayHostCache = function clearDisplayHostCache() {
	  this.getDisplayHost = getDisplayHost
	}
	
	function getDisplayHost() {
	  var _displayHost
	  this.getDisplayHost = function getCachedDisplayHost() {
	    return _displayHost
	  }
	  if (this.process_host.display_name === '') {
	    _displayHost = this.getHostnameSafe()
	    return _displayHost
	  }
	  var stringBuffer = new Buffer(this.process_host.display_name, 'utf8')
	  var numBytes = stringBuffer.length
	
	  if (numBytes > 255) {
	    logger.warn('Custom host display name must be less than 255 bytes')
	    _displayHost = this.getHostnameSafe()
	    return _displayHost
	  }
	
	  _displayHost = this.process_host.display_name
	  return _displayHost
	}
	
	/**
	 * Gets the system's host name. If that fails, it just returns ipv4/6 based on the user's
	 * process_host.ipv_preferenece setting.
	 *
	 * This function is written is this strange way becauase of the use of caching variables.
	 * I wanted to cache the Hostname, but if I attached the variable to the config object,
	 * it sends the extra variable to New Relic, which is not desired.
	 *
	 * @return {string} host name
	 */
	Config.prototype.getHostnameSafe = getHostnameSafe
	
	Config.prototype.clearHostnameCache = function clearHostnameCache() {
	  this.getHostnameSafe = getHostnameSafe
	}
	
	Config.prototype.getIPAddresses = function getIPAddresses() {
	  var addresses = {}
	  var interfaces = os.networkInterfaces()
	
	  for (var interfaceKey in interfaces) {
	    if (interfaceKey.match(/^lo/)) continue
	
	    var interfaceDescriptions = interfaces[interfaceKey]
	    for (var i = 0; i < interfaceDescriptions.length; i++) {
	      var description = interfaceDescriptions[i]
	      var family = description.family.toLowerCase()
	      addresses[family] = description.address
	    }
	  }
	  return addresses
	}
	
	function getHostnameSafe() {
	  var _hostname
	  this.getHostnameSafe = function getCachedHostname() {
	    return _hostname
	  }
	  try {
	    _hostname = os.hostname()
	    return _hostname
	  } catch (e) {
	    var addresses = this.getIPAddresses()
	
	    if (this.process_host.ipv_preference === '6' && addresses.ipv6) {
	      _hostname = addresses.ipv6
	    } else if (addresses.ipv4) {
	      logger.info('Defaulting to ipv4 address for host name')
	      _hostname = addresses.ipv4
	    } else if (addresses.ipv6) {
	      logger.info('Defaulting to ipv6 address for host name')
	      _hostname = addresses.ipv6
	    } else {
	      logger.info('No hostname, ipv4, or ipv6 address found for machine')
	      _hostname = 'UNKNOWN_BOX'
	    }
	
	    return _hostname
	  }
	}
	
	/**
	 * Ensure that the apps names are always returned as a list.
	 */
	Config.prototype.applications = function applications() {
	  var apps = this.app_name
	
	  if (Array.isArray(apps) && apps.length > 0) {
	    return apps
	  }
	
	  if (apps && typeof apps === 'string') {
	    return [apps]
	  }
	
	  return []
	}
	
	/**
	 * Safely overwrite defaults with values passed to constructor.
	 *
	 * @param object external The configuration being loaded.
	 * @param object internal Whichever chunk of the config being overridden.
	 */
	Config.prototype._fromPassed = function _fromPassed(external, internal, arbitrary) {
	  if (!external) return
	  if (!internal) internal = this
	
	  Object.keys(external).forEach(function cb_forEach(key) {
	    // if it's not in the defaults, it doesn't exist
	    if (!arbitrary && internal[key] === undefined) return
	
	    try {
	      var node = external[key]
	    } catch (err) {
	      logger.warn('Error thrown on access of user config for key: %s', key)
	      return
	    }
	
	    if (Array.isArray(node)) {
	      internal[key] = node
	    } else if (typeof node === 'object') {
	      // is top level and can have arbitrary keys
	      if (internal === this && HAS_ARBITRARY_KEYS.indexOf(key) !== -1) {
	        this._fromPassed(node, internal[key], true)
	      } else {
	        this._fromPassed(node, internal[key], false)
	      }
	    } else {
	      internal[key] = node
	    }
	  }, this)
	}
	
	/**
	 * Some values should be picked up only if they're not otherwise set, like
	 * the Windows / Azure application name. Don't set it if there's already
	 * a non-empty value set via the configuration file, and allow these
	 * values to be overwritten by environment variables. Just saves a step for
	 * PaaS users who don't want to have multiple settings for a single piece
	 * of configuration.
	 */
	Config.prototype._fromSpecial = function _fromSpecial() {
	  var name = this.app_name
	  if (name === null || name === undefined || name === '' ||
	      (Array.isArray(name) && name.length === 0)) {
	    var azureName = process.env[AZURE_APP_NAME]
	    if (azureName) this.app_name = azureName.split(',')
	  }
	}
	
	/**
	 * Recursively visit the nodes of the constant containing the mapping between
	 * environment variable names, overriding any configuration values that are
	 * found in the environment. Operates purely via side effects.
	 *
	 * @param object metadata The current level of the mapping object. Should never
	 *                        need to set this yourself.
	 * @param object data     The current level of the configuration object. Should
	 *                        never need to set this yourself.
	 */
	Config.prototype._fromEnvironment = function _fromEnvironment(metadata, data) {
	  if (!metadata) metadata = ENV_MAPPING
	  if (!data) data = this
	
	  Object.keys(metadata).forEach(function cb_forEach(value) {
	    // if it's not in the config, it doesn't exist
	    if (data[value] === undefined) return
	
	    var node = metadata[value]
	    if (typeof node === 'string') {
	      var setting = process.env[node]
	      if (setting) {
	        if (LIST_VARS.indexOf(node) > -1) {
	          data[value] = setting.split(',').map(function cb_map(k) {
	            return k.trim()
	          })
	        } else if (OBJECT_LIST_VARS.indexOf(node) > -1) {
	          data[value] = fromObjectList(setting)
	        } else if (BOOLEAN_VARS.indexOf(node) > -1) {
	          data[value] = isTruthular(setting)
	        } else if (FLOAT_VARS.indexOf(node) > -1) {
	          data[value] = parseFloat(setting, 10)
	        } else if (INT_VARS.indexOf(node) > -1) {
	          data[value] = parseInt(setting, 10)
	        } else {
	          data[value] = setting
	        }
	      }
	    } else {
	      // don't crash if the mapping has config keys the current config doesn't.
	      if (!data[value]) data[value] = {}
	      this._fromEnvironment(node, data[value])
	    }
	  }, this)
	}
	
	/**
	 * Depending on how the status codes are set, they could be strings, which
	 * makes strict equality testing / indexOf fail. To keep things cheap, parse
	 * them once, after configuration has finished loading. Other one-off shims
	 * based on special properties of configuration values should go here as well.
	 */
	Config.prototype._canonicalize = function _canonicalize() {
	  var codes = this.error_collector && this.error_collector.ignore_status_codes
	  if (codes) {
	    this.error_collector.ignore_status_codes = codes.map(function cb_map(code) {
	      return parseInt(code, 10)
	    })
	  }
	
	  var logAliases = {
	    'verbose': 'trace',
	    'debugging': 'debug',
	    'warning': 'warn',
	    'err': 'error'
	  }
	  var level = this.logging.level
	  this.logging.level = logAliases[level] || level
	}
	
	/**
	 * This goes through the settings that high security mode needs and coerces
	 * them to be correct.
	 */
	Config.prototype._applyHighSecurity = function _applyHighSecurity() {
	  var config = this
	  checkNode('', this, HIGH_SECURITY_SETTINGS)
	
	  function checkNode(base, config, settings) {
	    Object.keys(settings).forEach(checkKey.bind(null, base, config, settings))
	  }
	
	  function checkKey(base, target, settings, key) {
	    var hsValue = settings[key]
	
	
	    if (hsValue && typeof hsValue === 'object') {
	      if (typeof target[key] !== 'object') {
	        logger.warn(
	          'High Security Mode: %s should be an object, found %s',
	          key,
	          target[key]
	        )
	        target[key] = {}
	      }
	
	      return checkNode(base + key + '.', target[key], hsValue)
	    }
	
	    if (target[key] !== hsValue) {
	      logger.warn('High Security Mode: %s was set to %s, coercing to %s',
	                  key, target[key], hsValue)
	      target[key] = hsValue
	      config.emit(base + key, hsValue)
	    }
	  }
	}
	
	/**
	 * The agent will use the supportability metrics object if it's
	 * available.
	 *
	 * @param string suffix Supportability metric name.
	 * @param number duration Milliseconds that the measured operation took.
	 */
	Config.prototype.measureInternal = function measureInternal(suffix, duration) {
	  if (this.debug.supportability) {
	    var internal = this.debug.supportability
	    internal.measureMilliseconds(NAMES.SUPPORTABILITY.PREFIX + suffix, null, duration)
	  }
	}
	
	Config.prototype.validateFlags = function validateFlags() {
	  Object.keys(this.feature_flag).forEach(function cb_forEach(key) {
	    if (feature_flag.released.indexOf(key) > -1) {
	      logger.warn('Feature flag ' + key + ' has been released')
	    }
	    if (feature_flag.unreleased.indexOf(key) > -1) {
	      logger.warn('Feature flag ' + key + ' has been deprecated')
	    }
	  })
	}
	
	/**
	 * Get a JSONifiable object containing all settings we want to report to the
	 * collector and store in the environment_values table.
	 *
	 * @return Object containing simple key-value pairs of settings
	 */
	Config.prototype.publicSettings = function publicSettings() {
	  var settings = {}
	
	  for (var key in this) {
	    if (this.hasOwnProperty(key)) {
	      var item = this[key]
	
	      if (REDACT_BEFORE_SEND.indexOf(key) > -1) {
	        item = '****'
	      }
	
	      if (REMOVE_BEFORE_SEND.indexOf(key) === -1) {
	        settings[key] = item
	      }
	    }
	  }
	
	  // Agent-side setting is 'enable', but collector-side setting is
	  // 'auto_instrument'. Send both values up.
	  settings.browser_monitoring.auto_instrument = settings.browser_monitoring.enable
	
	  // Remove simple circular references
	  parse(stringifySync(settings), function cb_parse(err, settingsCopy) {
	    if (err === null) {
	      settings = flatten({}, '', settingsCopy)
	    } else {
	      logger.warn('Error while creating deep copy: %s', err)
	    }
	  })
	
	  return settings
	}
	
	/**
	 * Create a configuration, either from a configuration file or the node
	 * process's environment.
	 *
	 * For configuration via file, check these directories, in order, for a
	 * file named 'newrelic.js':
	 *
	 *   1. The process's current working directory at startup.
	 *   2. The same directory as the process's main module (i.e. the filename
	 *      passed to node on the command line).
	 *   3. The directory pointed to by the environment variable NEW_RELIC_HOME.
	 *   4. The current process's HOME directory.
	 *   5. If this module is installed as a dependency, the directory above the
	 *      node_modules folder in which newrelic is installed.
	 *
	 * For configration via environment (useful on Joyent, Azure, Heroku, or
	 * other PaaS offerings), set NEW_RELIC_NO_CONFIG_FILE to something truthy
	 * and read README.md for details on what configuration variables are
	 * necessary, as well as a complete enumeration of the other available
	 * variables.
	 *
	 * @param {object} config Optional configuration to be used in place of a
	 *                        config file.
	 */
	function initialize(config) {
	  /* When the logger is required here, it bootstraps itself and then
	   * injects itself into this module's closure via setLogger on the
	   * instance of the logger it creates.
	   */
	  logger = __webpack_require__(12)
	
	  if (config) return new Config(config)
	
	  if (isTruthular(process.env.NEW_RELIC_NO_CONFIG_FILE)) {
	    config = new Config({})
	    if (config.newrelic_home) delete config.newrelic_home
	    return config
	  }
	
	  var filepath = _findConfigFile()
	  if (!filepath) return _failHard()
	
	  try {
	    config = new Config(__webpack_require__(92)(filepath).config)
	    config.config_file_path = filepath
	    logger.debug("Using configuration file %s.", filepath)
	
	    config.validateFlags()
	
	    return config
	  } catch (error) {
	    logger.error(error)
	
	    throw new Error(
	      "Unable to read configuration file " + filepath + ". A default\n" +
	      "configuration file can be copied from " + DEFAULT_CONFIG_PATH + "\n" +
	      "and renamed to 'newrelic.js' in the directory from which you'll be starting\n" +
	      "your application."
	    )
	  }
	}
	
	/**
	 * Preserve the legacy initializer, but also allow consumers to manage their
	 * own configuration if they choose.
	 */
	Config.initialize = initialize
	
	module.exports = Config
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/", __webpack_require__(11), __webpack_require__(22).Buffer))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 59 */
/***/ function(module, exports) {

	'use strict'
	
	var NODEJS = {
	  PREFIX: 'Nodejs/'
	}
	
	var ALL = 'all'
	
	var ERRORS = {
	  PREFIX: 'Errors/',
	  ALL: 'Errors/' + ALL,
	  WEB: 'Errors/allWeb',
	  OTHER: 'Errors/allOther'
	}
	
	var EVENTS = {
	  WAIT: 'Events/wait'
	}
	
	var MEMORY = {
	  PHYSICAL: 'Memory/Physical',
	  FREE_HEAP: 'Memory/Heap/Free',
	  USED_HEAP: 'Memory/Heap/Used',
	  MAX_HEAP: 'Memory/Heap/Max',
	  USED_NONHEAP: 'Memory/NonHeap/Used'
	}
	
	var CPU = {
	  SYSTEM_TIME: 'CPU/System Time',
	  SYSTEM_UTILIZATION: 'CPU/System/Utilization',
	  USER_TIME: 'CPU/User Time',
	  USER_UTILIZATION: 'CPU/User/Utilization'
	}
	
	var GC = {
	  PREFIX: 'GC/',
	  PAUSE_TIME: 'GC/System/Pauses'
	}
	
	var VIEW = {
	  PREFIX: 'View/',
	  RENDER: '/Rendering'
	}
	
	var DB = {
	  PREFIX: 'Datastore/',
	  STATEMENT: 'Datastore/statement',
	  OPERATION: 'Datastore/operation',
	  INSTANCE: 'Datastore/instance',
	  ALL: 'Datastore/' + ALL,
	  WEB: 'allWeb',
	  OTHER: 'allOther'
	}
	
	var EXTERNAL = {
	  PREFIX: 'External/',
	  ALL: 'External/' + ALL,
	  WEB: 'External/allWeb',
	  OTHER: 'External/allOther',
	  APP: 'ExternalApp/',
	  TRANSACTION: 'ExternalTransaction/'
	}
	
	var FUNCTION = {
	  PREFIX: 'Function/'
	}
	
	var MIDDLEWARE = {
	  PREFIX: NODEJS.PREFIX + 'Middleware/'
	}
	
	var FS = {
	  PREFIX: 'Filesystem/'
	}
	
	var MEMCACHE = {
	  PREFIX: 'Memcache',
	  OPERATION: DB.OPERATION + '/Memcache/',
	  INSTANCE: DB.INSTANCE + '/Memcache/',
	  ALL: DB.PREFIX + 'Memcache/' + ALL
	}
	
	var MONGODB = {
	  PREFIX: 'MongoDB',
	  STATEMENT: DB.STATEMENT + '/MongoDB/',
	  OPERATION: DB.OPERATION + '/MongoDB/',
	  INSTANCE: DB.INSTANCE + '/MongoDB/'
	}
	
	var MYSQL = {
	  PREFIX: 'MySQL',
	  STATEMENT: DB.STATEMENT + '/MySQL/',
	  OPERATION: DB.OPERATION + '/MySQL/',
	  INSTANCE: DB.INSTANCE + '/MySQL/'
	}
	
	var REDIS = {
	  PREFIX: 'Redis',
	  OPERATION: DB.OPERATION + '/Redis/',
	  INSTANCE: DB.INSTANCE + '/Redis/',
	  ALL: DB.PREFIX + 'Redis/' + ALL
	}
	
	var POSTGRES = {
	  PREFIX: 'Postgres',
	  STATEMENT: DB.STATEMENT + '/Postgres/',
	  OPERATION: DB.OPERATION + '/Postgres/',
	  INSTANCE: DB.INSTANCE + '/Postgres/'
	}
	
	var CASSANDRA = {
	  PREFIX: 'Cassandra',
	  OPERATION: DB.OPERATION + '/Cassandra/',
	  STATEMENT: DB.STATEMENT + '/Cassandra/',
	  INSTANCE: DB.INSTANCE + '/Cassandra/',
	  ALL: DB.PREFIX + 'Cassandra/' + ALL
	
	}
	
	var ORACLE = {
	  PREFIX: 'Oracle',
	  STATEMENT: DB.STATEMENT + '/Oracle/',
	  OPERATION: DB.OPERATION + '/Oracle/',
	  INSTANCE: DB.INSTANCE + '/Oracle/'
	}
	
	var EXPRESS = {
	  PREFIX: 'Expressjs/',
	  MIDDLEWARE: MIDDLEWARE.PREFIX + 'Expressjs/',
	  ERROR_HANDLER: MIDDLEWARE.PREFIX + 'Expressjs/'
	}
	
	var RESTIFY = {
	  PREFIX: 'Restify/'
	}
	
	var HAPI = {
	  PREFIX: 'Hapi/'
	}
	
	var SUPPORTABILITY = {
	  PREFIX: 'Supportability/',
	  UNINSTRUMENTED: 'Supportability/Uninstrumented',
	  EVENTS: 'Supportability/Events',
	  API: 'Supportability/API',
	  UTILIZATION: 'Supportability/utilization',
	  DEPENDENCIES: 'Supportability/InstalledDependencies'
	}
	
	var UTILIZATION = {
	  AWS_ERROR: SUPPORTABILITY.UTILIZATION + '/aws/error',
	  DOCKER_ERROR: SUPPORTABILITY.UTILIZATION + '/docker/error'
	}
	
	
	var CUSTOM_EVENTS = {
	  PREFIX: SUPPORTABILITY.EVENTS + '/Customer/',
	  DROPPED: SUPPORTABILITY.EVENTS + '/Customer/Dropped',
	  SEEN: SUPPORTABILITY.EVENTS + '/Customer/Seen',
	  SENT: SUPPORTABILITY.EVENTS + '/Customer/Sent',
	  TOO_LARGE: SUPPORTABILITY.EVENTS + '/Customer/TooLarge',
	  FAILED: SUPPORTABILITY.EVENTS + '/Customer/FailedToSend'
	}
	
	var TRANSACTION_ERROR = {
	  SEEN: SUPPORTABILITY.EVENTS + '/TransactionError/Seen',
	  SENT: SUPPORTABILITY.EVENTS + '/TransactionError/Sent'
	}
	
	var WEB = {
	  RESPONSE_TIME: 'WebTransaction',
	  TOTAL_TIME: 'WebTransactionTotalTime'
	}
	
	var BACKGROUND = {
	  RESPONSE_TIME: 'OtherTransaction',
	  TOTAL_TIME: 'OtherTransactionTotalTime'
	}
	
	var TRUNCATED = {
	  PREFIX: 'Truncated/'
	}
	
	module.exports = {
	  ACTION_DELIMITER: '/',
	  ALL: ALL,
	  APDEX: 'Apdex',
	  BACKGROUND: BACKGROUND,
	  CASSANDRA: CASSANDRA,
	  CLIENT_APPLICATION: 'ClientApplication',
	  CONTROLLER: 'Controller',
	  CPU: CPU,
	  GC: GC,
	  CUSTOM: 'Custom',
	  CUSTOM_EVENTS: CUSTOM_EVENTS,
	  DB: DB,
	  ERRORS: ERRORS,
	  EVENTS: EVENTS,
	  EXPRESS: EXPRESS,
	  EXTERNAL: EXTERNAL,
	  FS: FS,
	  FUNCTION: FUNCTION,
	  HAPI: HAPI,
	  HTTP: 'HttpDispatcher',
	  MEMCACHE: MEMCACHE,
	  MEMORY: MEMORY,
	  MONGODB: MONGODB,
	  MYSQL: MYSQL,
	  NORMALIZED: 'NormalizedUri',
	  NODEJS: NODEJS,
	  ORACLE: ORACLE,
	  POSTGRES: POSTGRES,
	  QUEUETIME: 'WebFrontend/QueueTime',
	  REDIS: REDIS,
	  RESTIFY: RESTIFY,
	  SUPPORTABILITY: SUPPORTABILITY,
	  TRANSACTION_ERROR: TRANSACTION_ERROR,
	  TRUNCATED: TRUNCATED,
	  URI: 'Uri',
	  UTILIZATION: UTILIZATION,
	  VIEW: VIEW,
	  WEB: WEB
	}


/***/ },
/* 60 */
/***/ function(module, exports) {

	'use strict'
	
	// unreleased flags gating an active feature
	exports.prerelease = {
	  cat: true,
	  custom_instrumentation: true,
	  custom_metrics: true,
	  express5: false,
	  synthetics: true,
	  express_segments: true,
	  native_metrics: true,
	  promise_segments: false,
	  reverse_naming_rules: true,
	  send_request_uri_attribute: false
	}
	
	// flags that are no longer used for released features
	exports.released = [
	  'released',
	  'express4',
	  'insights',
	  'postgres',
	  'mysql_pool',
	  'proxy',
	  'custom_events'
	]
	
	// flags that are no longer used for unreleased features
	exports.unreleased = [
	  'unreleased'
	]


/***/ },
/* 61 */
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * Flatten nested maps of JSONifiable data.
	 *
	 * Ex: {a: 5, b: {c: true, d: 7}} -> {a: 5, 'b.c': true, 'b.d': 7}
	 *
	 * @param result Object to place key-value pairs into, normally called with {}
	 * @param prefix Prefix for keys, normally called with ''
	 * @param obj    Object to be flattened
	 *
	 * @return Object with flattened key-value pairs
	 */
	module.exports = function flatten(result, prefix, obj, seen) {
	  seen = seen || []
	  seen.push(obj)
	
	  for (var key in obj) {
	    if (seen.indexOf(obj[key]) > -1) {
	      continue
	    }
	
	    if (obj[key] instanceof Object) flatten(result, prefix + key + '.', obj[key], seen)
	    else result[prefix + key] = obj[key]
	  }
	
	  return result
	}


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict'
	
	var crypto = __webpack_require__(63)
	
	function encode(bytes, keyBytes) {
	  for (var i = 0; i < bytes.length; i++) {
	    // This is really dense but happens commonly so I'm in-lining some of what
	    // could be tossed into variables. It takes the current byte of bytes, then
	    // XORs it with the current byte of the key (which uses modulo to make sure
	    // to not overrun the end.)
	    bytes.writeUInt8(bytes.readUInt8(i) ^ keyBytes.readUInt8(i % keyBytes.length), i)
	  }
	  return bytes
	}
	
	function obfuscateNameUsingKey(name, key) {
	  var encodedBytes = new Buffer(name, 'utf-8')
	  var keyBytes = new Buffer(key)
	  return encode(encodedBytes, keyBytes).toString('base64')
	}
	
	function deobfuscateNameUsingKey(name, key) {
	  var bytes = new Buffer(name, 'base64')
	  var keyBytes = new Buffer(key)
	
	  return encode(bytes, keyBytes).toString("utf-8")
	}
	
	function calculatePathHash(appName, pathName, referingPathHash) {
	  if (typeof referingPathHash === 'string') {
	    referingPathHash = parseInt(referingPathHash, 16)
	  }
	  var rotated = ((referingPathHash << 1) | (referingPathHash >>> 31)) >>> 0
	  var hash = getHash(appName, pathName)
	
	  var result = (rotated ^ hash) >>> 0
	
	  // This is a trick to pad it out to 8 chars regardless of length.
	  var retval = ('00000000' + result.toString(16)).substr(-8)
	
	  return retval
	}
	
	function getHash(appName, txName) {
	  var md5sum = crypto.createHash('md5')
	  md5sum.update(new Buffer(appName + ';' + txName), 'utf8')
	  var buf = new Buffer(md5sum.digest('base64'), 'base64')
	  // pull the low 4 bytes in network byte order
	  return buf.slice(buf.length - 4, buf.length).readUInt32BE(0)
	}
	
	exports.obfuscateNameUsingKey = obfuscateNameUsingKey
	exports.deobfuscateNameUsingKey = deobfuscateNameUsingKey
	exports.calculatePathHash = calculatePathHash
	exports.getHash = getHash
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(64)
	
	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}
	
	exports.createHash = __webpack_require__(66)
	
	exports.createHmac = __webpack_require__(75)
	
	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}
	
	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}
	
	var p = __webpack_require__(76)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	__webpack_require__(78)(exports, module.exports);
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(65)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(22).Buffer))

/***/ },
/* 65 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(67)
	
	var md5 = toConstructor(__webpack_require__(72))
	var rmd160 = toConstructor(__webpack_require__(74))
	
	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}
	
	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}
	
	var Buffer = __webpack_require__(22).Buffer
	var Hash   = __webpack_require__(68)(Buffer)
	
	exports.sha1 = __webpack_require__(69)(Buffer, Hash)
	exports.sha256 = __webpack_require__(70)(Buffer, Hash)
	exports.sha512 = __webpack_require__(71)(Buffer, Hash)


/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }
	
	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)
	
	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }
	
	      s += ch
	      f += ch
	
	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s
	
	    return this
	  }
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)
	
	    var hash = this._update(this._block) || this._hash()
	
	    return enc ? hash.toString(enc) : hash
	  }
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }
	
	  return Hash
	}


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(16).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)
	
	  var POOL = []
	
	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()
	
	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)
	
	    this._h = null
	    this.init()
	  }
	
	  inherits(Sha1, Hash)
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0
	
	    Hash.prototype.init.call(this)
	    return this
	  }
	
	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e
	
	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e
	
	    var w = this._w
	
	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)
	
	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )
	
	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }
	
	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }
	
	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }
	
	  return Sha1
	}


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(16).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]
	
	  var W = new Array(64)
	
	  function Sha256() {
	    this.init()
	
	    this._w = W //new Array(64)
	
	    Hash.call(this, 16*4, 14*4)
	  }
	
	  inherits(Sha256, Hash)
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }
	
	  function R (X, n) {
	    return (X >>> n);
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }
	
	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }
	
	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }
	
	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }
	
	  Sha256.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }
	
	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0
	
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)
	
	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)
	
	    return H
	  }
	
	  return Sha256
	
	}


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(16).inherits
	
	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]
	
	  var W = new Array(160)
	
	  function Sha512() {
	    this.init()
	    this._w = W
	
	    Hash.call(this, 128, 112)
	  }
	
	  inherits(Sha512, Hash)
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  Sha512.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2
	
	      var Wi, Wil
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)
	
	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
	
	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]
	
	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]
	
	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
	
	        W[j] = Wi
	        W[j + 1] = Wil
	      }
	
	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]
	
	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)
	
	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
	
	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }
	
	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0
	
	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }
	
	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)
	
	    return H
	  }
	
	  return Sha512
	
	}


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(73);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;
	
	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
	
	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160
	
	
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];
	
	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};
	
	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function (H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};
	
	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}
	
	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}
	
	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}
	
	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}
	
	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}
	
	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );
	
	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(66)
	
	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)
	
	module.exports = Hmac
	
	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg
	
	  var blocksize = (alg === 'sha512') ? 128 : 64
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key
	
	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)
	
	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }
	
	  this._hash = createHash(alg).update(ipad)
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(77)
	
	module.exports = function (crypto, exports) {
	  exports = exports || {}
	
	  var exported = pbkdf2Export(crypto)
	
	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync
	
	  return exports
	}


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }
	
	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')
	
	    setTimeout(function() {
	      var result
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }
	
	      callback(undefined, result)
	    })
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')
	
	    if (iterations < 0)
	      throw new TypeError('Bad iterations')
	
	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')
	
	    if (keylen < 0)
	      throw new TypeError('Bad key length')
	
	    digest = digest || 'sha1'
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)
	
	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)
	
	      var U = crypto.createHmac(digest, password).update(block1).digest()
	
	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }
	
	      U.copy(T, 0, 0, hLen)
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }
	
	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }
	
	    return DK
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function (crypto, exports) {
	  exports = exports || {};
	  var ciphers = __webpack_require__(79)(crypto);
	  exports.createCipher = ciphers.createCipher;
	  exports.createCipheriv = ciphers.createCipheriv;
	  var deciphers = __webpack_require__(91)(crypto);
	  exports.createDecipher = deciphers.createDecipher;
	  exports.createDecipheriv = deciphers.createDecipheriv;
	  var modes = __webpack_require__(82);
	  function listCiphers () {
	    return Object.keys(modes);
	  }
	  exports.listCiphers = listCiphers;
	};
	


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(80);
	var Transform = __webpack_require__(81);
	var inherits = __webpack_require__(28);
	var modes = __webpack_require__(82);
	var ebtk = __webpack_require__(83);
	var StreamCipher = __webpack_require__(84);
	inherits(Cipher, Transform);
	function Cipher(mode, key, iv) {
	  if (!(this instanceof Cipher)) {
	    return new Cipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cache = new Splitter();
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	Cipher.prototype._transform = function (data, _, next) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  while ((chunk = this._cache.get())) {
	    thing = this._mode.encrypt(this, chunk);
	    this.push(thing);
	  }
	  next();
	};
	Cipher.prototype._flush = function (next) {
	  var chunk = this._cache.flush();
	  this.push(this._mode.encrypt(this, chunk));
	  this._cipher.scrub();
	  next();
	};
	
	
	function Splitter() {
	   if (!(this instanceof Splitter)) {
	    return new Splitter();
	  }
	  this.cache = new Buffer('');
	}
	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data]);
	};
	
	Splitter.prototype.get = function () {
	  if (this.cache.length > 15) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out;
	  }
	  return null;
	};
	Splitter.prototype.flush = function () {
	  var len = 16 - this.cache.length;
	  var padBuff = new Buffer(len);
	
	  var i = -1;
	  while (++i < len) {
	    padBuff.writeUInt8(len, i);
	  }
	  var out = Buffer.concat([this.cache, padBuff]);
	  return out;
	};
	var modelist = {
	  ECB: __webpack_require__(85),
	  CBC: __webpack_require__(86),
	  CFB: __webpack_require__(88),
	  OFB: __webpack_require__(89),
	  CTR: __webpack_require__(90)
	};
	module.exports = function (crypto) {
	  function createCipheriv(suite, password, iv) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    if (typeof iv === 'string') {
	      iv = new Buffer(iv);
	    }
	    if (typeof password === 'string') {
	      password = new Buffer(password);
	    }
	    if (password.length !== config.key/8) {
	      throw new TypeError('invalid key length ' + password.length);
	    }
	    if (iv.length !== config.iv) {
	      throw new TypeError('invalid iv length ' + iv.length);
	    }
	    if (config.type === 'stream') {
	      return new StreamCipher(modelist[config.mode], password, iv);
	    }
	    return new Cipher(modelist[config.mode], password, iv);
	  }
	  function createCipher (suite, password) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    var keys = ebtk(crypto, password, config.key, config.iv);
	    return createCipheriv(suite, keys.key, keys.iv);
	  }
	  return {
	    createCipher: createCipher,
	    createCipheriv: createCipheriv
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var uint_max = Math.pow(2, 32);
	function fixup_uint32(x) {
	    var ret, x_pos;
	    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
	    return ret;
	}
	function scrub_vec(v) {
	  var i, _i, _ref;
	  for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	    v[i] = 0;
	  }
	  return false;
	}
	
	function Global() {
	  var i;
	  this.SBOX = [];
	  this.INV_SBOX = [];
	  this.SUB_MIX = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 4; i = ++_i) {
	      _results.push([]);
	    }
	    return _results;
	  })();
	  this.INV_SUB_MIX = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 4; i = ++_i) {
	      _results.push([]);
	    }
	    return _results;
	  })();
	  this.init();
	  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
	}
	
	Global.prototype.init = function() {
	  var d, i, sx, t, x, x2, x4, x8, xi, _i;
	  d = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 256; i = ++_i) {
	      if (i < 128) {
	        _results.push(i << 1);
	      } else {
	        _results.push((i << 1) ^ 0x11b);
	      }
	    }
	    return _results;
	  })();
	  x = 0;
	  xi = 0;
	  for (i = _i = 0; _i < 256; i = ++_i) {
	    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	    this.SBOX[x] = sx;
	    this.INV_SBOX[sx] = x;
	    x2 = d[x];
	    x4 = d[x2];
	    x8 = d[x4];
	    t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
	    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
	    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
	    this.SUB_MIX[3][x] = t;
	    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
	    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
	    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
	    this.INV_SUB_MIX[3][sx] = t;
	    if (x === 0) {
	      x = xi = 1;
	    } else {
	      x = x2 ^ d[d[d[x8 ^ x2]]];
	      xi ^= d[d[xi]];
	    }
	  }
	  return true;
	};
	
	var G = new Global();
	
	
	AES.blockSize = 4 * 4;
	
	AES.prototype.blockSize = AES.blockSize;
	
	AES.keySize = 256 / 8;
	
	AES.prototype.keySize = AES.keySize;
	
	AES.ivSize = AES.blockSize;
	
	AES.prototype.ivSize = AES.ivSize;
	
	 function bufferToArray(buf) {
	  var len = buf.length/4;
	  var out = new Array(len);
	  var i = -1;
	  while (++i < len) {
	    out[i] = buf.readUInt32BE(i * 4);
	  }
	  return out;
	 }
	function AES(key) {
	  this._key = bufferToArray(key);
	  this._doReset();
	}
	
	AES.prototype._doReset = function() {
	  var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;
	  keyWords = this._key;
	  keySize = keyWords.length;
	  this._nRounds = keySize + 6;
	  ksRows = (this._nRounds + 1) * 4;
	  this._keySchedule = [];
	  for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {
	    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
	  }
	  this._invKeySchedule = [];
	  for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {
	    ksRow = ksRows - invKsRow;
	    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
	    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
	  }
	  return true;
	};
	
	AES.prototype.encryptBlock = function(M) {
	  M = bufferToArray(new Buffer(M));
	  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);
	  var buf = new Buffer(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[1], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[3], 12);
	  return buf;
	};
	
	AES.prototype.decryptBlock = function(M) {
	  M = bufferToArray(new Buffer(M));
	  var temp = [M[3], M[1]];
	  M[1] = temp[0];
	  M[3] = temp[1];
	  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
	  var buf = new Buffer(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[3], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[1], 12);
	  return buf;
	};
	
	AES.prototype.scrub = function() {
	  scrub_vec(this._keySchedule);
	  scrub_vec(this._invKeySchedule);
	  scrub_vec(this._key);
	};
	
	AES.prototype._doCryptBlock = function(M, keySchedule, SUB_MIX, SBOX) {
	  var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;
	
	  s0 = M[0] ^ keySchedule[0];
	  s1 = M[1] ^ keySchedule[1];
	  s2 = M[2] ^ keySchedule[2];
	  s3 = M[3] ^ keySchedule[3];
	  ksRow = 4;
	  for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {
	    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
	    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
	    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
	    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
	    s0 = t0;
	    s1 = t1;
	    s2 = t2;
	    s3 = t3;
	  }
	  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
	  return [
	    fixup_uint32(t0),
	    fixup_uint32(t1),
	    fixup_uint32(t2),
	    fixup_uint32(t3)
	  ];
	
	};
	
	
	
	
	  exports.AES = AES;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Transform = __webpack_require__(27).Transform;
	var inherits = __webpack_require__(28);
	
	module.exports = CipherBase;
	inherits(CipherBase, Transform);
	function CipherBase() {
	  Transform.call(this);
	}
	CipherBase.prototype.update = function (data, inputEnd, outputEnc) {
	  this.write(data, inputEnd);
	  var outData = new Buffer('');
	  var chunk;
	  while ((chunk = this.read())) {
	    outData = Buffer.concat([outData, chunk]);
	  }
	  if (outputEnc) {
	    outData = outData.toString(outputEnc);
	  }
	  return outData;
	};
	CipherBase.prototype.final = function (outputEnc) {
	  this.end();
	  var outData = new Buffer('');
	  var chunk;
	  while ((chunk = this.read())) {
	    outData = Buffer.concat([outData, chunk]);
	  }
	  if (outputEnc) {
	    outData = outData.toString(outputEnc);
	  }
	  return outData;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 82 */
/***/ function(module, exports) {

	exports['aes-128-ecb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-192-ecb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-256-ecb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-128-cbc'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes-192-cbc'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes-256-cbc'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes128'] = exports['aes-128-cbc'];
	exports['aes192'] = exports['aes-192-cbc'];
	exports['aes256'] = exports['aes-256-cbc'];
	exports['aes-128-cfb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-192-cfb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-256-cfb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-128-ofb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-192-ofb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-256-ofb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-128-ctr'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};
	exports['aes-192-ctr'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};
	exports['aes-256-ctr'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = function (crypto, password, keyLen, ivLen) {
	  keyLen = keyLen/8;
	  ivLen = ivLen || 0;
	  var ki = 0;
	  var ii = 0;
	  var key = new Buffer(keyLen);
	  var iv = new Buffer(ivLen);
	  var addmd = 0;
	  var md, md_buf;
	  var i;
	  while (true) {
	    md = crypto.createHash('md5');
	    if(addmd++ > 0) {
	       md.update(md_buf);
	    }
	    md.update(password);
	    md_buf = md.digest();
	    i = 0;
	    if(keyLen > 0) {
	      while(true) {
	        if(keyLen === 0) {
	          break;
	        }
	        if(i === md_buf.length) {
	          break;
	        }
	        key[ki++] = md_buf[i];
	        keyLen--;
	        i++;
	       }
	    }
	    if(ivLen > 0 && i !== md_buf.length) {
	      while(true) {
	        if(ivLen === 0) {
	          break;
	        }
	        if(i === md_buf.length) {
	          break;
	        }
	       iv[ii++] = md_buf[i];
	       ivLen--;
	       i++;
	     }
	   }
	   if(keyLen === 0 && ivLen === 0) {
	      break;
	    }
	  }
	  for(i=0;i<md_buf.length;i++) {
	    md_buf[i] = 0;
	  }
	  return {
	    key: key,
	    iv: iv
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(80);
	var Transform = __webpack_require__(81);
	var inherits = __webpack_require__(28);
	
	inherits(StreamCipher, Transform);
	module.exports = StreamCipher;
	function StreamCipher(mode, key, iv, decrypt) {
	  if (!(this instanceof StreamCipher)) {
	    return new StreamCipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  this._cache = new Buffer('');
	  this._secCache = new Buffer('');
	  this._decrypt = decrypt;
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	StreamCipher.prototype._transform = function (chunk, _, next) {
	  next(null, this._mode.encrypt(this, chunk, this._decrypt));
	};
	StreamCipher.prototype._flush = function (next) {
	  this._cipher.scrub();
	  next();
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 85 */
/***/ function(module, exports) {

	exports.encrypt = function (self, block) {
	  return self._cipher.encryptBlock(block);
	};
	exports.decrypt = function (self, block) {
	  return self._cipher.decryptBlock(block);
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var xor = __webpack_require__(87);
	exports.encrypt = function (self, block) {
	  var data = xor(block, self._prev);
	  self._prev = self._cipher.encryptBlock(data);
	  return self._prev;
	};
	exports.decrypt = function (self, block) {
	  var pad = self._prev;
	  self._prev = block;
	  var out = self._cipher.decryptBlock(block);
	  return xor(out, pad);
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = xor;
	function xor(a, b) {
	  var len = Math.min(a.length, b.length);
	  var out = new Buffer(len);
	  var i = -1;
	  while (++i < len) {
	    out.writeUInt8(a[i] ^ b[i], i);
	  }
	  return out;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(87);
	exports.encrypt = function (self, data, decrypt) {
	  var out = new Buffer('');
	  var len;
	  while (data.length) {
	    if (self._cache.length === 0) {
	      self._cache = self._cipher.encryptBlock(self._prev);
	      self._prev = new Buffer('');
	    }
	    if (self._cache.length <= data.length) {
	      len = self._cache.length;
	      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
	      data = data.slice(len);
	    } else {
	      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
	      break;
	    }
	  }
	  return out;
	};
	function encryptStart(self, data, decrypt) {
	  var len = data.length;
	  var out = xor(data, self._cache);
	  self._cache = self._cache.slice(len);
	  self._prev = Buffer.concat([self._prev, decrypt?data:out]);
	  return out;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(87);
	function getBlock(self) {
	  self._prev = self._cipher.encryptBlock(self._prev);
	  return self._prev;
	}
	exports.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)]);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor(chunk, pad);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(87);
	function getBlock(self) {
	  var out = self._cipher.encryptBlock(self._prev);
	  incr32(self._prev);
	  return out;
	}
	exports.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)]);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor(chunk, pad);
	};
	function incr32(iv) {
	  var len = iv.length;
	  var item;
	  while (len--) {
	    item = iv.readUInt8(len);
	    if (item === 255) {
	      iv.writeUInt8(0, len);
	    } else {
	      item++;
	      iv.writeUInt8(item, len);
	      break;
	    }
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(80);
	var Transform = __webpack_require__(81);
	var inherits = __webpack_require__(28);
	var modes = __webpack_require__(82);
	var StreamCipher = __webpack_require__(84);
	var ebtk = __webpack_require__(83);
	
	inherits(Decipher, Transform);
	function Decipher(mode, key, iv) {
	  if (!(this instanceof Decipher)) {
	    return new Decipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cache = new Splitter();
	  this._last = void 0;
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	Decipher.prototype._transform = function (data, _, next) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  while ((chunk = this._cache.get())) {
	    thing = this._mode.decrypt(this, chunk);
	    this.push(thing);
	  }
	  next();
	};
	Decipher.prototype._flush = function (next) {
	  var chunk = this._cache.flush();
	  if (!chunk) {
	    return next;
	  }
	
	  this.push(unpad(this._mode.decrypt(this, chunk)));
	
	  next();
	};
	
	function Splitter() {
	   if (!(this instanceof Splitter)) {
	    return new Splitter();
	  }
	  this.cache = new Buffer('');
	}
	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data]);
	};
	
	Splitter.prototype.get = function () {
	  if (this.cache.length > 16) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out;
	  }
	  return null;
	};
	Splitter.prototype.flush = function () {
	  if (this.cache.length) {
	    return this.cache;
	  }
	};
	function unpad(last) {
	  var padded = last[15];
	  if (padded === 16) {
	    return;
	  }
	  return last.slice(0, 16 - padded);
	}
	
	var modelist = {
	  ECB: __webpack_require__(85),
	  CBC: __webpack_require__(86),
	  CFB: __webpack_require__(88),
	  OFB: __webpack_require__(89),
	  CTR: __webpack_require__(90)
	};
	
	module.exports = function (crypto) {
	  function createDecipheriv(suite, password, iv) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    if (typeof iv === 'string') {
	      iv = new Buffer(iv);
	    }
	    if (typeof password === 'string') {
	      password = new Buffer(password);
	    }
	    if (password.length !== config.key/8) {
	      throw new TypeError('invalid key length ' + password.length);
	    }
	    if (iv.length !== config.iv) {
	      throw new TypeError('invalid iv length ' + iv.length);
	    }
	    if (config.type === 'stream') {
	      return new StreamCipher(modelist[config.mode], password, iv, true);
	    }
	    return new Decipher(modelist[config.mode], password, iv);
	  }
	
	  function createDecipher (suite, password) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    var keys = ebtk(crypto, password, config.key, config.iv);
	    return createDecipheriv(suite, keys.key, keys.iv);
	  }
	  return {
	    createDecipher: createDecipher,
	    createDecipheriv: createDecipheriv
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./agent": 93,
		"./agent.js": 93,
		"./aws-info": 100,
		"./aws-info.js": 100,
		"./collector/api": 97,
		"./collector/api.js": 97,
		"./collector/facts": 98,
		"./collector/facts.js": 98,
		"./collector/http-agents": 154,
		"./collector/http-agents.js": 154,
		"./collector/parse-response": 152,
		"./collector/parse-response.js": 152,
		"./collector/remote-method": 136,
		"./collector/remote-method.js": 136,
		"./collector/ssl/certificates": 165,
		"./collector/ssl/certificates.js": 165,
		"./config": 57,
		"./config.default": 192,
		"./config.default.js": 192,
		"./config.js": 57,
		"./db/parse-sql": 193,
		"./db/parse-sql.js": 193,
		"./db/parsed-statement": 195,
		"./db/parsed-statement.js": 195,
		"./db/statement-matcher": 194,
		"./db/statement-matcher.js": 194,
		"./db/tracer": 182,
		"./db/tracer.js": 182,
		"./db/util": 196,
		"./db/util.js": 196,
		"./environment": 185,
		"./environment.js": 185,
		"./errors/aggregator": 166,
		"./errors/aggregator.js": 166,
		"./errors/index": 169,
		"./errors/index.js": 169,
		"./feature_flags": 60,
		"./feature_flags.js": 60,
		"./instrumentation/bluebird": 197,
		"./instrumentation/bluebird.js": 197,
		"./instrumentation/cassandra-driver": 200,
		"./instrumentation/cassandra-driver.js": 200,
		"./instrumentation/connect": 201,
		"./instrumentation/connect.js": 201,
		"./instrumentation/core/child_process": 202,
		"./instrumentation/core/child_process.js": 202,
		"./instrumentation/core/crypto": 203,
		"./instrumentation/core/crypto.js": 203,
		"./instrumentation/core/dns": 204,
		"./instrumentation/core/dns.js": 204,
		"./instrumentation/core/domain": 205,
		"./instrumentation/core/domain.js": 205,
		"./instrumentation/core/fs": 206,
		"./instrumentation/core/fs.js": 206,
		"./instrumentation/core/globals": 208,
		"./instrumentation/core/globals.js": 208,
		"./instrumentation/core/http": 209,
		"./instrumentation/core/http.js": 209,
		"./instrumentation/core/net": 215,
		"./instrumentation/core/net.js": 215,
		"./instrumentation/core/timers": 216,
		"./instrumentation/core/timers.js": 216,
		"./instrumentation/core/zlib": 217,
		"./instrumentation/core/zlib.js": 217,
		"./instrumentation/director": 218,
		"./instrumentation/director.js": 218,
		"./instrumentation/express": 219,
		"./instrumentation/express.js": 219,
		"./instrumentation/express/common": 222,
		"./instrumentation/express/common.js": 222,
		"./instrumentation/express/express-2": 221,
		"./instrumentation/express/express-2.js": 221,
		"./instrumentation/generic-pool": 223,
		"./instrumentation/generic-pool.js": 223,
		"./instrumentation/hapi": 224,
		"./instrumentation/hapi.js": 224,
		"./instrumentation/ioredis": 225,
		"./instrumentation/ioredis.js": 225,
		"./instrumentation/memcached": 227,
		"./instrumentation/memcached.js": 227,
		"./instrumentation/mongodb": 229,
		"./instrumentation/mongodb.js": 229,
		"./instrumentation/mysql": 230,
		"./instrumentation/mysql.js": 230,
		"./instrumentation/node-cassandra-cql": 231,
		"./instrumentation/node-cassandra-cql.js": 231,
		"./instrumentation/oracle": 233,
		"./instrumentation/oracle.js": 233,
		"./instrumentation/pg": 234,
		"./instrumentation/pg.js": 234,
		"./instrumentation/promise": 198,
		"./instrumentation/promise.js": 198,
		"./instrumentation/q": 235,
		"./instrumentation/q.js": 235,
		"./instrumentation/redis": 236,
		"./instrumentation/redis.js": 236,
		"./instrumentation/restify": 237,
		"./instrumentation/restify.js": 237,
		"./instrumentations": 181,
		"./instrumentations.js": 181,
		"./logger": 12,
		"./logger.js": 12,
		"./metrics/index": 170,
		"./metrics/index.js": 170,
		"./metrics/mapper": 178,
		"./metrics/mapper.js": 178,
		"./metrics/names": 59,
		"./metrics/names.js": 59,
		"./metrics/normalizer": 173,
		"./metrics/normalizer.js": 173,
		"./metrics/normalizer/rule": 176,
		"./metrics/normalizer/rule.js": 176,
		"./metrics/normalizer/tx_segment": 177,
		"./metrics/normalizer/tx_segment.js": 177,
		"./metrics/recorders/cassandra": 232,
		"./metrics/recorders/cassandra.js": 232,
		"./metrics/recorders/custom": 238,
		"./metrics/recorders/custom.js": 238,
		"./metrics/recorders/express": 220,
		"./metrics/recorders/express.js": 220,
		"./metrics/recorders/generic": 207,
		"./metrics/recorders/generic.js": 207,
		"./metrics/recorders/http": 210,
		"./metrics/recorders/http.js": 210,
		"./metrics/recorders/http_external": 213,
		"./metrics/recorders/http_external.js": 213,
		"./metrics/recorders/memcached": 228,
		"./metrics/recorders/memcached.js": 228,
		"./metrics/recorders/other": 239,
		"./metrics/recorders/other.js": 239,
		"./metrics/recorders/redis": 226,
		"./metrics/recorders/redis.js": 226,
		"./parse-dockerinfo": 133,
		"./parse-dockerinfo.js": 133,
		"./parse-proc-cpuinfo": 132,
		"./parse-proc-cpuinfo.js": 132,
		"./parse-proc-meminfo": 134,
		"./parse-proc-meminfo.js": 134,
		"./reservoir": 94,
		"./reservoir.js": 94,
		"./sampler": 95,
		"./sampler.js": 95,
		"./shimmer": 199,
		"./shimmer.js": 199,
		"./stats/apdex": 172,
		"./stats/apdex.js": 172,
		"./stats/index": 171,
		"./stats/index.js": 171,
		"./system-info": 99,
		"./system-info.js": 99,
		"./timer": 96,
		"./timer.js": 96,
		"./transaction/index": 187,
		"./transaction/index.js": 187,
		"./transaction/name-state": 191,
		"./transaction/name-state.js": 191,
		"./transaction/trace/aggregator": 179,
		"./transaction/trace/aggregator.js": 179,
		"./transaction/trace/index": 188,
		"./transaction/trace/index.js": 188,
		"./transaction/trace/segment": 189,
		"./transaction/trace/segment.js": 189,
		"./transaction/tracer/index": 186,
		"./transaction/tracer/index.js": 186,
		"./transaction/tracer/instrumentation/outbound": 212,
		"./transaction/tracer/instrumentation/outbound.js": 212,
		"./uninstrumented": 180,
		"./uninstrumented.js": 180,
		"./util/arrays": 174,
		"./util/arrays.js": 174,
		"./util/cat": 211,
		"./util/cat.js": 211,
		"./util/codec": 184,
		"./util/codec.js": 184,
		"./util/copy": 167,
		"./util/copy.js": 167,
		"./util/deep-equal": 175,
		"./util/deep-equal.js": 175,
		"./util/flatten": 61,
		"./util/flatten.js": 61,
		"./util/hashes": 62,
		"./util/hashes.js": 62,
		"./util/label-parser": 135,
		"./util/label-parser.js": 135,
		"./util/logger": 13,
		"./util/logger.js": 13,
		"./util/safe-json": 14,
		"./util/safe-json.js": 14,
		"./util/sql/obfuscate": 183,
		"./util/sql/obfuscate.js": 183,
		"./util/stream-sink": 153,
		"./util/stream-sink.js": 153,
		"./util/sum-children": 190,
		"./util/sum-children.js": 190,
		"./util/urltils": 168,
		"./util/urltils.js": 168
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 92;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var util = __webpack_require__(16)
	var EventEmitter = __webpack_require__(26).EventEmitter
	var Reservoir = __webpack_require__(94)
	var logger = __webpack_require__(12)
	var sampler = __webpack_require__(95)
	var NAMES = __webpack_require__(59)
	var CollectorAPI = __webpack_require__(97)
	var ErrorAggregator = __webpack_require__(166)
	var Metrics = __webpack_require__(170)
	var MetricNormalizer = __webpack_require__(173)
	var TxSegmentNormalizer = __webpack_require__(177)
	var MetricMapper = __webpack_require__(178)
	var TraceAggregator = __webpack_require__(179)
	var hashes = __webpack_require__(62)
	var uninstrumented = __webpack_require__(180)
	var QueryTracer = __webpack_require__(182)
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	
	var STATES = [
	  'stopped',      // start state
	  'starting',     // handshaking with NR
	  'connected',    // connected to collector
	  'disconnected', // disconnected from collector
	  'started',      // up and running
	  'stopping',     // shutting down
	  'errored'       // stopped due to error
	]
	
	// just to make clear what's going on
	var TO_MILLIS = 1e3
	var FROM_MILLIS = 1e-3
	
	// Check for already loaded modules and warn about them. This must be executed
	// only once, at the first require of this file, or else we have problems in
	// unit tests.
	uninstrumented.check()
	
	/**
	 * There's a lot of stuff in this constructor, due to Agent acting as the
	 * orchestrator for New Relic within instrumented applications.
	 *
	 * This constructor can throw if, for some reason, the configuration isn't
	 * available. Don't try to recover here, because without configuration the
	 * agent can't be brought up to a useful state.
	 */
	function Agent(config) {
	  EventEmitter.call(this)
	
	  if (!config) throw new Error("Agent must be created with a configuration!")
	
	  // The agent base attributes which last throughout its lifetime.
	  this._state = 'stopped'
	  this.config = config
	  this.environment = __webpack_require__(185)
	  this.version = this.config.version
	  this.collector = new CollectorAPI(this)
	
	  // Reset the agent to add all the sub-objects it needs. These object are the
	  // ones that get re-created if the agent is told to restart from the collector.
	  this.events = null
	  this.customEvents = null
	  this.errors = null
	  this.mapper = null
	  this.metricNameNormalizer = null
	  this.metrics = null
	  this.transactionNameNormalizer = null
	  this.urlNormalizer = null
	  this.txSegmentNormalizer = null
	  this.userNormalizer = null
	  this.reset()
	
	  // Transaction tracing.
	  this.tracer = this._setupTracer()
	  this.traces = new TraceAggregator(this.config)
	
	  // Query tracing.
	  this.queries = new QueryTracer(this.config)
	
	  // Set up all the configuration events the agent needs to listen for.
	  var self = this
	  this.config.on('apdex_t', this._apdexTChange.bind(this))
	  this.config.on('data_report_period', this._harvesterIntervalChange.bind(this))
	  this.config.on('agent_enabled', this._enabledChange.bind(this))
	  this.config.on('change', this._configChange.bind(this))
	  this.config.on('metric_name_rules', function updateMetricNameNormalizer() {
	    self.metricNameNormalizer.load.apply(self.metricNameNormalizer, arguments)
	  })
	  this.config.on('transaction_name_rules', function updateTransactionNameNormalizer() {
	    self.transactionNameNormalizer.load.apply(self.transactionNameNormalizer, arguments)
	  })
	  this.config.on('url_rules', function updateUrlNormalizer() {
	    self.urlNormalizer.load.apply(self.urlNormalizer, arguments)
	  })
	  this.config.on('transaction_segment_terms', function updateSegmentNormalizer() {
	    self.txSegmentNormalizer.load.apply(self.txSegmentNormalizer, arguments)
	  })
	
	  // Entity tracking metrics.
	  this.totalActiveSegments = 0
	  this.segmentsCreatedInHarvest = 0
	  this.segmentsClearedInHarvest = 0
	  this.activeTransactions = 0
	
	  // Hidden class optimizations.
	  this.harvesterHandle = null
	
	  // Finally, add listeners for the agent's own events.
	  this.on('transactionFinished', this._transactionFinished.bind(this))
	}
	util.inherits(Agent, EventEmitter)
	
	/**
	 * The agent is meant to only exist once per application, but the singleton is
	 * managed by index.js. An agent will be created even if the agent's disabled by
	 * the configuration.
	 *
	 * @config {boolean} agent_enabled Whether to start up the agent.
	 *
	 * @param {Function} callback Continuation and error handler.
	 */
	Agent.prototype.start = function start(callback) {
	  if (!callback) throw new TypeError("callback required!")
	
	  var agent = this
	
	  this.setState('starting')
	
	  if (this.config.agent_enabled !== true) {
	    logger.warn("The New Relic Node.js agent is disabled by its configuration. " +
	                "Not starting!")
	
	    this.setState('stopped')
	    return process.nextTick(callback)
	  }
	
	  if (!(this.config.license_key)) {
	    logger.error("A valid account license key cannot be found. " +
	                 "Has a license key been specified in the agent configuration " +
	                 "file or via the NEW_RELIC_LICENSE_KEY environment variable?")
	
	    this.setState('errored')
	    return process.nextTick(function cb_nextTick() {
	      callback(new Error("Not starting without license key!"))
	    })
	  }
	
	  sampler.start(agent)
	
	  logger.info("Starting New Relic for Node.js connection process.")
	
	  this.collector.connect(function cb_connect(error, config) {
	    if (error) {
	      agent.setState('errored')
	      return callback(error, config)
	    }
	
	    if (agent.collector.isConnected() && !agent.config.no_immediate_harvest) {
	      // harvest immediately for quicker data display, but after at least 1
	      // second or the collector will throw away the data.
	      setTimeout(function one_sec_delayed_harvest() {
	        agent.harvest(function cb_harvest(error) {
	          agent._startHarvester(agent.config.data_report_period)
	
	          agent.setState('started')
	          callback(error, config)
	        })
	      }, 1000)
	    } else {
	      process.nextTick(function cb_nextTick() {
	        callback(null, config)
	      })
	    }
	  })
	}
	
	/**
	 * Any memory claimed by the agent will be retained after stopping.
	 *
	 * FIXME: make it possible to dispose of the agent, as well as do a
	 * "hard" restart. This requires working with shimmer to strip the
	 * current instrumentation and patch to the module loader.
	 */
	Agent.prototype.stop = function stop(callback) {
	  if (!callback) throw new TypeError("callback required!")
	
	  var agent = this
	
	  this.setState('stopping')
	  this._stopHarvester()
	  sampler.stop()
	
	  if (this.collector.isConnected()) {
	    this.collector.shutdown(function cb_shutdown(error) {
	      if (error) {
	        agent.setState('errored')
	        logger.warn(error, "Got error shutting down connection to New Relic:")
	      } else {
	        agent.setState('stopped')
	        logger.info("Stopped New Relic for Node.js.")
	      }
	
	      callback(error)
	    })
	  } else {
	    process.nextTick(callback)
	  }
	}
	
	/**
	 * Builds all of the sub-properties of the agent that rely on configurations.
	 */
	Agent.prototype.reset = function reset() {
	  // Insights events.
	  if (!this.events) {
	    this.events = new Reservoir()
	  }
	  this.events.setLimit(this.config.transaction_events.max_samples_per_minute)
	  if (!this.customEvents) {
	    this.customEvents = new Reservoir()
	  }
	  this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)
	
	  // Error tracing.
	  if (!this.errors) {
	    this.errors = new ErrorAggregator(this.config)
	  }
	  this.errors.reconfigure(this.config)
	
	  // Metrics.
	  this.mapper = new MetricMapper()
	  this.metricNameNormalizer = new MetricNormalizer(this.config, 'metric name')
	  this.metrics = new Metrics(this.config.apdex_t, this.mapper, this.metricNameNormalizer)
	
	  // Transaction naming.
	  this.transactionNameNormalizer = new MetricNormalizer(this.config, 'transaction name')
	  this.urlNormalizer = new MetricNormalizer(this.config, 'URL')
	
	  // Segment term based tx renaming for MGI mitigation.
	  this.txSegmentNormalizer = new TxSegmentNormalizer()
	
	  // User naming and ignoring rules.
	  this.userNormalizer = new MetricNormalizer(this.config, 'user')
	  this.userNormalizer.loadFromConfig()
	
	  // Supportability.
	  if (this.config.debug.internal_metrics) {
	    this.config.debug.supportability = new Metrics(
	      this.config.apdex_t,
	      this.mapper,
	      this.metricNameNormalizer
	    )
	  }
	}
	
	/**
	 * On agent startup, an interval timer is started that calls this method once
	 * a minute, which in turn invokes the pieces of the harvest cycle. It calls
	 * the various collector API methods in order, bailing out if one of them fails,
	 * to ensure that the agents don't pummel the collector if it's already
	 * struggling.
	 */
	Agent.prototype.harvest = function harvest(callback) {
	  if (!callback) throw new TypeError("callback required!")
	
	  var agent = this
	  var harvestSteps = [
	    '_sendMetrics',
	    '_sendErrors',
	    '_sendTrace',
	    '_sendEvents',
	    '_sendCustomEvents',
	    '_sendQueries',
	    '_sendErrorEvents'
	  ]
	
	  logger.trace({
	    segmentTotal: this.totalActiveSegments,
	    harvestCreated: this.segmentsCreatedInHarvest,
	    harvestCleared: this.segmentsClearedInHarvest,
	    activeTransactions: this.activeTransactions
	  }, 'Entity stats on harvest')
	
	  this.segmentsCreatedInHarvest = 0
	  this.segmentsClearedInHarvest = 0
	
	  if (!this.collector.isConnected()) {
	    return process.nextTick(function cb_nextTick() {
	      callback(new Error("Not connected to New Relic!"))
	    })
	  }
	  runHarvestStep(0)
	
	  function runHarvestStep(n) {
	    agent[harvestSteps[n++]](next)
	
	    function next(error) {
	      if (error || n >= harvestSteps.length) return callback(error)
	      runHarvestStep(n)
	    }
	  }
	}
	
	/**
	 * Public interface for passing configuration data from the collector
	 * on to the configuration, in an effort to keep them at least somewhat
	 * decoupled.
	 *
	 * @param {object} configuration New config JSON from the collector.
	 */
	Agent.prototype.reconfigure = function reconfigure(configuration) {
	  if (!configuration) throw new TypeError("must pass configuration")
	
	  this.config.onConnect(configuration)
	}
	
	/**
	 * Make it easier to determine what state the agent thinks it's in (needed
	 * for a few tests, but fragile).
	 *
	 * FIXME: remove the need for this
	 *
	 * @param {string} newState The new state of the agent.
	 */
	Agent.prototype.setState = function setState(newState) {
	  if (STATES.indexOf(newState) === -1) {
	    throw new TypeError("Invalid state " + newState)
	  }
	  logger.debug("Agent state changed from %s to %s.", this._state, newState)
	  this._state = newState
	  this.emit(this._state)
	}
	
	/**
	 * Server-side configuration value.
	 *
	 * @param {number} apdexT Apdex tolerating value, in seconds.
	 */
	Agent.prototype._apdexTChange = function _apdexTChange(apdexT) {
	  logger.debug("Apdex tolerating value changed to %s.", apdexT)
	  this.metrics.apdexT = apdexT
	  if (this.config.debug.supportability) {
	    this.config.debug.supportability.apdexT = apdexT
	  }
	}
	
	/**
	 * Server-side configuration value. When run, forces a harvest cycle
	 * so as to not cause the agent to go too long without reporting.
	 *
	 * @param {number} interval Time in seconds between harvest runs.
	 */
	Agent.prototype._harvesterIntervalChange = _harvesterIntervalChange
	
	function _harvesterIntervalChange(interval, callback) {
	  var agent = this
	
	  // only change the setup if the harvester is currently running
	  if (this.harvesterHandle) {
	    // force a harvest now, to be safe
	    this.harvest(function cb_harvest(error) {
	      agent._restartHarvester(interval)
	      if (callback) callback(error)
	    })
	  } else if (callback) {
	    process.nextTick(callback)
	  }
	}
	
	/**
	 * Restart the harvest cycle timer.
	 *
	 * @param {number} harvestSeconds How many seconds between harvests.
	 */
	Agent.prototype._restartHarvester = function _restartHarvester(harvestSeconds) {
	  this._stopHarvester()
	  this._startHarvester(harvestSeconds)
	}
	
	/**
	 * Safely stop the harvest cycle timer.
	 */
	Agent.prototype._stopHarvester = function _stopHarvester() {
	  if (this.harvesterHandle) clearInterval(this.harvesterHandle)
	  this.harvesterHandle = undefined
	}
	
	/**
	 * Safely start the harvest cycle timer, and ensure that the harvest
	 * cycle won't keep an application from exiting if nothing else is
	 * happening to keep it up.
	 *
	 * @param {number} harvestSeconds How many seconds between harvests.
	 */
	Agent.prototype._startHarvester = function _startHarvester(harvestSeconds) {
	  var agent = this
	
	  function onError(error) {
	    if (error) {
	      logger.info(error, "Error on submission to New Relic (data held for redelivery):")
	    }
	  }
	
	  function harvester() {
	    agent.harvest(onError)
	  }
	
	  this.harvesterHandle = setInterval(harvester, harvestSeconds * TO_MILLIS)
	  // timer.unref is 0.9+
	  if (this.harvesterHandle.unref) this.harvesterHandle.unref()
	}
	
	/**
	 * `agent_enabled` changed. This will generally only happen because of a high
	 * security mode mismatch between the agent and the collector. This only
	 * expects to have to stop the agent. No provisions have been made, nor
	 * testing have been done to make sure it is safe to start the agent back up.
	 */
	Agent.prototype._enabledChange = function _enabledChange() {
	  if (this.config.agent_enabled === false) {
	    logger.warn('agent_enabled has been changed to false, stopping the agent.')
	    this.stop(function nop() {})
	  }
	}
	
	/**
	 * Report new settings to collector after a configuration has changed. This
	 * always occurs after handling a response from a connect call.
	 */
	Agent.prototype._configChange = function _configChange() {
	  this.collector.reportSettings()
	}
	
	/**
	 * To develop the current transaction tracer, I created a tracing tracer that
	 * tracks when transactions, segments and function calls are proxied. This is
	 * used by the tests, but can also be dumped and logged, and is useful for
	 * figuring out where in the execution chain tracing is breaking down.
	 *
	 * @param object config Agent configuration.
	 *
	 * @returns Tracer Either a debugging or production transaction tracer.
	 */
	Agent.prototype._setupTracer = function _setupTracer() {
	  var Tracer = __webpack_require__(186)
	  return new Tracer(this)
	}
	
	/**
	 * The pieces of supportability metrics are scattered all over the place -- only
	 * send supportability metrics if they're explicitly enabled in the
	 * configuration.
	 *
	 * @param {Function} callback Gets any delivery errors.
	 */
	Agent.prototype._sendMetrics = function _sendMetrics(callback) {
	  var agent = this
	
	  if (this.collector.isConnected()) {
	    if (this.errors.getTotalErrorCount() > 0) {
	      var count = this.errors.getTotalErrorCount()
	      this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount(count)
	
	      count = this.errors.getWebTransactionsErrorCount()
	      this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount(count)
	
	      count = this.errors.getBackgroundTransactionsErrorCount()
	      this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount(count)
	    }
	
	    if (this.config.debug.supportability) {
	      this.metrics.merge(this.config.debug.supportability)
	    }
	
	    // Send uninstrumented supportability metrics every harvest cycle
	    uninstrumented.createMetrics(this.metrics)
	
	    this._processCustomEvents()
	    this._processErrorEvents()
	
	    // wait to check until all the standard stuff has been added
	    if (this.metrics.toJSON().length < 1) {
	      logger.debug("No metrics to send.")
	      return process.nextTick(callback)
	    }
	
	    var metrics = this.metrics
	    var beginSeconds = metrics.started * FROM_MILLIS
	    var endSeconds = Date.now() * FROM_MILLIS
	    var payload = [this.config.run_id, beginSeconds, endSeconds, metrics]
	
	
	    // reset now to avoid losing metrics that come in after delivery starts
	    this.metrics = new Metrics(
	      this.config.apdex_t,
	      this.mapper,
	      this.metricNameNormalizer
	    )
	
	    this.collector.metricData(payload, function cb_metricData(error, rules) {
	      if (error) agent.metrics.merge(metrics)
	      if (rules) agent.mapper.load(rules)
	
	      callback(error)
	    })
	  } else {
	    process.nextTick(function cb_nextTick() {
	      callback(new Error("not connected to New Relic (metrics will be held)"))
	    })
	  }
	}
	
	/**
	 * This function takes the custom events reservoir, gets stats on it for
	 * metric purposes, then instantiates a new custom events reservoir. This is
	 * so the stats are consistent with what actually gets pushed by the later
	 * call to _sendCustomEvents.
	 */
	Agent.prototype._processCustomEvents = function _processCustomEvents() {
	  this.customEventsPool = this.customEvents.toArray()
	
	  // Create the metrics so they are at least set to 0
	  var dropped = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.DROPPED)
	  var seen = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SEEN)
	  var sent = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SENT)
	
	  // Bail out if there are no events
	  if (this.customEventsPool.length === 0) {
	    return
	  }
	
	  if (this.config.custom_insights_events.enabled) {
	    // Record their values
	    var diff = this.customEvents.overflow()
	    dropped.incrementCallCount(diff)
	    seen.incrementCallCount(this.customEvents.seen)
	    sent.incrementCallCount(this.customEvents.seen - diff)
	
	    // Log any warnings about dropping events
	    if (diff) {
	      logger.warn('Dropped %s custom events out of %s.', diff, this.customEvents.seen)
	    }
	
	    // Create a new reservoir now (instead of at send time) so metrics match
	    // what we actually send.
	    this.customEvents = new Reservoir(
	      this.config.custom_insights_events.max_samples_stored
	    )
	  } else if (this.customEventsPool.length > 0) {
	    // We have events and custom events are disabled. Clear everything out so we
	    // don't hold onto memory that we shouldn't. Only time this could happen is
	    // if the server sent down settings disabling custom events in the middle of
	    // a harvest cycle.
	    this.customEventsPool = []
	    this.customEvents = new Reservoir(
	      this.config.custom_insights_events.max_samples_stored
	    )
	  }
	}
	
	/**
	 * This function takes the error events reservoir, gets stats on it for
	 * metric purposes, then instantiates a new error events reservoir. This is
	 * so the stats are consistent with what actually gets pushed by the later
	 * call to _sendErrorEvents.
	 */
	Agent.prototype._processErrorEvents = function _processErrorEvents() {
	  var events = this.errors.getEvents()
	
	  this._lastErrorEvents = [
	    this.errors.getEventsLimit(),
	    this.errors.getEventsSeen(),
	    events
	  ]
	
	  // Create the metrics so they are at least set to 0
	  var seen = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SEEN)
	  var sent = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SENT)
	
	  // Bail out if there are no events
	  if (events.length === 0) {
	    return
	  }
	
	  if (this.config.error_collector.capture_events) {
	    // Record their values
	    var diff = this.errors.events.overflow()
	    seen.incrementCallCount(this.errors.events.seen)
	    sent.incrementCallCount(this.errors.events.seen - diff)
	
	    // Log any warnings about dropping events
	    if (diff) {
	      logger.warn('Dropped %s error events out of %s.', diff, this.errors.events.seen)
	    }
	
	    // clear the reservoir now (instead of at send time) so metrics match
	    // what we actually send.
	    this.errors.clearEvents()
	  } else if (events.length > 0) {
	    // We have events and error events are disabled. Clear everything out so we
	    // don't hold onto memory that we shouldn't. Only time this could happen is
	    // if the server sent down settings disabling error events in the middle of
	    // a harvest cycle.
	    this._lastErrorEvents = []
	    this.errors.clearEvents()
	  }
	}
	
	/**
	 * The error tracer doesn't know about the agent, and the connection
	 * doesn't know about the error tracer. Only the agent knows about both.
	 *
	 * @param {Function} callback Gets any delivery errors.
	 */
	Agent.prototype._sendErrors = function _sendErrors(callback) {
	  var agent = this
	
	  if (this.config.collect_errors && this.config.error_collector.enabled) {
	    if (!this.collector.isConnected()) {
	      return process.nextTick(function cb_nextTick() {
	        callback(new Error("not connected to New Relic (errors will be held)"))
	      })
	    } else if (this.errors.getTotalErrorCount() < 1) {
	      logger.debug("No errors to send.")
	      return process.nextTick(callback)
	    }
	
	    var errors = this.errors.getErrors()
	    var payload = [this.config.run_id, errors]
	
	    // reset now to avoid losing errors that come in after delivery starts
	    this.errors.clearErrors()
	
	    this.collector.errorData(payload, function cb_errorData(error) {
	      if (error) agent.errors.merge(errors)
	
	      callback(error)
	    })
	  } else {
	    /**
	     * Reset the errors object even if collection is disabled due to error
	     * counting. Also covers the case where the error collector gets disabled
	     * in the middle of a harvest cycle so the agent doesn't continue to hold
	     * on to the errors it had collected during the harvest cycle so far.
	     */
	    this.errors.clearErrors()
	    process.nextTick(callback)
	  }
	}
	
	/**
	 * The trace aggregator has its own harvester, which is already
	 * asynchronous, due to its need to compress the nested transaction
	 * trace data.
	 *
	 * @param {Function} callback Gets any encoding or delivery errors.
	 */
	Agent.prototype._sendTrace = function _sendTrace(callback) {
	  var agent = this
	  if (this.config.collect_traces && this.config.transaction_tracer.enabled) {
	    if (!this.collector.isConnected()) {
	      return process.nextTick(function cb_nextTick() {
	        callback(new Error("not connected to New Relic (slow trace data will be held)"))
	      })
	    }
	
	    this.traces.harvest(function cb_harvest(error, traces, trace) {
	      if (error || !traces || traces.length === 0) return callback(error)
	
	      var payload = [agent.config.run_id, traces]
	      agent.collector.transactionSampleData(
	        payload,
	        function cb_transactionSampleData(error) {
	          if (!error) agent.traces.reset(trace)
	
	          callback(error)
	        }
	      )
	    })
	  } else {
	    process.nextTick(callback)
	  }
	}
	
	Agent.prototype._sendEvents = function _sendEvents(callback) {
	  if (this.config.transaction_events.enabled) {
	    var agent = this
	    var events = agent.events
	    var sample = events.toArray()
	    var run_id = agent.config.run_id
	
	    // bail if there are no events
	    if (sample.length < 1) {
	      return process.nextTick(callback)
	    }
	
	    var metrics = {
	      reservoir_size: events.limit,
	      events_seen: events.seen
	    }
	
	    var payload = [
	      run_id,
	      metrics,
	      sample
	    ]
	
	    // clear events
	    agent.events = new Reservoir(agent.config.transaction_events.max_samples_per_minute)
	
	    // send data to collector
	    agent.collector.analyticsEvents(payload, function cb_analyticsEvents(err) {
	      if (err && err.statusCode === 413 ) {
	        logger.warn('request too large; event data dropped')
	      } else if (err) {
	        logger.warn('analytics events failed to send; re-sampling')
	
	        // boost the limit if a connection fails
	        // and re-aggregate on failure
	        var newlimit = agent.config.transaction_events.max_samples_stored
	        agent.events.limit = newlimit
	
	        for (var k = 0; k < sample.length; k++) agent.events.add(sample[k])
	      } else {
	        // if we had to limit events and sample them, emit a warning
	        var diff = events.overflow()
	        if (diff > 0) logger.warn(
	          'analytics event overflow, dropped %d events; ' +
	           'try increasing your limit above %d',
	          diff, events.limit
	        )
	      }
	
	      callback(err)
	    })
	  } else {
	    process.nextTick(callback)
	  }
	}
	
	/**
	 * This is separate from _sendEvents because of potential post size problems.
	 * _processCustomEvents needs to happen before _sendCustomEvents. In the
	 * normal case it will have happened in _sendMetrics but if you are testing
	 * this or trying to use it directly for some reason you'll need to call
	 * _processCustomEvents first.
	 */
	Agent.prototype._sendCustomEvents = function _sendCustomEvents(callback) {
	  // Must be enabled and actually have events to send, otherwise bail and nextTick
	  if (this.config.custom_insights_events.enabled && this.customEventsPool.length > 0) {
	    var agent = this
	    var run_id = agent.config.run_id
	
	    var payload = [
	      run_id,
	      agent.customEventsPool
	    ]
	
	    // send data to collector
	    agent.collector.customEvents(payload, function cb_customEvents(err) {
	      if (err && err.statusCode === 413 ) {
	        var tooLarge = agent.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.TOO_LARGE)
	        tooLarge.incrementCallCount()
	        logger.warn('request too large; custom event data dropped')
	      } else if (err) {
	        var failed = agent.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.FAILED)
	        failed.incrementCallCount()
	        logger.warn('custom events failed to send; re-sampling')
	
	        for (var i = 0; i < agent.customEventsPool.length; i++) {
	          agent.customEvents.add(agent.customEventsPool[i])
	        }
	      }
	
	      callback(err)
	    })
	  } else {
	    process.nextTick(callback)
	  }
	}
	
	Agent.prototype._sendQueries = function _sendQueries(callback) {
	  var agent = this
	  var queries = this.queries
	
	  this.queries = new QueryTracer(agent.config)
	
	  if (!this.config.slow_sql.enabled) {
	    logger.debug('Slow Query is not enabled.')
	    return process.nextTick(callback)
	  }
	
	  if (Object.keys(queries.samples).length < 1) {
	    logger.debug('No queries to send.')
	    return process.nextTick(callback)
	  }
	
	  queries.prepareJSON(function gotJSON(err, data) {
	    if (err) {
	      this.queries.merge(queries)
	      logger.debug('Error while serializing query data: %s', err.message)
	      return callback(err)
	    }
	
	    agent.collector.queryData([data], function handleResponse(error) {
	      if (error) agent.queries.merge(queries)
	      callback(error)
	    })
	  })
	}
	
	Agent.prototype._sendErrorEvents = function _sendErrorEvents(callback) {
	  if (this.config.error_collector.capture_events && this._lastErrorEvents &&
	        this._lastErrorEvents[2].length > 0) {
	    var agent = this
	    var eventsLimit = this._lastErrorEvents[0]
	    var eventsSeen = this._lastErrorEvents[1]
	    var events = this._lastErrorEvents[2]
	    var run_id = agent.config.run_id
	
	    if (events.length < 1) {
	      return process.nextTick(callback)
	    }
	
	    var metrics = {
	      reservoir_size: eventsLimit,
	      events_seen: eventsSeen
	    }
	
	    var payload = [
	      run_id,
	      metrics,
	      events
	    ]
	
	    // send data to collector
	    agent.collector.errorEvents(payload, function cb_errorEvents(err) {
	      if (err && err.statusCode === 413 ) {
	        logger.warn('request too large; event data dropped')
	      } else if (err) {
	        logger.warn('error events failed to send; re-sampling')
	        agent.errors.mergeEvents(events)
	      }
	      callback(err)
	    })
	  } else {
	    process.nextTick(callback)
	  }
	}
	
	Agent.prototype._addIntrinsicAttrsFromTransaction = _addIntrinsicAttrsFromTransaction
	
	function _addIntrinsicAttrsFromTransaction(transaction) {
	  var intrinsicAttributes = {
	    webDuration: transaction.timer.duration / 1000,
	    timestamp: transaction.timer.start,
	    name: transaction.name,
	    duration: transaction.timer.duration / 1000,
	    type: 'Transaction',
	    error: transaction.hasErrors()
	  }
	
	  var metric = transaction.metrics.getMetric(NAMES.QUEUETIME)
	  if (metric) {
	    intrinsicAttributes.queueDuration = metric.total
	  }
	
	  metric = transaction.metrics.getMetric(NAMES.EXTERNAL.ALL)
	  if (metric) {
	    intrinsicAttributes.externalDuration = metric.total
	    intrinsicAttributes.externalCallCount = metric.callCount
	  }
	
	  metric = transaction.metrics.getMetric(NAMES.DB.ALL)
	  if (metric) {
	    intrinsicAttributes.databaseDuration = metric.total
	    intrinsicAttributes.databaseCallCount = metric.callCount
	  }
	
	  // FLAG: cat
	  if (this.config.feature_flag.cat) {
	    if (!transaction.invalidIncomingExternalTransaction &&
	         (
	           transaction.referringTransactionGuid ||
	           transaction.includesOutboundRequests()
	         )
	       ) {
	      intrinsicAttributes['nr.guid'] = transaction.id
	      intrinsicAttributes['nr.tripId'] = transaction.tripId || transaction.id
	      intrinsicAttributes['nr.pathHash'] = hashes.calculatePathHash(
	        this.config.applications()[0],
	        transaction.name || transaction.nameState.getName(),
	        transaction.referringPathHash
	      )
	      if (transaction.referringPathHash) {
	        intrinsicAttributes['nr.referringPathHash'] = transaction.referringPathHash
	      }
	      if (transaction.referringTransactionGuid) {
	        var refId = transaction.referringTransactionGuid
	        intrinsicAttributes['nr.referringTransactionGuid'] = refId
	      }
	      var alternatePathHashes = transaction.alternatePathHashes()
	      if (alternatePathHashes) {
	        intrinsicAttributes['nr.alternatePathHashes'] = alternatePathHashes
	      }
	      if (transaction.webSegment) {
	        var apdex = (this.config.web_transactions_apdex[transaction.name] ||
	                     this.config.apdex_t)
	        var duration = transaction.webSegment.getDurationInMillis() / 1000
	        intrinsicAttributes['nr.apdexPerfZone'] = calculateApdexZone(duration, apdex)
	      }
	    }
	  }
	
	  if (transaction.syntheticsData) {
	    intrinsicAttributes["nr.syntheticsResourceId"] = transaction.syntheticsData.resourceId
	    intrinsicAttributes["nr.syntheticsJobId"] = transaction.syntheticsData.jobId
	    intrinsicAttributes["nr.syntheticsMonitorId"] = transaction.syntheticsData.monitorId
	  }
	
	  return intrinsicAttributes
	}
	
	function calculateApdexZone(duration, apdexT) {
	  if (duration <= apdexT) {
	    return 'S' // satisfied
	  }
	
	  if (duration <= apdexT * 4) {
	    return 'T' // tolerating
	  }
	
	  return 'F' // frustrated
	}
	
	Agent.prototype._addEventFromTransaction = _addEventFromTransaction
	
	function _addEventFromTransaction(transaction) {
	  if (!this.config.transaction_events.enabled) return
	
	  var intrinsicAttributes = this._addIntrinsicAttrsFromTransaction(transaction)
	  var userAttributes = transaction.trace.custom
	  var agentAttributes = transaction.trace.parameters
	
	  var event = [
	    intrinsicAttributes,
	    userAttributes,
	    agentAttributes
	  ]
	
	  this.events.add(event)
	}
	
	/**
	 * Put all the logic for handing finalized transactions off to the tracers and
	 * metric collections in one place.
	 *
	 * @param {Transaction} transaction Newly-finalized transaction.
	 */
	Agent.prototype._transactionFinished = function _transactionFinished(transaction) {
	  // only available when this.config.debug.tracer_tracing is true
	  if (transaction.describer) {
	    logger.trace({trace_dump: transaction.describer.verbose}, 'Dumped transaction state.')
	  }
	
	  // Allow the API to explicitly set the ignored status on bg-tx.
	  // This is handled for web-tx when setName is called on the tx.
	  if (!transaction.isWeb() && transaction.forceIgnore !== null) {
	    transaction.ignore = transaction.forceIgnore
	  }
	
	  if (!transaction.ignore) {
	    if (transaction.forceIgnore === false) {
	      logger.debug("Explicitly not ignoring %s.", transaction.name)
	    }
	    this.metrics.merge(transaction.metrics)
	    this.errors.onTransactionFinished(transaction, this.metrics)
	    this.traces.add(transaction)
	
	    var trace = transaction.trace
	    trace.intrinsics = transaction.getIntrinsicAttributes()
	
	    this._addEventFromTransaction(transaction)
	  } else if (transaction.forceIgnore === true) {
	    logger.debug("Explicitly ignoring %s.", transaction.name)
	  } else {
	    logger.debug("Ignoring %s.", transaction.name)
	  }
	
	  this.activeTransactions--
	  this.totalActiveSegments -= transaction.numSegments
	  this.segmentsClearedInHarvest += transaction.numSegments
	}
	
	/**
	 * Get the current transaction (if there is one) from the tracer.
	 *
	 * @returns {Transaction} The current transaction.
	 */
	Agent.prototype.getTransaction = function getTransaction() {
	  return this.tracer.getTransaction()
	}
	
	module.exports = Agent
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 94 */
/***/ function(module, exports) {

	'use strict'
	
	// from http://en.wikipedia.org/wiki/Reservoir_sampling
	
	function Reservoir(limit) {
	  this.limit = limit || 10
	  this.seen = 0
	  this._data = []
	}
	
	Reservoir.prototype.overflow = function overflow() {
	  var diff = this.seen - this.limit
	  return diff >= 0 ? diff : 0
	}
	
	Reservoir.prototype.add = function add(item) {
	  if (this.seen < this.limit) {
	    this._data.push(item)
	  } else {
	    // Take a number between 0 and n + 1, drop the element at that index
	    // from the array. If the element to drop is the (n + 1)th, the new item is
	    // not added, otherwise the new item replaces the item that was
	    // dropped.
	    // This is effectively the same as adding the new element to the
	    // end, swapping the last element (the new one) with a random element in the list,
	    // then dropping the last element (the potentially swapped one) in the list.
	    var toReplace = Math.floor(Math.random() * (this.seen + 2))
	    if (toReplace < this.limit) this._data[toReplace] = item
	  }
	  this.seen++
	}
	
	Reservoir.prototype.toArray = function toArray() {
	  return this._data
	}
	
	Reservoir.prototype.merge = function merge(items) {
	  if (!items || !items.length) return
	  if (items === this._data) return
	  for (var i = 0; i < items.length; i++) {
	    this.add(items[i])
	  }
	}
	
	Reservoir.prototype.setLimit = function setLimit(newLimit) {
	  this.limit = newLimit
	  if (this._data.length > newLimit) {
	    this._data = this._data.slice(0, newLimit)
	  }
	}
	
	module.exports = Reservoir


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var NAMES = __webpack_require__(59)
	var logger = __webpack_require__(12).child({component: 'sampler'})
	var Timer = __webpack_require__(96)
	var os = __webpack_require__(56)
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var MILLIS = 1e3
	var MICROS = 1e6
	var NANOS = 1e9
	var CPUS = os.cpus().length
	var SAMPLE_INTERVAL = 15 * MILLIS
	
	var samplers = []
	
	function Sampler(sampler, interval) {
	  this.id = setInterval(sampler, interval)
	  // timer.unref only in 0.9+
	  if (this.id.unref) this.id.unref()
	}
	
	Sampler.prototype.stop = function stop() {
	  clearInterval(this.id)
	}
	
	function recordQueueTime(agent, timer) {
	  timer.end()
	  agent.metrics.measureMilliseconds(NAMES.EVENTS.WAIT, null, timer.getDurationInMillis())
	}
	
	function sampleMemory(agent) {
	  return function memorySampler() {
	    try {
	      var mem = process.memoryUsage()
	      agent.metrics.measureBytes(NAMES.MEMORY.PHYSICAL, mem.rss)
	      agent.metrics.measureBytes(NAMES.MEMORY.USED_HEAP, mem.heapUsed)
	      agent.metrics.measureBytes(NAMES.MEMORY.MAX_HEAP, mem.heapTotal)
	      agent.metrics.measureBytes(NAMES.MEMORY.FREE_HEAP, mem.heapTotal - mem.heapUsed)
	      agent.metrics.measureBytes(NAMES.MEMORY.USED_NONHEAP, mem.rss - mem.heapTotal)
	      logger.trace('Recorded memory:', mem)
	    } catch (e) {
	      logger.debug('Could not record memory usage', e)
	    }
	  }
	}
	
	function checkEvents(agent) {
	  return function eventSampler() {
	    var timer = new Timer()
	    timer.begin()
	    setTimeout(recordQueueTime.bind(null, agent, timer), 0)
	  }
	}
	
	function getCpuSample(lastSample) {
	  try {
	    return process.cpuUsage(lastSample)
	  } catch (e) {
	    logger.debug('Could not record cpu usage', e)
	    return null
	  }
	}
	
	function generateCPUMetricRecorder(agent) {
	  var lastSampleTime
	  // userTime and sysTime are in seconds
	  return function recordCPUMetrics(userTime, sysTime) {
	    var elapsedUptime
	    if (!lastSampleTime) {
	      elapsedUptime = process.uptime()
	    } else {
	      elapsedUptime = (Date.now() - lastSampleTime) / MILLIS
	    }
	
	    var totalCpuTime = CPUS * elapsedUptime
	
	    lastSampleTime = Date.now()
	
	    var userUtil = userTime / totalCpuTime
	    var sysUtil  = sysTime / totalCpuTime
	
	    recordValue(agent, NAMES.CPU.USER_TIME, userTime)
	    recordValue(agent, NAMES.CPU.SYSTEM_TIME, sysTime)
	    recordValue(agent, NAMES.CPU.USER_UTILIZATION, userUtil)
	    recordValue(agent, NAMES.CPU.SYSTEM_UTILIZATION, sysUtil)
	  }
	}
	
	function sampleCpu(agent) {
	  var lastSample
	  var recordCPU = generateCPUMetricRecorder(agent)
	  return function cpuSampler() {
	    var cpuSample = getCpuSample(lastSample)
	    lastSample = getCpuSample()
	
	    if (lastSample == null) {
	      return
	    }
	
	    recordCPU(cpuSample.user / MICROS, cpuSample.system / MICROS)
	  }
	}
	
	function sampleCpuNative(agent, nativeMetrics) {
	  var recordCPU = generateCPUMetricRecorder(agent)
	  nativeMetrics.on('usage', function collectResourceUsage(usage) {
	    recordCPU(usage.diff.ru_utime / MILLIS, usage.diff.ru_stime / MILLIS)
	  })
	
	  return function cpuSampler() {
	    // NOOP?
	  }
	}
	
	function sampleGc(agent, nativeMetrics) {
	  // Hook into the stats event to accumulate total pause time and record per-run
	  // pause time metric.
	  nativeMetrics.on('gc', function onGCStatsEvent(stats) {
	    var duration = stats.duration / NANOS
	    recordValue(agent, NAMES.GC.PAUSE_TIME, duration)
	
	    if (stats.type) {
	      recordValue(agent, NAMES.GC.PREFIX + stats.type, duration)
	    } else {
	      logger.debug(stats, 'Unknown GC type %j', stats.typeId)
	    }
	  })
	
	  return function gcSampler() {
	    // NOOP?
	  }
	}
	
	var sampler = module.exports = {
	  state: 'stopped',
	  sampleMemory: sampleMemory,
	  checkEvents: checkEvents,
	  sampleCpu: sampleCpu,
	  sampleGc: sampleGc,
	  nativeMetrics: null,
	
	  start: function start(agent) {
	    samplers.push(new Sampler(sampleMemory(agent), 5 * MILLIS))
	    samplers.push(new Sampler(checkEvents(agent), SAMPLE_INTERVAL))
	    var metricFeatureFlag = agent.config.feature_flag.native_metrics
	
	    // This requires a native module which may have failed to build.
	    if (!this.nativeMetrics) {
	      if (metricFeatureFlag) {
	        try {
	          this.nativeMetrics = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"@newrelic/native-metrics\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))({
	            timeout: SAMPLE_INTERVAL
	          })
	        } catch (err) {
	          logger.info(
	            {error: {message: err.message, stack: err.stack}},
	            'Not adding native metric sampler.'
	          )
	          agent.metrics.getOrCreateMetric(
	            NAMES.SUPPORTABILITY.DEPENDENCIES + '/NoNativeMetricsModule'
	          ).incrementCallCount()
	        }
	      } else {
	        logger.info('Feature flag for native metrics is false')
	      }
	    } else if (!this.nativeMetrics.bound) {
	      this.nativeMetrics.bind(SAMPLE_INTERVAL)
	    }
	
	    // Add GC events if available.
	    if (this.nativeMetrics && this.nativeMetrics.gcEnabled) {
	      samplers.push(new Sampler(sampleGc(agent, this.nativeMetrics), SAMPLE_INTERVAL))
	    }
	
	    // Add CPU sampling using the built-in data if available, otherwise pulling
	    // from the native module.
	    if (process.cpuUsage) { // introduced in 6.1.0
	      samplers.push(new Sampler(sampleCpu(agent), SAMPLE_INTERVAL))
	    } else if (this.nativeMetrics && this.nativeMetrics.usageEnabled) {
	      samplers.push(
	        new Sampler(sampleCpuNative(agent, this.nativeMetrics), SAMPLE_INTERVAL)
	      )
	    } else {
	      logger.debug('Not adding CPU metric sampler.')
	    }
	
	    sampler.state = 'running'
	  },
	
	  stop: function stop() {
	    samplers.forEach(function forEachSampler(s) {
	      s.stop()
	    })
	    samplers = []
	    sampler.state = 'stopped'
	    if (this.nativeMetrics) {
	      this.nativeMetrics.unbind()
	      this.nativeMetrics.removeAllListeners()
	
	      // Setting this.nativeMetrics to null allows us to config a new
	      // nativeMetrics object after the first start call.
	      this.nativeMetrics = null
	    }
	  }
	}
	
	function recordValue(agent, metric, value) {
	  var stats = agent.metrics.getOrCreateMetric(metric)
	  stats.recordValue(value)
	  logger.trace('Recorded metric %s: %j', metric, value)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	/**
	
	 * Explicit enumeration of the states a transaction can be in:
	 *
	 * PENDING upon instantiation (implicitly, no start time set)
	 * RUNNING while timer is running (implicitly, start time is set but no stop
	 *   time is set).
	 * STOPPED timer has been completed (implicitly, start time and stop time
	 *   are set, but the timer has not yet been harvested).
	 * DEAD timer has been harvested and can only have its duration read.
	 */
	var PENDING = 1
	var RUNNING = 2
	var STOPPED = 3
	
	
	function hrToMillis(hr) {
	  // process.hrTime gives you [second, nanosecond] duration pairs
	  return (hr[0] * 1e3) + (hr[1] / 1e6)
	}
	
	/**
	 * A mildly tricky timer that tracks its own state and allows its duration
	 * to be set manually.
	 */
	function Timer() {
	  this.state = PENDING
	  this.touched = false
	  this.duration = null
	  this.hrDuration = null
	  this.hrstart = null
	  this.durationInMillis = null
	}
	
	/**
	 * Start measuring time elapsed.
	 *
	 * Uses process.hrtime if available, Date.now() otherwise.
	 */
	Timer.prototype.begin = function begin() {
	  if (this.state > PENDING) return
	
	  this.start = Date.now()
	  // need to put a guard on this for compatibility with Node < 0.8
	  if (process.hrtime) this.hrstart = process.hrtime()
	  this.state = RUNNING
	}
	
	/**
	 * End measurement.
	 */
	Timer.prototype.end = function end() {
	  if (this.state > RUNNING) return
	  if (this.state === PENDING) this.begin()
	  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
	  this.touched = true
	  this.duration = Date.now() - this.start
	  this.state = STOPPED
	}
	
	/**
	 * Update the duration of the timer without ending it..
	 */
	Timer.prototype.touch = function touch() {
	  this.touched = true
	  if (this.state > RUNNING) return
	  if (this.state === PENDING) this.begin()
	
	  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
	  this.duration = Date.now() - this.start
	}
	
	/**
	 * End the segment if it is still running, if touched use that time instead of
	 * "now". Returns a boolean indicating whether the end time changed.
	 */
	Timer.prototype.softEnd = function softEnd() {
	  if (this.state > RUNNING) return false
	  if (this.state === PENDING) this.begin()
	
	  this.state = STOPPED
	
	  if (this.touched) return false
	  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
	  this.touched = true
	  this.duration = Date.now() - this.start
	  return true
	}
	
	/**
	 * @return {bool} Is this timer currently running?
	 */
	Timer.prototype.isRunning = function isRunning() {
	  return this.state === RUNNING
	}
	
	/**
	 * @return {bool} Is this timer still alive?
	 */
	Timer.prototype.isActive = function isActive() {
	  return this.state < STOPPED
	}
	
	/**
	 * @return {bool} Has the timer been touched or ended?
	 */
	Timer.prototype.hasEnd = function hasEnd() {
	  return !!this.hrDuration
	}
	
	/*
	 * Sets duration and stops the timer, since the passed-in duration will take precendence
	 * over the measured duration.
	 * @param {number} duration The duration the timer should report.
	 */
	Timer.prototype.overwriteDurationInMillis = overwriteDurationInMillis
	function overwriteDurationInMillis(duration) {
	  this.touched = true
	  this.durationInMillis = duration
	  this.state = STOPPED
	}
	
	/**
	 * When testing, it's convenient to be able to control time. Stops the timer
	 * as a byproduct.
	 *
	 * @param {number} duration How long the timer ran.
	 * @param {number} start When the timer started running (optional).
	 */
	Timer.prototype.setDurationInMillis = function setDurationInMillis(duration, start) {
	  if (this.state > RUNNING) return
	  if (this.state === PENDING)
	  if (!start && start !== 0) this.begin()
	
	  this.state = STOPPED
	  this.durationInMillis = duration
	
	  // this assignment is incorrect, process.hrtime doesn't time from epoch, which
	  // is the assumption being made here.  since hrstart isn't used
	  // anywhere except to calculate duration, and we are setting duration
	  // this is fine.
	  this.hrstart = [Math.floor(start / 1e3), start % 1e3 * 1e6]
	  this.start = start
	}
	
	/**
	 * Returns how long the timer has been running (if it's still running) or
	 * how long it ran (if it's been ended or touched).
	 */
	Timer.prototype.getDurationInMillis = function getDurationInMillis() {
	  if (this.state === PENDING) return 0
	
	  // only set by setDurationInMillis
	  if (this.durationInMillis !== null && this.durationInMillis >= 0) {
	    return this.durationInMillis
	  }
	
	  // prioritize .end() and .touch()
	  if (this.hrDuration) {
	    return hrToMillis(this.hrDuration)
	  }
	
	  if (this.duration) {
	    return this.duration
	  }
	
	  if (process.hrtime) {
	    return hrToMillis(process.hrtime(this.hrstart))
	  }
	
	  return Date.now() - this.start
	}
	
	/**
	 * Get a single object containing the interval this timer was active.
	 *
	 * @return {Array} 2-tuple of start time in milliseconds, end time in
	 *                 milliseconds.
	 */
	Timer.prototype.toRange = function toRange() {
	  return [this.start, this.start + this.getDurationInMillis()]
	}
	
	/**
	 * Abstract away the nonsense related to having both an
	 * hrtime start time and a regular one, and always return
	 * milliseconds since start.
	 *
	 * @param {Timer} other The point relative to which this timer started.
	 * @return {number} The offset in (floating-point) milliseconds.
	 */
	Timer.prototype.startedRelativeTo = function startedRelativeTo(other) {
	  if (this.hrstart && other.hrstart && process.hrtime) {
	    var s = this.hrstart[0] - other.hrstart[0]
	    var ns = this.hrstart[1] - other.hrstart[1]
	
	
	    return hrToMillis([s, ns])
	  }
	
	  return this.start - other.start
	}
	
	/**
	 * Returns true if this timer ends after the other.
	 */
	Timer.prototype.endsAfter = function compare(other) {
	  return (this.getDurationInMillis() + this.start) >
	    (other.getDurationInMillis() + other.start)
	}
	
	
	module.exports = Timer
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'collector_api'})
	var facts = __webpack_require__(98)
	var RemoteMethod = __webpack_require__(136)
	
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	
	// just to make clear what's going on
	var TO_MILLIS = 1e3
	
	// taken directly from Python agent's newrelic.core.application
	var BACKOFFS = [
	  {interval: 15, warn: false},
	  {interval: 15, warn: false},
	  {interval: 30, warn: false},
	  {interval: 60, warn: true},
	  {interval: 120, warn: false},
	  {interval: 300, warn: false}
	]
	
	var ERRORS = {
	  INVALID_LICENSE: 'NewRelic::Agent::LicenseException',
	  LIMIT_EXCEEDED: 'NewRelic::Agent::InternalLimitExceeded',
	  RESTART: 'NewRelic::Agent::ForceRestartException',
	  DISCONNECT: 'NewRelic::Agent::ForceDisconnectException',
	  MAINTENANCE: 'NewRelic::Agent::MaintenanceError',
	  RUNTIME: 'RuntimeError'
	}
	
	var HTTP_REQUEST_TOO_LARGE = 413
	var HTTP_UNSUPPORTED_MEDIA_TYPE = 415
	var HTTP_SERVER_INTERNAL = 500
	var HTTP_LOL_COLLECTOR = 503
	
	
	function dumpErrors(errors, name) {
	  var index = 1
	
	  errors.forEach(function cb_forEach(error) {
	    logger.trace(error, "Error %s during %s:", index++, name)
	
	    if (error.laterErrors) {
	      error.laterErrors.forEach(function cb_forEach(laterError) {
	        logger.trace(laterError, "Error %s during %s:", index++, name)
	      })
	    }
	  })
	}
	
	function CollectorAPI(agent) {
	  this._agent = agent
	
	  /* RemoteMethods can be reused and have little per-object state, so why not
	   * save some GC time?
	   */
	  this._methods = {
	    redirect: new RemoteMethod('get_redirect_host', agent.config),
	    handshake: new RemoteMethod('connect', agent.config),
	    settings: new RemoteMethod('agent_settings', agent.config),
	    errors: new RemoteMethod('error_data', agent.config),
	    metrics: new RemoteMethod('metric_data', agent.config),
	    traces: new RemoteMethod('transaction_sample_data', agent.config),
	    shutdown: new RemoteMethod('shutdown', agent.config),
	    events: new RemoteMethod('analytic_event_data', agent.config),
	    customEvents: new RemoteMethod('custom_event_data', agent.config),
	    queryData: new RemoteMethod('sql_trace_data', agent.config),
	    errorEvents: new RemoteMethod('error_event_data', agent.config)
	  }
	}
	
	CollectorAPI.prototype.connect = function connect(callback) {
	  if (!callback) throw new TypeError("callback is required")
	
	  var api = this
	  var attempts = 1
	  var max = BACKOFFS.length
	  var errors = []
	
	
	  function retry(error, response, body) {
	    if (error) errors.push(error)
	
	    if (!error || attempts >= max) {
	      dumpErrors(errors, 'connect')
	      return callback(error, response, body)
	    }
	
	    // failing high-security mode compliance will cause a disconnect
	    if (error.class === ERRORS.DISCONNECT) {
	      logger.error("The New Relic collector rejected this agent.")
	      logger.error(error.message)
	    }
	
	    var backoff = BACKOFFS[attempts - 1]
	    if (backoff.warn) {
	      logger.warn(
	        "No connection has been established to New Relic after %s attempts.",
	        attempts
	      )
	    }
	
	    logger.debug(
	      "Failed attempting to connect to New Relic, waiting %ss to retry.",
	      backoff.interval
	    )
	
	    attempts++
	
	    setTimeout(function again() {
	      api._login(retry)
	    }, backoff.interval * TO_MILLIS)
	  }
	
	  this._login(retry)
	}
	
	CollectorAPI.prototype._login = function _login(callback) {
	  var methods = this._methods
	  var agent = this._agent
	
	
	  methods.redirect.invoke(null, function cb_invoke(error, collector, body) {
	    if (error) return callback(error, collector, body)
	    if (!collector) {
	      logger.error(
	        "Requesting this account's collector from %s failed; trying default.",
	        agent.config.host
	      )
	    } else {
	      var parts = collector.split(':')
	      if (parts.length > 2) {
	        logger.error(
	          "Requesting collector from %s returned bogus result '%s'; trying default.",
	          agent.config.host,
	          collector
	        )
	      } else {
	        logger.debug(
	          "Requesting this account's collector from %s returned %s; reconfiguring.",
	          agent.config.host,
	          collector
	        )
	
	        agent.config.host = parts[0]
	        if (parts.length > 1) {
	          agent.config.port = parts[1]
	        }
	      }
	    }
	
	    facts(agent, function getEnvDict(environmentDict) {
	      // The collector really likes arrays.
	      // In fact, it kind of insists on them.
	      var environment = [environmentDict]
	
	      methods.handshake.invoke(environment, function cb_invoke(error, config, body) {
	        if (error) return callback(error, config, body)
	        if (!config || !config.agent_run_id) {
	          return callback(new Error("No agent run ID received from handshake."), config)
	        }
	
	        agent.setState('connected')
	        logger.info(
	          "Connected to %s:%d with agent run ID %s.",
	          agent.config.host,
	          agent.config.port,
	          config.agent_run_id
	        )
	
	        // pass configuration data from the API so automatic reconnect works
	        agent.reconfigure(config)
	
	        callback(null, config, body)
	      })
	    })
	  })
	}
	
	/**
	 * Send current public agent settings to collector. This should always be
	 * invoked after a successful connect response with server-side settings, but
	 * will also be invoked on any other config changes.
	 *
	 * @param {Function} callback The continuation / error handler.
	 */
	CollectorAPI.prototype.reportSettings = function reportSettings(callback) {
	  // The second argument to the callback is always empty data
	  this._methods.settings.invoke(
	    [this._agent.config.publicSettings()],
	    function cb_invoke(error, unused, body) {
	      if (error) dumpErrors([error], 'agent_settings')
	
	      if (callback) callback(error, body)
	    }
	  )
	}
	
	/**
	 * Send already-formatted error data by calling error_data. For
	 * performance reasons, the API methods do no validation, but the
	 * collector expects data in an exact format. It expects a JSON array
	 * containing the following 2 elements:
	 *
	 * 1. The agent run ID.
	 * 2. An array of one or more errors. See lib/error.js for details.
	 *
	 * @param {Array}    errors   The encoded errors list.
	 * @param {Function} callback The continuation / error handler.
	 */
	CollectorAPI.prototype.errorData = function errorData(errors, callback) {
	  if (!errors) throw new TypeError("must pass errors to send")
	  if (!callback) throw new TypeError("callback is required")
	
	  this._runLifecycle(this._methods.errors, errors, callback)
	}
	
	/**
	 * Send already-formatted metric data by calling metric_data. For
	 * performance reasons, the API methods do no validation, but the collector
	 * expects data in an exact format format. It expects a JSON array containing
	 * the following 4 elements:
	 *
	 * 1. The agent run ID.
	 * 2. The time the metric data started being collected, in seconds since the
	 *    epoch.
	 * 3. The time the metric data finished being collected, in seconds since the
	 *    epoch.
	 * 4. An array of 1 or more metric arrays. See lib/metrics.js for details.
	 *
	 * @param {Array}    metrics  The encoded metrics list.
	 * @param {Function} callback The continuation / error handler.
	 */
	CollectorAPI.prototype.metricData = function metricData(metrics, callback) {
	  if (!metrics) throw new TypeError("must pass metrics to send")
	  if (!callback) throw new TypeError("callback is required")
	
	  this._runLifecycle(this._methods.metrics, metrics, callback)
	}
	
	CollectorAPI.prototype.analyticsEvents = function analyticsEvents(events, callback) {
	  if (!events) throw new TypeError("must pass events to send")
	  if (!callback) throw new TypeError("callback is required")
	  this._runLifecycle(this._methods.events, events, callback)
	}
	
	CollectorAPI.prototype.customEvents = function customEvents(events, callback) {
	  if (!events) throw new TypeError("must pass events to send")
	  if (!callback) throw new TypeError("callback is required")
	  this._runLifecycle(this._methods.customEvents, events, callback)
	}
	
	/**
	 * Send already-formatted slow SQL data by calling
	 * sql_trace_data. For performance reasons, the API methods
	 * do no validation, but the collector expects data in an exact format
	 * format. It expects a JSON array containing the following 2 elements:
	 *
	 * 1. The agent run ID.
	 * 2. The encoded slow SQL data.
	 *
	 * @param {Array}    queries  The encoded slow SQL data.
	 * @param {Function} callback The continuation / error handler.
	 */
	CollectorAPI.prototype.queryData = function queryData(queries, callback) {
	  if (!queries) throw new TypeError("must pass queries to send")
	  if (!callback) throw new TypeError("callback is required")
	  this._runLifecycle(this._methods.queryData, queries, callback)
	}
	
	CollectorAPI.prototype.errorEvents = function errorEvents(events, callback) {
	  if (!events) throw new TypeError("must pass queries to send")
	  if (!callback) throw new TypeError("callback is required")
	  this._runLifecycle(this._methods.errorEvents, events, callback)
	}
	
	/**
	 * Send already-formatted slow trace data by calling
	 * transaction_sample_data. For performance reasons, the API methods
	 * do no validation, but the collector expects data in an exact format
	 * format. It expects a JSON array containing the following 2 elements:
	 *
	 * 1. The agent run ID.
	 * 2. The encoded slow trace data. This is the most complicated data
	 *    format handled by the module, and documenting it is almost beyond the
	 *    scope of comments. See lib/transaction/trace.js for details.
	 *
	 * @param {Array}    trace    The encoded trace data.
	 * @param {Function} callback The continuation / error handler.
	 */
	CollectorAPI.prototype.transactionSampleData =
	  function transactionSampleData(trace, callback) {
	  if (!trace) throw new TypeError("must pass slow trace data to send")
	  if (!callback) throw new TypeError("callback is required")
	
	  this._runLifecycle(this._methods.traces, trace, callback)
	}
	
	
	/**
	 * Sends no data aside from the message itself. Clears the run ID, which
	 * effectively disconnects the agent from the collector.
	 *
	 * @param Function callback Runs after the run ID has been cleared.
	 */
	CollectorAPI.prototype.shutdown = function shutdown(callback) {
	  if (!callback) throw new TypeError("callback is required")
	
	  var agent = this._agent
	  this._methods.shutdown.invoke(null, function closed(error, returned, body) {
	    if (error) {
	      dumpErrors([error], 'shutdown')
	    } else {
	      agent.setState('disconnected')
	      logger.info(
	        "Disconnected from New Relic; clearing run ID %s.",
	        agent.config.run_id
	      )
	      agent.config.run_id = undefined
	    }
	
	    callback(error, returned, body)
	  })
	}
	
	CollectorAPI.prototype._restart = function _restart(callback) {
	  var api = this
	  this.shutdown(function reconnect() {
	    api.connect(callback)
	  })
	}
	
	CollectorAPI.prototype._runLifecycle = function _runLifecycle(method, body, callback) {
	  if (!this.isConnected()) {
	    logger.warn("Not connected to New Relic. Not calling.", method.name)
	    return callback(new Error("Not connected to collector.", null, null))
	  }
	
	  var api = this
	  function standardHandler(error, returned, json) {
	    if (!error) return callback(error, returned, json)
	
	    dumpErrors([error], method.name)
	
	    if (error.statusCode === HTTP_REQUEST_TOO_LARGE) {
	      logger.error(
	        error,
	        "This call of %s sent New Relic too much data; discarding (%s):",
	        method.name,
	        HTTP_REQUEST_TOO_LARGE
	      )
	      return callback(null, returned, json)
	    } else if (error.statusCode === HTTP_UNSUPPORTED_MEDIA_TYPE) {
	      logger.error(
	        error,
	        "The New Relic collector couldn't deserialize data; discarding for %s (%s):",
	        method.name,
	        HTTP_UNSUPPORTED_MEDIA_TYPE
	      )
	      return callback(null, returned, json)
	    } else if (error.statusCode === HTTP_LOL_COLLECTOR) {
	      logger.debug(
	        error,
	        "New Relic is experiencing a spot of bother; please hold on (%s):",
	        HTTP_LOL_COLLECTOR
	      )
	      return callback(error, returned, json)
	    } else if (error.statusCode === HTTP_SERVER_INTERNAL) {
	      logger.error(
	        error,
	        "New Relic's servers encountered a severe internal error on %s (%s):",
	        method.name,
	        HTTP_SERVER_INTERNAL
	      )
	      return callback(error, returned, json)
	    } else if (error.class === ERRORS.INVALID_LICENSE) {
	      logger.error(
	        error,
	        "Your New Relic license key appears to be invalid. Please double-check it:"
	      )
	
	      return callback(error, returned, json)
	    } else if (error.class === ERRORS.LIMIT_EXCEEDED) {
	      logger.error(
	        error,
	        "New Relic ran into a weird problem with %s. Let support@newrelic.com know:",
	        method.name
	      )
	      return callback(null, returned, json)
	    } else if (error.class === ERRORS.RESTART) {
	      logger.info(
	        error,
	        "The New Relic collector requested a connection restart on %s:",
	        method.name
	      )
	
	      return api._restart(function cb__restart() {
	        method.invoke(body, standardHandler)
	      })
	    } else if (error.class === ERRORS.DISCONNECT) {
	      logger.error(error, "The New Relic collector is shutting down this agent:")
	
	      return api._agent.stop(function cb_stop() {
	        callback(error, returned, json)
	      })
	    } else if (error.class === ERRORS.MAINTENANCE) {
	      logger.info(
	        error,
	        "The New Relic server for your account is currently undergoing maintenance. " +
	          "Data will be held until it can be submitted (failed on %s):",
	        method.name
	      )
	      return callback(error, returned, json)
	    } else if (error.class === ERRORS.RUNTIME) {
	      logger.warn(
	        error,
	        "Calling %s on New Relic failed due to a runtime error. " +
	          "Data will be held until it can be submitted:",
	        method.name
	      )
	      return callback(error, returned, json)
	    }
	    logger.error(
	      error,
	      "Calling %s on New Relic failed unexpectedly. " +
	        "Data will be held until it can be submitted:",
	      method.name
	    )
	    return callback(error, returned, json)
	  }
	
	  method.invoke(body, standardHandler)
	}
	
	CollectorAPI.prototype.isConnected = function isConnected() {
	  return !!this._agent.config.run_id
	}
	
	module.exports = CollectorAPI


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var fetchSystemInfo = __webpack_require__(99)
	var parse_labels = __webpack_require__(135)
	
	module.exports = facts
	
	function facts(agent, callback) {
	  fetchSystemInfo(agent, function cb_fetchSystemInfo(systemInfo) {
	    var hostname = agent.config.getHostnameSafe()
	    var results = {
	      utilization: {
	        metadata_version: 2,
	        logical_processors: systemInfo.logicalProcessors,
	        total_ram_mib: systemInfo.memory,
	        hostname: hostname
	      },
	      pid: process.pid,
	      host: hostname,
	      display_host: agent.config.getDisplayHost() || hostname,
	      language: 'nodejs',
	      app_name: agent.config.applications(),
	      agent_version: agent.version,
	      environment: agent.environment,
	      settings: agent.config.publicSettings(),
	      high_security: agent.config.high_security,
	      labels: parse_labels(agent.config.labels)
	    }
	
	    // TODO:  After reconfiguring agent startup to wait for the server to start
	    //        or for the first transaction, add the `port` for the server too.
	    // NOTE: The concat is necessary to prevent sort from happening in-place.
	    results.identifier = [
	      'nodejs',
	      results.host,
	      results.app_name.concat([]).sort().join(',')
	    ].join(':')
	
	    if (systemInfo.aws || systemInfo.docker) {
	      results.utilization.vendors = {}
	      if (systemInfo.aws) {
	        results.utilization.vendors.aws = systemInfo.aws
	      }
	      if (systemInfo.docker) {
	        results.utilization.vendors.docker = systemInfo.docker
	      }
	    }
	    if (systemInfo.config) {
	      results.utilization.config = systemInfo.config
	    }
	    return callback(results)
	  })
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var exec = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"child_process\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).exec
	var fetchAWSInfo = __webpack_require__(100)
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var logger = __webpack_require__(12).child({component: 'system-info'})
	var os = __webpack_require__(56)
	var parseCpuInfo = __webpack_require__(132)
	var parseDockerInfo = __webpack_require__(133)
	var parseMemInfo = __webpack_require__(134)
	var platform = os.platform()
	
	module.exports = fetchSystemInfo
	
	function isInteger(i) {
	  return i === parseInt(i, 10)
	}
	
	function fetchSystemInfo(agent, callback) {
	  var config = agent.config
	  var systemInfo = {
	    processorArch: os.arch()
	  }
	
	  var utilizationConfig = {}
	  if (config.utilization) {
	    var configProcessors = config.utilization.logical_processors
	    var configRam = config.utilization.total_ram_mib
	    var configHostname = config.utilization.billing_hostname
	
	    if (configProcessors) {
	      var parsedConfigProcessors = parseFloat(configProcessors, 10)
	      if (!isNaN(parsedConfigProcessors) && isInteger(parsedConfigProcessors)) {
	        utilizationConfig.logical_processors = parsedConfigProcessors
	      } else {
	        logger.info(
	          '%s supplied in config for utilization.logical_processors, expected a number',
	          configProcessors
	        )
	      }
	    }
	
	    if (configRam) {
	      var parsedConfigRam = parseFloat(configRam, 10)
	      if (!isNaN(parsedConfigRam) && isInteger(parsedConfigRam)) {
	        utilizationConfig.total_ram_mib = parsedConfigRam
	      } else {
	        logger.info(
	          '%s supplied in config for utilization.total_ram_mib, expected a number',
	          configRam
	        )
	      }
	    }
	
	    if (configHostname) {
	      if (typeof configHostname === 'string') {
	        utilizationConfig.hostname = configHostname
	      } else {
	        logger.info(
	          '%s supplied in config for utilization.Hostname, expected a string',
	          configHostname
	        )
	      }
	    }
	
	    if (Object.keys(utilizationConfig).length > 0) {
	      systemInfo.config = utilizationConfig
	    }
	  }
	
	  var tasksDone = 0
	  var numTasks = 5
	  function finishedResponse() {
	    if (++tasksDone === numTasks) return callback(systemInfo)
	  }
	
	  module.exports._getProcessorStats(function getProcessCB(processorStats) {
	    systemInfo.packages = processorStats.packages
	    systemInfo.logicalProcessors = processorStats.logical
	    systemInfo.cores = processorStats.cores
	    finishedResponse()
	  })
	  module.exports._getMemoryStats(function getMemCB(memory) {
	    systemInfo.memory = memory
	    finishedResponse()
	  })
	  getKernelVersion(function getVersionCB(kernelVersion) {
	    systemInfo.kernelVersion = kernelVersion
	    finishedResponse()
	  })
	  module.exports._getDockerContainerId(agent, function getContainerId(containerId) {
	    if (containerId) {
	      systemInfo.docker = {
	        id: containerId
	      }
	    }
	    finishedResponse()
	  })
	  fetchAWSInfo(agent, function getAWSInfo(aws) {
	    systemInfo.aws = aws
	    finishedResponse()
	  })
	}
	
	// placed on module for mocking purposes in tests
	module.exports._getProcessorStats = function getProcessorStats(callback) {
	  var processorStats = {
	    logical: null,
	    cores: null,
	    packages: null
	  }
	
	  if (platform.match(/darwin/i)) {
	    getSysctlValue(['hw.packages'], function getPackages(packages) {
	      getSysctlValue(['hw.physicalcpu_max', 'hw.physicalcpu'],
	      function getCores(cores) {
	        getSysctlValue(['hw.logicalcpu_max', 'hw.logicalcpu', 'hw.ncpu'],
	        function getLogicalCpu(logical) {
	          processorStats.logical = parseFloat(logical, 10)
	          processorStats.cores = parseFloat(cores, 10)
	          processorStats.packages = parseFloat(packages, 10)
	
	          for (var key in processorStats) {
	            if (!processorStats[key] || !isInteger(processorStats[key])) {
	              processorStats[key] = null
	            }
	          }
	
	          callback(processorStats)
	        })
	      })
	    })
	  } else if (platform.match(/bsd/i)) {
	    getSysctlValue(['hw.ncpu'], function getLogicalCpu(logical) {
	      processorStats.logical = logical
	      callback(processorStats)
	    })
	  } else if (platform.match(/linux/i)) {
	    readProc('/proc/cpuinfo', function parseProc(data) {
	      callback(parseCpuInfo(data))
	    })
	  } else {
	    logger.debug('Unknown platform: ' + platform + ', could not retrieve processor info')
	    callback(processorStats)
	  }
	}
	
	// placed on module for mocking purposes in tests
	module.exports._getMemoryStats = function getMemoryStats(callback) {
	  if (platform.match(/darwin/i)) {
	    getSysctlValue(['hw.memsize'], function getMem(memory) {
	      callback(parseInt(memory, 10) / (1024 * 1024))
	    })
	  } else if (platform.match(/bsd/i)) {
	    getSysctlValue(['hw.realmem'], function getMem(memory) {
	      callback(parseInt(memory, 10) / (1024 * 1024))
	    })
	  } else if (platform.match(/linux/i)) {
	    readProc('/proc/meminfo', function parseProc(data) {
	      callback(parseMemInfo(data))
	    })
	  } else {
	    logger.debug('Unknown platform: ' + platform + ', could not retrieve memory info')
	    callback(null)
	  }
	}
	
	function getKernelVersion(callback) {
	  if (platform.match(/darwin/i)) {
	    getSysctlValue(['kern.version'], function getMem(version) {
	      callback(version)
	    })
	  } else if (platform.match(/bsd/i)) {
	    getSysctlValue(['kern.version'], function getMem(version) {
	      callback(version)
	    })
	  } else if (platform.match(/linux/i)) {
	    readProc('/proc/version', function parseProc(data) {
	      callback(data)
	    })
	  } else {
	    logger.debug('Unknown platform' + platform + ', could not read kernel version')
	    callback(null)
	  }
	}
	
	module.exports._getDockerContainerId = function getDockerContainerId(agent, callback) {
	  if (!platform.match(/linux/i)) {
	    logger.debug('Platform is not a flavor of linux, omitting docker info')
	    callback(null)
	  } else {
	    readProc('/proc/self/cgroup', function getCGroup(data) {
	      if (!data) callback(null)
	      else callback(parseDockerInfo(agent, data))
	    })
	  }
	}
	
	function getSysctlValue(names, callback) {
	  if (!names) return callback(null)
	  var returned = false
	  var ran = 0
	  names.forEach(function sysctlName(name) {
	    exec('sysctl -n ' + name, respond)
	
	    function respond(err, stdout, stderr) {
	      if (returned) return
	      if (err) {
	        logger.debug('Error when trying to run: sysctl -n ' + name + ': %s', err.message)
	        callback(null)
	        returned = true
	      } else if (!stderr) {
	        callback(stdout)
	        returned = true
	      }
	      if (++ran === names.length && !returned) {
	        logger.debug('No sysctl info found for names: ' + names.toString())
	        callback(null)
	      }
	    }
	  })
	}
	
	function readProc(path, callback) {
	  fs.readFile(path, function readProcFile(err, data) {
	    if (err) {
	      logger.error('Error when trying to read ' + path, err)
	      callback(null)
	    } else {
	      callback(data.toString())
	    }
	  })
	}


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'aws-info'})
	var http = __webpack_require__(101)
	var NAMES = __webpack_require__(59)
	var concat = __webpack_require__(115)
	
	module.exports = fetchAWSInfo
	module.exports.clearCache = function clearAWSCache() {
	  resultDict = null
	}
	
	var resultDict
	
	function fetchAWSInfo(agent, callback) {
	  if (!agent.config.utilization || !agent.config.utilization.detect_aws) {
	    return callback(null)
	  }
	
	  if (resultDict) {
	    return callback(resultDict)
	  }
	
	  var awsQuery = module.exports._awsQuery
	
	  awsQuery('instance-type', agent, function getInstanceType(type) {
	    if (!type) return callback(null)
	    awsQuery('instance-id', agent, function getInstanceId(id) {
	      if (!id) return callback(null)
	      awsQuery('placement/availability-zone', agent, function getZone(zone) {
	        if (!zone) return callback(null)
	        resultDict = {
	          type: type,
	          id: id,
	          zone: zone
	        }
	        return callback(resultDict)
	      })
	    })
	  })
	}
	
	
	module.exports._awsQuery = function awsQuery(key, agent, callback) {
	  var instanceHost = '169.254.169.254'
	  var apiVersion = '2008-02-01'
	  var url = ['http:/', instanceHost, apiVersion, 'meta-data', key].join('/')
	  var req = http.get(url, function awsRequest(res) {
	    res.pipe(concat(respond))
	    function respond(data) {
	      var valid = checkResponseString(data)
	      if (!valid) {
	        var awsError = agent.metrics.getOrCreateMetric(NAMES.UTILIZATION.AWS_ERROR)
	        awsError.incrementCallCount()
	        logger.debug('Response for attribute ' + key + ': %s'
	          , data)
	        data = null
	      } else {
	        data = data.toString('utf8')
	      }
	
	      agent.removeListener('errored', abortRequest)
	      agent.removeListener('stopped', abortRequest)
	      callback(data)
	    }
	  })
	  req.setTimeout(1000, function awsTimeout() {
	    logger.debug('Request for attribute %s timed out', key)
	    callback(null)
	  })
	  req.on('error', function awsError(err) {
	    logger.debug('Message for attribute %s: %s', key, err.message)
	    callback(null)
	  })
	
	  agent.once('errored', abortRequest)
	  agent.once('stopped', abortRequest)
	
	  function abortRequest() {
	    logger.debug('Abborting request for attribute %s', key)
	    req.abort()
	    agent.removeListener('errored', abortRequest)
	    agent.removeListener('stopped', abortRequest)
	  }
	}
	
	function checkResponseString(str) {
	  var validCharacters = /[0-9a-zA-Z_ ./-]/
	  var valid = str.length <= 255 && str.length > 0
	
	  var i = 0
	  var len = str.length
	
	  while (valid && i < len) {
	    valid = valid && (str[i] > 127 || String.fromCharCode(str[i]).match(validCharacters))
	    i++
	  }
	
	  return valid
	}


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var ClientRequest = __webpack_require__(102)
	var extend = __webpack_require__(106)
	var statusCodes = __webpack_require__(107)
	var url = __webpack_require__(108)
	
	var http = exports
	
	http.request = function (opts, cb) {
		if (typeof opts === 'string')
			opts = url.parse(opts)
		else
			opts = extend(opts)
	
		// Normally, the page is loaded from http or https, so not specifying a protocol
		// will result in a (valid) protocol-relative url. However, this won't work if
		// the protocol is something else, like 'file:'
		var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''
	
		var protocol = opts.protocol || defaultProtocol
		var host = opts.hostname || opts.host
		var port = opts.port
		var path = opts.path || '/'
	
		// Necessary for IPv6 addresses
		if (host && host.indexOf(':') !== -1)
			host = '[' + host + ']'
	
		// This may be a relative url. The browser should always be able to interpret it correctly.
		opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
		opts.method = (opts.method || 'GET').toUpperCase()
		opts.headers = opts.headers || {}
	
		// Also valid opts.auth, opts.mode
	
		var req = new ClientRequest(opts)
		if (cb)
			req.on('response', cb)
		return req
	}
	
	http.get = function get (opts, cb) {
		var req = http.request(opts, cb)
		req.end()
		return req
	}
	
	http.Agent = function () {}
	http.Agent.defaultMaxSockets = 4
	
	http.STATUS_CODES = statusCodes
	
	http.METHODS = [
		'CHECKOUT',
		'CONNECT',
		'COPY',
		'DELETE',
		'GET',
		'HEAD',
		'LOCK',
		'M-SEARCH',
		'MERGE',
		'MKACTIVITY',
		'MKCOL',
		'MOVE',
		'NOTIFY',
		'OPTIONS',
		'PATCH',
		'POST',
		'PROPFIND',
		'PROPPATCH',
		'PURGE',
		'PUT',
		'REPORT',
		'SEARCH',
		'SUBSCRIBE',
		'TRACE',
		'UNLOCK',
		'UNSUBSCRIBE'
	]
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {var capability = __webpack_require__(103)
	var inherits = __webpack_require__(28)
	var response = __webpack_require__(104)
	var stream = __webpack_require__(29)
	var toArrayBuffer = __webpack_require__(105)
	
	var IncomingMessage = response.IncomingMessage
	var rStates = response.readyStates
	
	function decideMode (preferBinary, useFetch) {
		if (capability.fetch && useFetch) {
			return 'fetch'
		} else if (capability.mozchunkedarraybuffer) {
			return 'moz-chunked-arraybuffer'
		} else if (capability.msstream) {
			return 'ms-stream'
		} else if (capability.arraybuffer && preferBinary) {
			return 'arraybuffer'
		} else if (capability.vbArray && preferBinary) {
			return 'text:vbarray'
		} else {
			return 'text'
		}
	}
	
	var ClientRequest = module.exports = function (opts) {
		var self = this
		stream.Writable.call(self)
	
		self._opts = opts
		self._body = []
		self._headers = {}
		if (opts.auth)
			self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
		Object.keys(opts.headers).forEach(function (name) {
			self.setHeader(name, opts.headers[name])
		})
	
		var preferBinary
		var useFetch = true
		if (opts.mode === 'disable-fetch' || 'timeout' in opts) {
			// If the use of XHR should be preferred and includes preserving the 'content-type' header.
			// Force XHR to be used since the Fetch API does not yet support timeouts.
			useFetch = false
			preferBinary = true
		} else if (opts.mode === 'prefer-streaming') {
			// If streaming is a high priority but binary compatibility and
			// the accuracy of the 'content-type' header aren't
			preferBinary = false
		} else if (opts.mode === 'allow-wrong-content-type') {
			// If streaming is more important than preserving the 'content-type' header
			preferBinary = !capability.overrideMimeType
		} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
			// Use binary if text streaming may corrupt data or the content-type header, or for speed
			preferBinary = true
		} else {
			throw new Error('Invalid value for opts.mode')
		}
		self._mode = decideMode(preferBinary, useFetch)
	
		self.on('finish', function () {
			self._onFinish()
		})
	}
	
	inherits(ClientRequest, stream.Writable)
	
	ClientRequest.prototype.setHeader = function (name, value) {
		var self = this
		var lowerName = name.toLowerCase()
		// This check is not necessary, but it prevents warnings from browsers about setting unsafe
		// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
		// http-browserify did it, so I will too.
		if (unsafeHeaders.indexOf(lowerName) !== -1)
			return
	
		self._headers[lowerName] = {
			name: name,
			value: value
		}
	}
	
	ClientRequest.prototype.getHeader = function (name) {
		var self = this
		return self._headers[name.toLowerCase()].value
	}
	
	ClientRequest.prototype.removeHeader = function (name) {
		var self = this
		delete self._headers[name.toLowerCase()]
	}
	
	ClientRequest.prototype._onFinish = function () {
		var self = this
	
		if (self._destroyed)
			return
		var opts = self._opts
	
		var headersObj = self._headers
		var body = null
		if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH' || opts.method === 'MERGE') {
			if (capability.blobConstructor) {
				body = new global.Blob(self._body.map(function (buffer) {
					return toArrayBuffer(buffer)
				}), {
					type: (headersObj['content-type'] || {}).value || ''
				})
			} else {
				// get utf8 string
				body = Buffer.concat(self._body).toString()
			}
		}
	
		if (self._mode === 'fetch') {
			var headers = Object.keys(headersObj).map(function (name) {
				return [headersObj[name].name, headersObj[name].value]
			})
	
			global.fetch(self._opts.url, {
				method: self._opts.method,
				headers: headers,
				body: body || undefined,
				mode: 'cors',
				credentials: opts.withCredentials ? 'include' : 'same-origin'
			}).then(function (response) {
				self._fetchResponse = response
				self._connect()
			}, function (reason) {
				self.emit('error', reason)
			})
		} else {
			var xhr = self._xhr = new global.XMLHttpRequest()
			try {
				xhr.open(self._opts.method, self._opts.url, true)
			} catch (err) {
				process.nextTick(function () {
					self.emit('error', err)
				})
				return
			}
	
			// Can't set responseType on really old browsers
			if ('responseType' in xhr)
				xhr.responseType = self._mode.split(':')[0]
	
			if ('withCredentials' in xhr)
				xhr.withCredentials = !!opts.withCredentials
	
			if (self._mode === 'text' && 'overrideMimeType' in xhr)
				xhr.overrideMimeType('text/plain; charset=x-user-defined')
	
			if ('timeout' in opts) {
				xhr.timeout = opts.timeout
				xhr.ontimeout = function () {
					self.emit('timeout')
				}
			}
	
			Object.keys(headersObj).forEach(function (name) {
				xhr.setRequestHeader(headersObj[name].name, headersObj[name].value)
			})
	
			self._response = null
			xhr.onreadystatechange = function () {
				switch (xhr.readyState) {
					case rStates.LOADING:
					case rStates.DONE:
						self._onXHRProgress()
						break
				}
			}
			// Necessary for streaming in Firefox, since xhr.response is ONLY defined
			// in onprogress, not in onreadystatechange with xhr.readyState = 3
			if (self._mode === 'moz-chunked-arraybuffer') {
				xhr.onprogress = function () {
					self._onXHRProgress()
				}
			}
	
			xhr.onerror = function () {
				if (self._destroyed)
					return
				self.emit('error', new Error('XHR error'))
			}
	
			try {
				xhr.send(body)
			} catch (err) {
				process.nextTick(function () {
					self.emit('error', err)
				})
				return
			}
		}
	}
	
	/**
	 * Checks if xhr.status is readable and non-zero, indicating no error.
	 * Even though the spec says it should be available in readyState 3,
	 * accessing it throws an exception in IE8
	 */
	function statusValid (xhr) {
		try {
			var status = xhr.status
			return (status !== null && status !== 0)
		} catch (e) {
			return false
		}
	}
	
	ClientRequest.prototype._onXHRProgress = function () {
		var self = this
	
		if (!statusValid(self._xhr) || self._destroyed)
			return
	
		if (!self._response)
			self._connect()
	
		self._response._onXHRProgress()
	}
	
	ClientRequest.prototype._connect = function () {
		var self = this
	
		if (self._destroyed)
			return
	
		self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
		self._response.on('error', function(err) {
			self.emit('error', err)
		})
	
		self.emit('response', self._response)
	}
	
	ClientRequest.prototype._write = function (chunk, encoding, cb) {
		var self = this
	
		self._body.push(chunk)
		cb()
	}
	
	ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
		var self = this
		self._destroyed = true
		if (self._response)
			self._response._destroyed = true
		if (self._xhr)
			self._xhr.abort()
		// Currently, there isn't a way to truly abort a fetch.
		// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
	}
	
	ClientRequest.prototype.end = function (data, encoding, cb) {
		var self = this
		if (typeof data === 'function') {
			cb = data
			data = undefined
		}
	
		stream.Writable.prototype.end.call(self, data, encoding, cb)
	}
	
	ClientRequest.prototype.flushHeaders = function () {}
	ClientRequest.prototype.setTimeout = function () {}
	ClientRequest.prototype.setNoDelay = function () {}
	ClientRequest.prototype.setSocketKeepAlive = function () {}
	
	// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
	var unsafeHeaders = [
		'accept-charset',
		'accept-encoding',
		'access-control-request-headers',
		'access-control-request-method',
		'connection',
		'content-length',
		'cookie',
		'cookie2',
		'date',
		'dnt',
		'expect',
		'host',
		'keep-alive',
		'origin',
		'referer',
		'te',
		'trailer',
		'transfer-encoding',
		'upgrade',
		'user-agent',
		'via'
	]
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer, (function() { return this; }()), __webpack_require__(11)))

/***/ },
/* 103 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)
	
	exports.blobConstructor = false
	try {
		new Blob([new ArrayBuffer(1)])
		exports.blobConstructor = true
	} catch (e) {}
	
	// The xhr request to example.com may violate some restrictive CSP configurations,
	// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
	// and assume support for certain features below.
	var xhr
	function getXHR () {
		// Cache the xhr value
		if (xhr !== undefined) return xhr
	
		if (global.XMLHttpRequest) {
			xhr = new global.XMLHttpRequest()
			// If XDomainRequest is available (ie only, where xhr might not work
			// cross domain), use the page location. Otherwise use example.com
			// Note: this doesn't actually make an http request.
			try {
				xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
			} catch(e) {
				xhr = null
			}
		} else {
			// Service workers don't have XHR
			xhr = null
		}
		return xhr
	}
	
	function checkTypeSupport (type) {
		var xhr = getXHR()
		if (!xhr) return false
		try {
			xhr.responseType = type
			return xhr.responseType === type
		} catch (e) {}
		return false
	}
	
	// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
	// Safari 7.1 appears to have fixed this bug.
	var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
	var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)
	
	// If fetch is supported, then arraybuffer will be supported too. Skip calling
	// checkTypeSupport(), since that calls getXHR().
	exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))
	
	// These next two tests unavoidably show warnings in Chrome. Since fetch will always
	// be used if it's available, just return false for these to avoid the warnings.
	exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
	exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
		checkTypeSupport('moz-chunked-arraybuffer')
	
	// If fetch is supported, then overrideMimeType will be supported too. Skip calling
	// getXHR().
	exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)
	
	exports.vbArray = isFunction(global.VBArray)
	
	function isFunction (value) {
		return typeof value === 'function'
	}
	
	xhr = null // Help gc
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var capability = __webpack_require__(103)
	var inherits = __webpack_require__(28)
	var stream = __webpack_require__(29)
	
	var rStates = exports.readyStates = {
		UNSENT: 0,
		OPENED: 1,
		HEADERS_RECEIVED: 2,
		LOADING: 3,
		DONE: 4
	}
	
	var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
		var self = this
		stream.Readable.call(self)
	
		self._mode = mode
		self.headers = {}
		self.rawHeaders = []
		self.trailers = {}
		self.rawTrailers = []
	
		// Fake the 'close' event, but only once 'end' fires
		self.on('end', function () {
			// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
			process.nextTick(function () {
				self.emit('close')
			})
		})
	
		if (mode === 'fetch') {
			self._fetchResponse = response
	
			self.url = response.url
			self.statusCode = response.status
			self.statusMessage = response.statusText
			
			response.headers.forEach(function(header, key){
				self.headers[key.toLowerCase()] = header
				self.rawHeaders.push(key, header)
			})
	
	
			// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
			var reader = response.body.getReader()
			function read () {
				reader.read().then(function (result) {
					if (self._destroyed)
						return
					if (result.done) {
						self.push(null)
						return
					}
					self.push(new Buffer(result.value))
					read()
				}).catch(function(err) {
					self.emit('error', err)
				})
			}
			read()
	
		} else {
			self._xhr = xhr
			self._pos = 0
	
			self.url = xhr.responseURL
			self.statusCode = xhr.status
			self.statusMessage = xhr.statusText
			var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
			headers.forEach(function (header) {
				var matches = header.match(/^([^:]+):\s*(.*)/)
				if (matches) {
					var key = matches[1].toLowerCase()
					if (key === 'set-cookie') {
						if (self.headers[key] === undefined) {
							self.headers[key] = []
						}
						self.headers[key].push(matches[2])
					} else if (self.headers[key] !== undefined) {
						self.headers[key] += ', ' + matches[2]
					} else {
						self.headers[key] = matches[2]
					}
					self.rawHeaders.push(matches[1], matches[2])
				}
			})
	
			self._charset = 'x-user-defined'
			if (!capability.overrideMimeType) {
				var mimeType = self.rawHeaders['mime-type']
				if (mimeType) {
					var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
					if (charsetMatch) {
						self._charset = charsetMatch[1].toLowerCase()
					}
				}
				if (!self._charset)
					self._charset = 'utf-8' // best guess
			}
		}
	}
	
	inherits(IncomingMessage, stream.Readable)
	
	IncomingMessage.prototype._read = function () {}
	
	IncomingMessage.prototype._onXHRProgress = function () {
		var self = this
	
		var xhr = self._xhr
	
		var response = null
		switch (self._mode) {
			case 'text:vbarray': // For IE9
				if (xhr.readyState !== rStates.DONE)
					break
				try {
					// This fails in IE8
					response = new global.VBArray(xhr.responseBody).toArray()
				} catch (e) {}
				if (response !== null) {
					self.push(new Buffer(response))
					break
				}
				// Falls through in IE8	
			case 'text':
				try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
					response = xhr.responseText
				} catch (e) {
					self._mode = 'text:vbarray'
					break
				}
				if (response.length > self._pos) {
					var newData = response.substr(self._pos)
					if (self._charset === 'x-user-defined') {
						var buffer = new Buffer(newData.length)
						for (var i = 0; i < newData.length; i++)
							buffer[i] = newData.charCodeAt(i) & 0xff
	
						self.push(buffer)
					} else {
						self.push(newData, self._charset)
					}
					self._pos = response.length
				}
				break
			case 'arraybuffer':
				if (xhr.readyState !== rStates.DONE || !xhr.response)
					break
				response = xhr.response
				self.push(new Buffer(new Uint8Array(response)))
				break
			case 'moz-chunked-arraybuffer': // take whole
				response = xhr.response
				if (xhr.readyState !== rStates.LOADING || !response)
					break
				self.push(new Buffer(new Uint8Array(response)))
				break
			case 'ms-stream':
				response = xhr.response
				if (xhr.readyState !== rStates.LOADING)
					break
				var reader = new global.MSStreamReader()
				reader.onprogress = function () {
					if (reader.result.byteLength > self._pos) {
						self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
						self._pos = reader.result.byteLength
					}
				}
				reader.onload = function () {
					self.push(null)
				}
				// reader.onerror = ??? // TODO: this
				reader.readAsArrayBuffer(response)
				break
		}
	
		// The ms-stream case handles end separately in reader.onload()
		if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
			self.push(null)
		}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), __webpack_require__(22).Buffer, (function() { return this; }())))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(22).Buffer
	
	module.exports = function (buf) {
		// If the buffer is backed by a Uint8Array, a faster version will work
		if (buf instanceof Uint8Array) {
			// If the buffer isn't a subarray, return the underlying ArrayBuffer
			if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
				return buf.buffer
			} else if (typeof buf.buffer.slice === 'function') {
				// Otherwise we need to get a proper copy
				return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
			}
		}
	
		if (Buffer.isBuffer(buf)) {
			// This is the slow version that will work with any Buffer
			// implementation (even in old browsers)
			var arrayCopy = new Uint8Array(buf.length)
			var len = buf.length
			for (var i = 0; i < len; i++) {
				arrayCopy[i] = buf[i]
			}
			return arrayCopy.buffer
		} else {
			throw new Error('Argument must be a Buffer')
		}
	}


/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = {
	  "100": "Continue",
	  "101": "Switching Protocols",
	  "102": "Processing",
	  "200": "OK",
	  "201": "Created",
	  "202": "Accepted",
	  "203": "Non-Authoritative Information",
	  "204": "No Content",
	  "205": "Reset Content",
	  "206": "Partial Content",
	  "207": "Multi-Status",
	  "208": "Already Reported",
	  "226": "IM Used",
	  "300": "Multiple Choices",
	  "301": "Moved Permanently",
	  "302": "Found",
	  "303": "See Other",
	  "304": "Not Modified",
	  "305": "Use Proxy",
	  "307": "Temporary Redirect",
	  "308": "Permanent Redirect",
	  "400": "Bad Request",
	  "401": "Unauthorized",
	  "402": "Payment Required",
	  "403": "Forbidden",
	  "404": "Not Found",
	  "405": "Method Not Allowed",
	  "406": "Not Acceptable",
	  "407": "Proxy Authentication Required",
	  "408": "Request Timeout",
	  "409": "Conflict",
	  "410": "Gone",
	  "411": "Length Required",
	  "412": "Precondition Failed",
	  "413": "Payload Too Large",
	  "414": "URI Too Long",
	  "415": "Unsupported Media Type",
	  "416": "Range Not Satisfiable",
	  "417": "Expectation Failed",
	  "418": "I'm a teapot",
	  "421": "Misdirected Request",
	  "422": "Unprocessable Entity",
	  "423": "Locked",
	  "424": "Failed Dependency",
	  "425": "Unordered Collection",
	  "426": "Upgrade Required",
	  "428": "Precondition Required",
	  "429": "Too Many Requests",
	  "431": "Request Header Fields Too Large",
	  "451": "Unavailable For Legal Reasons",
	  "500": "Internal Server Error",
	  "501": "Not Implemented",
	  "502": "Bad Gateway",
	  "503": "Service Unavailable",
	  "504": "Gateway Timeout",
	  "505": "HTTP Version Not Supported",
	  "506": "Variant Also Negotiates",
	  "507": "Insufficient Storage",
	  "508": "Loop Detected",
	  "509": "Bandwidth Limit Exceeded",
	  "510": "Not Extended",
	  "511": "Network Authentication Required"
	}


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var punycode = __webpack_require__(109);
	var util = __webpack_require__(111);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // Special case for a simple path URL
	    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(112);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter =
	          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1)
	        continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      util.isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol')
	        result[rkey] = relative[rkey];
	    }
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host || srcPath.length > 1) &&
	      (last === '.' || last === '..') || last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(110)(module), (function() { return this; }())))

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 111 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  isString: function(arg) {
	    return typeof(arg) === 'string';
	  },
	  isObject: function(arg) {
	    return typeof(arg) === 'object' && arg !== null;
	  },
	  isNull: function(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function(arg) {
	    return arg == null;
	  }
	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(113);
	exports.encode = exports.stringify = __webpack_require__(114);


/***/ },
/* 113 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 114 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Writable = __webpack_require__(116).Writable
	var inherits = __webpack_require__(122)
	
	if (typeof Uint8Array === 'undefined') {
	  var U8 = __webpack_require__(131).Uint8Array
	} else {
	  var U8 = Uint8Array
	}
	
	function ConcatStream(opts, cb) {
	  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)
	
	  if (typeof opts === 'function') {
	    cb = opts
	    opts = {}
	  }
	  if (!opts) opts = {}
	
	  var encoding = opts.encoding
	  var shouldInferEncoding = false
	
	  if (!encoding) {
	    shouldInferEncoding = true
	  } else {
	    encoding =  String(encoding).toLowerCase()
	    if (encoding === 'u8' || encoding === 'uint8') {
	      encoding = 'uint8array'
	    }
	  }
	
	  Writable.call(this, { objectMode: true })
	
	  this.encoding = encoding
	  this.shouldInferEncoding = shouldInferEncoding
	
	  if (cb) this.on('finish', function () { cb(this.getBody()) })
	  this.body = []
	}
	
	module.exports = ConcatStream
	inherits(ConcatStream, Writable)
	
	ConcatStream.prototype._write = function(chunk, enc, next) {
	  this.body.push(chunk)
	  next()
	}
	
	ConcatStream.prototype.inferEncoding = function (buff) {
	  var firstBuffer = buff === undefined ? this.body[0] : buff;
	  if (Buffer.isBuffer(firstBuffer)) return 'buffer'
	  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
	  if (Array.isArray(firstBuffer)) return 'array'
	  if (typeof firstBuffer === 'string') return 'string'
	  if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
	  return 'buffer'
	}
	
	ConcatStream.prototype.getBody = function () {
	  if (!this.encoding && this.body.length === 0) return []
	  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
	  if (this.encoding === 'array') return arrayConcat(this.body)
	  if (this.encoding === 'string') return stringConcat(this.body)
	  if (this.encoding === 'buffer') return bufferConcat(this.body)
	  if (this.encoding === 'uint8array') return u8Concat(this.body)
	  return this.body
	}
	
	var isArray = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]'
	}
	
	function isArrayish (arr) {
	  return /Array\]$/.test(Object.prototype.toString.call(arr))
	}
	
	function isBufferish (p) {
	  return typeof p === 'string' || isArrayish(p) || (p && typeof p.subarray === 'function')
	}
	
	function stringConcat (parts) {
	  var strings = []
	  var needsToString = false
	  for (var i = 0; i < parts.length; i++) {
	    var p = parts[i]
	    if (typeof p === 'string') {
	      strings.push(p)
	    } else if (Buffer.isBuffer(p)) {
	      strings.push(p)
	    } else if (isBufferish(p)) {
	      strings.push(new Buffer(p))
	    } else {
	      strings.push(new Buffer(String(p)))
	    }
	  }
	  if (Buffer.isBuffer(parts[0])) {
	    strings = Buffer.concat(strings)
	    strings = strings.toString('utf8')
	  } else {
	    strings = strings.join('')
	  }
	  return strings
	}
	
	function bufferConcat (parts) {
	  var bufs = []
	  for (var i = 0; i < parts.length; i++) {
	    var p = parts[i]
	    if (Buffer.isBuffer(p)) {
	      bufs.push(p)
	    } else if (isBufferish(p)) {
	      bufs.push(new Buffer(p))
	    } else {
	      bufs.push(new Buffer(String(p)))
	    }
	  }
	  return Buffer.concat(bufs)
	}
	
	function arrayConcat (parts) {
	  var res = []
	  for (var i = 0; i < parts.length; i++) {
	    res.push.apply(res, parts[i])
	  }
	  return res
	}
	
	function u8Concat (parts) {
	  var len = 0
	  for (var i = 0; i < parts.length; i++) {
	    if (typeof parts[i] === 'string') {
	      parts[i] = new Buffer(parts[i])
	    }
	    len += parts[i].length
	  }
	  var u8 = new U8(len)
	  for (var i = 0, offset = 0; i < parts.length; i++) {
	    var part = parts[i]
	    for (var j = 0; j < part.length; j++) {
	      u8[offset++] = part[j]
	    }
	  }
	  return u8
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(27); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(117);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(126);
	exports.Duplex = __webpack_require__(125);
	exports.Transform = __webpack_require__(129);
	exports.PassThrough = __webpack_require__(130);
	
	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = Readable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(118);
	/*</replacement>*/
	
	/*<replacement>*/
	var isArray = __webpack_require__(119);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(26).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(27);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(26).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(22).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(120);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(121);
	util.inherits = __webpack_require__(122);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(123);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(124);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(125);
	
	  options = options || {};
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(128).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(125);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options && typeof options.read === 'function') this._read = options.read;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	
	      if (!addToFront) state.reading = false;
	
	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(128).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }
	
	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 119 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var buffer = __webpack_require__(22);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 122 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 123 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Buffer = __webpack_require__(22).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(120);
	/*</replacement>*/
	
	module.exports = BufferList;
	
	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	
	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	
	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};
	
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(118);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(121);
	util.inherits = __webpack_require__(122);
	/*</replacement>*/
	
	var Readable = __webpack_require__(117);
	var Writable = __webpack_require__(126);
	
	util.inherits(Duplex, Readable);
	
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	module.exports = Writable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(118);
	/*</replacement>*/
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(121);
	util.inherits = __webpack_require__(122);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(127)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(27);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(26).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(22).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(120);
	/*</replacement>*/
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(125);
	
	  options = options || {};
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}
	
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(125);
	
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), __webpack_require__(38).setImmediate))

/***/ },
/* 127 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(22).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(125);
	
	/*<replacement>*/
	var util = __webpack_require__(121);
	util.inherits = __webpack_require__(122);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(this);
	
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  // When the writable side finishes, then flush out anything remaining.
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er, data) {
	      done(stream, er, data);
	    });else done(stream);
	  });
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(129);
	
	/*<replacement>*/
	var util = __webpack_require__(121);
	util.inherits = __webpack_require__(122);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 131 */
/***/ function(module, exports) {

	var undefined = (void 0); // Paranoia
	
	// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
	// create, and consume so much memory, that the browser appears frozen.
	var MAX_ARRAY_LENGTH = 1e5;
	
	// Approximations of internal ECMAScript conversion functions
	var ECMAScript = (function() {
	  // Stash a copy in case other scripts modify these
	  var opts = Object.prototype.toString,
	      ophop = Object.prototype.hasOwnProperty;
	
	  return {
	    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
	    Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
	    HasProperty: function(o, p) { return p in o; },
	    HasOwnProperty: function(o, p) { return ophop.call(o, p); },
	    IsCallable: function(o) { return typeof o === 'function'; },
	    ToInt32: function(v) { return v >> 0; },
	    ToUint32: function(v) { return v >>> 0; }
	  };
	}());
	
	// Snapshot intrinsics
	var LN2 = Math.LN2,
	    abs = Math.abs,
	    floor = Math.floor,
	    log = Math.log,
	    min = Math.min,
	    pow = Math.pow,
	    round = Math.round;
	
	// ES5: lock down object properties
	function configureProperties(obj) {
	  if (getOwnPropNames && defineProp) {
	    var props = getOwnPropNames(obj), i;
	    for (i = 0; i < props.length; i += 1) {
	      defineProp(obj, props[i], {
	        value: obj[props[i]],
	        writable: false,
	        enumerable: false,
	        configurable: false
	      });
	    }
	  }
	}
	
	// emulate ES5 getter/setter API using legacy APIs
	// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
	// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
	// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
	var defineProp
	if (Object.defineProperty && (function() {
	      try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	      } catch (e) {
	        return false;
	      }
	    })()) {
	  defineProp = Object.defineProperty;
	} else {
	  defineProp = function(o, p, desc) {
	    if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
	    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
	    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
	    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
	    return o;
	  };
	}
	
	var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
	  if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
	  var props = [], p;
	  for (p in o) {
	    if (ECMAScript.HasOwnProperty(o, p)) {
	      props.push(p);
	    }
	  }
	  return props;
	};
	
	// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
	// for index in 0 ... obj.length
	function makeArrayAccessors(obj) {
	  if (!defineProp) { return; }
	
	  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
	
	  function makeArrayAccessor(index) {
	    defineProp(obj, index, {
	      'get': function() { return obj._getter(index); },
	      'set': function(v) { obj._setter(index, v); },
	      enumerable: true,
	      configurable: false
	    });
	  }
	
	  var i;
	  for (i = 0; i < obj.length; i += 1) {
	    makeArrayAccessor(i);
	  }
	}
	
	// Internal conversion functions:
	//    pack<Type>()   - take a number (interpreted as Type), output a byte array
	//    unpack<Type>() - take a byte array, output a Type-like number
	
	function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
	function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }
	
	function packI8(n) { return [n & 0xff]; }
	function unpackI8(bytes) { return as_signed(bytes[0], 8); }
	
	function packU8(n) { return [n & 0xff]; }
	function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }
	
	function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }
	
	function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
	function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }
	
	function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
	function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }
	
	function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
	function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }
	
	function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
	function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }
	
	function packIEEE754(v, ebits, fbits) {
	
	  var bias = (1 << (ebits - 1)) - 1,
	      s, e, f, ln,
	      i, bits, str, bytes;
	
	  function roundToEven(n) {
	    var w = floor(n), f = n - w;
	    if (f < 0.5)
	      return w;
	    if (f > 0.5)
	      return w + 1;
	    return w % 2 ? w + 1 : w;
	  }
	
	  // Compute sign, exponent, fraction
	  if (v !== v) {
	    // NaN
	    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
	    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
	  } else if (v === Infinity || v === -Infinity) {
	    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
	  } else if (v === 0) {
	    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
	  } else {
	    s = v < 0;
	    v = abs(v);
	
	    if (v >= pow(2, 1 - bias)) {
	      e = min(floor(log(v) / LN2), 1023);
	      f = roundToEven(v / pow(2, e) * pow(2, fbits));
	      if (f / pow(2, fbits) >= 2) {
	        e = e + 1;
	        f = 1;
	      }
	      if (e > bias) {
	        // Overflow
	        e = (1 << ebits) - 1;
	        f = 0;
	      } else {
	        // Normalized
	        e = e + bias;
	        f = f - pow(2, fbits);
	      }
	    } else {
	      // Denormalized
	      e = 0;
	      f = roundToEven(v / pow(2, 1 - bias - fbits));
	    }
	  }
	
	  // Pack sign, exponent, fraction
	  bits = [];
	  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
	  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
	  bits.push(s ? 1 : 0);
	  bits.reverse();
	  str = bits.join('');
	
	  // Bits to bytes
	  bytes = [];
	  while (str.length) {
	    bytes.push(parseInt(str.substring(0, 8), 2));
	    str = str.substring(8);
	  }
	  return bytes;
	}
	
	function unpackIEEE754(bytes, ebits, fbits) {
	
	  // Bytes to bits
	  var bits = [], i, j, b, str,
	      bias, s, e, f;
	
	  for (i = bytes.length; i; i -= 1) {
	    b = bytes[i - 1];
	    for (j = 8; j; j -= 1) {
	      bits.push(b % 2 ? 1 : 0); b = b >> 1;
	    }
	  }
	  bits.reverse();
	  str = bits.join('');
	
	  // Unpack sign, exponent, fraction
	  bias = (1 << (ebits - 1)) - 1;
	  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
	  e = parseInt(str.substring(1, 1 + ebits), 2);
	  f = parseInt(str.substring(1 + ebits), 2);
	
	  // Produce number
	  if (e === (1 << ebits) - 1) {
	    return f !== 0 ? NaN : s * Infinity;
	  } else if (e > 0) {
	    // Normalized
	    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
	  } else if (f !== 0) {
	    // Denormalized
	    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
	  } else {
	    return s < 0 ? -0 : 0;
	  }
	}
	
	function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
	function packF64(v) { return packIEEE754(v, 11, 52); }
	function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
	function packF32(v) { return packIEEE754(v, 8, 23); }
	
	
	//
	// 3 The ArrayBuffer Type
	//
	
	(function() {
	
	  /** @constructor */
	  var ArrayBuffer = function ArrayBuffer(length) {
	    length = ECMAScript.ToInt32(length);
	    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');
	
	    this.byteLength = length;
	    this._bytes = [];
	    this._bytes.length = length;
	
	    var i;
	    for (i = 0; i < this.byteLength; i += 1) {
	      this._bytes[i] = 0;
	    }
	
	    configureProperties(this);
	  };
	
	  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;
	
	  //
	  // 4 The ArrayBufferView Type
	  //
	
	  // NOTE: this constructor is not exported
	  /** @constructor */
	  var ArrayBufferView = function ArrayBufferView() {
	    //this.buffer = null;
	    //this.byteOffset = 0;
	    //this.byteLength = 0;
	  };
	
	  //
	  // 5 The Typed Array View Types
	  //
	
	  function makeConstructor(bytesPerElement, pack, unpack) {
	    // Each TypedArray type requires a distinct constructor instance with
	    // identical logic, which this produces.
	
	    var ctor;
	    ctor = function(buffer, byteOffset, length) {
	      var array, sequence, i, s;
	
	      if (!arguments.length || typeof arguments[0] === 'number') {
	        // Constructor(unsigned long length)
	        this.length = ECMAScript.ToInt32(arguments[0]);
	        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');
	
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;
	      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
	        // Constructor(TypedArray array)
	        array = arguments[0];
	
	        this.length = array.length;
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;
	
	        for (i = 0; i < this.length; i += 1) {
	          this._setter(i, array._getter(i));
	        }
	      } else if (typeof arguments[0] === 'object' &&
	                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
	        // Constructor(sequence<type> array)
	        sequence = arguments[0];
	
	        this.length = ECMAScript.ToUint32(sequence.length);
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;
	
	        for (i = 0; i < this.length; i += 1) {
	          s = sequence[i];
	          this._setter(i, Number(s));
	        }
	      } else if (typeof arguments[0] === 'object' &&
	                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
	        // Constructor(ArrayBuffer buffer,
	        //             optional unsigned long byteOffset, optional unsigned long length)
	        this.buffer = buffer;
	
	        this.byteOffset = ECMAScript.ToUint32(byteOffset);
	        if (this.byteOffset > this.buffer.byteLength) {
	          throw new RangeError("byteOffset out of range");
	        }
	
	        if (this.byteOffset % this.BYTES_PER_ELEMENT) {
	          // The given byteOffset must be a multiple of the element
	          // size of the specific type, otherwise an exception is raised.
	          throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
	        }
	
	        if (arguments.length < 3) {
	          this.byteLength = this.buffer.byteLength - this.byteOffset;
	
	          if (this.byteLength % this.BYTES_PER_ELEMENT) {
	            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
	          }
	          this.length = this.byteLength / this.BYTES_PER_ELEMENT;
	        } else {
	          this.length = ECMAScript.ToUint32(length);
	          this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        }
	
	        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
	          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
	        }
	      } else {
	        throw new TypeError("Unexpected argument type(s)");
	      }
	
	      this.constructor = ctor;
	
	      configureProperties(this);
	      makeArrayAccessors(this);
	    };
	
	    ctor.prototype = new ArrayBufferView();
	    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
	    ctor.prototype._pack = pack;
	    ctor.prototype._unpack = unpack;
	    ctor.BYTES_PER_ELEMENT = bytesPerElement;
	
	    // getter type (unsigned long index);
	    ctor.prototype._getter = function(index) {
	      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
	
	      index = ECMAScript.ToUint32(index);
	      if (index >= this.length) {
	        return undefined;
	      }
	
	      var bytes = [], i, o;
	      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
	           i < this.BYTES_PER_ELEMENT;
	           i += 1, o += 1) {
	        bytes.push(this.buffer._bytes[o]);
	      }
	      return this._unpack(bytes);
	    };
	
	    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
	    ctor.prototype.get = ctor.prototype._getter;
	
	    // setter void (unsigned long index, type value);
	    ctor.prototype._setter = function(index, value) {
	      if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
	
	      index = ECMAScript.ToUint32(index);
	      if (index >= this.length) {
	        return undefined;
	      }
	
	      var bytes = this._pack(value), i, o;
	      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
	           i < this.BYTES_PER_ELEMENT;
	           i += 1, o += 1) {
	        this.buffer._bytes[o] = bytes[i];
	      }
	    };
	
	    // void set(TypedArray array, optional unsigned long offset);
	    // void set(sequence<type> array, optional unsigned long offset);
	    ctor.prototype.set = function(index, value) {
	      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
	      var array, sequence, offset, len,
	          i, s, d,
	          byteOffset, byteLength, tmp;
	
	      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
	        // void set(TypedArray array, optional unsigned long offset);
	        array = arguments[0];
	        offset = ECMAScript.ToUint32(arguments[1]);
	
	        if (offset + array.length > this.length) {
	          throw new RangeError("Offset plus length of array is out of range");
	        }
	
	        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
	        byteLength = array.length * this.BYTES_PER_ELEMENT;
	
	        if (array.buffer === this.buffer) {
	          tmp = [];
	          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
	            tmp[i] = array.buffer._bytes[s];
	          }
	          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
	            this.buffer._bytes[d] = tmp[i];
	          }
	        } else {
	          for (i = 0, s = array.byteOffset, d = byteOffset;
	               i < byteLength; i += 1, s += 1, d += 1) {
	            this.buffer._bytes[d] = array.buffer._bytes[s];
	          }
	        }
	      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
	        // void set(sequence<type> array, optional unsigned long offset);
	        sequence = arguments[0];
	        len = ECMAScript.ToUint32(sequence.length);
	        offset = ECMAScript.ToUint32(arguments[1]);
	
	        if (offset + len > this.length) {
	          throw new RangeError("Offset plus length of array is out of range");
	        }
	
	        for (i = 0; i < len; i += 1) {
	          s = sequence[i];
	          this._setter(offset + i, Number(s));
	        }
	      } else {
	        throw new TypeError("Unexpected argument type(s)");
	      }
	    };
	
	    // TypedArray subarray(long begin, optional long end);
	    ctor.prototype.subarray = function(start, end) {
	      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
	
	      start = ECMAScript.ToInt32(start);
	      end = ECMAScript.ToInt32(end);
	
	      if (arguments.length < 1) { start = 0; }
	      if (arguments.length < 2) { end = this.length; }
	
	      if (start < 0) { start = this.length + start; }
	      if (end < 0) { end = this.length + end; }
	
	      start = clamp(start, 0, this.length);
	      end = clamp(end, 0, this.length);
	
	      var len = end - start;
	      if (len < 0) {
	        len = 0;
	      }
	
	      return new this.constructor(
	        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
	    };
	
	    return ctor;
	  }
	
	  var Int8Array = makeConstructor(1, packI8, unpackI8);
	  var Uint8Array = makeConstructor(1, packU8, unpackU8);
	  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
	  var Int16Array = makeConstructor(2, packI16, unpackI16);
	  var Uint16Array = makeConstructor(2, packU16, unpackU16);
	  var Int32Array = makeConstructor(4, packI32, unpackI32);
	  var Uint32Array = makeConstructor(4, packU32, unpackU32);
	  var Float32Array = makeConstructor(4, packF32, unpackF32);
	  var Float64Array = makeConstructor(8, packF64, unpackF64);
	
	  exports.Int8Array = exports.Int8Array || Int8Array;
	  exports.Uint8Array = exports.Uint8Array || Uint8Array;
	  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
	  exports.Int16Array = exports.Int16Array || Int16Array;
	  exports.Uint16Array = exports.Uint16Array || Uint16Array;
	  exports.Int32Array = exports.Int32Array || Int32Array;
	  exports.Uint32Array = exports.Uint32Array || Uint32Array;
	  exports.Float32Array = exports.Float32Array || Float32Array;
	  exports.Float64Array = exports.Float64Array || Float64Array;
	}());
	
	//
	// 6 The DataView View Type
	//
	
	(function() {
	  function r(array, index) {
	    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
	  }
	
	  var IS_BIG_ENDIAN = (function() {
	    var u16array = new(exports.Uint16Array)([0x1234]),
	        u8array = new(exports.Uint8Array)(u16array.buffer);
	    return r(u8array, 0) === 0x12;
	  }());
	
	  // Constructor(ArrayBuffer buffer,
	  //             optional unsigned long byteOffset,
	  //             optional unsigned long byteLength)
	  /** @constructor */
	  var DataView = function DataView(buffer, byteOffset, byteLength) {
	    if (arguments.length === 0) {
	      buffer = new exports.ArrayBuffer(0);
	    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
	      throw new TypeError("TypeError");
	    }
	
	    this.buffer = buffer || new exports.ArrayBuffer(0);
	
	    this.byteOffset = ECMAScript.ToUint32(byteOffset);
	    if (this.byteOffset > this.buffer.byteLength) {
	      throw new RangeError("byteOffset out of range");
	    }
	
	    if (arguments.length < 3) {
	      this.byteLength = this.buffer.byteLength - this.byteOffset;
	    } else {
	      this.byteLength = ECMAScript.ToUint32(byteLength);
	    }
	
	    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
	      throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
	    }
	
	    configureProperties(this);
	  };
	
	  function makeGetter(arrayType) {
	    return function(byteOffset, littleEndian) {
	
	      byteOffset = ECMAScript.ToUint32(byteOffset);
	
	      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
	        throw new RangeError("Array index out of range");
	      }
	      byteOffset += this.byteOffset;
	
	      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
	          bytes = [], i;
	      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
	        bytes.push(r(uint8Array, i));
	      }
	
	      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
	        bytes.reverse();
	      }
	
	      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
	    };
	  }
	
	  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
	  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
	  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
	  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
	  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
	  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
	  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
	  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);
	
	  function makeSetter(arrayType) {
	    return function(byteOffset, value, littleEndian) {
	
	      byteOffset = ECMAScript.ToUint32(byteOffset);
	      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
	        throw new RangeError("Array index out of range");
	      }
	
	      // Get bytes
	      var typeArray = new arrayType([value]),
	          byteArray = new exports.Uint8Array(typeArray.buffer),
	          bytes = [], i, byteView;
	
	      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
	        bytes.push(r(byteArray, i));
	      }
	
	      // Flip if necessary
	      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
	        bytes.reverse();
	      }
	
	      // Write them
	      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
	      byteView.set(bytes);
	    };
	  }
	
	  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
	  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
	  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
	  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
	  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
	  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
	  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
	  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);
	
	  exports.DataView = exports.DataView || DataView;
	
	}());


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'proc-cpuinfo'})
	module.exports = parseProcCPUInfo
	
	function parseProcCPUInfo(data) {
	  var relevantAttributes = [
	    'processor',
	    'physical id',
	    'cpu cores',
	    'core id'
	  ]
	
	  var processorStats = {
	    logical: null,
	    cores: null,
	    packages: null
	  }
	
	  // seperate the processors
	  var splitData = data.split('\n')
	    .map(function formatAttribute(attr) {
	      return attr.split(':')
	        .map(function eliminateExtraWhitespace(s) {
	          return s.replace(/\\r|\\t| {2,}/g, '').trim()
	        })
	    })
	
	  var validData = splitData.filter(function checkForValidAttrs(a) {
	    return a.length === 2 && relevantAttributes.indexOf(a[0]) !== -1
	  })
	  if (validData.length === 0) {
	    logger.debug('No applicable cpu attributes found')
	    return processorStats
	  }
	
	  splitData = collapseMultilineValues(splitData)
	
	  var processors = seperateProcessors(splitData)
	
	  processorStats = countProcessorStats(processors)
	  if (!processorStats.cores) {
	    if (processorStats.logical === 1) {
	      // some older, single-core processors might not list ids,
	      // so we'll mark them 1
	      processorStats.cores = 1
	      processorStats.packages = 1
	    } else {
	      // there is no way of knowing how many packages
	      // or cores there are
	      processorStats.cores = null
	      processorStats.packages = null
	    }
	  }
	  return processorStats
	}
	
	// some values are split up over multiple lines, these won't be broken
	// by split(':'), and should be folded into the last seen valid value
	function collapseMultilineValues(li) {
	  var tmp = []
	  var last
	  for (var i = 0; i < li.length; ++i) {
	    if (li[i].length === 2) {
	      // store the last valid entry to append invalid entries to
	      last = li[i]
	      tmp.push(last)
	    } else {
	      last[1] += li[i][0]
	    }
	  }
	
	  return tmp
	}
	
	// walk through the processed list of key, value pairs and populate
	// objects till you find a collision
	function seperateProcessors(processorData) {
	  var processors = []
	  var processor = {}
	  for (var i = 0; i < processorData.length; ++i) {
	    var key = processorData[i][0]
	    var value = processorData[i][1]
	    if (processor[key] !== undefined) {
	      processors.push(processor)
	      processor = {}
	    }
	    processor[key] = value
	  }
	  processors.push(processor)
	  return processors
	}
	
	function countProcessorStats(processors) {
	  var phys = []
	  var cores = []
	
	  for (var i = 0; i < processors.length; i++) {
	    var processor = processors[i]
	    if (processor['physical id'] &&
	        processor['cpu cores'] &&
	        phys.indexOf(processor['physical id']) === -1) {
	      phys.push(processor['physical id'])
	      cores.push(processor['cpu cores'])
	    }
	  }
	
	  return {
	    logical: processors.length,
	    cores: cores
	      .map(function convertToInt(s) {
	        return parseInt(s, 10)
	      })
	      .reduce(function sum(a, b) {
	        return a + b
	      }, 0),
	    packages: phys.length
	  }
	}


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'dockerinfo'})
	var NAMES = __webpack_require__(59)
	module.exports = parseDockerInfo
	
	function parseDockerInfo(agent, data) {
	  if (!agent.config.utilization || !agent.config.utilization.detect_docker) return null
	  var cpuCgroup = parseCgroupIds(data).cpu
	  // if we can't parse the cgroups, or if the cpu is not in a cgroup
	  var dockerError = agent.metrics.getOrCreateMetric(NAMES.UTILIZATION.DOCKER_ERROR)
	  if (!cpuCgroup) {
	    logger.debug('Could not parse cgroup data from: ' + data)
	    dockerError.incrementCallCount()
	    return null
	  }
	
	  // if cpu isn't in a cgroup
	  if (cpuCgroup === '/') return null
	
	  var patterns = [
	    /^\/docker\/([0-9a-f]+)$/, // docker native driver w/out systemd
	    /^\/system\.slice\/docker-([0-9a-f]+)\.scope$/, // with systemd
	    /^\/lxc\/([0-9a-f]+)$/ // docker lxc driver
	  ]
	  for (var i = 0; i < patterns.length; i++) {
	    var pattern = patterns[i]
	    var matches = cpuCgroup.match(pattern)
	    if (matches) {
	      var id = matches[1]
	      if (id.length !== 64) {
	        dockerError.incrementCallCount()
	        logger.debug('Encountered a malformed docker id: ', id)
	        return null
	      }
	      return id
	    }
	  }
	
	  logger.debug('Unable to recognise cgroup format')
	
	  return null
	}
	
	function parseCgroupIds(cgroupInfo) {
	  var cgroupIds = {}
	  cgroupInfo.split('\n').forEach(function parseCgroupInfo(line) {
	    var parts = line.split(':')
	    if (parts.length !== 3) return
	    var subsystems = parts[1]
	    var cgroupId = parts[2]
	    subsystems.split(',').forEach(function assignGroupIds(subsystem) {
	      cgroupIds[subsystem] = cgroupId
	    })
	  })
	  return cgroupIds
	}


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'proc-meminfo'})
	
	module.exports = parseProcMeminfo
	
	function parseProcMeminfo(data) {
	  var mem_total = parseInt(data.replace(/MemTotal:\s*(\d*)\skB/, '$1'), 10)
	
	  if (mem_total) return mem_total / 1024
	
	  logger.debug('Unable to parse memory string:', data)
	  return null
	}


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	module.exports = parse
	module.exports.fromString = fromString
	module.exports.fromMap = fromMap
	
	
	// this creates a copy of trim that can be used with map
	var trim = Function.prototype.call.bind(String.prototype.trim)
	var logger = __webpack_require__(12).child({component: 'label-parser'})
	var stringifySync = __webpack_require__(14).stringifySync
	
	function parse(labels) {
	  var results
	
	  if (!labels) {
	    return []
	  } else if (typeof labels === 'string') {
	    results = fromString(labels)
	  } else if (labels) {
	    results = fromMap(labels)
	  }
	
	  results.warnings.forEach(function logWarnings(messaage) {
	    logger.warn(messaage)
	  })
	
	  return results.labels
	}
	
	function fromString(raw) {
	  var map = {}
	
	  if (!raw) {
	    return {labels: [], warnings: []}
	  }
	
	  var pairs = raw.split(';').map(trim)
	  var parts
	
	
	  while (!pairs[pairs.length - 1]) {
	    pairs.pop()
	  }
	
	  while (!pairs[0]) {
	    pairs.shift()
	  }
	
	  for (var i = 0, l = pairs.length; i < l; ++i) {
	    parts = pairs[i].split(':').map(trim)
	
	    if (parts.length !== 2) {
	      return warn('Could not create a Label pair from ' + parts[i])
	    } else if (!parts[0]) {
	      return warn('Label key can not be empty')
	    } else if (!parts[1]) {
	      return warn('Label value can not be empty')
	    }
	
	    map[parts[0]] = parts[1]
	  }
	
	  return fromMap(map)
	
	  function warn(message) {
	    return {labels: [], warnings: [
	      'Invalid Label String: ' + raw,
	       message
	    ]}
	  }
	}
	
	function fromMap(map) {
	  var warnings = []
	  var labels = []
	
	  Object.keys(map).forEach(function processKeys(key) {
	    var type = truncate(key, 255)
	
	    if (!map[key] || typeof map[key] !== 'string') {
	      return warnings.push(
	        'Label value for ' + type +
	        'should be a string with a length between 1 and 255 characters'
	      )
	    }
	
	    var value = truncate(map[key], 255)
	
	    if (type !== key) {
	      warnings.push('Label key too long: ' + type)
	    }
	
	    if (value !== map[key]) {
	      warnings.push('Label value too long: ' + value)
	    }
	
	    labels.push({label_type: type, label_value: value})
	  })
	
	  if (labels.length > 64) {
	    warnings.push('Too many Labels, list truncated to 64')
	    labels = labels.slice(0, 64)
	  }
	
	  if (warnings.length) {
	    warnings.unshift('Partially Invalid Label Setting: ' + stringifySync(map))
	  }
	
	  return {labels: labels, warnings: warnings}
	}
	
	function truncate(str, max) {
	  var len = 0
	  var chr
	  for (var i = 0, l = str.length; i < l; ++i) {
	    chr = str.charCodeAt(i)
	    if (chr >= 0xD800 && chr <= 0xDBFF && i !== l) {
	      i += 1
	    }
	
	    if (++len === max) {
	      break
	    }
	  }
	
	  return str.slice(0, i + 1)
	}


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict'
	
	var util = __webpack_require__(16)
	var url = __webpack_require__(108)
	var http = __webpack_require__(101)
	var https = __webpack_require__(137)
	var zlib = __webpack_require__(138)
	var logger = __webpack_require__(12).child({component: 'remote_method_invoke'})
	var parse = __webpack_require__(152)
	var Sink = __webpack_require__(153)
	var agents = __webpack_require__(154)
	var certificates = __webpack_require__(165)
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var PROTOCOL_VERSION = 14
	var RUN_ID_NAME = 'run_id'
	var RAW_METHOD_PATH = '/agent_listener/invoke_raw_method'
	  // see job/collector-master/javadoc/com/nr/servlet/AgentListener.html on NR Jenkins
	var USER_AGENT_FORMAT = "NewRelic-NodeAgent/%s (nodejs %s %s-%s)"
	var ENCODING_HEADER = 'CONTENT-ENCODING'
	var CONTENT_TYPE_HEADER = 'Content-Type'
	var DEFAULT_ENCODING = 'identity'
	var DEFAULT_CONTENT_TYPE = 'application/json'
	var COMPRESSED_CONTENT_TYPE = 'application/octet-stream'
	
	
	function RemoteMethod(name, config) {
	  if (!name) {
	    throw new TypeError("Must include name of method to invoke on collector.")
	  }
	
	  this.name = name
	  this._config = config
	}
	
	RemoteMethod.prototype.serialize = function serialize(payload, callback) {
	  try {
	    var res = JSON.stringify(payload)
	  } catch (error) {
	    logger.error(error, "Unable to serialize payload for method %s.", this.name)
	    return process.nextTick(function cb_nextTick() {
	      return callback(error)
	    })
	  }
	  return callback(null, res)
	}
	
	/**
	 * The primary operation on RemoteMethod objects. If you're calling anything on
	 * RemoteMethod objects aside from invoke (and you're not writing test code),
	 * you're doing it wrong.
	 *
	 * @param object   payload    Serializable payload.
	 * @param Function callback   What to do next. Gets passed any error.
	 */
	RemoteMethod.prototype.invoke = function call(payload, callback) {
	  if (!payload) payload = []
	
	  this.serialize(payload, function cb_serialize(err, serialized) {
	    if (err) return callback(err)
	    this._post(serialized, callback)
	  }.bind(this))
	}
	
	/**
	 * Take a serialized payload and create a response wrapper for it before
	 * invoking the method on the collector.
	 *
	 * @param string   methodName Name of method to invoke on collector.
	 * @param string   data       Serialized payload.
	 * @param Function callback   What to do next. Gets passed any error.
	 */
	RemoteMethod.prototype._post = function _post(data, callback) {
	  var method = this
	
	  // set up standard response handling
	  function onResponse(response) {
	    response.on('end', function handle_end() {
	      logger.debug(
	        "Finished receiving data back from the collector for %s.",
	        method.name
	      )
	    })
	
	    response.setEncoding('utf8')
	    response.pipe(new Sink(parse(method.name, response, callback)))
	  }
	
	  var options = {
	    port: this._config.port,
	    host: this._config.host,
	    compressed: this._shouldCompress(data),
	    path: this._path(),
	    onError: callback,
	    onResponse: onResponse
	  }
	
	  if (options.compressed) {
	    logger.trace({data: data}, "Sending %s on collector API with (COMPRESSED)", this.name)
	
	    var useGzip = this._config.compressed_content_encoding === 'gzip'
	    var compressor = useGzip ? zlib.gzip : zlib.deflate
	    compressor(data, function cb_compressor(err, compressed) {
	      if (err) {
	        logger.warn(err, "Error compressing JSON for delivery. Not sending.")
	        return callback(err)
	      }
	
	      options.body = compressed
	      method._safeRequest(options)
	    })
	  } else {
	    logger.debug({data: data}, "Calling %s on collector API", this.name)
	
	    options.body = data
	    this._safeRequest(options)
	  }
	}
	
	/**
	 * http.request does its own DNS lookup, and if it fails, will cause
	 * dns.lookup to throw asynchronously instead of passing the error to
	 * the callback (which is obviously awesome). To prevent New Relic from
	 * crashing people's applications, verify that lookup works and bail out
	 * early if not.
	 *
	 * Also, ensure that all the necessary parameters are set before
	 * actually making the request. Useful to put here to simplify test code
	 * that calls _request directly.
	 *
	 * @param object options A dictionary of request parameters.
	 */
	RemoteMethod.prototype._safeRequest = function _safeRequest(options) {
	  if (!options) throw new Error("Must include options to make request!")
	  if (!options.host) throw new Error("Must include collector hostname!")
	  if (!options.port) throw new Error("Must include collector port!")
	  if (!options.onError) throw new Error("Must include error handler!")
	  if (!options.onResponse) throw new Error("Must include response handler!")
	  if (!options.body) throw new Error("Must include body to send to collector!")
	  if (!options.path) throw new Error("Must include URL to request!")
	
	  var protocol = this._config.ssl ? 'https' : 'http'
	  var logconfig = this._config.logging
	  var audit_log = this._config.audit_log
	  var logevent = util.format({
	    body: Buffer.isBuffer(options.body) ? 'Buffer ' + options.body.length : options.body
	  }, "Posting to %s://%s:%s%s",
	    protocol,
	    options.host,
	    options.port,
	    options.path
	  )
	  // if trace level is not explicity enabled
	  // check to see if the audit log is enabled
	  if ((typeof logconfig !== 'undefined') && logconfig.level !== 'trace') {
	    if (audit_log.enabled &&
	          // if the filter property is empty, then always log the event
	          // otherwise check to see if the filter includes this method
	          (audit_log.endpoints.length > 0 ?
	           audit_log.endpoints.indexOf(this.name) > -1 : true)) {
	      logger.info(logevent)
	    }
	  } else {
	    logger.trace(logevent)
	  }
	
	
	  this._request(options)
	}
	
	/**
	 * Generate the request headers and wire up the request. There are many
	 * parameters used to make a request:
	 *
	 * @param string   options.host       Hostname (or proxy hostname) for collector.
	 * @param string   options.port       Port (or proxy port) for collector.
	 * @param string   options.path       URL path for method being invoked on collector.
	 * @param string   options.body       Serialized payload to be sent to collector.
	 * @param boolean  options.compressed Whether the payload has been compressed.
	 * @param Function options.onError    Error handler for this request (probably the
	 *                                    original callback given to .send).
	 * @param Function options.onResponse Response handler for this request (created by
	 *                                    ._post).
	 */
	RemoteMethod.prototype._request = function _request(options) {
	  var requestOptions = {
	    method: this._config.put_for_data_send ? 'PUT' : 'POST',
	    setHost: false,         // See below
	    host: options.host,     // Set explicitly in the headers
	    port: options.port,
	    path: options.path,
	    headers: this._headers(options.body, options.compressed),
	    __NR__connection: true  // Who measures the metrics measurer?
	  }
	  var request
	
	  var isProxy = !!(
	    this._config.proxy ||
	    this._config.proxy_port ||
	    this._config.proxy_host
	  )
	
	  if (isProxy) {
	    // proxy
	    requestOptions.agent = agents.proxyAgent(this._config)
	    request = https.request(requestOptions)
	
	    // FIXME: The agent keeps this connection open when using the proxy.
	    // This will prevent the application from shutting down correctly.
	    // Explicitly destroy the socket when the response is completed.
	    //
	    // This goes against keep-alive, but for now letting the application die
	    // gracefully is more important.
	    request.on('response', function cb_on_response(sock) {
	      sock.on('end', function cb_on_end() {
	        sock.destroy()
	      })
	    })
	  } else if (this._config.ssl) {
	    if (this._config.certificates && this._config.certificates.length > 0) {
	      logger.debug(
	        'Adding custom certificate to the cert bundle.'
	      )
	      requestOptions.ca = this._config.certificates.concat(certificates)
	    }
	    requestOptions.agent = agents.https
	    request = https.request(requestOptions)
	  } else {
	    requestOptions.agent = agents.http
	    request = http.request(requestOptions)
	  }
	
	  request.on('error', options.onError)
	  request.on('response', options.onResponse)
	
	  request.end(options.body)
	}
	
	/**
	 * See the constants list for the format string (and the URL that explains it).
	 */
	RemoteMethod.prototype._userAgent = function _userAgent() {
	  return util.format(USER_AGENT_FORMAT,
	                     this._config.version,
	                     process.versions.node,
	                     process.platform,
	                     process.arch)
	}
	
	/**
	 * Generate a URL the collector understands.
	 *
	 * @returns string The URL path to be POSTed to.
	 */
	RemoteMethod.prototype._path = function _path() {
	  var query = {
	      marshal_format: 'json',
	      protocol_version: PROTOCOL_VERSION,
	      license_key: this._config.license_key,
	      method: this.name
	  }
	
	  if (this._config.run_id) query[RUN_ID_NAME] = this._config.run_id
	
	  var formatted = url.format({
	    pathname: RAW_METHOD_PATH,
	    query: query
	  })
	
	  return formatted
	}
	
	/**
	 * @param {number}  length      - Length of data to be sent.
	 * @param {bool}    compressed  - The compression method used, if any.
	 */
	RemoteMethod.prototype._headers = function _headers(body, compressed) {
	  var agent = this._userAgent()
	
	  var headers = {
	    // select the virtual host on the server end
	    'Host': this._config.host,
	    'User-Agent': agent,
	    'Connection': 'Keep-Alive',
	    'Content-Length': byteLength(body)
	  }
	
	  if (compressed) {
	    headers[ENCODING_HEADER] = this._config.compressed_content_encoding
	    headers[CONTENT_TYPE_HEADER] = COMPRESSED_CONTENT_TYPE
	  } else {
	    headers[ENCODING_HEADER] = DEFAULT_ENCODING
	    headers[CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE
	  }
	
	  return headers
	}
	
	/**
	 * FLN pretty much decided on his own recognizance that 64K was a good point
	 * at which to compress a server response. There's only a loose consensus that
	 * the threshold should probably be much higher than this, if only to keep the
	 * load on the collector down.
	 *
	 * FIXME: come up with a better heuristic
	 */
	RemoteMethod.prototype._shouldCompress = function _shouldCompress(data) {
	  return data && byteLength(data) > 65536
	}
	
	function byteLength(data) {
	  if (!data) {
	    return 0
	  }
	
	  if (data instanceof Buffer) {
	    return data.length
	  }
	
	  return Buffer.byteLength(data, 'utf8')
	}
	
	module.exports = RemoteMethod
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), __webpack_require__(22).Buffer))

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var http = __webpack_require__(101);
	
	var https = module.exports;
	
	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};
	
	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    params.protocol = 'https:';
	    return http.request.call(this, params, cb);
	}


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Transform = __webpack_require__(46);
	
	var binding = __webpack_require__(139);
	var util = __webpack_require__(16);
	var assert = __webpack_require__(151).ok;
	
	// zlib doesn't provide these, so kludge them in following the same
	// const naming scheme zlib uses.
	binding.Z_MIN_WINDOWBITS = 8;
	binding.Z_MAX_WINDOWBITS = 15;
	binding.Z_DEFAULT_WINDOWBITS = 15;
	
	// fewer than 64 bytes per chunk is stupid.
	// technically it could work with as few as 8, but even 64 bytes
	// is absurdly low.  Usually a MB or more is best.
	binding.Z_MIN_CHUNK = 64;
	binding.Z_MAX_CHUNK = Infinity;
	binding.Z_DEFAULT_CHUNK = (16 * 1024);
	
	binding.Z_MIN_MEMLEVEL = 1;
	binding.Z_MAX_MEMLEVEL = 9;
	binding.Z_DEFAULT_MEMLEVEL = 8;
	
	binding.Z_MIN_LEVEL = -1;
	binding.Z_MAX_LEVEL = 9;
	binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
	
	// expose all the zlib constants
	Object.keys(binding).forEach(function(k) {
	  if (k.match(/^Z/)) exports[k] = binding[k];
	});
	
	// translation table for return codes.
	exports.codes = {
	  Z_OK: binding.Z_OK,
	  Z_STREAM_END: binding.Z_STREAM_END,
	  Z_NEED_DICT: binding.Z_NEED_DICT,
	  Z_ERRNO: binding.Z_ERRNO,
	  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
	  Z_DATA_ERROR: binding.Z_DATA_ERROR,
	  Z_MEM_ERROR: binding.Z_MEM_ERROR,
	  Z_BUF_ERROR: binding.Z_BUF_ERROR,
	  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
	};
	
	Object.keys(exports.codes).forEach(function(k) {
	  exports.codes[exports.codes[k]] = k;
	});
	
	exports.Deflate = Deflate;
	exports.Inflate = Inflate;
	exports.Gzip = Gzip;
	exports.Gunzip = Gunzip;
	exports.DeflateRaw = DeflateRaw;
	exports.InflateRaw = InflateRaw;
	exports.Unzip = Unzip;
	
	exports.createDeflate = function(o) {
	  return new Deflate(o);
	};
	
	exports.createInflate = function(o) {
	  return new Inflate(o);
	};
	
	exports.createDeflateRaw = function(o) {
	  return new DeflateRaw(o);
	};
	
	exports.createInflateRaw = function(o) {
	  return new InflateRaw(o);
	};
	
	exports.createGzip = function(o) {
	  return new Gzip(o);
	};
	
	exports.createGunzip = function(o) {
	  return new Gunzip(o);
	};
	
	exports.createUnzip = function(o) {
	  return new Unzip(o);
	};
	
	
	// Convenience methods.
	// compress/decompress a string or buffer in one step.
	exports.deflate = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Deflate(opts), buffer, callback);
	};
	
	exports.deflateSync = function(buffer, opts) {
	  return zlibBufferSync(new Deflate(opts), buffer);
	};
	
	exports.gzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gzip(opts), buffer, callback);
	};
	
	exports.gzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Gzip(opts), buffer);
	};
	
	exports.deflateRaw = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
	};
	
	exports.deflateRawSync = function(buffer, opts) {
	  return zlibBufferSync(new DeflateRaw(opts), buffer);
	};
	
	exports.unzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Unzip(opts), buffer, callback);
	};
	
	exports.unzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Unzip(opts), buffer);
	};
	
	exports.inflate = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Inflate(opts), buffer, callback);
	};
	
	exports.inflateSync = function(buffer, opts) {
	  return zlibBufferSync(new Inflate(opts), buffer);
	};
	
	exports.gunzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gunzip(opts), buffer, callback);
	};
	
	exports.gunzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Gunzip(opts), buffer);
	};
	
	exports.inflateRaw = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new InflateRaw(opts), buffer, callback);
	};
	
	exports.inflateRawSync = function(buffer, opts) {
	  return zlibBufferSync(new InflateRaw(opts), buffer);
	};
	
	function zlibBuffer(engine, buffer, callback) {
	  var buffers = [];
	  var nread = 0;
	
	  engine.on('error', onError);
	  engine.on('end', onEnd);
	
	  engine.end(buffer);
	  flow();
	
	  function flow() {
	    var chunk;
	    while (null !== (chunk = engine.read())) {
	      buffers.push(chunk);
	      nread += chunk.length;
	    }
	    engine.once('readable', flow);
	  }
	
	  function onError(err) {
	    engine.removeListener('end', onEnd);
	    engine.removeListener('readable', flow);
	    callback(err);
	  }
	
	  function onEnd() {
	    var buf = Buffer.concat(buffers, nread);
	    buffers = [];
	    callback(null, buf);
	    engine.close();
	  }
	}
	
	function zlibBufferSync(engine, buffer) {
	  if (typeof buffer === 'string')
	    buffer = new Buffer(buffer);
	  if (!Buffer.isBuffer(buffer))
	    throw new TypeError('Not a string or buffer');
	
	  var flushFlag = binding.Z_FINISH;
	
	  return engine._processChunk(buffer, flushFlag);
	}
	
	// generic zlib
	// minimal 2-byte header
	function Deflate(opts) {
	  if (!(this instanceof Deflate)) return new Deflate(opts);
	  Zlib.call(this, opts, binding.DEFLATE);
	}
	
	function Inflate(opts) {
	  if (!(this instanceof Inflate)) return new Inflate(opts);
	  Zlib.call(this, opts, binding.INFLATE);
	}
	
	
	
	// gzip - bigger header, same deflate compression
	function Gzip(opts) {
	  if (!(this instanceof Gzip)) return new Gzip(opts);
	  Zlib.call(this, opts, binding.GZIP);
	}
	
	function Gunzip(opts) {
	  if (!(this instanceof Gunzip)) return new Gunzip(opts);
	  Zlib.call(this, opts, binding.GUNZIP);
	}
	
	
	
	// raw - no header
	function DeflateRaw(opts) {
	  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
	  Zlib.call(this, opts, binding.DEFLATERAW);
	}
	
	function InflateRaw(opts) {
	  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
	  Zlib.call(this, opts, binding.INFLATERAW);
	}
	
	
	// auto-detect header.
	function Unzip(opts) {
	  if (!(this instanceof Unzip)) return new Unzip(opts);
	  Zlib.call(this, opts, binding.UNZIP);
	}
	
	
	// the Zlib class they all inherit from
	// This thing manages the queue of requests, and returns
	// true or false if there is anything in the queue when
	// you call the .write() method.
	
	function Zlib(opts, mode) {
	  this._opts = opts = opts || {};
	  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
	
	  Transform.call(this, opts);
	
	  if (opts.flush) {
	    if (opts.flush !== binding.Z_NO_FLUSH &&
	        opts.flush !== binding.Z_PARTIAL_FLUSH &&
	        opts.flush !== binding.Z_SYNC_FLUSH &&
	        opts.flush !== binding.Z_FULL_FLUSH &&
	        opts.flush !== binding.Z_FINISH &&
	        opts.flush !== binding.Z_BLOCK) {
	      throw new Error('Invalid flush flag: ' + opts.flush);
	    }
	  }
	  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
	
	  if (opts.chunkSize) {
	    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
	        opts.chunkSize > exports.Z_MAX_CHUNK) {
	      throw new Error('Invalid chunk size: ' + opts.chunkSize);
	    }
	  }
	
	  if (opts.windowBits) {
	    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
	        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
	      throw new Error('Invalid windowBits: ' + opts.windowBits);
	    }
	  }
	
	  if (opts.level) {
	    if (opts.level < exports.Z_MIN_LEVEL ||
	        opts.level > exports.Z_MAX_LEVEL) {
	      throw new Error('Invalid compression level: ' + opts.level);
	    }
	  }
	
	  if (opts.memLevel) {
	    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
	        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
	      throw new Error('Invalid memLevel: ' + opts.memLevel);
	    }
	  }
	
	  if (opts.strategy) {
	    if (opts.strategy != exports.Z_FILTERED &&
	        opts.strategy != exports.Z_HUFFMAN_ONLY &&
	        opts.strategy != exports.Z_RLE &&
	        opts.strategy != exports.Z_FIXED &&
	        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
	      throw new Error('Invalid strategy: ' + opts.strategy);
	    }
	  }
	
	  if (opts.dictionary) {
	    if (!Buffer.isBuffer(opts.dictionary)) {
	      throw new Error('Invalid dictionary: it should be a Buffer instance');
	    }
	  }
	
	  this._binding = new binding.Zlib(mode);
	
	  var self = this;
	  this._hadError = false;
	  this._binding.onerror = function(message, errno) {
	    // there is no way to cleanly recover.
	    // continuing only obscures problems.
	    self._binding = null;
	    self._hadError = true;
	
	    var error = new Error(message);
	    error.errno = errno;
	    error.code = exports.codes[errno];
	    self.emit('error', error);
	  };
	
	  var level = exports.Z_DEFAULT_COMPRESSION;
	  if (typeof opts.level === 'number') level = opts.level;
	
	  var strategy = exports.Z_DEFAULT_STRATEGY;
	  if (typeof opts.strategy === 'number') strategy = opts.strategy;
	
	  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
	                     level,
	                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
	                     strategy,
	                     opts.dictionary);
	
	  this._buffer = new Buffer(this._chunkSize);
	  this._offset = 0;
	  this._closed = false;
	  this._level = level;
	  this._strategy = strategy;
	
	  this.once('end', this.close);
	}
	
	util.inherits(Zlib, Transform);
	
	Zlib.prototype.params = function(level, strategy, callback) {
	  if (level < exports.Z_MIN_LEVEL ||
	      level > exports.Z_MAX_LEVEL) {
	    throw new RangeError('Invalid compression level: ' + level);
	  }
	  if (strategy != exports.Z_FILTERED &&
	      strategy != exports.Z_HUFFMAN_ONLY &&
	      strategy != exports.Z_RLE &&
	      strategy != exports.Z_FIXED &&
	      strategy != exports.Z_DEFAULT_STRATEGY) {
	    throw new TypeError('Invalid strategy: ' + strategy);
	  }
	
	  if (this._level !== level || this._strategy !== strategy) {
	    var self = this;
	    this.flush(binding.Z_SYNC_FLUSH, function() {
	      self._binding.params(level, strategy);
	      if (!self._hadError) {
	        self._level = level;
	        self._strategy = strategy;
	        if (callback) callback();
	      }
	    });
	  } else {
	    process.nextTick(callback);
	  }
	};
	
	Zlib.prototype.reset = function() {
	  return this._binding.reset();
	};
	
	// This is the _flush function called by the transform class,
	// internally, when the last chunk has been written.
	Zlib.prototype._flush = function(callback) {
	  this._transform(new Buffer(0), '', callback);
	};
	
	Zlib.prototype.flush = function(kind, callback) {
	  var ws = this._writableState;
	
	  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
	    callback = kind;
	    kind = binding.Z_FULL_FLUSH;
	  }
	
	  if (ws.ended) {
	    if (callback)
	      process.nextTick(callback);
	  } else if (ws.ending) {
	    if (callback)
	      this.once('end', callback);
	  } else if (ws.needDrain) {
	    var self = this;
	    this.once('drain', function() {
	      self.flush(callback);
	    });
	  } else {
	    this._flushFlag = kind;
	    this.write(new Buffer(0), '', callback);
	  }
	};
	
	Zlib.prototype.close = function(callback) {
	  if (callback)
	    process.nextTick(callback);
	
	  if (this._closed)
	    return;
	
	  this._closed = true;
	
	  this._binding.close();
	
	  var self = this;
	  process.nextTick(function() {
	    self.emit('close');
	  });
	};
	
	Zlib.prototype._transform = function(chunk, encoding, cb) {
	  var flushFlag;
	  var ws = this._writableState;
	  var ending = ws.ending || ws.ended;
	  var last = ending && (!chunk || ws.length === chunk.length);
	
	  if (!chunk === null && !Buffer.isBuffer(chunk))
	    return cb(new Error('invalid input'));
	
	  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
	  // If it's explicitly flushing at some other time, then we use
	  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
	  // goodness.
	  if (last)
	    flushFlag = binding.Z_FINISH;
	  else {
	    flushFlag = this._flushFlag;
	    // once we've flushed the last of the queue, stop flushing and
	    // go back to the normal behavior.
	    if (chunk.length >= ws.length) {
	      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
	    }
	  }
	
	  var self = this;
	  this._processChunk(chunk, flushFlag, cb);
	};
	
	Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
	  var availInBefore = chunk && chunk.length;
	  var availOutBefore = this._chunkSize - this._offset;
	  var inOff = 0;
	
	  var self = this;
	
	  var async = typeof cb === 'function';
	
	  if (!async) {
	    var buffers = [];
	    var nread = 0;
	
	    var error;
	    this.on('error', function(er) {
	      error = er;
	    });
	
	    do {
	      var res = this._binding.writeSync(flushFlag,
	                                        chunk, // in
	                                        inOff, // in_off
	                                        availInBefore, // in_len
	                                        this._buffer, // out
	                                        this._offset, //out_off
	                                        availOutBefore); // out_len
	    } while (!this._hadError && callback(res[0], res[1]));
	
	    if (this._hadError) {
	      throw error;
	    }
	
	    var buf = Buffer.concat(buffers, nread);
	    this.close();
	
	    return buf;
	  }
	
	  var req = this._binding.write(flushFlag,
	                                chunk, // in
	                                inOff, // in_off
	                                availInBefore, // in_len
	                                this._buffer, // out
	                                this._offset, //out_off
	                                availOutBefore); // out_len
	
	  req.buffer = chunk;
	  req.callback = callback;
	
	  function callback(availInAfter, availOutAfter) {
	    if (self._hadError)
	      return;
	
	    var have = availOutBefore - availOutAfter;
	    assert(have >= 0, 'have should not go down');
	
	    if (have > 0) {
	      var out = self._buffer.slice(self._offset, self._offset + have);
	      self._offset += have;
	      // serve some output to the consumer.
	      if (async) {
	        self.push(out);
	      } else {
	        buffers.push(out);
	        nread += out.length;
	      }
	    }
	
	    // exhausted the output buffer, or used all the input create a new one.
	    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
	      availOutBefore = self._chunkSize;
	      self._offset = 0;
	      self._buffer = new Buffer(self._chunkSize);
	    }
	
	    if (availOutAfter === 0) {
	      // Not actually done.  Need to reprocess.
	      // Also, update the availInBefore to the availInAfter value,
	      // so that if we have to hit it a third (fourth, etc.) time,
	      // it'll have the correct byte counts.
	      inOff += (availInBefore - availInAfter);
	      availInBefore = availInAfter;
	
	      if (!async)
	        return true;
	
	      var newReq = self._binding.write(flushFlag,
	                                       chunk,
	                                       inOff,
	                                       availInBefore,
	                                       self._buffer,
	                                       self._offset,
	                                       self._chunkSize);
	      newReq.callback = callback; // this same function
	      newReq.buffer = chunk;
	      return;
	    }
	
	    if (!async)
	      return false;
	
	    // finished with the chunk.
	    cb();
	  }
	};
	
	util.inherits(Deflate, Zlib);
	util.inherits(Inflate, Zlib);
	util.inherits(Gzip, Zlib);
	util.inherits(Gunzip, Zlib);
	util.inherits(DeflateRaw, Zlib);
	util.inherits(InflateRaw, Zlib);
	util.inherits(Unzip, Zlib);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer, __webpack_require__(11)))

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {var msg = __webpack_require__(140);
	var zstream = __webpack_require__(141);
	var zlib_deflate = __webpack_require__(142);
	var zlib_inflate = __webpack_require__(147);
	var constants = __webpack_require__(150);
	
	for (var key in constants) {
	  exports[key] = constants[key];
	}
	
	// zlib modes
	exports.NONE = 0;
	exports.DEFLATE = 1;
	exports.INFLATE = 2;
	exports.GZIP = 3;
	exports.GUNZIP = 4;
	exports.DEFLATERAW = 5;
	exports.INFLATERAW = 6;
	exports.UNZIP = 7;
	
	/**
	 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
	 */
	function Zlib(mode) {
	  if (mode < exports.DEFLATE || mode > exports.UNZIP)
	    throw new TypeError("Bad argument");
	    
	  this.mode = mode;
	  this.init_done = false;
	  this.write_in_progress = false;
	  this.pending_close = false;
	  this.windowBits = 0;
	  this.level = 0;
	  this.memLevel = 0;
	  this.strategy = 0;
	  this.dictionary = null;
	}
	
	Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
	  this.windowBits = windowBits;
	  this.level = level;
	  this.memLevel = memLevel;
	  this.strategy = strategy;
	  // dictionary not supported.
	  
	  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
	    this.windowBits += 16;
	    
	  if (this.mode === exports.UNZIP)
	    this.windowBits += 32;
	    
	  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
	    this.windowBits = -this.windowBits;
	    
	  this.strm = new zstream();
	  
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateInit2(
	        this.strm,
	        this.level,
	        exports.Z_DEFLATED,
	        this.windowBits,
	        this.memLevel,
	        this.strategy
	      );
	      break;
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	    case exports.UNZIP:
	      var status  = zlib_inflate.inflateInit2(
	        this.strm,
	        this.windowBits
	      );
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }
	  
	  if (status !== exports.Z_OK) {
	    this._error(status);
	    return;
	  }
	  
	  this.write_in_progress = false;
	  this.init_done = true;
	};
	
	Zlib.prototype.params = function() {
	  throw new Error("deflateParams Not supported");
	};
	
	Zlib.prototype._writeCheck = function() {
	  if (!this.init_done)
	    throw new Error("write before init");
	    
	  if (this.mode === exports.NONE)
	    throw new Error("already finalized");
	    
	  if (this.write_in_progress)
	    throw new Error("write already in progress");
	    
	  if (this.pending_close)
	    throw new Error("close is pending");
	};
	
	Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
	  this._writeCheck();
	  this.write_in_progress = true;
	  
	  var self = this;
	  process.nextTick(function() {
	    self.write_in_progress = false;
	    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
	    self.callback(res[0], res[1]);
	    
	    if (self.pending_close)
	      self.close();
	  });
	  
	  return this;
	};
	
	// set method for Node buffers, used by pako
	function bufferSet(data, offset) {
	  for (var i = 0; i < data.length; i++) {
	    this[offset + i] = data[i];
	  }
	}
	
	Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
	  this._writeCheck();
	  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
	};
	
	Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
	  this.write_in_progress = true;
	  
	  if (flush !== exports.Z_NO_FLUSH &&
	      flush !== exports.Z_PARTIAL_FLUSH &&
	      flush !== exports.Z_SYNC_FLUSH &&
	      flush !== exports.Z_FULL_FLUSH &&
	      flush !== exports.Z_FINISH &&
	      flush !== exports.Z_BLOCK) {
	    throw new Error("Invalid flush value");
	  }
	  
	  if (input == null) {
	    input = new Buffer(0);
	    in_len = 0;
	    in_off = 0;
	  }
	  
	  if (out._set)
	    out.set = out._set;
	  else
	    out.set = bufferSet;
	  
	  var strm = this.strm;
	  strm.avail_in = in_len;
	  strm.input = input;
	  strm.next_in = in_off;
	  strm.avail_out = out_len;
	  strm.output = out;
	  strm.next_out = out_off;
	  
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflate(strm, flush);
	      break;
	    case exports.UNZIP:
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflate(strm, flush);
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }
	  
	  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
	    this._error(status);
	  }
	  
	  this.write_in_progress = false;
	  return [strm.avail_in, strm.avail_out];
	};
	
	Zlib.prototype.close = function() {
	  if (this.write_in_progress) {
	    this.pending_close = true;
	    return;
	  }
	  
	  this.pending_close = false;
	  
	  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
	    zlib_deflate.deflateEnd(this.strm);
	  } else {
	    zlib_inflate.inflateEnd(this.strm);
	  }
	  
	  this.mode = exports.NONE;
	};
	
	Zlib.prototype.reset = function() {
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateReset(this.strm);
	      break;
	    case exports.INFLATE:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflateReset(this.strm);
	      break;
	  }
	  
	  if (status !== exports.Z_OK) {
	    this._error(status);
	  }
	};
	
	Zlib.prototype._error = function(status) {
	  this.onerror(msg[status] + ': ' + this.strm.msg, status);
	  
	  this.write_in_progress = false;
	  if (this.pending_close)
	    this.close();
	};
	
	exports.Zlib = Zlib;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), __webpack_require__(22).Buffer))

/***/ },
/* 140 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  2:      'need dictionary',     /* Z_NEED_DICT       2  */
	  1:      'stream end',          /* Z_STREAM_END      1  */
	  0:      '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};


/***/ },
/* 141 */
/***/ function(module, exports) {

	'use strict';
	
	
	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}
	
	module.exports = ZStream;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils   = __webpack_require__(143);
	var trees   = __webpack_require__(144);
	var adler32 = __webpack_require__(145);
	var crc32   = __webpack_require__(146);
	var msg     = __webpack_require__(140);
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH      = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	//var Z_TREES         = 6;
	
	
	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;
	
	
	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;
	
	
	var Z_FILTERED            = 1;
	var Z_HUFFMAN_ONLY        = 2;
	var Z_RLE                 = 3;
	var Z_FIXED               = 4;
	var Z_DEFAULT_STRATEGY    = 0;
	
	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;
	
	
	/* The deflate compression method */
	var Z_DEFLATED  = 8;
	
	/*============================================================================*/
	
	
	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;
	
	
	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES       = 30;
	/* number of distance codes */
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS  = 15;
	/* All codes must not exceed MAX_BITS bits */
	
	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
	
	var PRESET_DICT = 0x20;
	
	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;
	
	var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE     = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */
	
	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.
	
	function err(strm, errorCode) {
	  strm.msg = msg[errorCode];
	  return errorCode;
	}
	
	function rank(f) {
	  return ((f) << 1) - ((f) > 4 ? 9 : 0);
	}
	
	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
	
	
	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;
	
	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) { return; }
	
	  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}
	
	
	function flush_block_only(s, last) {
	  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}
	
	
	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}
	
	
	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	//  put_byte(s, (Byte)(b >> 8));
	//  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}
	
	
	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;
	
	  if (len > size) { len = size; }
	  if (len === 0) { return 0; }
	
	  strm.avail_in -= len;
	
	  // zmemcpy(buf, strm->next_in, len);
	  utils.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32(strm.adler, buf, len, start);
	  }
	
	  else if (strm.state.wrap === 2) {
	    strm.adler = crc32(strm.adler, buf, len, start);
	  }
	
	  strm.next_in += len;
	  strm.total_in += len;
	
	  return len;
	}
	
	
	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length;      /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match;                       /* matched string */
	  var len;                           /* length of current match */
	  var best_len = s.prev_length;              /* best match length so far */
	  var nice_match = s.nice_match;             /* stop if match long enough */
	  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
	      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;
	
	  var _win = s.window; // shortcut
	
	  var wmask = s.w_mask;
	  var prev  = s.prev;
	
	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */
	
	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1  = _win[scan + best_len - 1];
	  var scan_end   = _win[scan + best_len];
	
	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
	
	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) { nice_match = s.lookahead; }
	
	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
	
	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;
	
	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */
	
	    if (_win[match + best_len]     !== scan_end  ||
	        _win[match + best_len - 1] !== scan_end1 ||
	        _win[match]                !== _win[scan] ||
	        _win[++match]              !== _win[scan + 1]) {
	      continue;
	    }
	
	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");
	
	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             scan < strend);
	
	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
	
	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;
	
	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1  = _win[scan + best_len - 1];
	      scan_end   = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
	
	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}
	
	
	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;
	
	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
	
	  do {
	    more = s.window_size - s.lookahead - s.strstart;
	
	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}
	
	
	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
	
	      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;
	
	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */
	
	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = (m >= _w_size ? m - _w_size : 0);
	      } while (--n);
	
	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);
	
	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }
	
	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;
	
	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];
	
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
	//#if MIN_MATCH != 3
	//        Call update_hash() MIN_MATCH-3 more times
	//#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
	
	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */
	
	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
	
	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	//  if (s.high_water < s.window_size) {
	//    var curr = s.strstart + s.lookahead;
	//    var init = 0;
	//
	//    if (s.high_water < curr) {
	//      /* Previous high water mark below current data -- zero WIN_INIT
	//       * bytes or up to end of window, whichever is less.
	//       */
	//      init = s.window_size - curr;
	//      if (init > WIN_INIT)
	//        init = WIN_INIT;
	//      zmemzero(s->window + curr, (unsigned)init);
	//      s->high_water = curr + init;
	//    }
	//    else if (s->high_water < (ulg)curr + WIN_INIT) {
	//      /* High water mark at or above current data, but below current data
	//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	//       * to end of window, whichever is less.
	//       */
	//      init = (ulg)curr + WIN_INIT - s->high_water;
	//      if (init > s->window_size - s->high_water)
	//        init = s->window_size - s->high_water;
	//      zmemzero(s->window + s->high_water, (unsigned)init);
	//      s->high_water += init;
	//    }
	//  }
	//
	//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	//    "not enough room for search");
	}
	
	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;
	
	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }
	
	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {
	
	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	//        s.block_start >= s.w_size)) {
	//        throw  new Error("slide too late");
	//      }
	
	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	
	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	//    if (s.block_start < 0) throw new Error("block gone");
	
	    s.strstart += s.lookahead;
	    s.lookahead = 0;
	
	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;
	
	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	
	
	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	
	  s.insert = 0;
	
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	
	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	
	  return BS_NEED_MORE;
	}
	
	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head;        /* head of the hash chain */
	  var bflush;           /* set if current block must be flushed */
	
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }
	
	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }
	
	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
	
	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
	
	      s.lookahead -= s.match_length;
	
	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else
	      {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
	
	//#if MIN_MATCH != 3
	//                Call UPDATE_HASH() MIN_MATCH-3 more times
	//#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	
	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head;          /* head of hash chain */
	  var bflush;              /* set if current block must be flushed */
	
	  var max_insert;
	
	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }
	
	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }
	
	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH - 1;
	
	    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
	        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	
	      if (s.match_length <= 5 &&
	         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {
	
	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH - 1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */
	
	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);
	
	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length - 1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH - 1;
	      s.strstart++;
	
	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }
	
	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
	
	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
	
	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	
	  return BS_BLOCK_DONE;
	}
	
	
	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush;            /* set if current block must be flushed */
	  var prev;              /* byte at distance one to match */
	  var scan, strend;      /* scan goes up to strend for length of run */
	
	  var _win = s.window;
	
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }
	
	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }
	
	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);
	
	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
	
	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	
	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush;             /* set if current block must be flushed */
	
	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break;      /* flush the current block */
	      }
	    }
	
	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}
	
	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	}
	
	var configuration_table;
	
	configuration_table = [
	  /*      good lazy nice chain */
	  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
	  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
	  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
	  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */
	
	  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
	  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
	  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
	  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
	  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
	  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
	];
	
	
	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;
	
	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);
	
	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;
	
	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}
	
	
	function DeflateState() {
	  this.strm = null;            /* pointer back to this zlib stream */
	  this.status = 0;            /* as the name implies */
	  this.pending_buf = null;      /* output still pending */
	  this.pending_buf_size = 0;  /* size of pending_buf */
	  this.pending_out = 0;       /* next pending byte to output to the stream */
	  this.pending = 0;           /* nb of bytes in the pending buffer */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null;         /* gzip header information to write */
	  this.gzindex = 0;           /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1;   /* value of flush param for previous deflate call */
	
	  this.w_size = 0;  /* LZ77 window size (32K by default) */
	  this.w_bits = 0;  /* log2(w_size)  (8..16) */
	  this.w_mask = 0;  /* w_size - 1 */
	
	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */
	
	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */
	
	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */
	
	  this.head = null;   /* Heads of the hash chains or NIL. */
	
	  this.ins_h = 0;       /* hash index of string to be inserted */
	  this.hash_size = 0;   /* number of elements in hash table */
	  this.hash_bits = 0;   /* log2(hash_size) */
	  this.hash_mask = 0;   /* hash_size-1 */
	
	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */
	
	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */
	
	  this.match_length = 0;      /* length of best match */
	  this.prev_match = 0;        /* previous match */
	  this.match_available = 0;   /* set if previous match exists */
	  this.strstart = 0;          /* start of string to insert */
	  this.match_start = 0;       /* start of matching string */
	  this.lookahead = 0;         /* number of valid bytes ahead in window */
	
	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */
	
	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */
	
	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */
	
	  this.level = 0;     /* compression level (1..9) */
	  this.strategy = 0;  /* favor or force Huffman coding*/
	
	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */
	
	  this.nice_match = 0; /* Stop searching when current match exceeds this */
	
	              /* used by trees.c: */
	
	  /* Didn't use ct_data typedef below to suppress compiler warning */
	
	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
	
	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
	  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);
	
	  this.l_desc   = null;         /* desc. for literal tree */
	  this.d_desc   = null;         /* desc. for distance tree */
	  this.bl_desc  = null;         /* desc. for bit length tree */
	
	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils.Buf16(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */
	
	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
	  zero(this.heap);
	
	  this.heap_len = 0;               /* number of elements in the heap */
	  this.heap_max = 0;               /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */
	
	  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */
	
	  this.l_buf = 0;          /* buffer index for literals or lengths */
	
	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */
	
	  this.last_lit = 0;      /* running index in l_buf */
	
	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */
	
	  this.opt_len = 0;       /* bit length of current block with optimal trees */
	  this.static_len = 0;    /* bit length of current block with static trees */
	  this.matches = 0;       /* number of string matches in current block */
	  this.insert = 0;        /* bytes at end of window left to insert */
	
	
	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */
	
	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}
	
	
	function deflateResetKeep(strm) {
	  var s;
	
	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;
	
	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;
	
	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
	  strm.adler = (s.wrap === 2) ?
	    0  // crc32(0, Z_NULL, 0)
	  :
	    1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}
	
	
	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}
	
	
	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
	  strm.state.gzhead = head;
	  return Z_OK;
	}
	
	
	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) { // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;
	
	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }
	
	  if (windowBits < 0) { /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	
	  else if (windowBits > 15) {
	    wrap = 2;           /* write gzip wrapper instead */
	    windowBits -= 16;
	  }
	
	
	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
	    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	
	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */
	
	  var s = new DeflateState();
	
	  strm.state = s;
	  s.strm = strm;
	
	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;
	
	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
	
	  s.window = new utils.Buf8(s.w_size * 2);
	  s.head = new utils.Buf16(s.hash_size);
	  s.prev = new utils.Buf16(s.w_size);
	
	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */
	
	  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
	
	  s.pending_buf_size = s.lit_bufsize * 4;
	
	  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
	  //s->pending_buf = (uchf *) overlay;
	  s.pending_buf = new utils.Buf8(s.pending_buf_size);
	
	  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
	  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
	  s.d_buf = 1 * s.lit_bufsize;
	
	  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
	  s.l_buf = (1 + 2) * s.lit_bufsize;
	
	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;
	
	  return deflateReset(strm);
	}
	
	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}
	
	
	function deflate(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only
	
	  if (!strm || !strm.state ||
	    flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }
	
	  s = strm.state;
	
	  if (!strm.output ||
	      (!strm.input && strm.avail_in !== 0) ||
	      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
	    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }
	
	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;
	
	  /* Write the header */
	  if (s.status === INIT_STATE) {
	
	    if (s.wrap === 2) { // GZIP header
	      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) { // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      }
	      else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) +
	                    (s.gzhead.hcrc ? 2 : 0) +
	                    (!s.gzhead.extra ? 0 : 4) +
	                    (!s.gzhead.name ? 0 : 8) +
	                    (!s.gzhead.comment ? 0 : 16)
	                );
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, (s.gzhead.time >> 8) & 0xff);
	        put_byte(s, (s.gzhead.time >> 16) & 0xff);
	        put_byte(s, (s.gzhead.time >> 24) & 0xff);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    }
	    else // DEFLATE header
	    {
	      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
	      var level_flags = -1;
	
	      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	        level_flags = 0;
	      } else if (s.level < 6) {
	        level_flags = 1;
	      } else if (s.level === 6) {
	        level_flags = 2;
	      } else {
	        level_flags = 3;
	      }
	      header |= (level_flags << 6);
	      if (s.strstart !== 0) { header |= PRESET_DICT; }
	      header += 31 - (header % 31);
	
	      s.status = BUSY_STATE;
	      putShortMSB(s, header);
	
	      /* Save the adler32 of the preset dictionary: */
	      if (s.strstart !== 0) {
	        putShortMSB(s, strm.adler >>> 16);
	        putShortMSB(s, strm.adler & 0xffff);
	      }
	      strm.adler = 1; // adler32(0L, Z_NULL, 0);
	    }
	  }
	
	//#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	
	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    }
	    else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;
	
	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);
	
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    }
	    else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;
	
	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);
	
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    }
	    else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, (strm.adler >> 8) & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    }
	    else {
	      s.status = BUSY_STATE;
	    }
	  }
	//#endif
	
	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }
	
	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
	    flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }
	
	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }
	
	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
	    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
	    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
	      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
	        configuration_table[s.level].func(s, flush));
	
	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      }
	      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
	
	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/             /* forget history */
	          zero(s.head); // Fill with NIL (= 0);
	
	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}
	
	  if (flush !== Z_FINISH) { return Z_OK; }
	  if (s.wrap <= 0) { return Z_STREAM_END; }
	
	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, (strm.adler >> 8) & 0xff);
	    put_byte(s, (strm.adler >> 16) & 0xff);
	    put_byte(s, (strm.adler >> 24) & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, (strm.total_in >> 8) & 0xff);
	    put_byte(s, (strm.total_in >> 16) & 0xff);
	    put_byte(s, (strm.total_in >> 24) & 0xff);
	  }
	  else
	  {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }
	
	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) { s.wrap = -s.wrap; }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}
	
	function deflateEnd(strm) {
	  var status;
	
	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }
	
	  status = strm.state.status;
	  if (status !== INIT_STATE &&
	    status !== EXTRA_STATE &&
	    status !== NAME_STATE &&
	    status !== COMMENT_STATE &&
	    status !== HCRC_STATE &&
	    status !== BUSY_STATE &&
	    status !== FINISH_STATE
	  ) {
	    return err(strm, Z_STREAM_ERROR);
	  }
	
	  strm.state = null;
	
	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}
	
	
	/* =========================================================================
	 * Initializes the compression dictionary from the given byte
	 * sequence without producing any compressed output.
	 */
	function deflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;
	
	  var s;
	  var str, n;
	  var wrap;
	  var avail;
	  var next;
	  var input;
	  var tmpDict;
	
	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }
	
	  s = strm.state;
	  wrap = s.wrap;
	
	  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
	    return Z_STREAM_ERROR;
	  }
	
	  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
	  if (wrap === 1) {
	    /* adler32(strm->adler, dictionary, dictLength); */
	    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
	  }
	
	  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */
	
	  /* if dictionary would fill window, just replace the history */
	  if (dictLength >= s.w_size) {
	    if (wrap === 0) {            /* already empty otherwise */
	      /*** CLEAR_HASH(s); ***/
	      zero(s.head); // Fill with NIL (= 0);
	      s.strstart = 0;
	      s.block_start = 0;
	      s.insert = 0;
	    }
	    /* use the tail */
	    // dictionary = dictionary.slice(dictLength - s.w_size);
	    tmpDict = new utils.Buf8(s.w_size);
	    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
	    dictionary = tmpDict;
	    dictLength = s.w_size;
	  }
	  /* insert dictionary into window and hash */
	  avail = strm.avail_in;
	  next = strm.next_in;
	  input = strm.input;
	  strm.avail_in = dictLength;
	  strm.next_in = 0;
	  strm.input = dictionary;
	  fill_window(s);
	  while (s.lookahead >= MIN_MATCH) {
	    str = s.strstart;
	    n = s.lookahead - (MIN_MATCH - 1);
	    do {
	      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
	
	      s.prev[str & s.w_mask] = s.head[s.ins_h];
	
	      s.head[s.ins_h] = str;
	      str++;
	    } while (--n);
	    s.strstart = str;
	    s.lookahead = MIN_MATCH - 1;
	    fill_window(s);
	  }
	  s.strstart += s.lookahead;
	  s.block_start = s.strstart;
	  s.insert = s.lookahead;
	  s.lookahead = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  strm.next_in = next;
	  strm.input = input;
	  strm.avail_in = avail;
	  s.wrap = wrap;
	  return Z_OK;
	}
	
	
	exports.deflateInit = deflateInit;
	exports.deflateInit2 = deflateInit2;
	exports.deflateReset = deflateReset;
	exports.deflateResetKeep = deflateResetKeep;
	exports.deflateSetHeader = deflateSetHeader;
	exports.deflate = deflate;
	exports.deflateEnd = deflateEnd;
	exports.deflateSetDictionary = deflateSetDictionary;
	exports.deflateInfo = 'pako deflate (from Nodeca project)';
	
	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	
	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');
	
	
	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }
	
	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }
	
	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }
	
	  return obj;
	};
	
	
	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};
	
	
	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    var i, l, len, pos, chunk, result;
	
	    // calculate data length
	    len = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      len += chunks[i].length;
	    }
	
	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }
	
	    return result;
	  }
	};
	
	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    return [].concat.apply([], chunks);
	  }
	};
	
	
	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};
	
	exports.setTyped(TYPED_OK);


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils = __webpack_require__(143);
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED               = 4;
	//var Z_DEFAULT_STRATEGY  = 0;
	
	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY              = 0;
	var Z_TEXT                = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;
	
	/*============================================================================*/
	
	
	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }
	
	// From zutil.h
	
	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES    = 2;
	/* The three kinds of block type */
	
	var MIN_MATCH    = 3;
	var MAX_MATCH    = 258;
	/* The minimum and maximum match lengths */
	
	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */
	
	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	
	var D_CODES       = 30;
	/* number of distance codes */
	
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	
	var HEAP_SIZE     = 2 * L_CODES + 1;
	/* maximum heap size */
	
	var MAX_BITS      = 15;
	/* All codes must not exceed MAX_BITS bits */
	
	var Buf_size      = 16;
	/* size of bit buffer in bi_buf */
	
	
	/* ===========================================================================
	 * Constants
	 */
	
	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */
	
	var END_BLOCK   = 256;
	/* end of block literal code */
	
	var REP_3_6     = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */
	
	var REPZ_3_10   = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */
	
	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */
	
	/* eslint-disable comma-spacing,array-bracket-spacing */
	var extra_lbits =   /* extra bits for each length code */
	  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
	
	var extra_dbits =   /* extra bits for each distance code */
	  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];
	
	var extra_blbits =  /* extra bits for each bit length code */
	  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];
	
	var bl_order =
	  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
	/* eslint-enable comma-spacing,array-bracket-spacing */
	
	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */
	
	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */
	
	// We pre-fill arrays with 0 to avoid uninitialized gaps
	
	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */
	
	// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
	var static_ltree  = new Array((L_CODES + 2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */
	
	var static_dtree  = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */
	
	var _dist_code    = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */
	
	var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */
	
	var base_length   = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */
	
	var base_dist     = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */
	
	
	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
	
	  this.static_tree  = static_tree;  /* static tree or NULL */
	  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
	  this.extra_base   = extra_base;   /* base index for extra_bits */
	  this.elems        = elems;        /* max number of elements in the tree */
	  this.max_length   = max_length;   /* max bit length for the codes */
	
	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree    = static_tree && static_tree.length;
	}
	
	
	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;
	
	
	function TreeDesc(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree;     /* the dynamic tree */
	  this.max_code = 0;            /* largest code with non zero frequency */
	  this.stat_desc = stat_desc;   /* the corresponding static tree */
	}
	
	
	
	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}
	
	
	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short(s, w) {
	//    put_byte(s, (uch)((w) & 0xff));
	//    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = (w) & 0xff;
	  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
	}
	
	
	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > (Buf_size - length)) {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> (Buf_size - s.bi_valid);
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    s.bi_valid += length;
	  }
	}
	
	
	function send_code(s, c, tree) {
	  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
	}
	
	
	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}
	
	
	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;
	
	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}
	
	
	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree            = desc.dyn_tree;
	  var max_code        = desc.max_code;
	  var stree           = desc.stat_desc.static_tree;
	  var has_stree       = desc.stat_desc.has_stree;
	  var extra           = desc.stat_desc.extra_bits;
	  var base            = desc.stat_desc.extra_base;
	  var max_length      = desc.stat_desc.max_length;
	  var h;              /* heap index */
	  var n, m;           /* iterate over the tree elements */
	  var bits;           /* bit length */
	  var xbits;          /* extra bits */
	  var f;              /* frequency */
	  var overflow = 0;   /* number of elements with bit length too large */
	
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }
	
	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */
	
	  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n * 2 + 1]/*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */
	
	    if (n > max_code) { continue; } /* not a leaf node */
	
	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n - base];
	    }
	    f = tree[n * 2]/*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) { return; }
	
	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */
	
	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length - 1;
	    while (s.bl_count[bits] === 0) { bits--; }
	    s.bl_count[bits]--;      /* move one leaf down the tree */
	    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);
	
	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) { continue; }
	      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
	        tree[m * 2 + 1]/*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
	  var code = 0;              /* running code value */
	  var bits;                  /* bit index */
	  var n;                     /* code index */
	
	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
	
	  for (n = 0;  n <= max_code; n++) {
	    var len = tree[n * 2 + 1]/*.Len*/;
	    if (len === 0) { continue; }
	    /* Now reverse the bits */
	    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);
	
	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}
	
	
	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n;        /* iterates over tree elements */
	  var bits;     /* bit counter */
	  var length;   /* length value */
	  var code;     /* code value */
	  var dist;     /* distance index */
	  var bl_count = new Array(MAX_BITS + 1);
	  /* number of codes at each bit length for an optimal tree */
	
	  // do check in _tr_init()
	  //if (static_init_done) return;
	
	  /* For some embedded targets, global variables are not initialized: */
	/*#ifdef NO_INIT_GLOBAL_POINTERS
	  static_l_desc.static_tree = static_ltree;
	  static_l_desc.extra_bits = extra_lbits;
	  static_d_desc.static_tree = static_dtree;
	  static_d_desc.extra_bits = extra_dbits;
	  static_bl_desc.extra_bits = extra_blbits;
	#endif*/
	
	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES - 1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < (1 << extra_lbits[code]); n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length - 1] = code;
	
	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < (1 << extra_dbits[code]); n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");
	
	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }
	
	  n = 0;
	  while (n <= 143) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n * 2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES + 1, bl_count);
	
	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n * 2 + 1]/*.Len*/ = 5;
	    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
	  }
	
	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
	  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);
	
	  //static_init_done = true;
	}
	
	
	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */
	
	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
	  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }
	
	  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}
	
	
	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s)
	{
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}
	
	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s);        /* align on byte boundary */
	
	  if (header) {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	//  while (len--) {
	//    put_byte(s, *buf++);
	//  }
	  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}
	
	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n * 2;
	  var _m2 = m * 2;
	  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
	         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
	}
	
	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1;  /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len &&
	      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) { break; }
	
	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;
	
	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}
	
	
	// inlined manually
	// var SMALLEST = 1;
	
	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist;           /* distance of matched string */
	  var lc;             /* match length or unmatched char (if dist == 0) */
	  var lx = 0;         /* running index in l_buf */
	  var code;           /* the code to send */
	  var extra;          /* number of extra bits to send */
	
	  if (s.last_lit !== 0) {
	    do {
	      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;
	
	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra);       /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");
	
	        send_code(s, code, dtree);       /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra);   /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */
	
	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");
	
	    } while (lx < s.last_lit);
	  }
	
	  send_code(s, END_BLOCK, ltree);
	}
	
	
	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree     = desc.dyn_tree;
	  var stree    = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems    = desc.stat_desc.elems;
	  var n, m;          /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node;          /* new node being created */
	
	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;
	
	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2]/*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;
	
	    } else {
	      tree[n * 2 + 1]/*.Len*/ = 0;
	    }
	  }
	
	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
	    tree[node * 2]/*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;
	
	    if (has_stree) {
	      s.static_len -= stree[node * 2 + 1]/*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;
	
	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }
	
	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems;              /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1/*SMALLEST*/];
	    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	    /***/
	
	    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */
	
	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;
	
	    /* Create a new node father of n and m */
	    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;
	
	    /* and insert the new node in the heap */
	    s.heap[1/*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	
	  } while (s.heap_len >= 2);
	
	  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];
	
	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);
	
	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}
	
	
	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */
	
	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
	
	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */
	
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */
	
	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
	
	    if (++count < max_count && curlen === nextlen) {
	      continue;
	
	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2]/*.Freq*/ += count;
	
	    } else if (curlen !== 0) {
	
	      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
	      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;
	
	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;
	
	    } else {
	      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
	    }
	
	    count = 0;
	    prevlen = curlen;
	
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */
	
	  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
	
	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */
	
	  /* tree[max_code+1].Len = -1; */  /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	
	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
	
	    if (++count < max_count && curlen === nextlen) {
	      continue;
	
	    } else if (count < min_count) {
	      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);
	
	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count - 3, 2);
	
	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count - 3, 3);
	
	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count - 11, 7);
	    }
	
	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;
	
	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;
	
	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}
	
	
	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex;  /* index of last bit length code of non zero freq */
	
	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
	
	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */
	
	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));
	
	  return max_blindex;
	}
	
	
	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank;                    /* index in bl_order */
	
	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes - 1,   5);
	  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
	
	  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
	
	  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}
	
	
	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;
	
	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
	      return Z_BINARY;
	    }
	  }
	
	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
	      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }
	
	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}
	
	
	var static_init_done = false;
	
	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s)
	{
	
	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }
	
	  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
	
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	
	  /* Initialize the first block of the first file: */
	  init_block(s);
	}
	
	
	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
	  copy_block(s, buf, stored_len, true); /* with header */
	}
	
	
	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES << 1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}
	
	
	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
	  var max_blindex = 0;        /* index of last bit length code of non zero freq */
	
	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {
	
	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }
	
	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	
	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */
	
	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);
	
	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
	    static_lenb = (s.static_len + 3 + 7) >>> 3;
	
	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));
	
	    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }
	
	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }
	
	  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
	    /* 4: two words for the lengths */
	
	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);
	
	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
	
	    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);
	
	  } else {
	    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);
	
	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}
	
	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;
	
	  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
	
	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;
	
	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc * 2]/*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--;             /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
	
	    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
	  }
	
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	
	//#ifdef TRUNCATE_BLOCK
	//  /* Try to guess if it is profitable to stop the current block here */
	//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	//    /* Compute an upper bound for the compressed length */
	//    out_length = s.last_lit*8;
	//    in_length = s.strstart - s.block_start;
	//
	//    for (dcode = 0; dcode < D_CODES; dcode++) {
	//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	//    }
	//    out_length >>>= 3;
	//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	//    //       s->last_lit, in_length, out_length,
	//    //       100L - out_length*100L/in_length));
	//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	//      return true;
	//    }
	//  }
	//#endif
	
	  return (s.last_lit === s.lit_bufsize - 1);
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}
	
	exports._tr_init  = _tr_init;
	exports._tr_stored_block = _tr_stored_block;
	exports._tr_flush_block  = _tr_flush_block;
	exports._tr_tally = _tr_tally;
	exports._tr_align = _tr_align;


/***/ },
/* 145 */
/***/ function(module, exports) {

	'use strict';
	
	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.
	
	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;
	
	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;
	
	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);
	
	    s1 %= 65521;
	    s2 %= 65521;
	  }
	
	  return (s1 | (s2 << 16)) |0;
	}
	
	
	module.exports = adler32;


/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';
	
	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.
	
	
	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];
	
	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }
	
	  return table;
	}
	
	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();
	
	
	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;
	
	  crc ^= -1;
	
	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }
	
	  return (crc ^ (-1)); // >>> 0;
	}
	
	
	module.exports = crc32;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils         = __webpack_require__(143);
	var adler32       = __webpack_require__(145);
	var crc32         = __webpack_require__(146);
	var inflate_fast  = __webpack_require__(148);
	var inflate_table = __webpack_require__(149);
	
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;
	
	/* Public constants ==========================================================*/
	/* ===========================================================================*/
	
	
	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;
	
	
	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;
	
	/* The deflate compression method */
	var Z_DEFLATED  = 8;
	
	
	/* STATES ====================================================================*/
	/* ===========================================================================*/
	
	
	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */
	
	/* ===========================================================================*/
	
	
	
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);
	
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;
	
	
	function zswap32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}
	
	
	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */
	
	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */
	
	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */
	
	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */
	
	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */
	
	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */
	
	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */
	
	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */
	
	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}
	
	function inflateResetKeep(strm) {
	  var state;
	
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
	
	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}
	
	function inflateReset(strm) {
	  var state;
	
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);
	
	}
	
	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;
	
	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	
	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }
	
	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }
	
	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}
	
	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;
	
	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */
	
	  state = new InflateState();
	
	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}
	
	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}
	
	
	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;
	
	var lenfix, distfix; // We have no pointers in JS, so keep tables separate
	
	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;
	
	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);
	
	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }
	
	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });
	
	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }
	
	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });
	
	    /* do this just once */
	    virgin = false;
	  }
	
	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}
	
	
	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.
	
	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;
	
	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;
	
	    state.window = new utils.Buf8(state.wsize);
	  }
	
	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}
	
	function inflate(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;
	
	  var n; // temporary var for NEED_BITS
	
	  var order = /* permutation of code lengths */
	    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
	
	
	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }
	
	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */
	
	
	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---
	
	  _in = have;
	  _out = left;
	  ret = Z_OK;
	
	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	    case HEAD:
	      if (state.wrap === 0) {
	        state.mode = TYPEDO;
	        break;
	      }
	      //=== NEEDBITS(16);
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = FLAGS;
	        break;
	      }
	      state.flags = 0;           /* expect zlib header */
	      if (state.head) {
	        state.head.done = false;
	      }
	      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	        strm.msg = 'incorrect header check';
	        state.mode = BAD;
	        break;
	      }
	      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	      len = (hold & 0x0f)/*BITS(4)*/ + 8;
	      if (state.wbits === 0) {
	        state.wbits = len;
	      }
	      else if (len > state.wbits) {
	        strm.msg = 'invalid window size';
	        state.mode = BAD;
	        break;
	      }
	      state.dmax = 1 << len;
	      //Tracev((stderr, "inflate:   zlib header ok\n"));
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = hold & 0x200 ? DICTID : TYPE;
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      break;
	    case FLAGS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.flags = hold;
	      if ((state.flags & 0xff) !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      if (state.flags & 0xe000) {
	        strm.msg = 'unknown header flags set';
	        state.mode = BAD;
	        break;
	      }
	      if (state.head) {
	        state.head.text = ((hold >> 8) & 1);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = TIME;
	      /* falls through */
	    case TIME:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.time = hold;
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC4(state.check, hold)
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        hbuf[2] = (hold >>> 16) & 0xff;
	        hbuf[3] = (hold >>> 24) & 0xff;
	        state.check = crc32(state.check, hbuf, 4, 0);
	        //===
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = OS;
	      /* falls through */
	    case OS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.xflags = (hold & 0xff);
	        state.head.os = (hold >> 8);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = EXLEN;
	      /* falls through */
	    case EXLEN:
	      if (state.flags & 0x0400) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length = hold;
	        if (state.head) {
	          state.head.extra_len = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      else if (state.head) {
	        state.head.extra = null/*Z_NULL*/;
	      }
	      state.mode = EXTRA;
	      /* falls through */
	    case EXTRA:
	      if (state.flags & 0x0400) {
	        copy = state.length;
	        if (copy > have) { copy = have; }
	        if (copy) {
	          if (state.head) {
	            len = state.head.extra_len - state.length;
	            if (!state.head.extra) {
	              // Use untyped array for more conveniend processing later
	              state.head.extra = new Array(state.head.extra_len);
	            }
	            utils.arraySet(
	              state.head.extra,
	              input,
	              next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy,
	              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len
	            );
	            //zmemcpy(state.head.extra + len, next,
	            //        len + copy > state.head.extra_max ?
	            //        state.head.extra_max - len : copy);
	          }
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          state.length -= copy;
	        }
	        if (state.length) { break inf_leave; }
	      }
	      state.length = 0;
	      state.mode = NAME;
	      /* falls through */
	    case NAME:
	      if (state.flags & 0x0800) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          // TODO: 2 or 1 bytes?
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.name_max*/)) {
	            state.head.name += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.name = null;
	      }
	      state.length = 0;
	      state.mode = COMMENT;
	      /* falls through */
	    case COMMENT:
	      if (state.flags & 0x1000) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.comm_max*/)) {
	            state.head.comment += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.comment = null;
	      }
	      state.mode = HCRC;
	      /* falls through */
	    case HCRC:
	      if (state.flags & 0x0200) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.check & 0xffff)) {
	          strm.msg = 'header crc mismatch';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      if (state.head) {
	        state.head.hcrc = ((state.flags >> 9) & 1);
	        state.head.done = true;
	      }
	      strm.adler = state.check = 0;
	      state.mode = TYPE;
	      break;
	    case DICTID:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      strm.adler = state.check = zswap32(hold);
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = DICT;
	      /* falls through */
	    case DICT:
	      if (state.havedict === 0) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        return Z_NEED_DICT;
	      }
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      /* falls through */
	    case TYPE:
	      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case TYPEDO:
	      if (state.last) {
	        //--- BYTEBITS() ---//
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        state.mode = CHECK;
	        break;
	      }
	      //=== NEEDBITS(3); */
	      while (bits < 3) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.last = (hold & 0x01)/*BITS(1)*/;
	      //--- DROPBITS(1) ---//
	      hold >>>= 1;
	      bits -= 1;
	      //---//
	
	      switch ((hold & 0x03)/*BITS(2)*/) {
	      case 0:                             /* stored block */
	        //Tracev((stderr, "inflate:     stored block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = STORED;
	        break;
	      case 1:                             /* fixed block */
	        fixedtables(state);
	        //Tracev((stderr, "inflate:     fixed codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = LEN_;             /* decode codes */
	        if (flush === Z_TREES) {
	          //--- DROPBITS(2) ---//
	          hold >>>= 2;
	          bits -= 2;
	          //---//
	          break inf_leave;
	        }
	        break;
	      case 2:                             /* dynamic block */
	        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = TABLE;
	        break;
	      case 3:
	        strm.msg = 'invalid block type';
	        state.mode = BAD;
	      }
	      //--- DROPBITS(2) ---//
	      hold >>>= 2;
	      bits -= 2;
	      //---//
	      break;
	    case STORED:
	      //--- BYTEBITS() ---// /* go to byte boundary */
	      hold >>>= bits & 7;
	      bits -= bits & 7;
	      //---//
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	        strm.msg = 'invalid stored block lengths';
	        state.mode = BAD;
	        break;
	      }
	      state.length = hold & 0xffff;
	      //Tracev((stderr, "inflate:       stored length %u\n",
	      //        state.length));
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = COPY_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case COPY_:
	      state.mode = COPY;
	      /* falls through */
	    case COPY:
	      copy = state.length;
	      if (copy) {
	        if (copy > have) { copy = have; }
	        if (copy > left) { copy = left; }
	        if (copy === 0) { break inf_leave; }
	        //--- zmemcpy(put, next, copy); ---
	        utils.arraySet(output, input, next, copy, put);
	        //---//
	        have -= copy;
	        next += copy;
	        left -= copy;
	        put += copy;
	        state.length -= copy;
	        break;
	      }
	      //Tracev((stderr, "inflate:       stored end\n"));
	      state.mode = TYPE;
	      break;
	    case TABLE:
	      //=== NEEDBITS(14); */
	      while (bits < 14) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	      if (state.nlen > 286 || state.ndist > 30) {
	        strm.msg = 'too many length or distance symbols';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracev((stderr, "inflate:       table sizes ok\n"));
	      state.have = 0;
	      state.mode = LENLENS;
	      /* falls through */
	    case LENLENS:
	      while (state.have < state.ncode) {
	        //=== NEEDBITS(3);
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	        //--- DROPBITS(3) ---//
	        hold >>>= 3;
	        bits -= 3;
	        //---//
	      }
	      while (state.have < 19) {
	        state.lens[order[state.have++]] = 0;
	      }
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      //state.next = state.codes;
	      //state.lencode = state.next;
	      // Switch to use dynamic table
	      state.lencode = state.lendyn;
	      state.lenbits = 7;
	
	      opts = { bits: state.lenbits };
	      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	      state.lenbits = opts.bits;
	
	      if (ret) {
	        strm.msg = 'invalid code lengths set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, "inflate:       code lengths ok\n"));
	      state.have = 0;
	      state.mode = CODELENS;
	      /* falls through */
	    case CODELENS:
	      while (state.have < state.nlen + state.ndist) {
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_val < 16) {
	          //--- DROPBITS(here.bits) ---//
	          hold >>>= here_bits;
	          bits -= here_bits;
	          //---//
	          state.lens[state.have++] = here_val;
	        }
	        else {
	          if (here_val === 16) {
	            //=== NEEDBITS(here.bits + 2);
	            n = here_bits + 2;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            if (state.have === 0) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            len = state.lens[state.have - 1];
	            copy = 3 + (hold & 0x03);//BITS(2);
	            //--- DROPBITS(2) ---//
	            hold >>>= 2;
	            bits -= 2;
	            //---//
	          }
	          else if (here_val === 17) {
	            //=== NEEDBITS(here.bits + 3);
	            n = here_bits + 3;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 3 + (hold & 0x07);//BITS(3);
	            //--- DROPBITS(3) ---//
	            hold >>>= 3;
	            bits -= 3;
	            //---//
	          }
	          else {
	            //=== NEEDBITS(here.bits + 7);
	            n = here_bits + 7;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 11 + (hold & 0x7f);//BITS(7);
	            //--- DROPBITS(7) ---//
	            hold >>>= 7;
	            bits -= 7;
	            //---//
	          }
	          if (state.have + copy > state.nlen + state.ndist) {
	            strm.msg = 'invalid bit length repeat';
	            state.mode = BAD;
	            break;
	          }
	          while (copy--) {
	            state.lens[state.have++] = len;
	          }
	        }
	      }
	
	      /* handle error breaks in while */
	      if (state.mode === BAD) { break; }
	
	      /* check for end-of-block code (better have one) */
	      if (state.lens[256] === 0) {
	        strm.msg = 'invalid code -- missing end-of-block';
	        state.mode = BAD;
	        break;
	      }
	
	      /* build code tables -- note: do not change the lenbits or distbits
	         values here (9 and 6) without reading the comments in inftrees.h
	         concerning the ENOUGH constants, which depend on those values */
	      state.lenbits = 9;
	
	      opts = { bits: state.lenbits };
	      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.lenbits = opts.bits;
	      // state.lencode = state.next;
	
	      if (ret) {
	        strm.msg = 'invalid literal/lengths set';
	        state.mode = BAD;
	        break;
	      }
	
	      state.distbits = 6;
	      //state.distcode.copy(state.codes);
	      // Switch to use dynamic table
	      state.distcode = state.distdyn;
	      opts = { bits: state.distbits };
	      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.distbits = opts.bits;
	      // state.distcode = state.next;
	
	      if (ret) {
	        strm.msg = 'invalid distances set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, 'inflate:       codes ok\n'));
	      state.mode = LEN_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case LEN_:
	      state.mode = LEN;
	      /* falls through */
	    case LEN:
	      if (have >= 6 && left >= 258) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        inflate_fast(strm, _out);
	        //--- LOAD() ---
	        put = strm.next_out;
	        output = strm.output;
	        left = strm.avail_out;
	        next = strm.next_in;
	        input = strm.input;
	        have = strm.avail_in;
	        hold = state.hold;
	        bits = state.bits;
	        //---
	
	        if (state.mode === TYPE) {
	          state.back = -1;
	        }
	        break;
	      }
	      state.back = 0;
	      for (;;) {
	        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;
	
	        if (here_bits <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if (here_op && (here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.lencode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      state.length = here_val;
	      if (here_op === 0) {
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        state.mode = LIT;
	        break;
	      }
	      if (here_op & 32) {
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.back = -1;
	        state.mode = TYPE;
	        break;
	      }
	      if (here_op & 64) {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break;
	      }
	      state.extra = here_op & 15;
	      state.mode = LENEXT;
	      /* falls through */
	    case LENEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	      //Tracevv((stderr, "inflate:         length %u\n", state.length));
	      state.was = state.length;
	      state.mode = DIST;
	      /* falls through */
	    case DIST:
	      for (;;) {
	        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;
	
	        if ((here_bits) <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if ((here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.distcode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;
	
	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      if (here_op & 64) {
	        strm.msg = 'invalid distance code';
	        state.mode = BAD;
	        break;
	      }
	      state.offset = here_val;
	      state.extra = (here_op) & 15;
	      state.mode = DISTEXT;
	      /* falls through */
	    case DISTEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	//#ifdef INFLATE_STRICT
	      if (state.offset > state.dmax) {
	        strm.msg = 'invalid distance too far back';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	      state.mode = MATCH;
	      /* falls through */
	    case MATCH:
	      if (left === 0) { break inf_leave; }
	      copy = _out - left;
	      if (state.offset > copy) {         /* copy from window */
	        copy = state.offset - copy;
	        if (copy > state.whave) {
	          if (state.sane) {
	            strm.msg = 'invalid distance too far back';
	            state.mode = BAD;
	            break;
	          }
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	        }
	        if (copy > state.wnext) {
	          copy -= state.wnext;
	          from = state.wsize - copy;
	        }
	        else {
	          from = state.wnext - copy;
	        }
	        if (copy > state.length) { copy = state.length; }
	        from_source = state.window;
	      }
	      else {                              /* copy from output */
	        from_source = output;
	        from = put - state.offset;
	        copy = state.length;
	      }
	      if (copy > left) { copy = left; }
	      left -= copy;
	      state.length -= copy;
	      do {
	        output[put++] = from_source[from++];
	      } while (--copy);
	      if (state.length === 0) { state.mode = LEN; }
	      break;
	    case LIT:
	      if (left === 0) { break inf_leave; }
	      output[put++] = state.length;
	      left--;
	      state.mode = LEN;
	      break;
	    case CHECK:
	      if (state.wrap) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          // Use '|' insdead of '+' to make sure that result is signed
	          hold |= input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        _out -= left;
	        strm.total_out += _out;
	        state.total += _out;
	        if (_out) {
	          strm.adler = state.check =
	              /*UPDATE(state.check, put - _out, _out);*/
	              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
	
	        }
	        _out = left;
	        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	          strm.msg = 'incorrect data check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   check matches trailer\n"));
	      }
	      state.mode = LENGTH;
	      /* falls through */
	    case LENGTH:
	      if (state.wrap && state.flags) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.total & 0xffffffff)) {
	          strm.msg = 'incorrect length check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   length matches trailer\n"));
	      }
	      state.mode = DONE;
	      /* falls through */
	    case DONE:
	      ret = Z_STREAM_END;
	      break inf_leave;
	    case BAD:
	      ret = Z_DATA_ERROR;
	      break inf_leave;
	    case MEM:
	      return Z_MEM_ERROR;
	    case SYNC:
	      /* falls through */
	    default:
	      return Z_STREAM_ERROR;
	    }
	  }
	
	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"
	
	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */
	
	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---
	
	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	      state.mode = MEM;
	      return Z_MEM_ERROR;
	    }
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}
	
	function inflateEnd(strm) {
	
	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }
	
	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}
	
	function inflateGetHeader(strm, head) {
	  var state;
	
	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }
	
	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}
	
	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;
	
	  var state;
	  var dictid;
	  var ret;
	
	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
	  state = strm.state;
	
	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR;
	  }
	
	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK;
	}
	
	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateInfo = 'pako inflate (from Nodeca project)';
	
	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/


/***/ },
/* 148 */
/***/ function(module, exports) {

	'use strict';
	
	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	
	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.
	
	   Entry assumptions:
	
	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8
	
	   On return, state.mode is one of:
	
	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data
	
	   Notes:
	
	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.
	
	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	module.exports = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;
	
	
	  var input, output; // JS specific, because we have no pointers
	
	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;
	
	
	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */
	
	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }
	
	    here = lcode[hold & lmask];
	
	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];
	
	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;
	
	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }
	
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }
	
	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }
	
	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);
	
	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;
	
	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	var utils = __webpack_require__(143);
	
	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
	
	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;
	
	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];
	
	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];
	
	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];
	
	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];
	
	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */
	
	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;
	
	  var here_bits, here_op, here_val;
	
	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.
	
	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.
	
	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.
	
	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */
	
	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }
	
	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;
	
	
	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;
	
	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }
	
	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }
	
	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }
	
	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }
	
	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.
	
	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.
	
	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.
	
	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.
	
	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */
	
	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;
	
	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;
	
	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }
	
	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */
	
	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }
	
	  var i = 0;
	  /* process all codes and make table entries */
	  for (;;) {
	    i++;
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }
	
	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);
	
	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }
	
	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }
	
	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }
	
	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */
	
	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }
	
	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }
	
	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }
	
	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }
	
	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';
	
	
	module.exports = {
	
	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,
	
	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,
	
	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,
	
	
	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,
	
	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,
	
	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:
	
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }
	
	  var x = a.length;
	  var y = b.length;
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	
	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}
	
	// based on node assert, original notice:
	
	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var util = __webpack_require__(16);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};
	
	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;
	
	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};
	
	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }
	
	    memos.actual.push(actual);
	    memos.expected.push(expected);
	
	    return objEquiv(actual, expected, strict, memos);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}
	
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }
	
	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }
	
	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }
	
	  return expected.call({}, actual) === true;
	}
	
	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }
	
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }
	
	  actual = _tryBlock(block);
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;
	
	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};
	
	assert.ifError = function(err) { if (err) throw err; };
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var format = __webpack_require__(16).format
	var logger = __webpack_require__(12).child({component: 'new_relic_response'})
	
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var RESPONSE_VALUE_NAME = 'return_value'
	var EXCEPTION_VALUE_NAME = 'exception'
	
	
	/**
	 * The collector has many ways of indicating failure, and isn't
	 * necessarily consistent. Because there can either be a failure at
	 * the network level, a nonstandard HTTP status code on the response,
	 * or a JSON-encoded exception in the response body, there's a lot of
	 * conditional logic in here that tries to grab as much information
	 * about errors as possible, and to parse out the return value as often
	 * as possible.
	 *
	 * @param string         name     Remote method name that was invoked.
	 * @param ServerResponse response HTTP response stream
	 * @param Function       callback Function that will be called with any
	 *                                error, the value returned by the server
	 *                                (if any), and the raw JSON of the
	 *                                server's response.
	 *
	 * @returns Function Another callback that is meant to be invoked with
	 *                   any errors from reading the response stream, as
	 *                   well as a string containing the full response.
	 */
	module.exports = function parse(name, response, callback) {
	  if (!name) throw new TypeError('collector method name required!')
	  if (!response) throw new TypeError('HTTP response required!')
	  if (!callback) throw new TypeError('callback required!')
	
	  return function parser(inError, body) {
	    /* jshint maxdepth:4 */
	
	    var code = response.statusCode
	    var errors = []
	    var errorClass
	    var json
	    var returned
	
	
	    if (code !== 200) logger.debug("Got %s as a response code from the collector.", code)
	
	    if (inError) errors.push(inError)
	
	    if (body) {
	      try {
	        json = JSON.parse(body)
	
	        // Can be super verbose, but useful for debugging.
	        logger.trace({response: json}, "Deserialized from collector:")
	
	        // If we get messages back from the collector, be polite and pass them along.
	        returned = json[RESPONSE_VALUE_NAME]
	        if (returned && returned.messages) {
	          returned.messages.forEach(function cb_forEach(element) {
	            logger.info(element.message)
	          })
	        }
	
	        /* Wait to deal with errors in the response until any messages have
	         * been passed along. Otherwise, ensure that there was a return
	         * value, raising an error if not.
	         *
	         * Some errors are only interesting if the status code indicates
	         * that the request went bad already, so filter out adding more
	         * errors when statusCode is not OK (200).
	         */
	        var exception = json[EXCEPTION_VALUE_NAME]
	        if (exception) {
	          if (exception.message) {
	            errors.push(new Error(exception.message))
	          } else if (code === 200 ) {
	            errors.push(new Error('New Relic internal error'))
	          }
	
	          if (exception.error_type) errorClass = exception.error_type
	        } else if (code === 200 && returned === undefined) {
	          errors.push(new Error(format('No data found in response to %s.', name)))
	        }
	      } catch (error) {
	        logger.trace(error, 'Could not parse response from the collector: %s', body)
	        errors.push(error)
	      }
	    } else {
	      errors.push(new Error(format('No body found in response to %s.', name)))
	    }
	
	    if (code !== 200) {
	      errors.push(new Error(format('Got HTTP %s in response to %s.', code, name)))
	    }
	
	    var error
	    if (errors.length > 0) {
	      error = errors.shift()
	      error.statusCode = code
	      // Preserve a consistent hidden class (cheaper than sub-classing Error).
	      error.class = errorClass ? errorClass : undefined
	      error.laterErrors = (errors.length > 0) ? errors : undefined
	    }
	
	    // Raw json is useful for testing and logging.
	    process.nextTick(function cb_nextTick() {
	      callback(error, returned, json)
	    })
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var EventEmitter = __webpack_require__(26).EventEmitter
	var util = __webpack_require__(16)
	
	
	/**
	 * Pipe a readable stream into this sink that fulfills the Writable Stream
	 * contract and the callback will be fired when the stream has been completely
	 * read.
	 */
	function StreamSink(callback) {
	  EventEmitter.call(this)
	
	  this.callback = callback
	  this.sink = ''
	  this.writable = true
	
	  var sink = this
	  this.on('error', function handle_error(error) {
	    sink.writable = false
	    callback(error)
	  })
	}
	util.inherits(StreamSink, EventEmitter)
	
	StreamSink.prototype.write = function write(string) {
	  if (!this.writable) {
	    this.emit('error', new Error("Sink no longer writable!"))
	    return false
	  }
	
	  // Explicitly copy buffer contents so we are sure to release references to
	  // the TLS slab buffer region.
	  this.sink += string.toString()
	
	  return true
	}
	
	StreamSink.prototype.end = function end() {
	  this.writable = false
	
	  this.callback(null, this.sink)
	}
	
	StreamSink.prototype.destroy = function destroy() {
	  this.emit('close')
	  this.writable = false
	
	  delete this.sink
	}
	
	module.exports = StreamSink


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var parse = __webpack_require__(108).parse
	var extend = __webpack_require__(16)._extend
	var HTTPAgent = __webpack_require__(155)
	var SSLAgent = HTTPAgent.SSL
	var ProxyAgent = __webpack_require__(159)
	var logger = __webpack_require__(12).child({component: 'http-agent'})
	var certificates = __webpack_require__(165)
	
	var CIPHERS = "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:" +
	              "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:" +
	              "DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:" +
	              "ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:" +
	              "ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:" +
	              "ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:" +
	              "ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:" +
	              "DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:" +
	              "DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:" +
	              "AES128-GCM-SHA256:AES256-GCM-SHA384:AES128:AES256:HIGH:" +
	              "!aNULL:!eNULL:!EXPORT:!DES:!3DES:!MD5:!PSK:!RC4"
	
	var baseConfig = {
	  keepAlive: true,
	  keepAliveTimeoutMsecs: 500,
	  maxSockets: 1 // requests are serialized
	}
	
	var httpsConfig = extend({
	  rejectUnauthorized: true,
	  ciphers: CIPHERS
	}, baseConfig)
	
	exports.httpAgent = new HTTPAgent(baseConfig)
	
	exports.httpsAgent = new SSLAgent(httpsConfig)
	
	exports.proxyAgent = function proxyAgent(config) {
	  var opts = proxyOptions(config)
	  var proxy_url = opts.proxy_url
	
	  var proxy_opts = {
	    host: proxy_url.host,
	    port: proxy_url.port,
	    protocol: proxy_url.protocol,
	    secureEndpoint: config.ssl,
	    auth: proxy_url.auth,
	    ca: opts.certificates
	  }
	
	  logger.info({
	    host: proxy_opts.host,
	    port: proxy_opts.port,
	    auth: !!proxy_opts.auth,
	    protocol: proxy_url.protocol
	  }, 'using proxy')
	
	  var proxy = new ProxyAgent(proxy_opts)
	
	  return proxy
	}
	
	function proxyOptions(config) {
	  if (config.proxy) {
	    var parsed_url = parse(config.proxy)
	
	    var proxy_url = {
	      protocol: parsed_url.protocol || 'http:',
	      host: parsed_url.hostname,
	      port: parsed_url.port || 80,
	      auth: parsed_url.auth
	    }
	  } else {
	    var proxy_auth = config.proxy_user
	    if (config.proxy_pass !== '') {
	      proxy_auth += ':' + config.proxy_pass
	    }
	
	    // Unless a proxy config is provided, default to HTTP.
	    proxy_url = {
	      protocol: 'http:',
	      host: config.proxy_host || 'localhost',
	      port: config.proxy_port || 80,
	      auth: proxy_auth
	    }
	  }
	
	  var opts = {
	    proxy_url: proxy_url
	  }
	
	  // merge user certificates with built-in certs
	
	  if (config.certificates && config.certificates.length > 0) {
	    logger.info(
	      'Using a proxy with a special cert. This enables our cert bundle which, combined ' +
	      'with some versions of node, exacerbates a leak in node core TLS.'
	    )
	    opts.certificates = config.certificates.concat(certificates)
	  }
	
	  return opts
	}


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Agent = __webpack_require__(156);
	Agent.SSL = __webpack_require__(158);
	
	module.exports = Agent;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var EventEmitter = __webpack_require__(26).EventEmitter;
	var util = __webpack_require__(16);
	
	var debug = __webpack_require__(157)('httpagent');
	
	// New Agent code.
	
	// The largest departure from the previous implementation is that
	// an Agent instance holds connections for a variable number of host:ports.
	// Surprisingly, this is still API compatible as far as third parties are
	// concerned. The only code that really notices the difference is the
	// request object.
	
	// Another departure is that all code related to HTTP parsing is in
	// ClientRequest.onSocket(). The Agent is now *strictly*
	// concerned with managing a connection pool.
	
	function Agent(options) {
	  if (!(this instanceof Agent)) return new Agent(options);
	
	  EventEmitter.call(this);
	
	  this.defaultPort = 80;
	  this.protocol    = 'http:';
	
	  this.options = util._extend({}, options);
	  // don't confuse net and make it think that we're connecting to a pipe
	  this.options.path = null;
	
	  this.requests    = {};
	  this.sockets     = {};
	  this.freeSockets = {};
	
	  this.keepAliveMsecs = this.options.keepAliveMsecs || 1000;
	  this.keepAlive      = this.options.keepAlive || false;
	
	  this.maxSockets     = this.options.maxSockets || Agent.defaultMaxSockets;
	  this.maxFreeSockets = this.options.maxFreeSockets || 256;
	
	  var self = this;
	  this.on('free', function(socket, options) {
	    var name = self.getName(options);
	    debug('agent.on(free)', name);
	
	    if (!self.isSocketDestroyed(socket) && self.requests[name] && self.requests[name].length) {
	      self.requests[name].shift().onSocket(socket);
	      if (self.requests[name].length === 0) {
	        // don't leak
	        delete self.requests[name];
	      }
	    }
	    else {
	      // If there are no pending requests, then put it in
	      // the freeSockets pool, but only if we're allowed to do so.
	      var req = socket._httpMessage;
	      if (req && req.shouldKeepAlive && !self.isSocketDestroyed(socket) && self.options.keepAlive) {
	        var freeSockets = self.freeSockets[name];
	        var freeLen     = freeSockets ? freeSockets.length : 0;
	        var count       = freeLen;
	
	        if (self.sockets[name]) count += self.sockets[name].length;
	
	        debug('potentially pooling', freeLen, count);
	
	        if (count > self.maxSockets || freeLen >= self.maxFreeSockets) {
	          debug('destroying socket', name);
	          self.removeSocket(socket, options);
	          socket.destroy();
	        } else {
	          debug('pooling socket', name);
	          freeSockets = freeSockets || [];
	          self.freeSockets[name] = freeSockets;
	          socket.setKeepAlive(true, self.keepAliveMsecs);
	
	          if (socket.unref) {
	            socket.unref();
	          }
	          else if (socket.socket &&
	                   socket.socket._handle &&
	                   socket.socket._handle.unref) {
	            socket.socket._handle.unref();
	          }
	
	          socket._httpMessage = null;
	          self.removeSocket(socket, options);
	          freeSockets.push(socket);
	
	          // set timeout on idle sockets
	          if (options.keepAliveTimeoutMsecs !== undefined) {
	            socket._yakaa_timeout = setTimeout(function () {
	              self.emit('yakaa_destroy');
	              socket.destroySoon();
	            }, options.keepAliveTimeoutMsecs);
	          }
	
	        }
	      } else {
	        self.removeSocket(socket, options);
	        socket.destroy();
	      }
	    }
	  });
	}
	
	util.inherits(Agent, EventEmitter);
	exports.Agent = Agent;
	
	Agent.defaultMaxSockets = Infinity;
	
	Agent.prototype.createConnection = net.createConnection;
	
	Agent.prototype.isSocketDestroyed = function(socket) {
	    // Different Node versions have different names for the property
	    return socket.destroyed || socket._destroyed;
	};
	
	// Get the key for a given set of request options
	Agent.prototype.getName = function(options) {
	  var name = '';
	
	  if (options.host)
	    name += options.host;
	  else
	    name += 'localhost';
	
	  name += ':';
	  if (options.port)
	    name += options.port;
	  name += ':';
	  if (options.localAddress)
	    name += options.localAddress;
	  name += ':';
	  return name;
	};
	
	Agent.prototype.addRequest = function(req, options) {
	  debug('addRequest');
	  // Legacy API: addRequest(req, host, port, path)
	  if (typeof options === 'string') {
	    options = {
	      host: options,
	      port: arguments[2],
	      path: arguments[3]
	    };
	  }
	
	  var name = this.getName(options);
	  if (!this.sockets[name]) {
	    this.sockets[name] = [];
	  }
	
	  var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;
	  var sockLen = freeLen + this.sockets[name].length;
	
	  if (freeLen) {
	    // we have a free socket, so use that.
	    var socket = this.freeSockets[name].shift();
	    debug('have free socket');
	
	    // mark socket as non-idle so it doesn't get destroyed mid-request
	    if (socket._yakaa_timeout) {
	      clearTimeout(socket._yakaa_timeout);
	      delete socket._yakaa_timeout;
	    }
	
	    // don't leak
	    if (!this.freeSockets[name].length)
	      delete this.freeSockets[name];
	
	    if (socket.ref) {
	      socket.ref();
	    }
	    else if (socket.socket && socket.socket._handle && socket.socket._handle.ref) {
	      socket.socket._handle.ref();
	    }
	
	    req.onSocket(socket);
	    this.sockets[name].push(socket);
	  } else if (sockLen < this.maxSockets) {
	    debug('call onSocket', name, sockLen, freeLen);
	    // If we are under maxSockets create a new one.
	    req.onSocket(this.createSocket(req, options));
	  } else {
	    debug('wait for socket');
	    // We are over limit so we'll add it to the queue.
	    if (!this.requests[name]) {
	      this.requests[name] = [];
	    }
	    this.requests[name].push(req);
	  }
	};
	
	Agent.prototype.createSocket = function(req, options) {
	  debug('createSocket');
	  var self = this;
	  options = util._extend({}, options);
	  options = util._extend(options, self.options);
	
	  options.servername = options.host;
	  if (req) {
	    var hostHeader = req.getHeader('host');
	    if (hostHeader) {
	      options.servername = hostHeader.replace(/:.*$/, '');
	    }
	  }
	
	  var name = self.getName(options);
	
	  debug('createConnection', name, options);
	  options.encoding = null;
	  var s = self.createConnection(options);
	  if (!self.sockets[name]) {
	    self.sockets[name] = [];
	  }
	  this.sockets[name].push(s);
	  debug('sockets', name, this.sockets[name].length);
	
	  function onFree() {
	    self.emit('free', s, options);
	  }
	  s.on('free', onFree);
	
	  function onClose() {
	    debug('CLIENT socket onClose');
	    // This is the only place where sockets get removed from the Agent.
	    // If you want to remove a socket from the pool, just close it.
	    // All socket errors end in a close event anyway.
	    self.removeSocket(s, options);
	  }
	  s.on('close', onClose);
	
	  function onRemove() {
	    // We need this function for cases like HTTP 'upgrade'
	    // (defined by WebSockets) where we need to remove a socket from the
	    // pool because it'll be locked up indefinitely
	    debug('CLIENT socket onRemove');
	    self.removeSocket(s, options);
	    s.removeListener('close', onClose);
	    s.removeListener('free', onFree);
	    s.removeListener('agentRemove', onRemove);
	  }
	  s.on('agentRemove', onRemove);
	  return s;
	};
	
	Agent.prototype.removeSocket = function(s, options) {
	  var name = this.getName(options);
	  debug('removeSocket', name, 'destroyed:', this.isSocketDestroyed(s));
	  var sets = [this.sockets];
	
	  this.emit('yakaa_remove', s);
	
	  // If the socket was destroyed, remove it from the free buffers too.
	  if (this.isSocketDestroyed(s))
	    sets.push(this.freeSockets);
	
	  sets.forEach(function(sockets) {
	    if (sockets[name]) {
	      var index = sockets[name].indexOf(s);
	      if (index !== -1) {
	        sockets[name].splice(index, 1);
	        // Don't leak
	        if (sockets[name].length === 0) delete sockets[name];
	      }
	    }
	  });
	
	  if (this.requests[name] && this.requests[name].length) {
	    debug('removeSocket, have a request, make a socket');
	    var req = this.requests[name][0];
	    // If we have pending requests and a socket gets closed make a new one
	    this.createSocket(req, options).emit('free');
	  }
	};
	
	Agent.prototype.destroy = function() {
	  var sets = [this.freeSockets, this.sockets];
	  sets.forEach(function(set) {
	    Object.keys(set).forEach(function(name) {
	      set[name].forEach(function(socket) {
	        socket.destroy();
	      });
	    });
	  });
	};
	
	module.exports = Agent;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var format = __webpack_require__(16).format;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	
	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = format.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    }
	    else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	}
	
	module.exports = debuglog;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	
	var tls = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tls\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var inherits = __webpack_require__(16).inherits;
	var Agent = __webpack_require__(156);
	var debug = __webpack_require__(157)('httpsagent');
	
	// HTTPS agents.
	function createConnection(port, host, options) {
	  if (isObject(port)) {
	    options = port;
	  }
	  else if (isObject(host)) {
	    options = host;
	  }
	  else if (isObject(options)) {
	    options = options;
	  }
	  else {
	    options = {};
	  }
	
	  if (isNumber(port)) {
	    options.port = port;
	  }
	
	  if (isString(host)) {
	    options.host = host;
	  }
	
	  debug('createConnection', options);
	  return tls.connect(options);
	}
	
	
	function SSLAgent(options) {
	  Agent.call(this, options);
	  this.defaultPort = 443;
	  this.protocol = 'https:';
	}
	inherits(SSLAgent, Agent);
	
	SSLAgent.prototype.createConnection = createConnection;
	
	SSLAgent.prototype.getName = function(options) {
	  var name = Agent.prototype.getName.call(this, options);
	
	  // name += ':';
	  // if (options.ca)
	  //   name += options.ca;
	
	  name += ':';
	  if (options.cert)
	    name += options.cert;
	
	  name += ':';
	  if (options.ciphers)
	    name += options.ciphers;
	
	  name += ':';
	  if (options.key)
	    name += options.key;
	
	  name += ':';
	  if (options.pfx)
	    name += options.pfx;
	
	  // name += ':';
	  // if (!isUndefined(options.rejectUnauthorized))
	  //   name += options.rejectUnauthorized;
	
	  return name;
	};
	
	module.exports = SSLAgent;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	/**
	 * Module dependencies.
	 */
	
	var net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var tls = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tls\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var url = __webpack_require__(108);
	var extend = __webpack_require__(160);
	var Agent = __webpack_require__(161);
	var inherits = __webpack_require__(16).inherits;
	var debug = __webpack_require__(162)('https-proxy-agent');
	
	/**
	 * Module exports.
	 */
	
	module.exports = HttpsProxyAgent;
	
	/**
	 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the
	 * specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
	 *
	 * @api public
	 */
	
	function HttpsProxyAgent (opts) {
	  if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);
	  if ('string' == typeof opts) opts = url.parse(opts);
	  if (!opts) throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
	  debug('creating new HttpsProxyAgent instance: %j', opts);
	  Agent.call(this, connect);
	
	  var proxy = extend({}, opts);
	
	  // if `true`, then connect to the proxy server over TLS. defaults to `false`.
	  this.secureProxy = proxy.protocol ? /^https:?$/i.test(proxy.protocol) : false;
	
	  // if `true`, then connect to the destination endpoint over TLS, defaults to `true`
	  this.secureEndpoint = opts.secureEndpoint !== false;
	
	  // prefer `hostname` over `host`, and set the `port` if needed
	  proxy.host = proxy.hostname || proxy.host;
	  proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);
	
	  if (proxy.host && proxy.path) {
	    // if both a `host` and `path` are specified then it's most likely the
	    // result of a `url.parse()` call... we need to remove the `path` portion so
	    // that `net.connect()` doesn't attempt to open that as a unix socket file.
	    delete proxy.path;
	    delete proxy.pathname;
	  }
	
	  this.proxy = proxy;
	}
	inherits(HttpsProxyAgent, Agent);
	
	/**
	 * Default options for the "connect" opts object.
	 */
	
	var defaults = { port: 80 };
	var secureDefaults = { port: 443 };
	
	/**
	 * Called when the node-core HTTP client library is creating a new HTTP request.
	 *
	 * @api public
	 */
	
	function connect (req, _opts, fn) {
	
	  var proxy = this.proxy;
	  var secureProxy = this.secureProxy;
	  var secureEndpoint = this.secureEndpoint;
	
	  // create a socket connection to the proxy server
	  var socket;
	  if (secureProxy) {
	    socket = tls.connect(proxy);
	  } else {
	    socket = net.connect(proxy);
	  }
	
	  // these `opts` are the connect options to connect to the destination endpoint
	  // XXX: we mix in the proxy options so that TLS options like
	  // `rejectUnauthorized` get passed to the destination endpoint as well
	  var proxyOpts = extend({}, proxy);
	  delete proxyOpts.host;
	  delete proxyOpts.hostname;
	  delete proxyOpts.port;
	  var opts = extend({}, proxyOpts, secureEndpoint ? secureDefaults : defaults, _opts);
	
	  // we need to buffer any HTTP traffic that happens with the proxy before we get
	  // the CONNECT response, so that if the response is anything other than an "200"
	  // response code, then we can re-play the "data" events on the socket once the
	  // HTTP parser is hooked up...
	  var buffers = [];
	  var buffersLength = 0;
	
	  function read () {
	    var b = socket.read();
	    if (b) ondata(b);
	    else socket.once('readable', read);
	  }
	
	  function cleanup () {
	    socket.removeListener('data', ondata);
	    socket.removeListener('end', onend);
	    socket.removeListener('error', onerror);
	    socket.removeListener('close', onclose);
	    socket.removeListener('readable', read);
	  }
	
	  function onclose (err) {
	    debug('onclose had error', err);
	  }
	
	  function onend () {
	    debug('onend');
	  }
	
	  function onerror (err) {
	    cleanup();
	    fn(err);
	  }
	
	  function ondata (b) {
	    buffers.push(b);
	    buffersLength += b.length;
	    var buffered = Buffer.concat(buffers, buffersLength);
	    var str = buffered.toString('ascii');
	
	    if (!~str.indexOf('\r\n\r\n')) {
	      // keep buffering
	      debug('have not received end of HTTP headers yet...');
	      if (socket.read) {
	        read();
	      } else {
	        socket.once('data', ondata);
	      }
	      return;
	    }
	
	    var firstLine = str.substring(0, str.indexOf('\r\n'));
	    var statusCode = +firstLine.split(' ')[1];
	    debug('got proxy server response: "%s"', firstLine);
	    //console.log('statusCode: %d', statusCode);
	    //console.log(b.length, b, b.toString());
	
	    if (200 == statusCode) {
	      // 200 Connected status code!
	      var sock = socket;
	
	      // nullify the buffered data since we won't be needing it
	      buffers = buffered = null;
	
	      if (secureEndpoint) {
	        // since the proxy is connecting to an SSL server, we have
	        // to upgrade this socket connection to an SSL connection
	        debug('upgrading proxy-connected socket to TLS connection: "%s"', opts.host);
	        opts.socket = socket;
	        opts.servername = opts.host;
	        opts.host = null;
	        opts.hostname = null;
	        opts.port = null;
	        sock = tls.connect(opts);
	      }
	
	      cleanup();
	      fn(null, sock);
	    } else {
	      // some other status code that's not 200... need to re-play the HTTP header
	      // "data" events onto the socket once the HTTP machinery is attached so that
	      // the user can parse and handle the error status code
	      cleanup();
	
	      // save a reference to the concat'd Buffer for the `onsocket` callback
	      buffers = buffered;
	
	      // need to wait for the "socket" event to re-play the "data" events
	      req.once('socket', onsocket);
	      fn(null, socket);
	    }
	  }
	
	  function onsocket (socket) {
	    // replay the "buffers" Buffer onto the `socket`, since at this point
	    // the HTTP module machinery has been hooked up for the user
	    if ('function' == typeof socket.ondata) {
	      // node <= v0.11.3, the `ondata` function is set on the socket
	      socket.ondata(buffers, 0, buffers.length);
	    } else if (socket.listeners('data').length > 0) {
	      // node > v0.11.3, the "data" event is listened for directly
	      socket.emit('data', buffers);
	    } else {
	      // never?
	      throw new Error('should not happen...');
	    }
	
	    // nullify the cached Buffer instance
	    buffers = null;
	  }
	
	  socket.on('error', onerror);
	  socket.on('close', onclose);
	  socket.on('end', onend);
	
	  if (socket.read) {
	    read();
	  } else {
	    socket.once('data', ondata);
	  }
	
	  var hostname = opts.host + ':' + opts.port;
	  var msg = 'CONNECT ' + hostname + ' HTTP/1.1\r\n';
	  var auth = proxy.auth;
	  if (auth) {
	    msg += 'Proxy-Authorization: Basic ' + new Buffer(auth).toString('base64') + '\r\n';
	  }
	  msg += 'Host: ' + hostname + '\r\n' +
	         'Connection: close\r\n' +
	         '\r\n';
	  socket.write(msg);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 160 */
/***/ function(module, exports) {

	'use strict';
	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	
	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}
	
		return toStr.call(arr) === '[object Array]';
	};
	
	var isPlainObject = function isPlainObject(obj) {
		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}
	
		var hasOwnConstructor = hasOwn.call(obj, 'constructor');
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
			return false;
		}
	
		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) {/**/}
	
		return typeof key === 'undefined' || hasOwn.call(obj, key);
	};
	
	module.exports = function extend() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0],
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
			target = {};
		}
	
		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];
	
					// Prevent never-ending loop
					if (target !== copy) {
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && isArray(src) ? src : [];
							} else {
								clone = src && isPlainObject(src) ? src : {};
							}
	
							// Never move original objects, clone them
							target[name] = extend(deep, clone, copy);
	
						// Don't bring in undefined values
						} else if (typeof copy !== 'undefined') {
							target[name] = copy;
						}
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	/**
	 * Module dependencies.
	 */
	
	var inherits = __webpack_require__(16).inherits;
	var EventEmitter = __webpack_require__(26).EventEmitter;
	
	/**
	 * Module exports.
	 */
	
	module.exports = Agent;
	
	/**
	 *
	 * @api public
	 */
	
	function Agent (callback) {
	  if (!(this instanceof Agent)) return new Agent(callback);
	  if ('function' != typeof callback) throw new Error('Must pass a "callback function"');
	  EventEmitter.call(this);
	  this.callback = callback;
	}
	inherits(Agent, EventEmitter);
	
	/**
	 * Called by node-core's "_http_client.js" module when creating
	 * a new HTTP request with this Agent instance.
	 *
	 * @api public
	 */
	
	Agent.prototype.addRequest = function (req, host, port, localAddress) {
	  var opts;
	  if ('object' == typeof host) {
	    // >= v0.11.x API
	    opts = host;
	    if (opts.host && opts.path) {
	      // if both a `host` and `path` are specified then it's most likely the
	      // result of a `url.parse()` call... we need to remove the `path` portion so
	      // that `net.connect()` doesn't attempt to open that as a unix socket file.
	      delete opts.path;
	    }
	  } else {
	    // <= v0.10.x API
	    opts = { host: host, port: port };
	    if (null != localAddress) {
	      opts.localAddress = localAddress;
	    }
	  }
	
	  // hint to use "Connection: close"
	  // XXX: non-documented `http` module API :(
	  req._last = true;
	  req.shouldKeepAlive = false;
	
	  // create the `net.Socket` instance
	  var sync = true;
	  this.callback(req, opts, function (err, socket) {
	    function emitErr () {
	      req.emit('error', err);
	      // For Safety. Some additional errors might fire later on
	      // and we need to make sure we don't double-fire the error event.
	      req._hadError = true;
	    }
	    if (err) {
	      if (sync) {
	        // need to defer the "error" event, when sync, because by now the `req`
	        // instance hasn't event been passed back to the user yet...
	        process.nextTick(emitErr);
	      } else {
	        emitErr();
	      }
	    } else {
	      req.onSocket(socket);
	    }
	  });
	  sync = false;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(163);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  try {
	    return exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (typeof process !== 'undefined' && 'env' in process) {
	    return process.env.DEBUG;
	  }
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug.default = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(164);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0, i;
	
	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 164 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 165 */
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * certificates.js - CA bundle for SSL communication with RPM.
	 *
	 * This file contains the X509 certificates used to communicate with New Relic
	 * over SSL.
	 */
	
	module.exports = [
	  // AddTrustExternalCARoot
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEU\n" +
	  "MBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFs\n" +
	  "IFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290\n" +
	  "MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0Ux\n" +
	  "FDASBgNVBAoTC0FkZFRydXN0IEFCMSYwJAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5h\n" +
	  "bCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1c3QgRXh0ZXJuYWwgQ0EgUm9v\n" +
	  "dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3GjPm8gAELTngTlvt\n" +
	  "H7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCwSXrbLpX9\n" +
	  "uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX\n" +
	  "mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LX\n" +
	  "a0Tkx63ubUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzN\n" +
	  "E0S3ySvdQwAl+mG5aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0\n" +
	  "WicCAwEAAaOB3DCB2TAdBgNVHQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYD\n" +
	  "VR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgZkGA1UdIwSBkTCBjoAUrb2YejS0\n" +
	  "Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRU\n" +
	  "cnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsx\n" +
	  "IjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJKoZIhvcN\n" +
	  "AQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH\n" +
	  "YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw5\n" +
	  "6wwCURQtjr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvC\n" +
	  "Nr4TDea9Y355e6cJDUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEX\n" +
	  "c4g/VhsxOBi0cQ+azcgOno4uG+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5a\n" +
	  "mnkPIAou1Z5jJh5VkpTYghdae9C8x49OhgQ=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // DigiCertAssuredIDRootCA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDtzCCAp+gAwIBAgIQDOfg5RfYRv6P5WD8G/AwOTANBgkqhkiG9w0BAQUFADBl\n" +
	  "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" +
	  "d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJv\n" +
	  "b3QgQ0EwHhcNMDYxMTEwMDAwMDAwWhcNMzExMTEwMDAwMDAwWjBlMQswCQYDVQQG\n" +
	  "EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNl\n" +
	  "cnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgQ0EwggEi\n" +
	  "MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCtDhXO5EOAXLGH87dg+XESpa7c\n" +
	  "JpSIqvTO9SA5KFhgDPiA2qkVlTJhPLWxKISKityfCgyDF3qPkKyK53lTXDGEKvYP\n" +
	  "mDI2dsze3Tyoou9q+yHyUmHfnyDXH+Kx2f4YZNISW1/5WBg1vEfNoTb5a3/UsDg+\n" +
	  "wRvDjDPZ2C8Y/igPs6eD1sNuRMBhNZYW/lmci3Zt1/GiSw0r/wty2p5g0I6QNcZ4\n" +
	  "VYcgoc/lbQrISXwxmDNsIumH0DJaoroTghHtORedmTpyoeb6pNnVFzF1roV9Iq4/\n" +
	  "AUaG9ih5yLHa5FcXxH4cDrC0kqZWs72yl+2qp/C3xag/lRbQ/6GW6whfGHdPAgMB\n" +
	  "AAGjYzBhMA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQW\n" +
	  "BBRF66Kv9JLLgjEtUYunpyGd823IDzAfBgNVHSMEGDAWgBRF66Kv9JLLgjEtUYun\n" +
	  "pyGd823IDzANBgkqhkiG9w0BAQUFAAOCAQEAog683+Lt8ONyc3pklL/3cmbYMuRC\n" +
	  "dWKuh+vy1dneVrOfzM4UKLkNl2BcEkxY5NM9g0lFWJc1aRqoR+pWxnmrEthngYTf\n" +
	  "fwk8lOa4JiwgvT2zKIn3X/8i4peEH+ll74fg38FnSbNd67IJKusm7Xi+fT8r87cm\n" +
	  "NW1fiQG2SVufAQWbqz0lwcy2f8Lxb4bG+mRo64EtlOtCt/qMHt1i8b5QZ7dsvfPx\n" +
	  "H2sMNgcWfzd8qVttevESRmCD1ycEvkvOl77DZypoEd+A5wwzZr8TDRRu838fYxAe\n" +
	  "+o0bJW1sj6W3YQGx0qMmoRBxna3iw/nDmVG3KwcIzi7mULKn+gpFL6Lw8g==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // DigiCertAssuredIDRootG2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDljCCAn6gAwIBAgIQC5McOtY5Z+pnI7/Dr5r0SzANBgkqhkiG9w0BAQsFADBl\n" +
	  "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" +
	  "d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJv\n" +
	  "b3QgRzIwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQG\n" +
	  "EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNl\n" +
	  "cnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzIwggEi\n" +
	  "MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDZ5ygvUj82ckmIkzTz+GoeMVSA\n" +
	  "n61UQbVH35ao1K+ALbkKz3X9iaV9JPrjIgwrvJUXCzO/GU1BBpAAvQxNEP4Htecc\n" +
	  "biJVMWWXvdMX0h5i89vqbFCMP4QMls+3ywPgym2hFEwbid3tALBSfK+RbLE4E9Hp\n" +
	  "EgjAALAcKxHad3A2m67OeYfcgnDmCXRwVWmvo2ifv922ebPynXApVfSr/5Vh88lA\n" +
	  "bx3RvpO704gqu52/clpWcTs/1PPRCv4o76Pu2ZmvA9OPYLfykqGxvYmJHzDNw6Yu\n" +
	  "YjOuFgJ3RFrngQo8p0Quebg/BLxcoIfhG69Rjs3sLPr4/m3wOnyqi+RnlTGNAgMB\n" +
	  "AAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQW\n" +
	  "BBTOw0q5mVXyuNtgv6l+vVa1lzan1jANBgkqhkiG9w0BAQsFAAOCAQEAyqVVjOPI\n" +
	  "QW5pJ6d1Ee88hjZv0p3GeDgdaZaikmkuOGybfQTUiaWxMTeKySHMq2zNixya1r9I\n" +
	  "0jJmwYrA8y8678Dj1JGG0VDjA9tzd29KOVPt3ibHtX2vK0LRdWLjSisCx1BL4Gni\n" +
	  "lmwORGYQRI+tBev4eaymG+g3NJ1TyWGqolKvSnAWhsI6yLETcDbYz+70CjTVW0z9\n" +
	  "B5yiutkBclzzTcHdDrEcDcRjvq30FPuJ7KJBDkzMyFdA0G4Dqs0MjomZmWzwPDCv\n" +
	  "ON9vvKO+KSAnq3T/EyJ43pdSVR6DtVQgA+6uwE9W3jfMw3+qBCe703e4YtsXfJwo\n" +
	  "IhNzbM8m9Yop5w==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // DigiCertAssuredIDRootG3
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIICRjCCAc2gAwIBAgIQC6Fa+h3foLVJRK/NJKBs7DAKBggqhkjOPQQDAzBlMQsw\n" +
	  "CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu\n" +
	  "ZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3Qg\n" +
	  "RzMwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQGEwJV\n" +
	  "UzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\n" +
	  "Y29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzMwdjAQBgcq\n" +
	  "hkjOPQIBBgUrgQQAIgNiAAQZ57ysRGXtzbg/WPuNsVepRC0FFfLvC/8QdJ+1YlJf\n" +
	  "Zn4f5dwbRXkLzMZTCp2NXQLZqVneAlr2lSoOjThKiknGvMYDOAdfVdp+CW7if17Q\n" +
	  "RSAPWXYQ1qAk8C3eNvJsKTmjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/\n" +
	  "BAQDAgGGMB0GA1UdDgQWBBTL0L2p4ZgFUaFNN6KDec6NHSrkhDAKBggqhkjOPQQD\n" +
	  "AwNnADBkAjAlpIFFAmsSS3V0T8gj43DydXLefInwz5FyYZ5eEJJZVrmDxxDnOOlY\n" +
	  "JjZ91eQ0hjkCMHw2U/Aw5WJjOpnitqM7mzT6HtoQknFekROn3aRukswy1vUhZscv\n" +
	  "6pZjamVFkpUBtA==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // DigiCertGlobalRootCA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh\n" +
	  "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" +
	  "d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\n" +
	  "QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT\n" +
	  "MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\n" +
	  "b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG\n" +
	  "9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB\n" +
	  "CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97\n" +
	  "nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt\n" +
	  "43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P\n" +
	  "T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4\n" +
	  "gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO\n" +
	  "BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR\n" +
	  "TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw\n" +
	  "DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr\n" +
	  "hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg\n" +
	  "06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF\n" +
	  "PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\n" +
	  "YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk\n" +
	  "CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // DigiCertGlobalRootG2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDjjCCAnagAwIBAgIQAzrx5qcRqaC7KGSxHQn65TANBgkqhkiG9w0BAQsFADBh\n" +
	  "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" +
	  "d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBH\n" +
	  "MjAeFw0xMzA4MDExMjAwMDBaFw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVT\n" +
	  "MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\n" +
	  "b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IEcyMIIBIjANBgkqhkiG\n" +
	  "9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuzfNNNx7a8myaJCtSnX/RrohCgiN9RlUyfuI\n" +
	  "2/Ou8jqJkTx65qsGGmvPrC3oXgkkRLpimn7Wo6h+4FR1IAWsULecYxpsMNzaHxmx\n" +
	  "1x7e/dfgy5SDN67sH0NO3Xss0r0upS/kqbitOtSZpLYl6ZtrAGCSYP9PIUkY92eQ\n" +
	  "q2EGnI/yuum06ZIya7XzV+hdG82MHauVBJVJ8zUtluNJbd134/tJS7SsVQepj5Wz\n" +
	  "tCO7TG1F8PapspUwtP1MVYwnSlcUfIKdzXOS0xZKBgyMUNGPHgm+F6HmIcr9g+UQ\n" +
	  "vIOlCsRnKPZzFBQ9RnbDhxSJITRNrw9FDKZJobq7nMWxM4MphQIDAQABo0IwQDAP\n" +
	  "BgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUTiJUIBiV\n" +
	  "5uNu5g/6+rkS7QYXjzkwDQYJKoZIhvcNAQELBQADggEBAGBnKJRvDkhj6zHd6mcY\n" +
	  "1Yl9PMWLSn/pvtsrF9+wX3N3KjITOYFnQoQj8kVnNeyIv/iPsGEMNKSuIEyExtv4\n" +
	  "NeF22d+mQrvHRAiGfzZ0JFrabA0UWTW98kndth/Jsw1HKj2ZL7tcu7XUIOGZX1NG\n" +
	  "Fdtom/DzMNU+MeKNhJ7jitralj41E6Vf8PlwUHBHQRFXGU7Aj64GxJUTFy8bJZ91\n" +
	  "8rGOmaFvE7FBcf6IKshPECBV1/MUReXgRPTqh5Uykw7+U0b6LJ3/iyK5S9kJRaTe\n" +
	  "pLiaWN0bfVKfjllDiIGknibVb63dDcY3fe0Dkhvld1927jyNxF1WW6LZZm6zNTfl\n" +
	  "MrY=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // DigiCertGlobalRootG3
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIICPzCCAcWgAwIBAgIQBVVWvPJepDU1w6QP1atFcjAKBggqhkjOPQQDAzBhMQsw\n" +
	  "CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu\n" +
	  "ZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBHMzAe\n" +
	  "Fw0xMzA4MDExMjAwMDBaFw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVTMRUw\n" +
	  "EwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20x\n" +
	  "IDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IEczMHYwEAYHKoZIzj0CAQYF\n" +
	  "K4EEACIDYgAE3afZu4q4C/sLfyHS8L6+c/MzXRq8NOrexpu80JX28MzQC7phW1FG\n" +
	  "fp4tn+6OYwwX7Adw9c+ELkCDnOg/QW07rdOkFFk2eJ0DQ+4QE2xy3q6Ip6FrtUPO\n" +
	  "Z9wj/wMco+I+o0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAd\n" +
	  "BgNVHQ4EFgQUs9tIpPmhxdiuNkHMEWNpYim8S8YwCgYIKoZIzj0EAwMDaAAwZQIx\n" +
	  "AK288mw/EkrRLTnDCgmXc/SINoyIJ7vmiI1Qhadj+Z4y3maTD/HMsQmP3Wyr+mt/\n" +
	  "oAIwOWZbwmSNuJ5Q3KjVSaLtx9zRSX8XAbjIho9OjIgrqJqpisXRAL34VOKa5Vt8\n" +
	  "sycX\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // DigiCertHighAssuranceEVRootCA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBs\n" +
	  "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" +
	  "d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j\n" +
	  "ZSBFViBSb290IENBMB4XDTA2MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDEL\n" +
	  "MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3\n" +
	  "LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNlcnQgSGlnaCBBc3N1cmFuY2Ug\n" +
	  "RVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMbM5XPm\n" +
	  "+9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlBWTrT3JTW\n" +
	  "PNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM\n" +
	  "xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFB\n" +
	  "Ik5lYYeBQVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3\n" +
	  "hzBWBOURtCmAEvF5OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsg\n" +
	  "EsxBu24LUTi4S8sCAwEAAaNjMGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQF\n" +
	  "MAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9HAdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaA\n" +
	  "FLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3DQEBBQUAA4IBAQAcGgaX3Nec\n" +
	  "nzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1ntlMMUu4kehDLI6z\n" +
	  "eM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VHMWEZ71jF\n" +
	  "hS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2\n" +
	  "Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCe\n" +
	  "vEsXCS+0yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep\n" +
	  "+OkuE6N36B9K\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // DigiCertTrustedRootG4
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIFkDCCA3igAwIBAgIQBZsbV56OITLiOQe9p3d1XDANBgkqhkiG9w0BAQwFADBi\n" +
	  "MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" +
	  "d3cuZGlnaWNlcnQuY29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3Qg\n" +
	  "RzQwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBiMQswCQYDVQQGEwJV\n" +
	  "UzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\n" +
	  "Y29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3QgRzQwggIiMA0GCSqG\n" +
	  "SIb3DQEBAQUAA4ICDwAwggIKAoICAQC/5pBzaN675F1KPDAiMGkz7MKnJS7JIT3y\n" +
	  "ithZwuEppz1Yq3aaza57G4QNxDAf8xukOBbrVsaXbR2rsnnyyhHS5F/WBTxSD1If\n" +
	  "xp4VpX6+n6lXFllVcq9ok3DCsrp1mWpzMpTREEQQLt+C8weE5nQ7bXHiLQwb7iDV\n" +
	  "ySAdYyktzuxeTsiT+CFhmzTrBcZe7FsavOvJz82sNEBfsXpm7nfISKhmV1efVFiO\n" +
	  "DCu3T6cw2Vbuyntd463JT17lNecxy9qTXtyOj4DatpGYQJB5w3jHtrHEtWoYOAMQ\n" +
	  "jdjUN6QuBX2I9YI+EJFwq1WCQTLX2wRzKm6RAXwhTNS8rhsDdV14Ztk6MUSaM0C/\n" +
	  "CNdaSaTC5qmgZ92kJ7yhTzm1EVgX9yRcRo9k98FpiHaYdj1ZXUJ2h4mXaXpI8OCi\n" +
	  "EhtmmnTK3kse5w5jrubU75KSOp493ADkRSWJtppEGSt+wJS00mFt6zPZxd9LBADM\n" +
	  "fRyVw4/3IbKyEbe7f/LVjHAsQWCqsWMYRJUadmJ+9oCw++hkpjPRiQfhvbfmQ6QY\n" +
	  "uKZ3AeEPlAwhHbJUKSWJbOUOUlFHdL4mrLZBdd56rF+NP8m800ERElvlEFDrMcXK\n" +
	  "chYiCd98THU/Y+whX8QgUWtvsauGi0/C1kVfnSD8oR7FwI+isX4KJpn15GkvmB0t\n" +
	  "9dmpsh3lGwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB\n" +
	  "hjAdBgNVHQ4EFgQU7NfjgtJxXWRM3y5nP+e6mK4cD08wDQYJKoZIhvcNAQEMBQAD\n" +
	  "ggIBALth2X2pbL4XxJEbw6GiAI3jZGgPVs93rnD5/ZpKmbnJeFwMDF/k5hQpVgs2\n" +
	  "SV1EY+CtnJYYZhsjDT156W1r1lT40jzBQ0CuHVD1UvyQO7uYmWlrx8GnqGikJ9yd\n" +
	  "+SeuMIW59mdNOj6PWTkiU0TryF0Dyu1Qen1iIQqAyHNm0aAFYF/opbSnr6j3bTWc\n" +
	  "fFqK1qI4mfN4i/RN0iAL3gTujJtHgXINwBQy7zBZLq7gcfJW5GqXb5JQbZaNaHqa\n" +
	  "sjYUegbyJLkJEVDXCLG4iXqEI2FCKeWjzaIgQdfRnGTZ6iahixTXTBmyUEFxPT9N\n" +
	  "cCOGDErcgdLMMpSEDQgJlxxPwO5rIHQw0uA5NBCFIRUBCOhVMt5xSdkoF1BN5r5N\n" +
	  "0XWs0Mr7QbhDparTwwVETyw2m+L64kW4I1NsBm9nVX9GtUw/bihaeSbSpKhil9Ie\n" +
	  "4u1Ki7wb/UdKDd9nZn6yW0HQO+T0O/QEY+nvwlQAUaCKKsnOeMzV6ocEGLPOr0mI\n" +
	  "r/OSmbaz5mEP0oUA51Aa5BuVnRmhuZyxm7EAHu/QD09CbMkKvO5D+jpxpchNJqU1\n" +
	  "/YldvIViHTLSoCtU7ZpXwdv6EM8Zt4tKG48BtieVU+i2iW1bvGjUI+iLUaJW+fCm\n" +
	  "gKDWHrO8Dw9TdSmq6hN35N6MgSGtBxBHEa2HPQfRdbzP82Z+\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // Equifax_Secure_Certificate_Authority
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDIDCCAomgAwIBAgIENd70zzANBgkqhkiG9w0BAQUFADBOMQswCQYDVQQGEwJV\n" +
	  "UzEQMA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2Vy\n" +
	  "dGlmaWNhdGUgQXV0aG9yaXR5MB4XDTk4MDgyMjE2NDE1MVoXDTE4MDgyMjE2NDE1\n" +
	  "MVowTjELMAkGA1UEBhMCVVMxEDAOBgNVBAoTB0VxdWlmYXgxLTArBgNVBAsTJEVx\n" +
	  "dWlmYXggU2VjdXJlIENlcnRpZmljYXRlIEF1dGhvcml0eTCBnzANBgkqhkiG9w0B\n" +
	  "AQEFAAOBjQAwgYkCgYEAwV2xWGcIYu6gmi0fCG2RFGiYCh7+2gRvE4RiIcPRfM6f\n" +
	  "BeC4AfBONOziipUEZKzxa1NfBbPLZ4C/QgKO/t0BCezhABRP/PvwDN1Dulsr4R+A\n" +
	  "cJkVV5MW8Q+XarfCaCMczE1ZMKxRHjuvK9buY0V7xdlfUNLjUA86iOe/FP3gx7kC\n" +
	  "AwEAAaOCAQkwggEFMHAGA1UdHwRpMGcwZaBjoGGkXzBdMQswCQYDVQQGEwJVUzEQ\n" +
	  "MA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2VydGlm\n" +
	  "aWNhdGUgQXV0aG9yaXR5MQ0wCwYDVQQDEwRDUkwxMBoGA1UdEAQTMBGBDzIwMTgw\n" +
	  "ODIyMTY0MTUxWjALBgNVHQ8EBAMCAQYwHwYDVR0jBBgwFoAUSOZo+SvSspXXR9gj\n" +
	  "IBBPM5iQn9QwHQYDVR0OBBYEFEjmaPkr0rKV10fYIyAQTzOYkJ/UMAwGA1UdEwQF\n" +
	  "MAMBAf8wGgYJKoZIhvZ9B0EABA0wCxsFVjMuMGMDAgbAMA0GCSqGSIb3DQEBBQUA\n" +
	  "A4GBAFjOKer89961zgK5F7WF0bnj4JXMJTENAKaSbn+2kmOeUJXRmm/kEd5jhW6Y\n" +
	  "7qj/WsjTVbJmcVfewCHrPSqnI0kBBIZCe/zuf6IWUrVnZ9NA2zsmWLIodz2uFHdh\n" +
	  "1voqZiegDfqnc1zqcPGUIWVEX/r87yloqaKHee9570+sB3c4\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GeoTrust_Global_CA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDVDCCAjygAwIBAgIDAjRWMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\n" +
	  "MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i\n" +
	  "YWwgQ0EwHhcNMDIwNTIxMDQwMDAwWhcNMjIwNTIxMDQwMDAwWjBCMQswCQYDVQQG\n" +
	  "EwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEbMBkGA1UEAxMSR2VvVHJ1c3Qg\n" +
	  "R2xvYmFsIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2swYYzD9\n" +
	  "9BcjGlZ+W988bDjkcbd4kdS8odhM+KhDtgPpTSEHCIjaWC9mOSm9BXiLnTjoBbdq\n" +
	  "fnGk5sRgprDvgOSJKA+eJdbtg/OtppHHmMlCGDUUna2YRpIuT8rxh0PBFpVXLVDv\n" +
	  "iS2Aelet8u5fa9IAjbkU+BQVNdnARqN7csiRv8lVK83Qlz6cJmTM386DGXHKTubU\n" +
	  "1XupGc1V3sjs0l44U+VcT4wt/lAjNvxm5suOpDkZALeVAjmRCw7+OC7RHQWa9k0+\n" +
	  "bw8HHa8sHo9gOeL6NlMTOdReJivbPagUvTLrGAMoUgRx5aszPeE4uwc2hGKceeoW\n" +
	  "MPRfwCvocWvk+QIDAQABo1MwUTAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTA\n" +
	  "ephojYn7qwVkDBF9qn1luMrMTjAfBgNVHSMEGDAWgBTAephojYn7qwVkDBF9qn1l\n" +
	  "uMrMTjANBgkqhkiG9w0BAQUFAAOCAQEANeMpauUvXVSOKVCUn5kaFOSPeCpilKIn\n" +
	  "Z57QzxpeR+nBsqTP3UEaBU6bS+5Kb1VSsyShNwrrZHYqLizz/Tt1kL/6cdjHPTfS\n" +
	  "tQWVYrmm3ok9Nns4d0iXrKYgjy6myQzCsplFAMfOEVEiIuCl6rYVSAlk6l5PdPcF\n" +
	  "PseKUgzbFbS9bZvlxrFUaKnjaZC2mqUPuLk/IH2uSrW4nOQdtqvmlKXBx4Ot2/Un\n" +
	  "hw4EbNX/3aBd7YdStysVAq45pmp06drE57xNNB6pXE0zX5IJL4hmXXeXxx12E6nV\n" +
	  "5fEWCRE11azbJHFwLJhWC9kXtNHjUStedejV0NxPNO3CBWaAocvmMw==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GeoTrust_Global_CA2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDZjCCAk6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBEMQswCQYDVQQGEwJVUzEW\n" +
	  "MBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEdMBsGA1UEAxMUR2VvVHJ1c3QgR2xvYmFs\n" +
	  "IENBIDIwHhcNMDQwMzA0MDUwMDAwWhcNMTkwMzA0MDUwMDAwWjBEMQswCQYDVQQG\n" +
	  "EwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEdMBsGA1UEAxMUR2VvVHJ1c3Qg\n" +
	  "R2xvYmFsIENBIDIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDvPE1A\n" +
	  "PRDfO1MA4Wf+lGAVPoWI8YkNkMgoI5kF6CsgncbzYEbYwbLVjDHZ3CB5JIG/NTL8\n" +
	  "Y2nbsSpr7iFY8gjpeMtvy/wWUsiRxP89c96xPqfCfWbB9X5SJBri1WeR0IIQ13hL\n" +
	  "TytCOb1kLUCgsBDTOEhGiKEMuzozKmKY+wCdE1l/bztyqu6mD4b5BWHqZ38MN5aL\n" +
	  "5mkWRxHCJ1kDs6ZgwiFAVvqgx306E+PsV8ez1q6diYD3Aecs9pYrEw15LNnA5IZ7\n" +
	  "S4wMcoKK+xfNAGw6EzywhIdLFnopsk/bHdQL82Y3vdj2V7teJHq4PIu5+pIaGoSe\n" +
	  "2HSPqht/XvT+RSIhAgMBAAGjYzBhMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\n" +
	  "FHE4NvICMVNHK266ZUapEBVYIAUJMB8GA1UdIwQYMBaAFHE4NvICMVNHK266ZUap\n" +
	  "EBVYIAUJMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQUFAAOCAQEAA/e1K6td\n" +
	  "EPx7srJerJsOflN4WT5CBP51o62sgU7XAotexC3IUnbHLB/8gTKY0UvGkpMzNTEv\n" +
	  "/NgdRN3ggX+d6YvhZJFiCzkIjKx0nVnZellSlxG5FntvRdOW2TF9AjYPnDtuzywN\n" +
	  "A0ZF66D0f0hExghAzN4bcLUprbqLOzRldRtxIR0sFAqwlpW41uryZfspuk/qkZN0\n" +
	  "abby/+Ea0AzRdoXLiiW9l14sbxWZJue2Kf8i7MkCx1YAzUm5s2x7UwQa4qjJqhIF\n" +
	  "I8LO57sEAszAR6LkxCkvW0VXiVHuPOtSCP8HNR6fNWpHSlaY0VqFH4z1Ir+rzoPz\n" +
	  "4iIprn2DQKi6bA==\n" +
	  "-----END CERTIFICATE----- \n",
	
	  // GeoTrust_Primary_CA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDfDCCAmSgAwIBAgIQGKy1av1pthU6Y2yv2vrEoTANBgkqhkiG9w0BAQUFADBY\n" +
	  "MQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjExMC8GA1UEAxMo\n" +
	  "R2VvVHJ1c3QgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjEx\n" +
	  "MjcwMDAwMDBaFw0zNjA3MTYyMzU5NTlaMFgxCzAJBgNVBAYTAlVTMRYwFAYDVQQK\n" +
	  "Ew1HZW9UcnVzdCBJbmMuMTEwLwYDVQQDEyhHZW9UcnVzdCBQcmltYXJ5IENlcnRp\n" +
	  "ZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC\n" +
	  "AQEAvrgVe//UfH1nrYNke8hCUy3f9oQIIGHWAVlqnEQRr+92/ZV+zmEwu3qDXwK9\n" +
	  "AWbK7hWNb6EwnL2hhZ6UOvNWiAAxz9juapYC2e0DjPt1befquFUWBRaa9OBesYjA\n" +
	  "ZIVcFU2Ix7e64HXprQU9nceJSOC7KMgD4TCTZF5SwFlwIjVXiIrxlQqD17wxcwE0\n" +
	  "7e9GceBrAqg1cmuXm2bgyxx5X9gaBGgeRwLmnWDiNpcB3841kt++Z8dtd1k7j53W\n" +
	  "kBWUvEI0EME5+bEnPn7WinXFsq+W06Lem+SYvn3h6YGttm/81w7a4DSwDRp35+MI\n" +
	  "mO9Y+pyEtzavwt+s0vQQBnBxNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4G\n" +
	  "A1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQULNVQQZcVi/CPNmFbSvtr2ZnJM5IwDQYJ\n" +
	  "KoZIhvcNAQEFBQADggEBAFpwfyzdtzRP9YZRqSa+S7iq8XEN3GHHoOo0Hnp3DwQ1\n" +
	  "6CePbJC/kRYkRj5KTs4rFtULUh38H2eiAkUxT87z+gOneZ1TatnaYzr4gNfTmeGl\n" +
	  "4b7UVXGYNTq+k+qurUKykG/g/CFNNWMziUnWm07Kx+dOCQD32sfvmWKZd7aVIl6K\n" +
	  "oKv0uHiYyjgZmclynnjNS6yvGaBzEi38wkG6gZHaFloxt/m0cYASSJlyc1pZU8Fj\n" +
	  "UjPtp8nSOQJw+uCxQmYpqptR7TBUIhRf2asdweSU8Pj1K/fqynhG1riR/aYNKxoU\n" +
	  "AT6A8EKglQdebc3MS6RFjasS6LPeWuWgfOgPIh1a6Vk=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GeoTrust_Primary_CA_G2_ECC
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIICrjCCAjWgAwIBAgIQPLL0SAoA4v7rJDteYD7DazAKBggqhkjOPQQDAzCBmDEL\n" +
	  "MAkGA1UEBhMCVVMxFjAUBgNVBAoTDUdlb1RydXN0IEluYy4xOTA3BgNVBAsTMChj\n" +
	  "KSAyMDA3IEdlb1RydXN0IEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTE2\n" +
	  "MDQGA1UEAxMtR2VvVHJ1c3QgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0\n" +
	  "eSAtIEcyMB4XDTA3MTEwNTAwMDAwMFoXDTM4MDExODIzNTk1OVowgZgxCzAJBgNV\n" +
	  "BAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMTkwNwYDVQQLEzAoYykgMjAw\n" +
	  "NyBHZW9UcnVzdCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxNjA0BgNV\n" +
	  "BAMTLUdlb1RydXN0IFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBH\n" +
	  "MjB2MBAGByqGSM49AgEGBSuBBAAiA2IABBWx6P0DFUPlrOuHNxFi79KDNlJ9RVcL\n" +
	  "So17VDs6bl8VAsBQps8lL33KSLjHUGMcKiEIfJo22Av+0SbFWDEwKCXzXV2juLal\n" +
	  "tJLtbCyf691DiaI8S0iRHVDsJt/WYC69IaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO\n" +
	  "BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFBVfNVdRVfslsq0DafwBo/q+EVXVMAoG\n" +
	  "CCqGSM49BAMDA2cAMGQCMGSWWaboCd6LuvpaiIjwH5HTRqjySkwCY/tsXzjbLkGT\n" +
	  "qQ7mndwxHLKgpxgceeHHNgIwOlavmnRs9vuD4DPTCF+hnMJbn0bWtsuRBmOiBucz\n" +
	  "rD6ogRLQy7rQkgu2npaqBA+K\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GeoTrust_Universal_CA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIFaDCCA1CgAwIBAgIBATANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJVUzEW\n" +
	  "MBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEeMBwGA1UEAxMVR2VvVHJ1c3QgVW5pdmVy\n" +
	  "c2FsIENBMB4XDTA0MDMwNDA1MDAwMFoXDTI5MDMwNDA1MDAwMFowRTELMAkGA1UE\n" +
	  "BhMCVVMxFjAUBgNVBAoTDUdlb1RydXN0IEluYy4xHjAcBgNVBAMTFUdlb1RydXN0\n" +
	  "IFVuaXZlcnNhbCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKYV\n" +
	  "VaCjxuAfjJ0hUNfBvitbtaSeodlyWL0AG0y/YckUHUWCq8YdgNY96xCcOq9tJPi8\n" +
	  "cQGeBvV8Xx7BDlXKg5pZMK4ZyzBIle0iN430SppyZj6tlcDgFgDgEB8rMQ7XlFTT\n" +
	  "QjOgNB0eRXbdT8oYN+yFFXoZCPzVx5zw8qkuEKmS5j1YPakWaDwvdSEYfyh3peFh\n" +
	  "F7em6fgemdtzbvQKoiFs7tqqhZJmr/Z6a4LauiIINQ/PQvE1+mrufislzDoR5G2v\n" +
	  "c7J2Ha3QsnhnGqQ5HFELZ1aD/ThdDc7d8Lsrlh/eezJS/R27tQahsiFepdaVaH/w\n" +
	  "mZ7cRQg+59IJDTWU3YBOU5fXtQlEIGQWFwMCTFMNaN7VqnJNk22CDtucvc+081xd\n" +
	  "VHppCZbW2xHBjXWotM85yM48vCR85mLK4b19p71XZQvk/iXttmkQ3CgaRr0BHdCX\n" +
	  "teGYO8A3ZNY9lO4L4fUorgtWv3GLIylBjobFS1J72HGrH4oVpjuDWtdYAVHGTEHZ\n" +
	  "f9hBZ3KiKN9gg6meyHv8U3NyWfWTehd2Ds735VzZC1U0oqpbtWpU5xPKV+yXbfRe\n" +
	  "Bi9Fi1jUIxaS5BZuKGNZMN9QAZxjiRqf2xeUgnA3wySemkfWWspOqGmJch+RbNt+\n" +
	  "nhutxx9z3SxPGWX9f5NAEC7S8O08ni4oPmkmM8V7AgMBAAGjYzBhMA8GA1UdEwEB\n" +
	  "/wQFMAMBAf8wHQYDVR0OBBYEFNq7LqqwDLiIJlF0XG0D08DYj3rWMB8GA1UdIwQY\n" +
	  "MBaAFNq7LqqwDLiIJlF0XG0D08DYj3rWMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG\n" +
	  "9w0BAQUFAAOCAgEAMXjmx7XfuJRAyXHEqDXsRh3ChfMoWIawC/yOsjmPRFWrZIRc\n" +
	  "aanQmjg8+uUfNeVE44B5lGiku8SfPeE0zTBGi1QrlaXv9z+ZhP015s8xxtxqv6fX\n" +
	  "IwjhmF7DWgh2qaavdy+3YL1ERmrvl/9zlcGO6JP7/TG37FcREUWbMPEaiDnBTzyn\n" +
	  "ANXH/KttgCJwpQzgXQQpAvvLoJHRfNbDflDVnVi+QTjruXU8FdmbyUqDWcDaU/0z\n" +
	  "uzYYm4UPFd3uLax2k7nZAY1IEKj79TiG8dsKxr2EoyNB3tZ3b4XUhRxQ4K5RirqN\n" +
	  "Pnbiucon8l+f725ZDQbYKxek0nxru18UGkiPGkzns0ccjkxFKyDuSN/n3QmOGKja\n" +
	  "QI2SJhFTYXNd673nxE0pN2HrrDktZy4W1vUAg4WhzH92xH3kt0tm7wNFYGm2DFKW\n" +
	  "koRepqO1pD4r2czYG0eq8kTaT/kD6PAUyz/zg97QwVTjt+gKN02LIFkDMBmhLMi9\n" +
	  "ER/frslKxfMnZmaGrGiR/9nmUxwPi1xpZQomyB40w11Re9epnAahNt3ViZS82eQt\n" +
	  "DF4JbAiXfKM9fJP/P6EUp8+1Xevb2xzEdt+Iub1FBZUbrvxGakyvSOPOrg/Sfuvm\n" +
	  "bJxPgWp6ZKy7PtXny3YuxadIwVyQD8vIP/rmMuGNG2+k5o7Y+SlIis5z/iw=\n" +
	  "-----END CERTIFICATE----- \n",
	
	  // GeoTrust_Universal_CA2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIFbDCCA1SgAwIBAgIBATANBgkqhkiG9w0BAQUFADBHMQswCQYDVQQGEwJVUzEW\n" +
	  "MBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEgMB4GA1UEAxMXR2VvVHJ1c3QgVW5pdmVy\n" +
	  "c2FsIENBIDIwHhcNMDQwMzA0MDUwMDAwWhcNMjkwMzA0MDUwMDAwWjBHMQswCQYD\n" +
	  "VQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEgMB4GA1UEAxMXR2VvVHJ1\n" +
	  "c3QgVW5pdmVyc2FsIENBIDIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC\n" +
	  "AQCzVFLByT7y2dyxUxpZKeexw0Uo5dfR7cXFS6GqdHtXr0om/Nj1XqduGdt0DE81\n" +
	  "WzILAePb63p3NeqqWuDW6KFXlPCQo3RWlEQwAx5cTiuFJnSCegx2oG9NzkEtoBUG\n" +
	  "FF+3Qs17j1hhNNwqCPkuwwGmIkQcTAeC5lvO0Ep8BNMZcyfwqph/Lq9O64ceJHdq\n" +
	  "XbboW0W63MOhBW9Wjo8QJqVJwy7XQYci4E+GymC16qFjwAGXEHm9ADwSbSsVsaxL\n" +
	  "se4YuU6W3Nx2/zu+z18DwPw76L5GG//aQMJS9/7jOvdqdzXQ2o3rXhhqMcceujwb\n" +
	  "KNZrVMaqW9eiLBsZzKIC9ptZvTdrhrVtgrrY6slWvKk2WP0+GfPtDCapkzj4T8Fd\n" +
	  "IgbQl+rhrcZV4IErKIM6+vR7IVEAvlI4zs1meaj0gVbi0IMJR1FbUGrP20gaXT73\n" +
	  "y/Zl92zxlfgCOzJWgjl6W70viRu/obTo/3+NjN8D8WBOWBFM66M/ECuDmgFz2ZRt\n" +
	  "hAAnZqzwcEAJQpKtT5MNYQlRJNiS1QuUYbKHsu3/mjX/hVTK7URDrBs8FmtISgoc\n" +
	  "QIgfksILAAX/8sgCSqSqqcyZlpwvWOB94b67B9xfBHJcMTTD7F8t4D1kkCLm0ey4\n" +
	  "Lt1ZrtmhN79UNdxzMk+MBB4zsslG8dhcyFVQyWi9qLo2CQIDAQABo2MwYTAPBgNV\n" +
	  "HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR281Xh+qQ2+/CfXGJx7Tz0RzgQKzAfBgNV\n" +
	  "HSMEGDAWgBR281Xh+qQ2+/CfXGJx7Tz0RzgQKzAOBgNVHQ8BAf8EBAMCAYYwDQYJ\n" +
	  "KoZIhvcNAQEFBQADggIBAGbBxiPz2eAubl/oz66wsCVNK/g7WJtAJDday6sWSf+z\n" +
	  "dXkzoS9tcBc0kf5nfo/sm+VegqlVHy/c1FEHEv6sFj4sNcZj/NwQ6w2jqtB8zNHQ\n" +
	  "L1EuxBRa3ugZ4T7GzKQp5y6EqgYweHZUcyiYWTjgAA1i00J9IZ+uPTqM1fp3DRgr\n" +
	  "Fg5fNuH8KrUwJM/gYwx7WBr+mbpCErGR9Hxo4sjoryzqyX6uuyo9DRXcNJW2GHSo\n" +
	  "ag/HtPQTxORb7QrSpJdMKu0vbBKJPfEncKpqA1Ihn0CoZ1Dy81of398j9tx4TuaY\n" +
	  "T1U6U+Pv8vSfx3zYWK8pIpe44L2RLrB27FcRz+8pRPPphXpgY+RdM4kX2TGq2tbz\n" +
	  "GDVyz4crL2MjhF2EjD9XoIj8mZEoJmmZ1I+XRL6O1UixpCgp8RW04eWe3fiPpm8m\n" +
	  "1wk8OhwRDqZsN/etRIcsKMfYdIKz0G9KV7s1KSegi+ghp4dkNl3M2Basx7InQJJV\n" +
	  "OCiNUW7dFGdTbHFcJoRNdVq2fmBWqU2t+5sel/MN2dKXVHfaPRK34B7vCAas+YWH\n" +
	  "6aLcr34YEoP9VhdBLtUpgn2Z9DH2canPLAEnpQW5qrJITirvn5NSUZU8UnOOVkwX\n" +
	  "QMAJKOSLakhT2+zNVVXxxvjpoixMptEmX36vWkzaH6byHCx+rgIW0lbQL1dTR+iS\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GlobalSign_Root_CA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\n" +
	  "A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\n" +
	  "b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\n" +
	  "MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\n" +
	  "YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\n" +
	  "aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\n" +
	  "jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\n" +
	  "xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\n" +
	  "1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\n" +
	  "snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\n" +
	  "U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\n" +
	  "9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\n" +
	  "BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\n" +
	  "AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\n" +
	  "yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\n" +
	  "38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\n" +
	  "AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\n" +
	  "DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\n" +
	  "HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GlobalSign_Root_CA_ECC_R4
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIB4TCCAYegAwIBAgIRKjikHJYKBN5CsiilC+g0mAIwCgYIKoZIzj0EAwIwUDEk\n" +
	  "MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI0MRMwEQYDVQQKEwpH\n" +
	  "bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoX\n" +
	  "DTM4MDExOTAzMTQwN1owUDEkMCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBD\n" +
	  "QSAtIFI0MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu\n" +
	  "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEuMZ5049sJQ6fLjkZHAOkrprlOQcJ\n" +
	  "FspjsbmG+IpXwVfOQvpzofdlQv8ewQCybnMO/8ch5RikqtlxP6jUuc6MHaNCMEAw\n" +
	  "DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFSwe61F\n" +
	  "uOJAf/sKbvu+M8k8o4TVMAoGCCqGSM49BAMCA0gAMEUCIQDckqGgE6bPA7DmxCGX\n" +
	  "kPoUVy0D7O48027KqGx2vKLeuwIgJ6iFJzWbVsaj8kfSt24bAgAXqmemFZHe+pTs\n" +
	  "ewv4n4Q=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GlobalSign_Root_CA_ECC_R5
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIICHjCCAaSgAwIBAgIRYFlJ4CYuu1X5CneKcflK2GwwCgYIKoZIzj0EAwMwUDEk\n" +
	  "MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI1MRMwEQYDVQQKEwpH\n" +
	  "bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoX\n" +
	  "DTM4MDExOTAzMTQwN1owUDEkMCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBD\n" +
	  "QSAtIFI1MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu\n" +
	  "MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAER0UOlvt9Xb/pOdEh+J8LttV7HpI6SFkc\n" +
	  "8GIxLcB6KP4ap1yztsyX50XUWPrRd21DosCHZTQKH3rd6zwzocWdTaRvQZU4f8ke\n" +
	  "hOvRnkmSh5SHDDqFSmafnVmTTZdhBoZKo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYD\n" +
	  "VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUPeYpSJvqB8ohREom3m7e0oPQn1kwCgYI\n" +
	  "KoZIzj0EAwMDaAAwZQIxAOVpEslu28YxuglB4Zf4+/2a4n0Sye18ZNPLBSWLVtmg\n" +
	  "515dTguDnFt2KaAJJiFqYgIwcdK1j1zqO+F4CYWodZI7yFz9SO8NdCKoCOJuxUnO\n" +
	  "xwy8p2Fp8fc74SrL+SvzZpA3\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GlobalSign_Root_CA_R3
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\n" +
	  "A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\n" +
	  "Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\n" +
	  "MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\n" +
	  "A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\n" +
	  "hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\n" +
	  "RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\n" +
	  "gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\n" +
	  "KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\n" +
	  "QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\n" +
	  "XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\n" +
	  "DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\n" +
	  "LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\n" +
	  "RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\n" +
	  "jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\n" +
	  "6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\n" +
	  "mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\n" +
	  "Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\n" +
	  "WD9f\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // GlobalSign_Root_CA_RC2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4G\n" +
	  "A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNp\n" +
	  "Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1\n" +
	  "MDgwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEG\n" +
	  "A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\n" +
	  "hvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8omUVCxKs+IVSbC9N/hHD6ErPL\n" +
	  "v4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7SqbKSaZeqKeMWhG8\n" +
	  "eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQBoZfXklq\n" +
	  "tTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd\n" +
	  "C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pa\n" +
	  "zq+r1feqCapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCB\n" +
	  "mTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IH\n" +
	  "V2ccHsBqBt5ZtJot39wZhi4wNgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5n\n" +
	  "bG9iYWxzaWduLm5ldC9yb290LXIyLmNybDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG\n" +
	  "3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEAmYFThxxol4aR7OBKuEQLq4Gs\n" +
	  "J0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkIk7mpM0sYmsL4h4hO\n" +
	  "291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRDLenVOavS\n" +
	  "ot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd\n" +
	  "AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7\n" +
	  "TBj0/VLZjmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-2G2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDAzCCAmwCEQC5L2DMiJ+hekYJuFtwbIqvMA0GCSqGSIb3DQEBBQUAMIHBMQsw\n" +
	  "CQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xPDA6BgNVBAsTM0Ns\n" +
	  "YXNzIDIgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBH\n" +
	  "MjE6MDgGA1UECxMxKGMpIDE5OTggVmVyaVNpZ24sIEluYy4gLSBGb3IgYXV0aG9y\n" +
	  "aXplZCB1c2Ugb25seTEfMB0GA1UECxMWVmVyaVNpZ24gVHJ1c3QgTmV0d29yazAe\n" +
	  "Fw05ODA1MTgwMDAwMDBaFw0yODA4MDEyMzU5NTlaMIHBMQswCQYDVQQGEwJVUzEX\n" +
	  "MBUGA1UEChMOVmVyaVNpZ24sIEluYy4xPDA6BgNVBAsTM0NsYXNzIDIgUHVibGlj\n" +
	  "IFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHMjE6MDgGA1UECxMx\n" +
	  "KGMpIDE5OTggVmVyaVNpZ24sIEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25s\n" +
	  "eTEfMB0GA1UECxMWVmVyaVNpZ24gVHJ1c3QgTmV0d29yazCBnzANBgkqhkiG9w0B\n" +
	  "AQEFAAOBjQAwgYkCgYEAp4gBIXQs5xoD8JjhlzwPIQjxnNuX6Zr8wgQGE75fUsjM\n" +
	  "HiwSViy4AWkszJkfrbCWrnkE8hM5wXuYuggs6MKEEyyqaekJ9MepAqRCwiNPStjw\n" +
	  "DqL7MWzJ5m+ZJwf15vRMeJ5t60aG+rmGyVTyssSv1EYcWskVMP8NbPUtDm3Of3cC\n" +
	  "AwEAATANBgkqhkiG9w0BAQUFAAOBgQByLvl/0fFx+8Se9sVeUYpAmLho+Jscg9ji\n" +
	  "nb3/7aHmZuovCfTK1+qlK5X2JGCGTUQug6XELaDTrnhpb3LabK4I8GOSN+a7xDAX\n" +
	  "rXfMSTWqz9iP0b63GJZHc2pUIjRkLbYWm1lbtFFZOrMLFPQS32eg9K0yZF6xRnIn\n" +
	  "jBJ7xUS0rg==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-2G3
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEGTCCAwECEGFwy0mMX5hFKeewptlQW3owDQYJKoZIhvcNAQEFBQAwgcoxCzAJ\n" +
	  "BgNVBAYTAlVTMRcwFQYDVQQKEw5WZXJpU2lnbiwgSW5jLjEfMB0GA1UECxMWVmVy\n" +
	  "aVNpZ24gVHJ1c3QgTmV0d29yazE6MDgGA1UECxMxKGMpIDE5OTkgVmVyaVNpZ24s\n" +
	  "IEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTFFMEMGA1UEAxM8VmVyaVNp\n" +
	  "Z24gQ2xhc3MgMiBQdWJsaWMgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0\n" +
	  "eSAtIEczMB4XDTk5MTAwMTAwMDAwMFoXDTM2MDcxNjIzNTk1OVowgcoxCzAJBgNV\n" +
	  "BAYTAlVTMRcwFQYDVQQKEw5WZXJpU2lnbiwgSW5jLjEfMB0GA1UECxMWVmVyaVNp\n" +
	  "Z24gVHJ1c3QgTmV0d29yazE6MDgGA1UECxMxKGMpIDE5OTkgVmVyaVNpZ24sIElu\n" +
	  "Yy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTFFMEMGA1UEAxM8VmVyaVNpZ24g\n" +
	  "Q2xhc3MgMiBQdWJsaWMgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAt\n" +
	  "IEczMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArwoNwtUs22e5LeWU\n" +
	  "J92lvuCwTY+zYVY81nzD9M0+hsuiiOLh2KRpxbXiv8GmR1BeRjmL1Za6tW8UvxDO\n" +
	  "JxOeBUebMXoT2B/Z0wI3i60sR/COgQanDTAM6/c8DyAd3HJG7qUCyFvDyVZpTMUY\n" +
	  "wZF7C9UTAJu878NIPkZgIIUq1ZC2zYugzDLdt/1AVbJQHFauzI13TccgTacxdu9o\n" +
	  "koqQHgiBVrKtaaNS0MscxCM9H5n+TOgWY47GCI72MfbS+uV23bUckqNJzc0BzWjN\n" +
	  "qWm6o+sdDZykIKbBoMXRRkwXbdKsZj+WjOCE1Db/IlnF+RFgqF8EffIa9iVCYQ/E\n" +
	  "Srg+iQIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQA0JhU8wI1NQ0kdvekhktdmnLfe\n" +
	  "xbjQ5F1fdiLAJvmEOjr5jLX77GDx6M4EsMjdpwOPMPOY36TmpDHf0xwLRtxyID+u\n" +
	  "7gU8pDM/CzmscHhzS5kr3zDCVLCoO1Wh/hYozUK9dG6A2ydEp85EXdQbkJgNHkKU\n" +
	  "sQAsBNB0owIFImNjzYO1+8FtYmtpdf1dcEG59b98377BMnMiIYtYgXsVkXq642RI\n" +
	  "sH/7NiXaldDxJBQX3RiAa0YjOVT1jmIJBB2UkKab5iXiQkWquJCtvgiPqQtCGJTP\n" +
	  "cjnhsUPgKM+351psE2tJs//jGHyJizNdrDPXp/naOlXJWBD5qu9ats9LS98q\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-3
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIICPDCCAaUCEDyRMcsf9tAbDpq40ES/Er4wDQYJKoZIhvcNAQEFBQAwXzELMAkG\n" +
	  "A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFz\n" +
	  "cyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTk2\n" +
	  "MDEyOTAwMDAwMFoXDTI4MDgwMjIzNTk1OVowXzELMAkGA1UEBhMCVVMxFzAVBgNV\n" +
	  "BAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFzcyAzIFB1YmxpYyBQcmlt\n" +
	  "YXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GN\n" +
	  "ADCBiQKBgQDJXFme8huKARS0EN8EQNvjV69qRUCPhAwL0TPZ2RHP7gJYHyX3KqhE\n" +
	  "BarsAx94f56TuZoAqiN91qyFomNFx3InzPRMxnVx0jnvT0Lwdd8KkMaOIG+YD/is\n" +
	  "I19wKTakyYbnsZogy1Olhec9vn2a/iRFM9x2Fe0PonFkTGUugWhFpwIDAQABMA0G\n" +
	  "CSqGSIb3DQEBBQUAA4GBABByUqkFFBkyCEHwxWsKzH4PIRnN5GfcX6kb5sroc50i\n" +
	  "2JhucwNhkcV8sEVAbkSdjbCxlnRhLQ2pRdKkkirWmnWXbj9T/UWZYB2oK0z5XqcJ\n" +
	  "2HUw19JlYD1n1khVdWk/kfVIC0dpImmClr7JyDiGSnoscxlIaU5rfGW/D/xwzoiQ\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-3G2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDAjCCAmsCEH3Z/gfPqB63EHln+6eJNMYwDQYJKoZIhvcNAQEFBQAwgcExCzAJ\n" +
	  "BgNVBAYTAlVTMRcwFQYDVQQKEw5WZXJpU2lnbiwgSW5jLjE8MDoGA1UECxMzQ2xh\n" +
	  "c3MgMyBQdWJsaWMgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEcy\n" +
	  "MTowOAYDVQQLEzEoYykgMTk5OCBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3Jp\n" +
	  "emVkIHVzZSBvbmx5MR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMB4X\n" +
	  "DTk4MDUxODAwMDAwMFoXDTI4MDgwMTIzNTk1OVowgcExCzAJBgNVBAYTAlVTMRcw\n" +
	  "FQYDVQQKEw5WZXJpU2lnbiwgSW5jLjE8MDoGA1UECxMzQ2xhc3MgMyBQdWJsaWMg\n" +
	  "UHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEcyMTowOAYDVQQLEzEo\n" +
	  "YykgMTk5OCBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5\n" +
	  "MR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMIGfMA0GCSqGSIb3DQEB\n" +
	  "AQUAA4GNADCBiQKBgQDMXtERXVxp0KvTuWpMmR9ZmDCOFoUgRm1HP9SFIIThbbP4\n" +
	  "pO0M8RcPO/mn+SXXwc+EY/J8Y8+iR/LGWzOOZEAEaMGAuWQcRXfH2G71lSk8UOg0\n" +
	  "13gfqLptQ5GVj0VXXn7F+8qkBOvqlzdUMG+7AUcyM83cV5tkaWH4mx0ciU9cZwID\n" +
	  "AQABMA0GCSqGSIb3DQEBBQUAA4GBAFFNzb5cy5gZnBWyATl4Lk0PZ3BwmcYQWpSk\n" +
	  "U01UbSuvDV1Ai2TT1+7eVmGSX6bEHRBhNtMsJzzoKQm5EWR0zLVznxxIqbxhAe7i\n" +
	  "F6YM40AIOw7n60RzKprxaZLvcRTDOaxxp5EJb+RxBrO6WVcmeQD2+A2iMzAo1KpY\n" +
	  "oJ2daZH9\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-3G3
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEGjCCAwICEQCbfgZJoz5iudXukEhxKe9XMA0GCSqGSIb3DQEBBQUAMIHKMQsw\n" +
	  "CQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZl\n" +
	  "cmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWdu\n" +
	  "LCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlT\n" +
	  "aWduIENsYXNzIDMgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3Jp\n" +
	  "dHkgLSBHMzAeFw05OTEwMDEwMDAwMDBaFw0zNjA3MTYyMzU5NTlaMIHKMQswCQYD\n" +
	  "VQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlT\n" +
	  "aWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWduLCBJ\n" +
	  "bmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlTaWdu\n" +
	  "IENsYXNzIDMgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkg\n" +
	  "LSBHMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMu6nFL8eB8aHm8b\n" +
	  "N3O9+MlrlBIwT/A2R/XQkQr1F8ilYcEWQE37imGQ5XYgwREGfassbqb1EUGO+i2t\n" +
	  "KmFZpGcmTNDovFJbcCAEWNF6yaRpvIMXZK0Fi7zQWM6NjPXr8EJJC52XJ2cybuGu\n" +
	  "kxUccLwgTS8Y3pKI6GyFVxEa6X7jJhFUokWWVYPKMIno3Nij7SqAP395ZVc+FSBm\n" +
	  "CC+Vk7+qRy+oRpfwEuL+wgorUeZ25rdGt+INpsyow0xZVYnm6FNcHOqd8GIWC6fJ\n" +
	  "Xwzw3sJ2zq/3avL6QaaiMxTJ5Xpj055iN9WFZZ4O5lMkdBteHRJTW8cs54NJOxWu\n" +
	  "imi5V5cCAwEAATANBgkqhkiG9w0BAQUFAAOCAQEAERSWwauSCPc/L8my/uRan2Te\n" +
	  "2yFPhpk0djZX3dAVL8WtfxUfN2JzPtTnX84XA9s1+ivbrmAJXx5fj267Cz3qWhMe\n" +
	  "DGBvtcC1IyIuBwvLqXTLR7sdwdela8wv0kL9Sd2nic9TutoAWii/gt/4uhMdUIaC\n" +
	  "/Y4wjylGsB49Ndo4YhYYSq3mtlFs3q9i6wHQHiT+eo8SGhJouPtmmRQURVyu565p\n" +
	  "F4ErWjfJXir0xuKhXFSbplQAz/DxwceYMBo7Nhbbo27q/a2ywtrvAkcTisDxszGt\n" +
	  "TxzhT5yvDwyd93gN2PQ1VoDat20Xj50egWTh/sVFuq1ruQp6Tk9LhO5L8X3dEQ==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-3G4
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDhDCCAwqgAwIBAgIQL4D+I4wOIg9IZxIokYesszAKBggqhkjOPQQDAzCByjEL\n" +
	  "MAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZW\n" +
	  "ZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNyBWZXJpU2ln\n" +
	  "biwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJp\n" +
	  "U2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9y\n" +
	  "aXR5IC0gRzQwHhcNMDcxMTA1MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCByjELMAkG\n" +
	  "A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJp\n" +
	  "U2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNyBWZXJpU2lnbiwg\n" +
	  "SW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2ln\n" +
	  "biBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5\n" +
	  "IC0gRzQwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASnVnp8Utpkmw4tXNherJI9/gHm\n" +
	  "GUo9FANL+mAnINmDiWn6VMaaGF5VKmTeBvaNSjutEDxlPZCIBIngMGGzrl0Bp3ve\n" +
	  "fLK+ymVhAIau2o970ImtTR1ZmkGxvEeA3J5iw/mjgbIwga8wDwYDVR0TAQH/BAUw\n" +
	  "AwEB/zAOBgNVHQ8BAf8EBAMCAQYwbQYIKwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJ\n" +
	  "aW1hZ2UvZ2lmMCEwHzAHBgUrDgMCGgQUj+XTGoasjY5rw8+AatRIGCx7GS4wJRYj\n" +
	  "aHR0cDovL2xvZ28udmVyaXNpZ24uY29tL3ZzbG9nby5naWYwHQYDVR0OBBYEFLMW\n" +
	  "kf3upm7ktS5Jj4d4gYDs5bG1MAoGCCqGSM49BAMDA2gAMGUCMGYhDBgmYFo4e1ZC\n" +
	  "4Kf8NoRRkSAsdk1DPcQdhCPQrNZ8NQbOzWm9kA3bbEhCHQ6qQgIxAJw9SDkjOVga\n" +
	  "FRJZap7v1VmyHVIsmXHNxynfGyphe3HR3vPA5Q06Sqotp9iGKt0uEA==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-3G5
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIE0zCCA7ugAwIBAgIQGNrRniZ96LtKIVjNzGs7SjANBgkqhkiG9w0BAQUFADCB\n" +
	  "yjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL\n" +
	  "ExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJp\n" +
	  "U2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxW\n" +
	  "ZXJpU2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0\n" +
	  "aG9yaXR5IC0gRzUwHhcNMDYxMTA4MDAwMDAwWhcNMzYwNzE2MjM1OTU5WjCByjEL\n" +
	  "MAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZW\n" +
	  "ZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJpU2ln\n" +
	  "biwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJp\n" +
	  "U2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9y\n" +
	  "aXR5IC0gRzUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvJAgIKXo1\n" +
	  "nmAMqudLO07cfLw8RRy7K+D+KQL5VwijZIUVJ/XxrcgxiV0i6CqqpkKzj/i5Vbex\n" +
	  "t0uz/o9+B1fs70PbZmIVYc9gDaTY3vjgw2IIPVQT60nKWVSFJuUrjxuf6/WhkcIz\n" +
	  "SdhDY2pSS9KP6HBRTdGJaXvHcPaz3BJ023tdS1bTlr8Vd6Gw9KIl8q8ckmcY5fQG\n" +
	  "BO+QueQA5N06tRn/Arr0PO7gi+s3i+z016zy9vA9r911kTMZHRxAy3QkGSGT2RT+\n" +
	  "rCpSx4/VBEnkjWNHiDxpg8v+R70rfk/Fla4OndTRQ8Bnc+MUCH7lP59zuDMKz10/\n" +
	  "NIeWiu5T6CUVAgMBAAGjgbIwga8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8E\n" +
	  "BAMCAQYwbQYIKwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJaW1hZ2UvZ2lmMCEwHzAH\n" +
	  "BgUrDgMCGgQUj+XTGoasjY5rw8+AatRIGCx7GS4wJRYjaHR0cDovL2xvZ28udmVy\n" +
	  "aXNpZ24uY29tL3ZzbG9nby5naWYwHQYDVR0OBBYEFH/TZafC3ey78DAJ80M5+gKv\n" +
	  "MzEzMA0GCSqGSIb3DQEBBQUAA4IBAQCTJEowX2LP2BqYLz3q3JktvXf2pXkiOOzE\n" +
	  "p6B4Eq1iDkVwZMXnl2YtmAl+X6/WzChl8gGqCBpH3vn5fJJaCGkgDdk+bW48DW7Y\n" +
	  "5gaRQBi5+MHt39tBquCWIMnNZBU4gcmU7qKEKQsTb47bDN0lAtukixlE0kF6BWlK\n" +
	  "WE9gyn6CagsCqiUXObXbf+eEZSqVir2G3l6BFoMtEMze/aiCKm0oHw0LxOXnGiYZ\n" +
	  "4fQRbxC1lfznQgUy286dUV4otp6F01vvpX1FQHKOtw5rDgb7MzVIcbidJ4vEZV8N\n" +
	  "hnacRHr2lVz2XTIIM6RUthg/aFzyQkqFOFSDX9HoLPKsEdao7WNq\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-4G3
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEGjCCAwICEQDsoKeLbnVqAc/EfMwvlF7XMA0GCSqGSIb3DQEBBQUAMIHKMQsw\n" +
	  "CQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZl\n" +
	  "cmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWdu\n" +
	  "LCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlT\n" +
	  "aWduIENsYXNzIDQgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3Jp\n" +
	  "dHkgLSBHMzAeFw05OTEwMDEwMDAwMDBaFw0zNjA3MTYyMzU5NTlaMIHKMQswCQYD\n" +
	  "VQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlT\n" +
	  "aWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWduLCBJ\n" +
	  "bmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlTaWdu\n" +
	  "IENsYXNzIDQgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkg\n" +
	  "LSBHMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAK3LpRFpxlmr8Y+1\n" +
	  "GQ9Wzsy1HyDkniYlS+BzZYlZ3tCD5PUPtbut8XzoIfzk6AzufEUiGXaStBO3IFsJ\n" +
	  "+mGuqPKljYXCKtbeZjbSmwL0qJJgfJxptI8kHtCGUvYynEFYHiK9zUVilQhu0Gbd\n" +
	  "U6LM8BDcVHOLBKFGMzNcF0C5nk3T875Vg+ixiY5afJqWIpA7iCXy0lOIAgwLePLm\n" +
	  "NxdLMEYH5IBtptiWLugs+BGzOA1mppvqySNb247i8xOOGlktqgLw7KSHZtzBP/XY\n" +
	  "ufTsgsbSPZUd5cBPhMnZo0QoBmrXRazwa2rvTl/4EYIeOGM0ZlDUPpNz+jDDZq3/\n" +
	  "ky2X7wMCAwEAATANBgkqhkiG9w0BAQUFAAOCAQEAj/ola09b5KROJ1WrIhVZPMq1\n" +
	  "CtRK26vdoV9TxaBXOcLORyu+OshWv8LZJxA6sQU8wHcxuzrTBXttmhwwjIDLk5Mq\n" +
	  "g6sFUYICABFna/OIYUdfA5PVWw3g8dShMjWFsjrbsIKr0csKvE+MW8VLADsfKoKm\n" +
	  "fjaF3H48ZwC15DtS4KjrXRX5xm3wrR0OhbepmnMUWluPQSjA1egtTaRezarZ7c7c\n" +
	  "2NU8Qh0XwRJdRTjDOPP8hS6DRkiy1yBfkjaP53kPmF6Z6PDQpLv1U70qzlmwr25/\n" +
	  "bLvSHgCwIe34QWKCudiyxLtGUPMxxY8BqHTr9Xgn2uf3ZkPznoM+IKrDNWCRzg==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // VeriSign-PCA-universal
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEuTCCA6GgAwIBAgIQQBrEZCGzEyEDDrvkEhrFHTANBgkqhkiG9w0BAQsFADCB\n" +
	  "vTELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL\n" +
	  "ExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwOCBWZXJp\n" +
	  "U2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MTgwNgYDVQQDEy9W\n" +
	  "ZXJpU2lnbiBVbml2ZXJzYWwgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAe\n" +
	  "Fw0wODA0MDIwMDAwMDBaFw0zNzEyMDEyMzU5NTlaMIG9MQswCQYDVQQGEwJVUzEX\n" +
	  "MBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRydXN0\n" +
	  "IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAyMDA4IFZlcmlTaWduLCBJbmMuIC0gRm9y\n" +
	  "IGF1dGhvcml6ZWQgdXNlIG9ubHkxODA2BgNVBAMTL1ZlcmlTaWduIFVuaXZlcnNh\n" +
	  "bCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEF\n" +
	  "AAOCAQ8AMIIBCgKCAQEAx2E3XrEBNNti1xWb/1hajCMj1mCOkdeQmIN65lgZOIzF\n" +
	  "9uVkhbSicfvtvbnazU0AtMgtc6XHaXGVHzk8skQHnOgO+k1KxCHfKWGPMiJhgsWH\n" +
	  "H26MfF8WIFFE0XBPV+rjHOPMee5Y2A7Cs0WTwCznmhcrewA3ekEzeOEz4vMQGn+H\n" +
	  "LL729fdC4uW/h2KJXwBL38Xd5HVEMkE6HnFuacsLdUYI0crSK5XQz/u5QGtkjFdN\n" +
	  "/BMReYTtXlT2NJ8IAfMQJQYXStrxHXpma5hgZqTZ79IugvHw7wnqRMkVauIDbjPT\n" +
	  "rJ9VAMf2CGqUuV/c4DPxhGD5WycRtPwW8rtWaoAljQIDAQABo4GyMIGvMA8GA1Ud\n" +
	  "EwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMG0GCCsGAQUFBwEMBGEwX6FdoFsw\n" +
	  "WTBXMFUWCWltYWdlL2dpZjAhMB8wBwYFKw4DAhoEFI/l0xqGrI2Oa8PPgGrUSBgs\n" +
	  "exkuMCUWI2h0dHA6Ly9sb2dvLnZlcmlzaWduLmNvbS92c2xvZ28uZ2lmMB0GA1Ud\n" +
	  "DgQWBBS2d/ppSEefUxLVwuoHMnYH0ZcHGTANBgkqhkiG9w0BAQsFAAOCAQEASvj4\n" +
	  "sAPmLGd75JR3Y8xuTPl9Dg3cyLk1uXBPY/ok+myDjEedO2Pzmvl2MpWRsXe8rJq+\n" +
	  "seQxIcaBlVZaDrHC1LGmWazxY8u4TB1ZkErvkBYoH1quEPuBUDgMbMzxPcP1Y+Oz\n" +
	  "4yHJJDnp/RVmRvQbEdBNc6N9Rvk97ahfYtTxP/jgdFcrGJ2BtMQo2pSXpXDrrB2+\n" +
	  "BxHw1dvd5Yzw1TKwg+ZX4o+/vqGqvz0dtdQ46tewXDpPaj+PwGZsY6rp2aQW9IHR\n" +
	  "lRQOfc2VNNnSj3BzgXucfr2YYdhFh5iQxeuGMMY1v/D/w1WIg0vvBZIGcfK4mJO3\n" +
	  "7M2CYfE45k+XmCpajQ==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // gd-class2-root
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEADCCAuigAwIBAgIBADANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJVUzEh\n" +
	  "MB8GA1UEChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBE\n" +
	  "YWRkeSBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA0MDYyOTE3\n" +
	  "MDYyMFoXDTM0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRo\n" +
	  "ZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3Mg\n" +
	  "MiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN\n" +
	  "ADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XCA\n" +
	  "PVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux6w\n" +
	  "wdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLOtXi\n" +
	  "EqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWoriMY\n" +
	  "avx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZEewo+\n" +
	  "YihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjgcAwgb0wHQYDVR0OBBYEFNLE\n" +
	  "sNKR1EwRcbNhyz2h/t2oatTjMIGNBgNVHSMEgYUwgYKAFNLEsNKR1EwRcbNhyz2h\n" +
	  "/t2oatTjoWekZTBjMQswCQYDVQQGEwJVUzEhMB8GA1UEChMYVGhlIEdvIERhZGR5\n" +
	  "IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRkeSBDbGFzcyAyIENlcnRpZmlj\n" +
	  "YXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQAD\n" +
	  "ggEBADJL87LKPpH8EsahB4yOd6AzBhRckB4Y9wimPQoZ+YeAEW5p5JYXMP80kWNy\n" +
	  "OO7MHAGjHZQopDH2esRU1/blMVgDoszOYtuURXO1v0XJJLXVggKtI3lpjbi2Tc7P\n" +
	  "TMozI+gciKqdi0FuFskg5YmezTvacPd+mSYgFFQlq25zheabIZ0KbIIOqPjCDPoQ\n" +
	  "HmyW74cNxA9hi63ugyuV+I6ShHI56yDqg+2DzZduCLzrTia2cyvk0/ZM/iZx4mER\n" +
	  "dEr/VxqHD3VILs9RaRegAhJhldXRQLIQTO7ErBBDpqWeCtWVYpoNz4iCxTIM5Cuf\n" +
	  "ReYNnyicsbkqWletNw+vHX/bvZ8=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // gdroot-g2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDxTCCAq2gAwIBAgIBADANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCVVMx\n" +
	  "EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAYBgNVBAoT\n" +
	  "EUdvRGFkZHkuY29tLCBJbmMuMTEwLwYDVQQDEyhHbyBEYWRkeSBSb290IENlcnRp\n" +
	  "ZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIz\n" +
	  "NTk1OVowgYMxCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQH\n" +
	  "EwpTY290dHNkYWxlMRowGAYDVQQKExFHb0RhZGR5LmNvbSwgSW5jLjExMC8GA1UE\n" +
	  "AxMoR28gRGFkZHkgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIw\n" +
	  "DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9xYgjx+lk09xvJGKP3gElY6SKD\n" +
	  "E6bFIEMBO4Tx5oVJnyfq9oQbTqC023CYxzIBsQU+B07u9PpPL1kwIuerGVZr4oAH\n" +
	  "/PMWdYA5UXvl+TW2dE6pjYIT5LY/qQOD+qK+ihVqf94Lw7YZFAXK6sOoBJQ7Rnwy\n" +
	  "DfMAZiLIjWltNowRGLfTshxgtDj6AozO091GB94KPutdfMh8+7ArU6SSYmlRJQVh\n" +
	  "GkSBjCypQ5Yj36w6gZoOKcUcqeldHraenjAKOc7xiID7S13MMuyFYkMlNAJWJwGR\n" +
	  "tDtwKj9useiciAF9n9T521NtYJ2/LOdYq7hfRvzOxBsDPAnrSTFcaUaz4EcCAwEA\n" +
	  "AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE\n" +
	  "FDqahQcQZyi27/a9BUFuIMGU2g/eMA0GCSqGSIb3DQEBCwUAA4IBAQCZ21151fmX\n" +
	  "WWcDYfF+OwYxdS2hII5PZYe096acvNjpL9DbWu7PdIxztDhC2gV7+AJ1uP2lsdeu\n" +
	  "9tfeE8tTEH6KRtGX+rcuKxGrkLAngPnon1rpN5+r5N9ss4UXnT3ZJE95kTXWXwTr\n" +
	  "gIOrmgIttRD02JDHBHNA7XIloKmf7J6raBKZV8aPEjoJpL1E/QYVN8Gb5DKj7Tjo\n" +
	  "2GTzLH4U/ALqn83/B2gX2yKQOC16jdFU8WnjXzPKej17CuPKf1855eJ1usV2GDPO\n" +
	  "LPAvTK33sefOT6jEm0pUBsV/fdUID+Ic/n4XuKxe9tQWskMJDE32p2u0mYRlynqI\n" +
	  "4uJEvlz36hz1\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // sf-class2-root
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEDzCCAvegAwIBAgIBADANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJVUzEl\n" +
	  "MCMGA1UEChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMp\n" +
	  "U3RhcmZpZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQw\n" +
	  "NjI5MTczOTE2WhcNMzQwNjI5MTczOTE2WjBoMQswCQYDVQQGEwJVUzElMCMGA1UE\n" +
	  "ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMpU3RhcmZp\n" +
	  "ZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggEgMA0GCSqGSIb3\n" +
	  "DQEBAQUAA4IBDQAwggEIAoIBAQC3Msj+6XGmBIWtDBFk385N78gDGIc/oav7PKaf\n" +
	  "8MOh2tTYbitTkPskpD6E8J7oX+zlJ0T1KKY/e97gKvDIr1MvnsoFAZMej2YcOadN\n" +
	  "+lq2cwQlZut3f+dZxkqZJRRU6ybH838Z1TBwj6+wRir/resp7defqgSHo9T5iaU0\n" +
	  "X9tDkYI22WY8sbi5gv2cOj4QyDvvBmVmepsZGD3/cVE8MC5fvj13c7JdBmzDI1aa\n" +
	  "K4UmkhynArPkPw2vCHmCuDY96pzTNbO8acr1zJ3o/WSNF4Azbl5KXZnJHoe0nRrA\n" +
	  "1W4TNSNe35tfPe/W93bC6j67eA0cQmdrBNj41tpvi/JEoAGrAgEDo4HFMIHCMB0G\n" +
	  "A1UdDgQWBBS/X7fRzt0fhvRbVazc1xDCDqmI5zCBkgYDVR0jBIGKMIGHgBS/X7fR\n" +
	  "zt0fhvRbVazc1xDCDqmI56FspGowaDELMAkGA1UEBhMCVVMxJTAjBgNVBAoTHFN0\n" +
	  "YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAsTKVN0YXJmaWVsZCBD\n" +
	  "bGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8w\n" +
	  "DQYJKoZIhvcNAQEFBQADggEBAAWdP4id0ckaVaGsafPzWdqbAYcaT1epoXkJKtv3\n" +
	  "L7IezMdeatiDh6GX70k1PncGQVhiv45YuApnP+yz3SFmH8lU+nLMPUxA2IGvd56D\n" +
	  "eruix/U0F47ZEUD0/CwqTRV/p2JdLiXTAAsgGh1o+Re49L2L7ShZ3U0WixeDyLJl\n" +
	  "xy16paq8U4Zt3VekyvggQQto8PT7dL5WXXp59fkdheMtlb71cZBDzI0fmgAKhynp\n" +
	  "VSJYACPq4xJDKVtHCN2MQWplBqjlIapBtJUhlbl90TSrE9atvNziPTnNvT51cKEY\n" +
	  "WQPJIrSPnNVeKtelttQKbfi3QBFGmh95DmK/D5fs4C8fF5Q=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // sfroot-g2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIID3TCCAsWgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBjzELMAkGA1UEBhMCVVMx\n" +
	  "EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\n" +
	  "HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAMTKVN0YXJmaWVs\n" +
	  "ZCBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAw\n" +
	  "MFoXDTM3MTIzMTIzNTk1OVowgY8xCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6\n" +
	  "b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFyZmllbGQgVGVj\n" +
	  "aG5vbG9naWVzLCBJbmMuMTIwMAYDVQQDEylTdGFyZmllbGQgUm9vdCBDZXJ0aWZp\n" +
	  "Y2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n" +
	  "ggEBAL3twQP89o/8ArFvW59I2Z154qK3A2FWGMNHttfKPTUuiUP3oWmb3ooa/RMg\n" +
	  "nLRJdzIpVv257IzdIvpy3Cdhl+72WoTsbhm5iSzchFvVdPtrX8WJpRBSiUZV9Lh1\n" +
	  "HOZ/5FSuS/hVclcCGfgXcVnrHigHdMWdSL5stPSksPNkN3mSwOxGXn/hbVNMYq/N\n" +
	  "Hwtjuzqd+/x5AJhhdM8mgkBj87JyahkNmcrUDnXMN/uLicFZ8WJ/X7NfZTD4p7dN\n" +
	  "dloedl40wOiWVpmKs/B/pM293DIxfJHP4F8R+GuqSVzRmZTRouNjWwl2tVZi4Ut0\n" +
	  "HZbUJtQIBFnQmA4O5t78w+wfkPECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO\n" +
	  "BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFHwMMh+n2TB/xH1oo2Kooc6rB1snMA0G\n" +
	  "CSqGSIb3DQEBCwUAA4IBAQARWfolTwNvlJk7mh+ChTnUdgWUXuEok21iXQnCoKjU\n" +
	  "sHU48TRqneSfioYmUeYs0cYtbpUgSpIB7LiKZ3sx4mcujJUDJi5DnUox9g61DLu3\n" +
	  "4jd/IroAow57UvtruzvE03lRTs2Q9GcHGcg8RnoNAX3FWOdt5oUwF5okxBDgBPfg\n" +
	  "8n/Uqgr/Qh037ZTlZFkSIHc40zI+OIF1lnP6aI+xy84fxez6nH7PfrHxBy22/L/K\n" +
	  "pL/QlwVKvOoYKAKQvVR4CSFx09F9HdkWsKlhPdAKACL8x3vLCWRFCztAgfd9fDL1\n" +
	  "mMpYjn0q7pBZc2T5NnReJaH1ZgUufzkVqSr7UIuOhWn0\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // sfsroot-g2
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx\n" +
	  "EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\n" +
	  "HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs\n" +
	  "ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5\n" +
	  "MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD\n" +
	  "VQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy\n" +
	  "ZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy\n" +
	  "dmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI\n" +
	  "hvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p\n" +
	  "OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2\n" +
	  "8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K\n" +
	  "Ts9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe\n" +
	  "hRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk\n" +
	  "6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw\n" +
	  "DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q\n" +
	  "AdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI\n" +
	  "bw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB\n" +
	  "ve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z\n" +
	  "qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd\n" +
	  "iEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn\n" +
	  "0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN\n" +
	  "sSi6\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // sfsroot
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEfjCCA2agAwIBAgIBADANBgkqhkiG9w0BAQUFADCBzzELMAkGA1UEBhMCVVMx\n" +
	  "EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\n" +
	  "HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOjA4BgNVBAsTMWh0dHA6Ly9j\n" +
	  "ZXJ0aWZpY2F0ZXMuc3RhcmZpZWxkdGVjaC5jb20vcmVwb3NpdG9yeS8xNjA0BgNV\n" +
	  "BAMTLVN0YXJmaWVsZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0\n" +
	  "eTAeFw0wODA2MDIwMDAwMDBaFw0yOTEyMzEyMzU5NTlaMIHPMQswCQYDVQQGEwJV\n" +
	  "UzEQMA4GA1UECBMHQXJpem9uYTETMBEGA1UEBxMKU2NvdHRzZGFsZTElMCMGA1UE\n" +
	  "ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjE6MDgGA1UECxMxaHR0cDov\n" +
	  "L2NlcnRpZmljYXRlcy5zdGFyZmllbGR0ZWNoLmNvbS9yZXBvc2l0b3J5LzE2MDQG\n" +
	  "A1UEAxMtU3RhcmZpZWxkIFNlcnZpY2VzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y\n" +
	  "aXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8sxWKk3mFjdal+pt\n" +
	  "NTjREJvbuNypBAmVMy4JxQB7GnhCj8j0BY7+0miDHk6ZzRfbRz5Q84nS59yY+wX4\n" +
	  "qtZj9FRNwXEDsB8bdrMaNDBz8SgyYIP9tJzXttIiN3wZqjveExBpblwG02+j8mZa\n" +
	  "dkJIr4DRVFk91LnU2+25qzmZ9O5iq+F4cnvYOI1AtszcEgBwQ4Vp2Bjjyldyn7Tf\n" +
	  "P/wiqEJS9XdbmfBWLSZwFjYSwieeV6Z80CPxedyjk1goOD2frTZD7jf7+PlDrchW\n" +
	  "8pQSXkLrc7gTDcum1Ya5qihqVAOhPw8p6wkA6D9eon8XPaEr+L7QdR2khOOrF2UG\n" +
	  "UgCvsQIDAQABo2MwYTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAd\n" +
	  "BgNVHQ4EFgQUtMZ/GkPMm3VdL8RL8ouYEOnxURAwHwYDVR0jBBgwFoAUtMZ/GkPM\n" +
	  "m3VdL8RL8ouYEOnxURAwDQYJKoZIhvcNAQEFBQADggEBAKyAu8QlBQtYpOR+KX6v\n" +
	  "vDvsLcBELvmR4NI7MieQLfaACVzCq2Uk2jgQRsRJ0v2aqyhId4jG6W/RR5HVNU8U\n" +
	  "CahbQAcdfHFWy4lC1L9hwCL3Lt+r83JDi0DolOuwJtrRE9Or0DYtLjqVs3cuFTkY\n" +
	  "DGm6qoDt8VNOM5toBOKgMC7X0V3UpmadhObnuzyJuzad/BepPVUrivubxEyE/9/S\n" +
	  "vmkbdLCo9uqwnLIpdIFMaDqaf3MlOfUT4GaRadRXS7furUXgLMOI076USYkf/3DV\n" +
	  "W205E7Ady5jmZ2MNY/b7w9dhcoOIP3B+U8meiVTWT399cbmu8WCLd2Ds+L/6aqOc\n" +
	  "ASI=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // thawte_Premium_Server_CA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDNjCCAp+gAwIBAgIQNhIilsXjOKUgodJfTNcJVDANBgkqhkiG9w0BAQUFADCB\n" +
	  "zjELMAkGA1UEBhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBxMJ\n" +
	  "Q2FwZSBUb3duMR0wGwYDVQQKExRUaGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UE\n" +
	  "CxMfQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjEhMB8GA1UEAxMYVGhh\n" +
	  "d3RlIFByZW1pdW0gU2VydmVyIENBMSgwJgYJKoZIhvcNAQkBFhlwcmVtaXVtLXNl\n" +
	  "cnZlckB0aGF3dGUuY29tMB4XDTk2MDgwMTAwMDAwMFoXDTIxMDEwMTIzNTk1OVow\n" +
	  "gc4xCzAJBgNVBAYTAlpBMRUwEwYDVQQIEwxXZXN0ZXJuIENhcGUxEjAQBgNVBAcT\n" +
	  "CUNhcGUgVG93bjEdMBsGA1UEChMUVGhhd3RlIENvbnN1bHRpbmcgY2MxKDAmBgNV\n" +
	  "BAsTH0NlcnRpZmljYXRpb24gU2VydmljZXMgRGl2aXNpb24xITAfBgNVBAMTGFRo\n" +
	  "YXd0ZSBQcmVtaXVtIFNlcnZlciBDQTEoMCYGCSqGSIb3DQEJARYZcHJlbWl1bS1z\n" +
	  "ZXJ2ZXJAdGhhd3RlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA0jY2\n" +
	  "aovXwlue2oFBYo847kkEVdbQ7xwblRZH7xhINTpS9CtqBo87L+pW46+GjZ4X9560\n" +
	  "ZXUCTe/LCaIhUdib0GfQug2SBhRz1JPLlyoAnFxODLz6FVL88kRu2hFKbgifLy3j\n" +
	  "+ao6hnO2RlNYyIkFvYMRuHM/qgeN9EJN50CdHDcCAwEAAaMTMBEwDwYDVR0TAQH/\n" +
	  "BAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQBlkKyID1bZ5jA01CbH0FDxkt5r1DmI\n" +
	  "CSLGpmODA/eZd9iy5Ri4XWPz1HP7bJyZePFLeH0ZJMMrAoT4vCLZiiLXoPxx7JGH\n" +
	  "IPG47LHlVYCsPVLIOQ7C8MAFT9aCdYy9X9LcdpoFEsmvcsPcJX6kTY4XpeCHf+Ga\n" +
	  "WuFg3GQjPEIuTQ==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // thawte_Primary_Root_CA-G2_ECC
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIICiDCCAg2gAwIBAgIQNfwmXNmET8k9Jj1Xm67XVjAKBggqhkjOPQQDAzCBhDEL\n" +
	  "MAkGA1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjE4MDYGA1UECxMvKGMp\n" +
	  "IDIwMDcgdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxJDAi\n" +
	  "BgNVBAMTG3RoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EgLSBHMjAeFw0wNzExMDUwMDAw\n" +
	  "MDBaFw0zODAxMTgyMzU5NTlaMIGEMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMdGhh\n" +
	  "d3RlLCBJbmMuMTgwNgYDVQQLEy8oYykgMjAwNyB0aGF3dGUsIEluYy4gLSBGb3Ig\n" +
	  "YXV0aG9yaXplZCB1c2Ugb25seTEkMCIGA1UEAxMbdGhhd3RlIFByaW1hcnkgUm9v\n" +
	  "dCBDQSAtIEcyMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEotWcgnuVnfFSeIf+iha/\n" +
	  "BebfowJPDQfGAFG6DAJSLSKkQjnE/o/qycG+1E3/n3qe4rF8mq2nhglzh9HnmuN6\n" +
	  "papu+7qzcMBniKI11KOasf2twu8x+qi58/sIxpHR+ymVo0IwQDAPBgNVHRMBAf8E\n" +
	  "BTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUmtgAMADna3+FGO6Lts6K\n" +
	  "DPgR4bswCgYIKoZIzj0EAwMDaQAwZgIxAN344FdHW6fmCsO99YCKlzUNG4k8VIZ3\n" +
	  "KMqh9HneteY4sPBlcIx/AlTCv//YoT7ZzwIxAMSNlPzcU9LcnXgWHxUzI1NS41ox\n" +
	  "XZ3Krr0TKUQNJ1uo52icEvdYPy5yAlejj6EULg==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // thawte_Primary_Root_CA-G3_SHA256
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEKjCCAxKgAwIBAgIQYAGXt0an6rS0mtZLL/eQ+zANBgkqhkiG9w0BAQsFADCB\n" +
	  "rjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMf\n" +
	  "Q2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYGA1UECxMvKGMpIDIw\n" +
	  "MDggdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxJDAiBgNV\n" +
	  "BAMTG3RoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EgLSBHMzAeFw0wODA0MDIwMDAwMDBa\n" +
	  "Fw0zNzEyMDEyMzU5NTlaMIGuMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMdGhhd3Rl\n" +
	  "LCBJbmMuMSgwJgYDVQQLEx9DZXJ0aWZpY2F0aW9uIFNlcnZpY2VzIERpdmlzaW9u\n" +
	  "MTgwNgYDVQQLEy8oYykgMjAwOCB0aGF3dGUsIEluYy4gLSBGb3IgYXV0aG9yaXpl\n" +
	  "ZCB1c2Ugb25seTEkMCIGA1UEAxMbdGhhd3RlIFByaW1hcnkgUm9vdCBDQSAtIEcz\n" +
	  "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsr8nLPvb2FvdeHsbnndm\n" +
	  "gcs+vHyu86YnmjSjaDFxODNi5PNxZnmxqWWjpYvVj2AtP0LMqmsywCPLLEHd5N/8\n" +
	  "YZzic7IilRFDGF/Eth9XbAoFWCLINkw6fKXRz4aviKdEAhN0cXMKQlkC+BsUa0Lf\n" +
	  "b1+6a4KinVvnSr0eAXLbS3ToO39/fR8EtCab4LRarEc9VbjXsCZSKAExQGbY2SS9\n" +
	  "9irY7CFJXJv2eul/VTV+lmuNk5Mny5K76qxAwJ/C+IDPXfRa3M50hqY+bAtTyr2S\n" +
	  "zhkGcuYMXDhpxwTWvGzOW/b3aJzcJRVIiKHpqfiYnODz1TEoYRFsZ5aNOZnLwkUk\n" +
	  "OQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNV\n" +
	  "HQ4EFgQUrWyqlGCc7eT/+j4KdCtjA/e2Wb8wDQYJKoZIhvcNAQELBQADggEBABpA\n" +
	  "2JVlrAmSicY59BDlqQ5mU1143vokkbvnRFHfxhY0Cu9qRFHqKweKA3rD6z8KLFIW\n" +
	  "oCtDuSWQP3CpMyVtRRooOyfPqsMpQhvfO0zAMzRbQYi/aytlryjvsvXDqmbOe1bu\n" +
	  "t8jLZ8HJnBoYuMTDSQPxYA5QzUbF83d597YV4Djbxy8ooAw/dyZ02SUS2jHaGh7c\n" +
	  "KUGRIjxpp7sC8rZcJwOJ9Abqm+RyguOhCcHpABnTPtRwa7pxpqpYrvS76Wy274fM\n" +
	  "m7v/OeZWYdMKp8RcTGB7BXcmer/YB1IsYvdwY9k5vG8cwnncdimvzsUsZAReiDZu\n" +
	  "MdRAGmI0Nj81Aa6sY6A=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // thawte_Primary_Root_CA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEIDCCAwigAwIBAgIQNE7VVyDV7exJ9C/ON9srbTANBgkqhkiG9w0BAQUFADCB\n" +
	  "qTELMAkGA1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMf\n" +
	  "Q2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYGA1UECxMvKGMpIDIw\n" +
	  "MDYgdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxHzAdBgNV\n" +
	  "BAMTFnRoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EwHhcNMDYxMTE3MDAwMDAwWhcNMzYw\n" +
	  "NzE2MjM1OTU5WjCBqTELMAkGA1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5j\n" +
	  "LjEoMCYGA1UECxMfQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYG\n" +
	  "A1UECxMvKGMpIDIwMDYgdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNl\n" +
	  "IG9ubHkxHzAdBgNVBAMTFnRoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EwggEiMA0GCSqG\n" +
	  "SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCsoPD7gFnUnMekz52hWXMJEEUMDSxuaPFs\n" +
	  "W0hoSVk3/AszGcJ3f8wQLZU0HObrTQmnHNK4yZc2AreJ1CRfBsDMRJSUjQJib+ta\n" +
	  "3RGNKJpchJAQeg29dGYvajig4tVUROsdB58Hum/u6f1OCyn1PoSgAfGcq/gcfomk\n" +
	  "6KHYcWUNo1F77rzSImANuVud37r8UVsLr5iy6S7pBOhih94ryNdOwUxkHt3Ph1i6\n" +
	  "Sk/KaAcdHJ1KxtUvkcx8cXIcxcBn6zL9yZJclNqFwJu/U30rCfSMnZEfl2pSy94J\n" +
	  "NqR32HuHUETVPm4pafs5SSYeCaWAe0At6+gnhcn+Yf1+5nyXHdWdAgMBAAGjQjBA\n" +
	  "MA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBR7W0XP\n" +
	  "r87Lev0xkhpqtvNG61dIUDANBgkqhkiG9w0BAQUFAAOCAQEAeRHAS7ORtvzw6WfU\n" +
	  "DW5FvlXok9LOAz/t2iWwHVfLHjp2oEzsUHboZHIMpKnxuIvW1oeEuzLlQRHAd9mz\n" +
	  "YJ3rG9XRbkREqaYB7FViHXe4XI5ISXycO1cRrK1zN44veFyQaEfZYGDm/Ac9IiAX\n" +
	  "xPcW6cTYcvnIc3zfFi8VqT79aie2oetaupgf1eNNZAqdE8hhuvU5HIe6uL17In/2\n" +
	  "/qxAeeWsEG89jxt5dovEN7MhGITlNgDrYyCZuen+MwS7QcjBAvlEYyCegc5C09Y/\n" +
	  "LHbTY5xZ3Y+m4Q6gLkH3LpVHz7z9M/P2C2F+fpErgUfCJzDupxBdN49cOSvkBPB7\n" +
	  "jVaMaA==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // thawte_Server_CA
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDIjCCAougAwIBAgIQNKT/9jCvTKU8MxdCoZRmdTANBgkqhkiG9w0BAQUFADCB\n" +
	  "xDELMAkGA1UEBhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBxMJ\n" +
	  "Q2FwZSBUb3duMR0wGwYDVQQKExRUaGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UE\n" +
	  "CxMfQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjEZMBcGA1UEAxMQVGhh\n" +
	  "d3RlIFNlcnZlciBDQTEmMCQGCSqGSIb3DQEJARYXc2VydmVyLWNlcnRzQHRoYXd0\n" +
	  "ZS5jb20wHhcNOTYwODAxMDAwMDAwWhcNMjEwMTAxMjM1OTU5WjCBxDELMAkGA1UE\n" +
	  "BhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBxMJQ2FwZSBUb3du\n" +
	  "MR0wGwYDVQQKExRUaGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UECxMfQ2VydGlm\n" +
	  "aWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjEZMBcGA1UEAxMQVGhhd3RlIFNlcnZl\n" +
	  "ciBDQTEmMCQGCSqGSIb3DQEJARYXc2VydmVyLWNlcnRzQHRoYXd0ZS5jb20wgZ8w\n" +
	  "DQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBANOkUG7I/1Zr5s9dtuoMaHVHoqrC2oQl\n" +
	  "/Kj0R1HahbUgdJSGHg91yekIYfUGbTBuFRkC6VLAYttNmZ7iagxEOM3+vuNkCXDF\n" +
	  "/rFrKbYvScg71CcEJRCXL+eQbcAoQpnXTEPew/UhbVSfXcNY4cDk2VuwuNy0e982\n" +
	  "OsK1ZiIS1ocNAgMBAAGjEzARMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEF\n" +
	  "BQADgYEAvkBpQW/G28GnvwfAReTQtUMeTJUzNelewj4o9qgNUNX/4gwP/FACjq6R\n" +
	  "ua00io2fJ3GqGcxL6ATK1BdrEhrWxl/WzV7/iXa/2EjYWb0IiokdV81FHlK6EpqE\n" +
	  "+hiJX+j5MDVqAWC5mYCDhQpu2vTJj15zLTFKY6B08h+LItIpPus=\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // trustcenter_TC_Universal_CA_III
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIID4TCCAsmgAwIBAgIOYyUAAQACFI0zFQLkbPQwDQYJKoZIhvcNAQEFBQAwezEL\n" +
	  "MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxJDAiBgNV\n" +
	  "BAsTG1RDIFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQTEoMCYGA1UEAxMfVEMgVHJ1\n" +
	  "c3RDZW50ZXIgVW5pdmVyc2FsIENBIElJSTAeFw0wOTA5MDkwODE1MjdaFw0yOTEy\n" +
	  "MzEyMzU5NTlaMHsxCzAJBgNVBAYTAkRFMRwwGgYDVQQKExNUQyBUcnVzdENlbnRl\n" +
	  "ciBHbWJIMSQwIgYDVQQLExtUQyBUcnVzdENlbnRlciBVbml2ZXJzYWwgQ0ExKDAm\n" +
	  "BgNVBAMTH1RDIFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQSBJSUkwggEiMA0GCSqG\n" +
	  "SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDC2pxisLlxErALyBpXsq6DFJmzNEubkKLF\n" +
	  "5+cvAqBNLaT6hdqbJYUtQCggbergvbFIgyIpRJ9Og+41URNzdNW88jBmlFPAQDYv\n" +
	  "DIRlzg9uwliT6CwLOunBjvvya8o84pxOjuT5fdMnnxvVZ3iHLX8LR7PH6MlIfK8v\n" +
	  "zArZQe+f/prhsq75U7Xl6UafYOPfjdN/+5Z+s7Vy+EutCHnNaYlAJ/Uqwa1D7KRT\n" +
	  "yGG299J5KmcYdkhtWyUB0SbFt1dpIxVbYYqt8Bst2a9c8SaQaanVDED1M4BDj5yj\n" +
	  "dipFtK+/fz6HP3bFzSreIMUWWMv5G/UPyw0RUmS40nZid4PxWJ//AgMBAAGjYzBh\n" +
	  "MB8GA1UdIwQYMBaAFFbn4VslQ4Dg9ozhcbyO5YAvxEjiMA8GA1UdEwEB/wQFMAMB\n" +
	  "Af8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRW5+FbJUOA4PaM4XG8juWAL8RI\n" +
	  "4jANBgkqhkiG9w0BAQUFAAOCAQEAg8ev6n9NCjw5sWi+e22JLumzCecYV42Fmhfz\n" +
	  "dkJQEw/HkG8zrcVJYCtsSVgZ1OK+t7+rSbyUyKu+KGwWaODIl0YgoGhnYIg5IFHY\n" +
	  "aAERzqf2EQf27OysGh+yZm5WZ2B6dF7AbZc2rrUNXWZzwCUyRdhKBgePxLcHsU0G\n" +
	  "DeGl6/R1yrqc0L2z0zIkTO5+4nYES0lT2PLpVDP85XEfPRRclkvxOvIAu2y0+pZV\n" +
	  "CIgJwcyRGSmwIC3/yzikQOEXvnlhgP8HA4ZMTnsGnxGGjYnuJ8Tb4rwZjgvDwxPH\n" +
	  "LQNjO9Po5KIqwoIIlBZU8O8fJ5AluA0OKBtHd0e9HKgl8ZS0Zg==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // trustcenter_Universal_CA-I
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIID3TCCAsWgAwIBAgIOHaIAAQAC7LdggHiNtgYwDQYJKoZIhvcNAQEFBQAweTEL\n" +
	  "MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxJDAiBgNV\n" +
	  "BAsTG1RDIFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQTEmMCQGA1UEAxMdVEMgVHJ1\n" +
	  "c3RDZW50ZXIgVW5pdmVyc2FsIENBIEkwHhcNMDYwMzIyMTU1NDI4WhcNMjUxMjMx\n" +
	  "MjI1OTU5WjB5MQswCQYDVQQGEwJERTEcMBoGA1UEChMTVEMgVHJ1c3RDZW50ZXIg\n" +
	  "R21iSDEkMCIGA1UECxMbVEMgVHJ1c3RDZW50ZXIgVW5pdmVyc2FsIENBMSYwJAYD\n" +
	  "VQQDEx1UQyBUcnVzdENlbnRlciBVbml2ZXJzYWwgQ0EgSTCCASIwDQYJKoZIhvcN\n" +
	  "AQEBBQADggEPADCCAQoCggEBAKR3I5ZEr5D0MacQ9CaHnPM42Q9e3s9B6DGtxnSR\n" +
	  "JJZ4Hgmgm5qVSkr1YnwCqMqs+1oEdjneX/H5s7/zA1hV0qq34wQi0fiU2iIIAI3T\n" +
	  "fCZdzHd55yx4Oagmcw6iXSVphU9VDprvxrlE4Vc93x9UIuVvZaozhDrzznq+VZeu\n" +
	  "jRIPFDPiUHDDSYcTvFHe15gSWu86gzOSBnWLknwSaHtwag+1m7Z3W0hZneTvWq3z\n" +
	  "wZ7U10VOylY0Ibw+F1tvdwxIAUMpsN0/lm7mlaoMwCC2/T42J5zjXM9OgdwZu5GQ\n" +
	  "fezmlwQek8wiSdeXhrYTCjxDI3d+8NzmzSQfO4ObNDqDNOMCAwEAAaNjMGEwHwYD\n" +
	  "VR0jBBgwFoAUkqR1LKSevoFE63n8isWVpesQdXMwDwYDVR0TAQH/BAUwAwEB/zAO\n" +
	  "BgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFJKkdSyknr6BROt5/IrFlaXrEHVzMA0G\n" +
	  "CSqGSIb3DQEBBQUAA4IBAQAo0uCG1eb4e/CX3CJrO5UUVg8RMKWaTzqwOuAGy2X1\n" +
	  "7caXJ/4l8lfmXpWMPmRgFVp/Lw0BxbFg/UU1z/CyvwbZ71q+s2IhtNerNXxTPqYn\n" +
	  "8aEt2hojnczd7Dwtnic0XQ/CNnm8yUpiLe1r2X1BQ3y2qsrtYbE3ghUJGooWMNjs\n" +
	  "ydZHcnhLEEYUjl8Or+zHL6sQ17bxbuyGssLoDZJz3KL0Dzq/YSMQiZxIQG5wALPT\n" +
	  "ujdEWBF6AmqI8Dc08BnprNRlc/ZpjGSUOnmFKbAWKwyCPwacx/0QK54PLLae4xW/\n" +
	  "2TYcuiUaUj0a7CIMHOCkoj3w6DnPgcB77V0fb8XQC9eY\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // trustcenter_Universal_CA-II
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIF3zCCA8egAwIBAgIOGTMAAQACKBqaBLzyVUUwDQYJKoZIhvcNAQEFBQAwejEL\n" +
	  "MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxJDAiBgNV\n" +
	  "BAsTG1RDIFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQTEnMCUGA1UEAxMeVEMgVHJ1\n" +
	  "c3RDZW50ZXIgVW5pdmVyc2FsIENBIElJMB4XDTA2MDMyMjE1NTgzNFoXDTMwMTIz\n" +
	  "MTIyNTk1OVowejELMAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVy\n" +
	  "IEdtYkgxJDAiBgNVBAsTG1RDIFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQTEnMCUG\n" +
	  "A1UEAxMeVEMgVHJ1c3RDZW50ZXIgVW5pdmVyc2FsIENBIElJMIICIjANBgkqhkiG\n" +
	  "9w0BAQEFAAOCAg8AMIICCgKCAgEAi9R3azRs5TbYalxeOO781R15Azt7g2JEgk6I\n" +
	  "7d6D/+7MUGIFBZWZdpj2ufJf2AaRksL2LWYXH/1TA+iojWOpbuHWG4y8mLOLO9Tk\n" +
	  "Lsp9hUkmW3m4GotAnn+7yT9jLM/RWny6KCJBElpN+Rd3/IX9wkngKhh/6aAsnPlE\n" +
	  "/AxoOUL1JwW+jhV6YJ3wO8c85j4WvK923mq3ouGrRkXrjGV90ZfzlxElq1nroCLZ\n" +
	  "gt2Y7X7i+qBhCkoy3iwX921E6oFHWZdXNwM53V6CItQzuPomCba8OYgvURVOm8M7\n" +
	  "3xOCiN1LNPIz1pDp81PcNXzAw9l8eLPNcD+NauCjgUjkKa1juPD8KGQ7mbN9/pqd\n" +
	  "iPaZIgiRRxaJNXhdd6HPv0nh/SSUK2k2e+gc5iqQilvVOzRZQtxtz7sPQRxVzfUN\n" +
	  "Wy4WIibvYR6X/OJTyM9bo8ep8boOhhLLE8oVx+zkNo3aXBM9ZdIOXXB03L+PemrB\n" +
	  "Lg/Txl4PK1lszGFs/sBhTtnmT0ayWuIZFHCE+CAA7QGnl37DvRJckiMXoKUdRRcV\n" +
	  "I5qSCLUiiI3cKyTr4LEXaNOvYb3ZhXj2jbp4yjeNY77nrB/fpUcJucglMVRGURFV\n" +
	  "DYlcjdrSGC1z8rjVJ/VIIjfRYvd7Dcg4i6FKsPzQ8eu3hmPn4A5zf/1yUbXpfeJV\n" +
	  "BWR4Z38CAwEAAaNjMGEwHwYDVR0jBBgwFoAUzdeQoW6jv9sw1toyJZAM5jkegGUw\n" +
	  "DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFM3XkKFu\n" +
	  "o7/bMNbaMiWQDOY5HoBlMA0GCSqGSIb3DQEBBQUAA4ICAQB+FojoEw42zG4qhQc4\n" +
	  "xlaJeuNHIWZMUAgxWlHQ/KZeFHXeTDvs8e3MfhEHSmHu6rOOOqQzxu2KQmZP8Tx7\n" +
	  "yaUFQZmx7Cxb7tyW0ohTS3g0uW7muw/FeqZ8Dhjfbw90TNGp8aHp2FRkzF6WeKJW\n" +
	  "GsFzshXGVwXf2vdIJIqOf2qp+U3pPmrOYCx9LZAI9mOPFdAtnIz/8f38DBZQVhT7\n" +
	  "upeG7rRJA1TuG1l/MDoCgoYhrv7wFfLfToPmmcW6NfcgkIw47XXP4S73BDD7Ua2O\n" +
	  "giRAyn0pXdXZ92Vk/KqfdLh9kl3ShCngE+qK99CrxK7vFcXCifJ7tjtJmGHzTnKR\n" +
	  "N4xJkunI7Cqg90lufA0kxmts8jgvynAF5X/fxisrgIDV2m/LQLvYG/AkyRDIRAJ+\n" +
	  "LtOYqqIN8SvQ2vqOHP9U6OFKbt2o1ni1N6WsZNUUI8cOpevhCTjXwHxgpV2Yj4wC\n" +
	  "1dxWqPNNWKkL1HxkdAEy8t8PSoqpAqKiHYR3wvHMl700GXRd4nQ+dSf3r7/ufA5t\n" +
	  "VIimVuImrTESPB5BeW0X6hNeH/Vcn0lZo7Ivo0LD+qh+v6WfSMlgYmIK371F3uNC\n" +
	  "tVGW/cT1Gpm4UqJEzS1hjBWPgdVdotSQPYxuQGHDWV3Y2eH2dEcieXR92sqjbzcV\n" +
	  "NvAsGnE8EXbfXRo+VGN4a2V+Hw==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // trustcenter_class_2_ii
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEqjCCA5KgAwIBAgIOLmoAAQACH9dSISwRXDswDQYJKoZIhvcNAQEFBQAwdjEL\n" +
	  "MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxIjAgBgNV\n" +
	  "BAsTGVRDIFRydXN0Q2VudGVyIENsYXNzIDIgQ0ExJTAjBgNVBAMTHFRDIFRydXN0\n" +
	  "Q2VudGVyIENsYXNzIDIgQ0EgSUkwHhcNMDYwMTEyMTQzODQzWhcNMjUxMjMxMjI1\n" +
	  "OTU5WjB2MQswCQYDVQQGEwJERTEcMBoGA1UEChMTVEMgVHJ1c3RDZW50ZXIgR21i\n" +
	  "SDEiMCAGA1UECxMZVEMgVHJ1c3RDZW50ZXIgQ2xhc3MgMiBDQTElMCMGA1UEAxMc\n" +
	  "VEMgVHJ1c3RDZW50ZXIgQ2xhc3MgMiBDQSBJSTCCASIwDQYJKoZIhvcNAQEBBQAD\n" +
	  "ggEPADCCAQoCggEBAKuAh5uO8MN8h9foJIIRszzdQ2Lu+MNF2ujhoF/RKrLqk2jf\n" +
	  "tMjWQ+nEdVl//OEd+DFwIxuInie5e/060smp6RQvkL4DUsFJzfb95AhmC1eKokKg\n" +
	  "uNV/aVyQMrKXDcpK3EY+AlWJU+MaWss2xgdW94zPEfRMuzBwBJWl9jmM/XOBCH2J\n" +
	  "XjIeIqkiRUuwZi4wzJ9l/fzLganx4Duvo4bRierERXlQXa7pIXSSTYtZgo+U4+lK\n" +
	  "8edJsBTj9WLL1XK9H7nSn6DNqPoByNkN39r8R52zyFTfSUrxIan+GE7uSNQZu+99\n" +
	  "5OKdy1u2bv/jzVrndIIFuoAlOMvkaZ6vQaoahPUCAwEAAaOCATQwggEwMA8GA1Ud\n" +
	  "EwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBTjq1RMgKHbVkO3\n" +
	  "kUrL84J6E1wIqzCB7QYDVR0fBIHlMIHiMIHfoIHcoIHZhjVodHRwOi8vd3d3LnRy\n" +
	  "dXN0Y2VudGVyLmRlL2NybC92Mi90Y19jbGFzc18yX2NhX0lJLmNybIaBn2xkYXA6\n" +
	  "Ly93d3cudHJ1c3RjZW50ZXIuZGUvQ049VEMlMjBUcnVzdENlbnRlciUyMENsYXNz\n" +
	  "JTIwMiUyMENBJTIwSUksTz1UQyUyMFRydXN0Q2VudGVyJTIwR21iSCxPVT1yb290\n" +
	  "Y2VydHMsREM9dHJ1c3RjZW50ZXIsREM9ZGU/Y2VydGlmaWNhdGVSZXZvY2F0aW9u\n" +
	  "TGlzdD9iYXNlPzANBgkqhkiG9w0BAQUFAAOCAQEAjNfffu4bgBCzg/XbEeprS6iS\n" +
	  "GNn3Bzn1LL4GdXpoUxUc6krtXvwjshOg0wn/9vYua0Fxec3ibf2uWWuFHbhOIprt\n" +
	  "ZjluS5TmVfwLG4t3wVMTZonZKNaL80VKY7f9ewthXbhtvsPcW3nS7Yblok2+XnR8\n" +
	  "au0WOB9/WIFaGusyiC2y8zl3gK9etmF1KdsjTYjKUCjLhdLTEKJZbtOTVAB6okaV\n" +
	  "hgWcqRmY5TFyDADiZ9lA4CQze28suVyrZZ0srHbqNZn1l7kPJOzHdiEoZa5X6AeI\n" +
	  "dUpWoNIFOqTmjZKILPPy4cHGYdtBxceb9w4aUUXCYWvcZCcXjFq32nQozZfkvQ==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // trustcenter_class_3_ii
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIEqjCCA5KgAwIBAgIOSkcAAQAC5aBd1j8AUb8wDQYJKoZIhvcNAQEFBQAwdjEL\n" +
	  "MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxIjAgBgNV\n" +
	  "BAsTGVRDIFRydXN0Q2VudGVyIENsYXNzIDMgQ0ExJTAjBgNVBAMTHFRDIFRydXN0\n" +
	  "Q2VudGVyIENsYXNzIDMgQ0EgSUkwHhcNMDYwMTEyMTQ0MTU3WhcNMjUxMjMxMjI1\n" +
	  "OTU5WjB2MQswCQYDVQQGEwJERTEcMBoGA1UEChMTVEMgVHJ1c3RDZW50ZXIgR21i\n" +
	  "SDEiMCAGA1UECxMZVEMgVHJ1c3RDZW50ZXIgQ2xhc3MgMyBDQTElMCMGA1UEAxMc\n" +
	  "VEMgVHJ1c3RDZW50ZXIgQ2xhc3MgMyBDQSBJSTCCASIwDQYJKoZIhvcNAQEBBQAD\n" +
	  "ggEPADCCAQoCggEBALTgu1G7OVyLBMVMeRwjhjEQY0NVJz/GRcekPewJDRoeIMJW\n" +
	  "Ht4bNwcwIi9v8Qbxq63WyKthoy9DxLCyLfzDlml7forkzMA5EpBCYMnMNWju2l+Q\n" +
	  "Vl/NHE1bWEnrDgFPZPosPIlY2C8u4rBo6SI7dYnWRBpl8huXJh0obazovVkdKyT2\n" +
	  "1oQDZogkAHhg8fir/gKya/si+zXmFtGt9i4S5Po1auUZuV3bOx4a+9P/FRQI2Alq\n" +
	  "ukWdFHlgfa9Aigdzs5OW03Q0jTo3Kd5c7PXuLjHCINy+8U9/I1LZW+Jk2ZyqBwi1\n" +
	  "Rb3R0DHBq1SfqdLDYmAD8bs5SpJKPQq5ncWg/jcCAwEAAaOCATQwggEwMA8GA1Ud\n" +
	  "EwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBTUovyfs8PYA9NX\n" +
	  "XAek0CSnwPIA1DCB7QYDVR0fBIHlMIHiMIHfoIHcoIHZhjVodHRwOi8vd3d3LnRy\n" +
	  "dXN0Y2VudGVyLmRlL2NybC92Mi90Y19jbGFzc18zX2NhX0lJLmNybIaBn2xkYXA6\n" +
	  "Ly93d3cudHJ1c3RjZW50ZXIuZGUvQ049VEMlMjBUcnVzdENlbnRlciUyMENsYXNz\n" +
	  "JTIwMyUyMENBJTIwSUksTz1UQyUyMFRydXN0Q2VudGVyJTIwR21iSCxPVT1yb290\n" +
	  "Y2VydHMsREM9dHJ1c3RjZW50ZXIsREM9ZGU/Y2VydGlmaWNhdGVSZXZvY2F0aW9u\n" +
	  "TGlzdD9iYXNlPzANBgkqhkiG9w0BAQUFAAOCAQEANmDkcPcGIEPZIxpC8vijsrlN\n" +
	  "irTzwppVMXzEO2eatN9NDoqTSheLG43KieHPOh6sHfGcMrSOWXaiQYUlN6AT0PV8\n" +
	  "TtXqluJucsG7Kv5sbviRmEb8yRtXW+rIGjs/sFGYPAfaLFkB2otE6OF0/ado3VS6\n" +
	  "g0bsyEa1+K+XwDsJHI/OcpY9M1ZwvJbL2NV9IJqDnxrcOfHFcqMRA/07QlIp2+gB\n" +
	  "95tejNaNhk4Z+rwcvsUhpYeeeC422wlxo3I0+GzjBgnyXlal092Y+tTmBvTwtiBj\n" +
	  "S+opvaqCZh77gaqnN60TGOaSw4HBM7uIHqHn4rS9MWwOUT1v+5ZWgOI2F9Hc5A==\n" +
	  "-----END CERTIFICATE-----\n",
	
	  // trustcenter_class_4_ii
	  "-----BEGIN CERTIFICATE-----\n" +
	  "MIIDtjCCAp6gAwIBAgIOBcAAAQACQdAGCk3OdRAwDQYJKoZIhvcNAQEFBQAwdjEL\n" +
	  "MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxIjAgBgNV\n" +
	  "BAsTGVRDIFRydXN0Q2VudGVyIENsYXNzIDQgQ0ExJTAjBgNVBAMTHFRDIFRydXN0\n" +
	  "Q2VudGVyIENsYXNzIDQgQ0EgSUkwHhcNMDYwMzIzMTQxMDIzWhcNMjUxMjMxMjI1\n" +
	  "OTU5WjB2MQswCQYDVQQGEwJERTEcMBoGA1UEChMTVEMgVHJ1c3RDZW50ZXIgR21i\n" +
	  "SDEiMCAGA1UECxMZVEMgVHJ1c3RDZW50ZXIgQ2xhc3MgNCBDQTElMCMGA1UEAxMc\n" +
	  "VEMgVHJ1c3RDZW50ZXIgQ2xhc3MgNCBDQSBJSTCCASIwDQYJKoZIhvcNAQEBBQAD\n" +
	  "ggEPADCCAQoCggEBALXNTJytrlG7fEjFDSmGehSt2VA9CXIgDRS2Y8b+WJ7gIV7z\n" +
	  "jyIZ3E6RIM1viCmis8GsKnK6i1S4QF/yqvhDhsIwXMynXX/GCEnkDjkvjhjWkd0j\n" +
	  "FnmA22xIHbzB3ygQY9GB493fL3l1oht48pQB5hBiecugfQLANIJ7x8CtHUzXapZ2\n" +
	  "W78mhEj9h/aECqqSB5lIPGG8ToVYx5ct/YFKocabEvVCUNFkPologiJw3fX64yhC\n" +
	  "L04y87OjNopq1mJcrPoBbbTgci6VaLTxkwzGioLSHVPqfOA/QrcSWrjN2qUGZ8uh\n" +
	  "d32llvCSHmcOHUJG5vnt+0dTf1cERh9GX8eu4I8CAwEAAaNCMEAwDwYDVR0TAQH/\n" +
	  "BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFB/quz4lGwa9pd1iBX7G\n" +
	  "TFq/6A9DMA0GCSqGSIb3DQEBBQUAA4IBAQBYpCubTPfkpJKknGWYGWIi/HIy6QRd\n" +
	  "xMRwLVpG3kxHiiW5ot3u6hKvSI3vK2fbO8w0mCr3CEf/Iq978fTr4jgCMxh1KBue\n" +
	  "dmWsiANy8jhHHYz1nwqIUxAUu4DlDLNdjRfuHhkcho0UZ3iMksseIUn3f9MYv5x5\n" +
	  "+F0IebWqak2SNmy8eesOPXmK2PajVnBd3ttPedJ60pVchidlvqDTB4FAVd0Qy+BL\n" +
	  "iILAkH0457+W4Ze6mqtCD9Of2J4VMxHL94J59bXAQVaS4d9VA61Iz9PyLrHHLVZM\n" +
	  "ZHQqMc7cdalUR6SnQnIJ5+ECpkeyBM1CE+FhDOB4OiIgohxgQoaH96Xm\n" +
	  "-----END CERTIFICATE-----\n"
	]


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	var copy = __webpack_require__(167)
	var urltils = __webpack_require__(168)
	var logger = __webpack_require__(12).child({component: 'error_tracer'})
	var NAMES = __webpack_require__(59)
	var errorsModule = __webpack_require__(169)
	var Reservoir = __webpack_require__(94)
	var WeakMap = global.WeakMap
	
	
	var createError = errorsModule.createError
	var createEvent = errorsModule.createEvent
	
	module.exports = ErrorAggregator
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var MAX_ERRORS = 20
	
	/**
	 * ErrorAggregator is responsible for collecting JS errors and errored-out HTTP
	 * transactions, and for converting them to error traces and error events expected by
	 * the collector.
	 */
	function ErrorAggregator(config) {
	  this.config = config
	  this.errorCount = 0
	  this.webTransactionErrorCount = 0
	  this.otherTransactionErrorCount = 0
	  this.errors = []
	  if (WeakMap) {
	    this.seenObjects = new WeakMap()
	  } else {
	    this.seenObjects = []
	  }
	  this.seenStrings = {}
	
	  // reservoir used for error events
	  this.events = new Reservoir(this.config.error_collector.max_event_samples_stored)
	}
	
	/**
	 * Every finished transaction goes through this handler, so do as
	 * little as possible.
	 */
	ErrorAggregator.prototype.onTransactionFinished = onTransactionFinished
	
	function onTransactionFinished(transaction, metrics) {
	  if (!transaction) throw new Error("Error collector got a blank transaction.")
	  if (!metrics) throw new Error("Error collector requires metrics to count errors.")
	  if (transaction.ignore) return
	
	  // collect user errors even if status code is ignored
	  var collectedErrors = 0
	  var exception, i
	  if (transaction.userErrors.length > 0) {
	    for (i = 0; i < transaction.userErrors.length; i++) {
	      exception = transaction.userErrors[i]
	      if (this._collect(transaction, exception[0], exception[1], exception[2])) {
	        collectedErrors++
	      }
	    }
	  }
	
	  var hasExceptions = transaction.exceptions.length > 0
	  var isErroredTransaction = urltils.isError(this.config, transaction.statusCode)
	  var isIgnoredErrorStatusCode = urltils.isIgnoredError(this.config,
	      transaction.statusCode)
	
	  // collect other exceptions only if status code is not ignored
	  if (hasExceptions && !isIgnoredErrorStatusCode) {
	    for (i = 0; i < transaction.exceptions.length; i++) {
	      exception = transaction.exceptions[i]
	      if (this._collect(transaction, exception[0], exception[1], exception[2])) {
	        collectedErrors++
	      }
	    }
	  } else if (isErroredTransaction) {
	    if (this._collect(transaction)) {
	      collectedErrors++
	    }
	  }
	
	  // the metric should be incremented only if the error was actually collected
	  if (collectedErrors > 0) {
	    var count = metrics.getOrCreateMetric(NAMES.ERRORS.PREFIX + transaction.name)
	    count.incrementCallCount(collectedErrors)
	  }
	}
	
	/**
	 * This function collects the error right away when transaction is not supplied.
	 * Otherwise it delays collecting the error until the transaction ends.
	 *
	 * NOTE: this interface is unofficial and may change in future.
	 *
	 * @param {Transaction} transaction      Transaction associated with the error
	 *                                       (optional).
	 * @param {Error}       exception        The error to be traced.
	 * @param {object}      customParameters Any custom parameters associated with
	 *                                       the request (optional).
	 */
	ErrorAggregator.prototype.add = function add(transaction, exception, customParameters) {
	  if (!exception) return
	
	  var timestamp = Date.now()
	
	  if (transaction) {
	    transaction.addException(exception, customParameters, timestamp)
	  } else {
	    this._collect(transaction, exception, customParameters, timestamp)
	  }
	}
	
	/**
	 * This function is used to collect errors specifically added using the noticeError() API.
	 * Similarly to add(), it collects the error right away when transaction is not supplied.
	 * Otherwise it delays collecting the error until the transaction ends.
	 * The reason for separating the API errors from other exceptions is that different ignore
	 * rules apply to them.
	 *
	 * NOTE: this interface is unofficial and may change in future.
	 *
	 * @param {Transaction} transaction      Transaction associated with the error
	 *                                       (optional).
	 * @param {Error}       exception        The error to be traced.
	 * @param {object}      customParameters Any custom parameters associated with
	 *                                       the request (optional).
	 */
	ErrorAggregator.prototype.addUserError = function addUserError(transaction, exception,
	    customParameters) {
	  if (!exception) return
	
	  var timestamp = Date.now()
	
	  if (transaction) {
	    transaction.addUserError(exception, customParameters, timestamp)
	  } else {
	    this._collect(transaction, exception, customParameters, timestamp)
	  }
	}
	
	/**
	 *
	 * This function takes an exception and determines whether the exception
	 * has been seen before by this aggregator.  This function mutates the
	 * book keeping structures to reflect the exception has been seen.
	 *
	 * @param {Error} exception  The error to be checked.
	 *
	 */
	
	ErrorAggregator.prototype.haveSeen = function haveSeen(exception) {
	  if (typeof exception === 'object') {
	    if (WeakMap) {
	      if (this.seenObjects.has(exception)) {
	        return true
	      }
	
	      this.seenObjects.set(exception, true)
	    } else {
	      if (this.seenObjects.indexOf(exception) !== -1) {
	        return true
	      }
	
	      this.seenObjects.push(exception)
	    }
	  } else { // typeof exception !== 'object'
	    if (this.seenStrings[exception]) {
	      return true
	    }
	
	    this.seenStrings[exception] = true
	  }
	  return false
	}
	
	/**
	 * Collects the error and also creates the error event.
	 * This function uses an array of seen exceptions to ensure errors don't get
	 * double-counted. It can also be used as an unofficial means of marking that
	 * user errors shouldn't be traced.
	 *
	 * For an error to be traced, at least one of the transaction or the error
	 * must be present.
	 *
	 * NOTE: this interface is unofficial and may change in future.
	 *
	 * @param {Transaction} transaction      Transaction associated with the error
	 *                                       (optional).
	 * @param {Error}       exception        The error to be traced (optional).
	 * @param {object}      customParameters Any custom parameters associated with
	 *                                       the request (optional).
	 * @returns {bool}  True if the error was collected.
	 */
	ErrorAggregator.prototype._collect = _collect
	
	function _collect(transaction, exception, customParameters, timestamp) {
	  if (exception) {
	    if (this.haveSeen(exception)) {
	      return
	    }
	
	    if (typeof exception !== 'string' && !exception.message && !exception.stack) {
	      logger.trace(exception,
	        "Got error that is not an instance of Error or string.")
	      exception = null
	    }
	  }
	
	  if (!exception) {
	    if (!transaction) return
	    if (!transaction.statusCode) return
	    if (transaction.error) return
	  }
	
	  this.errorCount++
	
	  if (transaction) {
	    if (transaction.isWeb()) {
	      this.webTransactionErrorCount++
	    } else {
	      this.otherTransactionErrorCount++
	    }
	  }
	
	  // allow enabling & disabling the error tracer at runtime
	  // TODO: it would be better to check config in the public add() to prevents collecting
	  // errors on the transaction unnecessarily
	  if (!this.config.collect_errors ||
	      !this.config.error_collector || !this.config.error_collector.enabled) return
	
	  if (exception) {
	    logger.trace(exception, "Got exception to trace:")
	  }
	
	  var error = createError(transaction, exception, customParameters, this.config)
	
	  if (this.errors.length < MAX_ERRORS) {
	    logger.debug({error: error}, "Error to be sent to collector:")
	
	    // XXX: 2016-05-24 Remove this when APM UI is updated to use correct request_uri
	    //
	    // For right now, when this flag is enabled, the request_uri will be added
	    // to the error data. This will result in duplicated data being displayed on
	    // APM which is a no-go, so we need to remove it here. However, we want the
	    // data to still be there for error events metrics, so we need to perform a
	    // deep copy and only remove it from this data.
	    //
	    // In order to save cycles, we perform a smart deep copy in the form of a
	    // series of shallow copies down just the path that needs to change.
	    if (this.config.feature_flag.send_request_uri_attribute) {
	      var err = []
	      err.push.apply(err, error)
	      err[4] = copy.shallow(err[4])
	      err[4].agentAttributes = copy.shallow(err[4].agentAttributes)
	      delete err[4].agentAttributes.request_uri
	      this.errors.push(err)
	    } else {
	      this.errors.push(error)
	    }
	  } else {
	    logger.debug("Already have %d errors to send to collector, not keeping.",
	                 MAX_ERRORS)
	  }
	
	  // add error event
	  if (this.config.error_collector.capture_events === true) {
	    this.events.add(createEvent(transaction, error, timestamp))
	  }
	  return true
	}
	
	/**
	 * Returns collected errors.
	 */
	ErrorAggregator.prototype.getErrors = function getErrors() {
	  return this.errors
	}
	
	/**
	 * Returns error events based on seen errors.
	 */
	ErrorAggregator.prototype.getEvents = function getEvents() {
	  return this.events.toArray()
	}
	
	/**
	 * Returns maximum number of events that are collected per a harvest cycle.
	 */
	ErrorAggregator.prototype.getEventsLimit = function getEventsLimit() {
	  return this.events.limit
	}
	
	/**
	 * Returns number of events that have been seen since the last harvest cycle.
	 */
	ErrorAggregator.prototype.getEventsSeen = function getEventsSeen() {
	  return this.events.seen
	}
	
	/**
	 * Returns total number of collected errors.
	 */
	ErrorAggregator.prototype.getTotalErrorCount = function getTotalErrorCount() {
	  return this.errorCount
	}
	
	/**
	 * Returns total number of errors collected during web transactions.
	 */
	ErrorAggregator.prototype.getWebTransactionsErrorCount =
	    function getWebTransactionsErrorCount() {
	  return this.webTransactionErrorCount
	}
	
	/**
	 * Returns total number of errors collected during background transactions.
	 */
	ErrorAggregator.prototype.getBackgroundTransactionsErrorCount =
	    function getOtherTransactionsErrorCount() {
	  return this.otherTransactionErrorCount
	}
	
	/**
	 * If the connection to the collector fails, retain as many as will fit without
	 * overflowing the current error list.
	 *
	 * @param array errors Previously harvested errors.
	 */
	ErrorAggregator.prototype.merge = function merge(errors) {
	  if (!errors) return
	
	  var len = Math.min(errors.length, MAX_ERRORS - this.errors.length)
	  logger.warn("Merging %s (of %s) errors for next delivery.", len, errors.length)
	  for (var i = 0; i < len; i++) this.errors.push(errors[i])
	}
	
	ErrorAggregator.prototype.mergeEvents = function mergeEvents(events) {
	  this.events.merge(events)
	}
	
	ErrorAggregator.prototype.clearEvents = function clearEvents() {
	  this.events = new Reservoir(this.config.error_collector.max_event_samples_stored)
	}
	
	ErrorAggregator.prototype.clearErrors = function clearErrors() {
	  this.errors = []
	  this.seenStrings = {}
	  if (WeakMap) {
	    this.seenObjects = new WeakMap()
	  } else {
	    this.seenObjects = []
	  }
	  this.errorCount = 0
	  this.webTransactionErrorCount = 0
	  this.otherTransactionErrorCount = 0
	}
	
	ErrorAggregator.prototype.reconfigure = function reconfigure(config) {
	  this.config = config
	  this.events.setLimit(this.config.error_collector.max_event_samples_stored)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 167 */
/***/ function(module, exports) {

	'use strict'
	
	exports.shallow = shallowCopy
	
	/**
	 * Performs a shallow copy of all properties on the source object.
	 *
	 * @param {object} source     - The object to copy the properties from.
	 * @param {object} [dest={}]  - The object to copy the properties to.
	 *
	 * @return {object} The destination object.
	 */
	function shallowCopy(source, dest) {
	  dest = dest || {}
	  for (var k in source) {
	    if (source.hasOwnProperty(k)) {
	      dest[k] = source[k]
	    }
	  }
	  return dest
	}


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var url = __webpack_require__(108)
	
	// TODO: Once Node v0.10 is deprecated, change this to use a `Set` instead.
	var LOCALHOST_NAMES = {
	  "localhost": true,
	  "127.0.0.1": true,
	  "0.0.0.0": true,
	  "0:0:0:0:0:0:0:1": true,
	  "::1": true,
	  "0:0:0:0:0:0:0:0": true,
	  "::": true
	}
	
	/**
	 * Utility functions for enforcing New Relic naming conditions on URLs,
	 * and extracting and setting parameters on traces / web trace segments.
	 */
	module.exports = {
	  /**
	   * Dictionary whose keys are all synonyms for localhost.
	   *
	   * @const
	   */
	  LOCALHOST_NAMES: LOCALHOST_NAMES,
	
	  /**
	   * Checks if the given name is in the dictionary of localhost names.
	   *
	   * @param {string} host - The hostname to lookup.
	   *
	   * @return {bool} - True if the given hostname is a synonym for localhost.
	   */
	  isLocalhost: function isLocahost(host) {
	    return LOCALHOST_NAMES.hasOwnProperty(host)
	  },
	
	  /**
	   * This was handed down from the prototype as the canonical list of status
	   * codes that short-circuit naming and normalization. The agent can be
	   * configured to mark HTTP status codes as not being errors.
	   *
	   * @param {Config} config The configuration containing the error list.
	   * @param {string} code   The HTTP status code to check.
	   *
	   * @returns {bool} Whether the status code should be ignored.
	   */
	  isError: function isError(config, code) {
	    return code >= 400 && !isIgnoredStatusCodeForErrors(config, code)
	  },
	
	  /**
	   * Returns true if the status code is an HTTP error, and it is configured to be ignored.
	   *
	   * @param {Config} config The configuration containing the error list.
	   * @param {string} code   The HTTP status code to check.
	   *
	   * @returns {bool} Whether the status code should be ignored.
	   */
	  isIgnoredError: function isIgnoredError(config, code) {
	    return code >= 400 && isIgnoredStatusCodeForErrors(config, code)
	  },
	
	  /**
	   * Get back the pieces of the URL that New Relic cares about. Apply these
	   * restrictions, in order:
	   *
	   * 1. Ensure that after parsing the URL, there's at least '/'
	   * 2. Strip off session trackers after ';' (a New Relic convention)
	   * 3. Remove trailing slash.
	   *
	   * @param {string} requestURL The URL fragment to be scrubbed.
	   * @return {string} The cleaned URL.
	   */
	  scrub: function scrub(requestURL) {
	    if (typeof requestURL === 'string') {
	      requestURL = url.parse(requestURL)
	    }
	
	    var path = requestURL.pathname
	
	    if (path) {
	      path = path.split(';')[0]
	
	      if (path !== '/' && path.charAt(path.length - 1) === '/') {
	        path = path.substring(0, path.length - 1)
	      }
	    } else {
	      path = '/'
	    }
	
	    return path
	  },
	
	  /**
	   * Extract query parameters, dealing with bare parameters and parameters with
	   * no value as appropriate:
	   *
	   * 'var1&var2=value' is not necessarily the same as 'var1=&var2=value'
	   *
	   * In my world, one is an assertion of presence, and the other is an empty
	   * variable. Some web frameworks behave this way as well, so don't lose
	   * information.
	   *
	   * @param {string} requestURL The URL to be parsed.
	   * @returns {object} The parameters parsed from the request
	   */
	  parseParameters: function parseParameters(requestURL) {
	    var parsed = requestURL
	
	    if (typeof requestURL === 'string') {
	      parsed = url.parse(requestURL, true)
	    }
	
	    var parameters = {}
	
	    if (parsed.query) {
	      var keys = Object.keys(parsed.query)
	
	      for (var i = 0, l = keys.length; i < l; ++i) {
	        var key = keys[i]
	        if (parsed.query[key] === '' && parsed.path.indexOf(key + '=') === -1) {
	          parameters[key] = true
	        } else {
	          parameters[key] = parsed.query[key]
	        }
	      }
	    }
	
	    return parameters
	  },
	
	  /**
	   * Copy a set of request parameters from one object to another, following
	   * a few important rules:
	   *
	   * 1. Do not copy a parameter if it's in config.ignored_params.
	   * 2. Do not overwrite any existing parameters in destination, including
	   *    parameters set to null or undefined.
	   *
	   * @param {Config} config      Configuration, where `ignored_params` is
	   *                             guaranteed to be an Array.
	   * @param {object} source      Parameters to be copied (not changed).
	   * @param {object} destination Dictionary to which parameters are copied
	   *                             (mutated in place).
	   */
	  copyParameters: function copyParameters(config, source, destination) {
	    if (!(config && config.capture_params && source && destination)) return
	
	    var keys = Object.keys(source)
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i]
	      if (config.ignored_params.indexOf(key) === -1 && !(key in destination)) {
	        destination[key] = source[key]
	      }
	    }
	  },
	
	  /**
	   * Copy a set of request parameters from one object to another.
	   * Existing attributes on the `destination` will be overwritten.
	   * Unlike `copyParameters`, this function will operate when
	   * `capture_params` is not enabled.
	   *
	   * @param {Config} config      Configuration, where `ignored_params` is
	   *                             guaranteed to be an Array.
	   * @param {object} source      Parameters to be copied (not changed).
	   * @param {object} destination Dictionary to which parameters are copied
	   *                             (mutated in place).
	   */
	  overwriteParameters: function overwriteParameters(config, source, destination) {
	    if (!(config && source && destination)) return
	
	    var keys = Object.keys(source)
	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i]
	      if (config.ignored_params.indexOf(key) === -1) {
	        destination[key] = source[key]
	      }
	    }
	  }
	}
	
	function isIgnoredStatusCodeForErrors(config, code) {
	  var codes = []
	  if (config &&
	      config.error_collector &&
	      config.error_collector.ignore_status_codes) {
	    codes = config.error_collector.ignore_status_codes
	  }
	  return codes.indexOf(parseInt(code, 10)) >= 0
	}


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var urltils = __webpack_require__(168)
	var NAMES = __webpack_require__(59)
	var util = __webpack_require__(16)
	
	module.exports.createError = createError
	module.exports.createEvent = createEvent
	
	/**
	 * Given either or both of a transaction and an exception, generate an error
	 * trace in the JSON format expected by the collector. Since this will be
	 * used by both the HTTP instrumentation, which uses HTTP status codes to
	 * determine whether a transaction is in error, and the domain-based error
	 * handler, which traps actual instances of Error, try to set sensible
	 * defaults for everything.
	 *
	 * @param {Transaction} transaction      The agent transaction, presumably
	 *                                       coming out of the instrumentation.
	 * @param {Error}       exception        Something trapped by an error listener.
	 * @param {object}      customParameters Any custom parameters associated with
	 *                                       the request (optional).
	 */
	function createError(transaction, exception, customParameters, config) {
	  var name = 'WebTransaction/Uri/*'
	  var message = ''
	  var type = 'Error'
	  var params = {
	    request_uri: '',
	    userAttributes: {},
	    agentAttributes: {},
	    intrinsics: {}
	  }
	
	  // String errors do not provide us with as much information to provide to the
	  // user, but it is a common pattern.
	  if (typeof exception === 'string') {
	    message = exception
	  } else if (exception !== null && typeof exception === 'object' && exception.message) {
	    message = exception.message
	
	    if (exception.name) {
	      type = exception.name
	    } else if (exception.constructor && exception.constructor.name) {
	      type = exception.constructor.name
	    }
	  } else if (transaction && transaction.statusCode &&
	             urltils.isError(config, transaction.statusCode)) {
	    message = 'HttpError ' + transaction.statusCode
	  }
	
	  if (transaction) {
	    // transaction.getName is expensive due to running normalizers and ignore
	    // rules if a name hasn't been assigned yet. Also has the side effect of
	    // changing the transaction's url property or ignore status.
	    var txName = transaction.getName()
	    if (txName) {
	      name = txName
	    }
	
	    if (transaction.isWeb()) {
	      params.request_uri = transaction.getScrubbedUrl()
	    }
	
	    // Copy all of the parameters off of the transaction.
	    params.agentAttributes = transaction.trace.parameters
	    params.intrinsics = transaction.getIntrinsicAttributes()
	
	    // Custom params aren't filtered by capture_params or ignore_params, just by
	    // high security mode.
	    if (!config.high_security) {
	      urltils.overwriteParameters(config, transaction.trace.custom, params.userAttributes)
	    }
	  }
	  // This will strip out any ignored params or not include the custom params if
	  // capture params is disabled.
	  if (!config.high_security && customParameters) {
	    urltils.overwriteParameters(config, customParameters, params.userAttributes)
	  }
	
	
	  var stack = exception && exception.stack
	  if (stack) params.stack_trace = ('' + stack).split(/[\n\r]/g)
	
	  var res = [0, name, message, type, params]
	  if (transaction) {
	    Object.defineProperty(res, 'transaction', {
	      value: transaction.id
	    })
	  }
	  return res
	}
	
	/**
	 * Creates a structure for error event that is sent to the collector.
	 * The error parameter is an output of the createError() function for a given exception.
	 */
	function createEvent(transaction, error, timestamp) {
	  var message = error[2]
	  var errorClass = error[3]
	  var paramsFromError = error[4]
	
	  var intrinsicAttributes = _getErrorEventIntrinsicAttrs(transaction, errorClass, message,
	      timestamp)
	
	  // the error structure created by createError() already performs filtering of custom
	  // and agent attributes, so it is ok to just copy them
	  var userAttributes = util._extend({}, paramsFromError.userAttributes)
	  var agentAttributes = util._extend({}, paramsFromError.agentAttributes)
	
	  var errorEvent = [
	    intrinsicAttributes,
	    userAttributes,
	    agentAttributes
	  ]
	
	  return errorEvent
	}
	
	function _getErrorEventIntrinsicAttrs(transaction, errorClass, message, timestamp) {
	  // the server expects seconds instead of milliseconds
	  if (timestamp) timestamp = timestamp / 1000
	
	  var attributes = {
	    type: "TransactionError",
	    "error.class": errorClass,
	    "error.message": message,
	    timestamp: timestamp
	  }
	
	  if (transaction) {
	    attributes.transactionName = transaction.name
	    attributes.duration = transaction.timer.getDurationInMillis() / 1000
	
	    var metric = transaction.metrics.getMetric(NAMES.QUEUETIME)
	    if (metric) {
	      attributes.queueDuration = metric.total
	    }
	
	    metric = transaction.metrics.getMetric(NAMES.EXTERNAL.ALL)
	    if (metric) {
	      attributes.externalDuration = metric.total
	      attributes.externalCallCount = metric.callCount
	    }
	
	    metric = transaction.metrics.getMetric(NAMES.DB.ALL)
	    if (metric) {
	      attributes.databaseDuration = metric.total
	      attributes.databaseCallCount = metric.callCount
	    }
	
	    if (transaction.syntheticsData) {
	      attributes["nr.syntheticsResourceId"] = transaction.syntheticsData.resourceId
	      attributes["nr.syntheticsJobId"] = transaction.syntheticsData.jobId
	      attributes["nr.syntheticsMonitorId"] = transaction.syntheticsData.monitorId
	    }
	
	    attributes['nr.transactionGuid'] = transaction.id
	    attributes['nr.referringTransactionGuid'] = transaction.referringTransactionGuid
	
	    if (transaction.port) {
	      attributes.port = transaction.port
	    }
	  } else {
	    attributes.transactionName = 'None'
	  }
	
	  return attributes
	}


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Stats = __webpack_require__(171)
	var ApdexStats = __webpack_require__(172)
	var NAMES = __webpack_require__(59)
	
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var FROM_MILLIS = 1e-3
	
	/**
	 * A metric is a set of aggregated data (summary statistics) associated with a
	 * metric name. Some metrics belong to scopes, which are typically the name of
	 * a transaction or a background task. This class is a collection of mappings
	 * from names (or scopes and names) to data, as well as functions for
	 * manipulating those data directly. It also can produce a serialized
	 * representation suitable for stringifying into JSON and sending to the
	 * collector.
	 *
	 * There are several metrics collections in existence at any given time. Each
	 * agent has one metrics collection, which is created at the beginning of each
	 * harvest cycle. Each new transaction also gets its own metrics collection,
	 * which is merged into the agent's metrics when the transaction is finalized.
	 * This allows each set of metrics to be added to the harvest cycle atomically,
	 * which guarantees that each transaction will not have its metrics split
	 * across multiple harvest cycles. If delivery to the collector fails, the
	 * metrics collection associated with the failed delivery can be merged back
	 * into the metrics collection for the ongoing harvest cycle.  Finally, if so
	 * configured, the agent will have an internal set of supportability metrics
	 * that can be used to report information about the operation of the agent.
	 *
	 * Metrics can be remapped, which is a process by which they are assigned a
	 * short, numerical ID by New Relic. This can shrink the serialized JSON
	 * considerably. The mapping from transaction name (and scope) happens only
	 * at serialization time, which allows the mappings from name to ID to happen
	 * on the fly.
	 *
	 * @param {Number} apdexT The apdex-tolerating value, for use in creating apdex
	 *                        statistics.
	 * @param {MetricMapper} mapper The mapper that turns metric names into IDs.
	 */
	function Metrics(apdexT, mapper, normalizer) {
	  if (apdexT === undefined || apdexT === null || apdexT === '') {
	    throw new Error("metrics must be created with apdexT")
	  }
	  if (!mapper) throw new Error("metrics must be created with a mapper")
	  if (!normalizer) throw new Error("metrics must be created with a name normalizer")
	
	  this.started = Date.now()
	  this.apdexT = apdexT
	  this.mapper = mapper
	  this.normalizer = normalizer
	  this.unscoped = {} // {name : stats}
	  this.scoped = {} // {scope : {name : stats}}
	}
	
	/**
	 * This is the preferred way for interacting with metrics. Set the duration
	 * (and optionally the amount of that duration that was exclusive to that
	 * particular metric and not any child operations to that metric) of an
	 * operation. If there are no data for the name (and optional scope) existing,
	 * the collection will create a set of data before recording the measurement.
	 *
	 * @param {string} name The name of the metric.
	 * @param {string} scope (Optional) The scope to which the metric belongs.
	 * @param {Number} duration The duration of the related operation, in milliseconds.
	 * @param {Number} exclusive (Optional) The portion of the operation specific to this
	 *                           metric.
	 * @return {Stats} The aggregated data related to this metric.
	 */
	Metrics.prototype.measureMilliseconds = measureMilliseconds
	
	function measureMilliseconds(name, scope, duration, exclusive) {
	  var stats = this.getOrCreateMetric(name, scope)
	  stats.recordValueInMillis(duration, exclusive)
	  return stats
	}
	
	/**
	 * Set the size of an operation. If there are no data for the name existing,
	 * the collection will create a set of data before recording the measurement.
	 *
	 * @param {string} name The name of the metric.
	 * @param {Number} size The size of the related operation, in bytes.
	 * @return {Stats} The aggregated data related to this metric.
	 */
	Metrics.prototype.measureBytes = function measureBytes(name, size) {
	  var stats = this.getOrCreateMetric(name)
	  stats.recordValueInBytes(size)
	  return stats
	}
	
	/**
	 * Look up the mapping from a name (and optionally a scope) to a set of metric
	 * data for that name, creating the data if they don't already exist.
	 *
	 * @param {string} name The name of the requested metric.
	 * @param {string} scope (Optional) The scope to which the metric is bound.
	 * @return {Stats} The aggregated data for that name.
	 */
	Metrics.prototype.getOrCreateMetric = function getOrCreateMetric(name, scope) {
	  if (!name) throw new Error('Metrics must be named')
	
	  var resolved = this._resolve(scope)
	  if (!resolved[name]) resolved[name] = new Stats()
	  return resolved[name]
	}
	
	/**
	 * Look up the mapping from a name (and optionally a scope) to a set of metric
	 * apdex data for that name, creating the data if they don't already exist.
	 *
	 * @param {string} name          The name of the requested metric.
	 * @param {string} scope         The scope to which the metric is bound
	 *                               (optional).
	 * @param {number} overrideApdex A custom apdexT for this metric, in
	 *                               milliseconds. This will be the same for
	 *                               a given run, because key transaction metrics
	 *                               are set at connect time via server-side
	 *                               configuration.
	 *
	 * @return {ApdexStats} The aggregated data for that name.
	 */
	Metrics.prototype.getOrCreateApdexMetric = getOrCreateApdexMetric
	
	function getOrCreateApdexMetric(name, scope, overrideApdex) {
	  if (!name) throw new Error('Metrics must be named')
	
	  var resolved = this._resolve(scope)
	
	  if (!resolved[name]) {
	    // Only use the given override to create the metric if this is not the
	    // global apdex AND we have a valid value.
	    var apdexT = name !== NAMES.APDEX && overrideApdex > 0
	      ? (overrideApdex * FROM_MILLIS) : this.apdexT
	    resolved[name] = new ApdexStats(apdexT)
	  }
	  return resolved[name]
	}
	
	/**
	 * Look up a metric, and don't create it if it doesn't exist. Can create scopes
	 * as a byproduct, but this function is only intended for use in testing, so
	 * it's not a big deal.
	 *
	 * @param {string} name Metric name.
	 * @param {string} scope (Optional) The scope, if any, to which the metric
	 *                       belongs.
	 * @return {object} Either a stats aggregate, an apdex stats aggregate, or
	 *                  undefined.
	 */
	Metrics.prototype.getMetric = function getMetric(name, scope) {
	  if (!name) throw new Error('Metrics must be named')
	
	  return this._resolve(scope)[name]
	}
	
	/**
	 * Convert this collection into a representation suitable for serialization
	 * by JSON.stringify and delivery to the collector. Hope you like nested
	 * arrays!
	 *
	 * @return {Object} Set of nested arrays containing metric information.
	 */
	Metrics.prototype.toJSON = function toJSON() {
	  return this._toUnscopedData().concat(this._toScopedData())
	}
	
	/**
	 * Combine two sets of metric data. Intended to be used as described above,
	 * either when folding a transaction's metrics into the agent's metrics for
	 * later harvest, or one harvest cycle's metrics into the next when a
	 * delivery attempt to the collector fails. Among the more performance-
	 * critical pieces of code in the agent, so some performance tuning would
	 * probably be a good idea.
	 *
	 * @param {Metrics} other The collection to be folded into this one.
	 */
	Metrics.prototype.merge = function merge(other) {
	  this.started = Math.min(this.started, other.started)
	
	  Object.keys(other.unscoped).forEach(function cb_forEach(name) {
	    if (this.unscoped[name]) {
	      this.unscoped[name].merge(other.unscoped[name])
	    } else {
	      this.unscoped[name] = other.unscoped[name]
	    }
	  }, this)
	
	  Object.keys(other.scoped).forEach(function cb_forEach(scope) {
	    Object.keys(other.scoped[scope]).forEach(function cb_forEach(name) {
	      if (other.scoped[scope][name]) {
	        var resolved = this._resolve(scope)
	        if (resolved[name]) {
	          resolved[name].merge(other.scoped[scope][name])
	        } else {
	          resolved[name] = other.scoped[scope][name]
	        }
	      }
	    }, this)
	  }, this)
	}
	
	/**
	 * Look up the metric namespace belonging to a scope, creating it if it doesn't
	 * already exist.
	 *
	 * @param {string} scope (Optional) The scope to look up.
	 * @return {object} The namespace associated with the provided scope, or the
	 *                  un-scoped metrics if the scope isn't set.
	 */
	Metrics.prototype._resolve = function _resolve(scope) {
	  var resolved
	
	  if (scope) {
	    if (!this.scoped[scope]) this.scoped[scope] = {}
	
	    resolved = this.scoped[scope]
	  } else {
	    resolved = this.unscoped
	  }
	
	  return resolved
	}
	
	/**
	 * Map a metric to its nested-array representation, applying any name -> ID
	 * mappings along the way. Split from _getScopedData for performance.
	 *
	 * @param {string} name The string to look up.
	 */
	Metrics.prototype._getUnscopedData = function _getUnscopedData(name) {
	  if (!this.unscoped[name]) return
	
	  var normalized = this.normalizer.normalize(name)
	  if (normalized.ignore || !normalized.value) return
	
	  return [this.mapper.map(normalized.value), this.unscoped[name]]
	}
	
	/**
	 * Map a metric to its nested-array representation, applying any name -> ID
	 * mappings along the way. Split from _getUnscopedData for performance.
	 *
	 * @param {string} name The string to look up.
	 */
	Metrics.prototype._getScopedData = function _getScopedData(name, scope) {
	  if (!this.scoped[scope][name]) return
	
	  var normalized = this.normalizer.normalize(name)
	  if (normalized.ignore || !normalized.value) return
	
	  return [this.mapper.map(normalized.value, scope), this.scoped[scope][name]]
	}
	
	/**
	 * @return {object} A serializable version of the unscoped metrics. Intended
	 *                  for use by toJSON.
	 */
	Metrics.prototype._toUnscopedData = function _toUnscopedData() {
	  var metricData = []
	
	  Object.keys(this.unscoped).forEach(function cb_forEach(name) {
	    var data = this._getUnscopedData(name)
	    if (data) metricData.push(data)
	  }, this)
	
	  return metricData
	}
	
	/**
	 * @return {object} A serializable version of the scoped metrics. Intended for
	 *                  use by toJSON.
	 */
	Metrics.prototype._toScopedData = function _toScopedData() {
	  var metricData = []
	
	  Object.keys(this.scoped).forEach(function cb_forEach(scope) {
	    Object.keys(this.scoped[scope]).forEach(function cb_forEach(name) {
	      var data = this._getScopedData(name, scope)
	      if (data) metricData.push(data)
	    }, this)
	  }, this)
	
	  return metricData
	}
	
	module.exports = Metrics


/***/ },
/* 171 */
/***/ function(module, exports) {

	'use strict'
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var BYTES_PER_MB = 1024 * 1024
	var FROM_MILLIS = 1e-3
	
	
	/**
	 * Simple container for tracking running statistics for a metric.
	 */
	function Stats() {
	  this.total = 0
	  this.totalExclusive = 0
	  this.min = 0
	  this.max = 0
	  this.sumOfSquares = 0
	  this.callCount = 0
	}
	
	/**
	 * Update the summary statistics with a new value.
	 *
	 * @param {Number} totalTime Time, in seconds, of the measurement.
	 * @param {Number} exclusiveTime Time that was taken by only the
	 *                               current measurement (optional).
	 */
	Stats.prototype.recordValue = function recordValue(totalTime, exclusiveTime) {
	  // even if a caller messes up, don't break everything else
	  if (totalTime !== 0 && !totalTime) totalTime = 0
	  if (exclusiveTime !== 0 && !exclusiveTime) exclusiveTime = totalTime
	
	  if (this.callCount > 0) {
	    this.min = Math.min(totalTime, this.min)
	  } else {
	    this.min = totalTime
	  }
	  this.max = Math.max(totalTime, this.max)
	
	  this.sumOfSquares += (totalTime * totalTime)
	  this.callCount += 1
	  this.total += totalTime
	  this.totalExclusive += exclusiveTime
	}
	
	/**
	 * Until the collector accepts statistics in milliseconds, this code is going
	 * to have some hinky floating-point values to deal with.
	 */
	Stats.prototype.recordValueInMillis = recordValueInMillis
	function recordValueInMillis(totalTime, exclusiveTime) {
	  this.recordValue(
	    totalTime * FROM_MILLIS,
	    exclusiveTime >= 0 ? exclusiveTime * FROM_MILLIS : null
	  )
	}
	
	/**
	 * Really?
	 *
	 * FIXME: Really?
	 */
	Stats.prototype.recordValueInBytes = function recordValueInBytes(bytes, exclusiveBytes) {
	  exclusiveBytes = exclusiveBytes || bytes
	  this.recordValue(bytes / BYTES_PER_MB, exclusiveBytes / BYTES_PER_MB)
	}
	
	Stats.prototype.incrementCallCount = function incrementCallCount(count) {
	  if (typeof count === 'undefined') count = 1
	  this.callCount += count
	}
	
	/**
	 * Fold another summary's statistics into this one.
	 */
	Stats.prototype.merge = function merge(other) {
	  if (other.callCount > 0) {
	    if (this.callCount > 0) {
	      this.min = Math.min(this.min, other.min)
	    } else {
	      this.min = other.min
	    }
	  }
	  this.max = Math.max(this.max, other.max)
	
	  this.total += other.total
	  this.totalExclusive += other.totalExclusive
	  this.sumOfSquares += other.sumOfSquares
	  this.callCount += other.callCount
	}
	
	/**
	 * The serializer relies upon this representation, so don't change the
	 * values, cardinality, or ordering of this array without ensuring that
	 * it matches the version of the "protocol" being sent to the collector.
	 *
	 * @returns {Array} Number of calls,
	 *                  total time in seconds,
	 *                  time for this metric alone in seconds,
	 *                  shortest individual time in seconds,
	 *                  longest individual time in seconds,
	 *                  running sum of squares.
	 */
	Stats.prototype.toJSON = function toJSON() {
	  return [
	    this.callCount,
	    this.total,
	    this.totalExclusive,
	    this.min,
	    this.max,
	    this.sumOfSquares
	  ]
	}
	
	module.exports = Stats


/***/ },
/* 172 */
/***/ function(module, exports) {

	'use strict'
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var FROM_MILLIS = 1e-3
	
	
	function ApdexStats(apdexT) {
	  if (!apdexT && apdexT !== 0) {
	    throw new Error('Apdex summary must be created with apdexT.')
	  }
	  this.apdexT = apdexT
	
	  this.satisfying = 0
	  this.tolerating = 0
	  this.frustrating = 0
	}
	
	ApdexStats.prototype.recordValue = function recordValue(time, overrideApdex) {
	  var apdexT = overrideApdex || this.apdexT
	  if (time <= apdexT) {
	    ++this.satisfying
	  } else if (time <= 4 * apdexT) {
	    ++this.tolerating
	  } else {
	    ++this.frustrating
	  }
	}
	
	ApdexStats.prototype.recordValueInMillis =
	function recordValueInMillis(timeInMillis, overrideApdex) {
	  this.recordValue(timeInMillis * FROM_MILLIS, overrideApdex * FROM_MILLIS)
	}
	
	/**
	 * Used by the error handler to indicate that a user was frustrated by a page
	 * error.
	 */
	ApdexStats.prototype.incrementFrustrating = function incrementFrustrating() {
	  ++this.frustrating
	}
	
	/**
	 * When merging apdex stastics, the apdex tolerating value isn't brought along
	 * for the ride.
	 *
	 * @param {ApdexStats} other The existing apdex stats being merged in.
	 */
	ApdexStats.prototype.merge = function merge(other) {
	  this.satisfying += other.satisfying
	  this.tolerating += other.tolerating
	  this.frustrating += other.frustrating
	}
	
	/**
	 * This feels dirty: ApdexStats override the ordinary statistics serialization
	 * format by putting satisfying, tolerating and frustrating values in the
	 * first three fields in the array and setting the next two to the apdex (used
	 * by calculations inside RPM), followed by 0.
	 *
	 * @returns {Array} A six-value array where only the first three values are
	 *                  significant: satisfying, tolerating, and frustrating
	 *                  load times, respectively.
	 */
	ApdexStats.prototype.toJSON = function toJSON() {
	  return [
	    this.satisfying,
	    this.tolerating,
	    this.frustrating,
	    this.apdexT,
	    this.apdexT,
	    0
	  ]
	}
	
	module.exports = ApdexStats


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var EventEmitter = __webpack_require__(26).EventEmitter
	var util = __webpack_require__(16)
	var arrUtil = __webpack_require__(174)
	var logger = __webpack_require__(12).child({component: 'metric_normalizer'})
	var deepEqual = __webpack_require__(175)
	var Rule = __webpack_require__(176)
	var NAMES = __webpack_require__(59)
	
	
	function url(normalized, path, config) {
	  if (normalized) return NAMES.NORMALIZED + normalized
	
	  if (config.enforce_backstop) {
	    return NAMES.NORMALIZED + '/*'
	  }
	
	  return NAMES.URI + path
	}
	
	function plain(normalized, path) {
	  if (normalized) {
	    return normalized
	  }
	
	  return path
	}
	
	/**
	 * The collector keeps track of rules that should be applied to metric names,
	 * and sends these rules to the agent at connection time. These rules can
	 * either change the name of the metric or indicate that metrics associated with
	 * this name (which is generally a URL path) should be ignored altogether.
	 *
	 * @param {object} config The agent's configuration blob, which has a parameter
	 *                        that indicates whether to enforce the normalization
	 *                        backstop.
	 */
	function MetricNormalizer(config, type) {
	  if (!config) throw new Error("normalizer must be created with configuration.")
	  if (!type) throw new Error("normalizer must be created with a type.")
	
	  EventEmitter.call(this)
	
	  this.config = config
	  this.type = type
	  // some mildly cheesy polymorphism to make normalizers work generically
	  if (type === 'URL') {
	    this.formatter = url
	  } else {
	    this.formatter = plain
	  }
	
	  this.rules = []
	}
	util.inherits(MetricNormalizer, EventEmitter)
	
	// -------------------------------------------------------------------------- //
	
	/**
	 * @typedef {Object} NormalizationResults
	 *
	 * @property {bool}   matched - True if a rule was found that matched.
	 * @property {bool}   ignore  - True if the given input should be ignored.
	 * @property {string} value   - The normalized input value.
	 */
	
	// -------------------------------------------------------------------------- //
	
	/**
	 * Convert the raw, de-serialized JSON response into a set of
	 * NormalizationRules.
	 *
	 * @param object json The de-serialized JSON response sent on collector
	 *                    connection.
	 */
	MetricNormalizer.prototype.load = function load(json) {
	  if (json) {
	    this.rules = []
	    logger.debug("Received %s %s normalization rule(s) from the server",
	      json.length, this.type)
	
	    json.forEach(function cb_forEach(ruleJSON) {
	      // no need to add the same rule twice
	      var rule = new Rule(ruleJSON)
	      if (!arrUtil.find(this.rules, deepEqual.bind(null, rule))) {
	        this.rules.push(rule)
	        logger.trace("Loaded %s normalization rule: %s", this.type, rule)
	      }
	    }, this)
	
	    /* I (FLN) always forget this, so making a note: JS sort is always
	     * IN-PLACE, even though it returns the sorted array.
	     */
	    this.rules.sort(function cb_sort(a, b) {
	      return a.precedence - b.precedence
	    })
	
	    logger.debug("Loaded %s %s normalization rule(s).",
	                 this.rules.length, this.type)
	  }
	}
	
	/**
	 * Load any rules found in the configuration into a metric normalizer.
	 *
	 * Operates via side effects.
	 */
	MetricNormalizer.prototype.loadFromConfig = function loadFromConfig() {
	  var rules = this.config.rules
	
	  if (rules && rules.name && rules.name.length > 0) {
	    rules.name.forEach(function cb_forEach(rule) {
	      if (!rule.pattern) {
	        return logger.error(
	          {rule: rule},
	          "Simple naming rules require a pattern."
	        )
	      }
	      if (!rule.name) {
	        return logger.error(
	          {rule: rule},
	          "Simple naming rules require a replacement name."
	        )
	      }
	
	      var precedence = rule.precedence
	      var terminal = rule.terminate_chain
	      var json = {
	        match_expression: rule.pattern,
	        eval_order: (typeof precedence === 'number') ? precedence : 500,
	        terminate_chain: (typeof terminal === 'boolean') ? terminal : true,
	        replace_all: rule.replace_all,
	        replacement: rule.name,
	        ignore: false
	      }
	
	      // Find where the rule should be inserted and do so.
	      var reverse = this.config.feature_flag.reverse_naming_rules
	      var insert = arrUtil.findIndex(this.rules, function findRule(r) {
	        return reverse
	          ? r.precedence >= json.eval_order
	          : r.precedence > json.eval_order
	      })
	      if (insert === -1) {
	        this.rules.push(new Rule(json))
	      } else {
	        this.rules.splice(insert, 0, new Rule(json))
	      }
	    }, this)
	  }
	
	  if (rules && rules.ignore && rules.ignore.length > 0) {
	    rules.ignore.forEach(function cb_forEach(pattern) {
	      this.addSimple(pattern)
	    }, this)
	  }
	}
	
	/**
	 * Add simple, user-provided rules to the head of the match list. These rules
	 * will always be highest precedence, always will terminate matching, and
	 * will always apply to the URL as a whole. If no name is provided, then
	 * transactions attached to the matching URLs will be ignored.
	 *
	 *  - `addSimple(opts)`
	 *  - `addSimple(pattern [, name])`
	 *
	 * @param {RegExp} pattern The pattern to rename (with capture groups).
	 * @param {string} [name]  The name to use for the transaction.
	 */
	MetricNormalizer.prototype.addSimple = function addSimple(pattern, name) {
	  if (!pattern) return logger.error("Simple naming rules require a pattern.")
	
	  var json = {
	    match_expression: pattern,
	    eval_order: 0,
	    terminate_chain: true,
	    replace_all: false,
	    replacement: null,
	    ignore: false
	  }
	
	  if (name) {
	    json.replacement = name
	  } else {
	    json.ignore = true
	  }
	
	  this.rules.unshift(new Rule(json))
	}
	
	/**
	 * Turn a (scrubbed) URL path into partial metric name.
	 *
	 * @param {string} path - The URL path to turn into a name.
	 *
	 * @returns {NormalizationResults} - The results of normalization.
	 */
	MetricNormalizer.prototype.normalize = function normalize(path) {
	  var last = path
	  var length = this.rules.length
	  var normalized
	  var matched = false
	  var ignored = false
	
	  // Apply each of our rules in turn.
	  for (var i = 0; i < length; i++) {
	    var rule = this.rules[i]
	    var applied = rule.apply(last)
	    if (!rule.matched) {
	      continue
	    }
	
	    if (rule.ignore) {
	      ignored = true
	    } else {
	      matched = true
	      normalized = applied
	
	      // emit event when a rule is matched
	      // we could also include an array of matched rules in the returned map, but
	      // that would increase memory overhead by creating additional array
	      this.emit('appliedRule', rule, normalized, last)
	
	      logger.trace({rule: rule, type: this.type},
	        "Normalized %s to %s.", last, normalized)
	      last = normalized
	    }
	
	    if (rule.isTerminal) {
	      logger.trace({rule: rule}, "Terminating normalization.")
	      break
	    }
	  }
	
	  // Return the normalized path.
	  return {
	    matched: matched,
	    ignore: ignored,
	    value: this.formatter(normalized, path, this.config)
	  }
	}
	
	module.exports = MetricNormalizer


/***/ },
/* 174 */
/***/ function(module, exports) {

	'use strict'
	
	exports.find = arrayFind
	exports.findLast = arrayFindLast
	exports.findIndex = arrayFindIndex
	exports.findLastIndex = arrayFindLastIndex
	
	/**
	 * Finds the first element in an array that `pred` matches.
	 *
	 * Remove once Node v0.10, v0.12, v1, v2, and v3 are no longer supported.
	 *
	 * @deprecated With Node.js v4
	 *
	 * @param {Array}     arr   - The array to search.
	 * @param {Function}  pred  - A predicate function which returns `true` on matches.
	 * @param {*}         [ctx] - The `this` arg for `pred`.
	 *
	 * @return {*?} - The first matching item if found, otherwise `undefined`.
	 */
	function arrayFind(arr, pred, ctx) {
	  var idx = arrayFindIndex(arr, pred, ctx)
	  if (idx >= 0) {
	    return arr[idx]
	  }
	}
	
	/**
	* Finds the last element in an array that `pred` matches.
	 *
	 * @param {Array}     arr   - The array to search.
	 * @param {Function}  pred  - A predicate function which returns `true` on matches.
	 * @param {*}         [ctx] - The `this` arg for `pred`.
	 *
	 * @return {*?} - The last matching item if found, otherwise `undefined`.
	 */
	function arrayFindLast(arr, pred, ctx) {
	  var idx = arrayFindLastIndex(arr, pred, ctx)
	  if (idx >= 0) {
	    return arr[idx]
	  }
	}
	
	/**
	 * Finds the first index of a single element in an array matching `pred`.
	 *
	 * Remove once Node v0.10, v0.12, v1, v2, and v3 are no longer supported.
	 *
	 * @deprecated With Node.js v4
	 *
	 * @param {Array}     arr   - The array to search.
	 * @param {Function}  pred  - A predicate function which returns `true` on matches.
	 * @param {*}         [ctx] - The `this` arg for `pred`.
	 *
	 * @return {number} - The index of the first matching item if found, otherwise `-1`.
	 */
	function arrayFindIndex(arr, pred, ctx) {
	  for (var i = 0; i < arr.length; ++i) {
	    if (pred.call(ctx, arr[i], i, arr)) {
	      return i
	    }
	  }
	  return -1
	}
	
	/**
	 * Finds the last index of a single element in an array matching `pred`.
	 *
	 * @param {Array}     arr   - The array to search.
	 * @param {Function}  pred  - A predicate function which returns `true` on matches.
	 * @param {*}         [ctx] - The `this` arg for `pred`.
	 *
	 * @return {number} - The index of the last matching item if found, otherwise `-1`.
	 */
	function arrayFindLastIndex(arr, pred, ctx) {
	  for (var i = arr.length - 1; i >= 0; --i) {
	    if (pred.call(ctx, arr[i], i, arr)) {
	      return i
	    }
	  }
	  return -1
	}


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict'
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) === '[object Arguments]'
	}
	
	function slice(args) {
	  // Array.prototype.slice on arguments array-like is expensive
	  var l = args.length, a = [], i
	  for (i = 0; i < l; i++) {
	    a[i] = args[i]
	  }
	  return a
	}
	
	/**
	 * This is a node-specific version of deepEquals, modeled on bits and pieces
	 * of loads of other implementations of this algorithm, most notably the
	 * one in the Node.js source and Underscore's. It doesn't throw and handles
	 * cycles.
	 *
	 * Everybody who writes one of these functions puts the documentation
	 * inline, which makes it incredibly hard to follow. Here's what this version
	 * of the algorithm does, in order:
	 *
	 * 1. === only tests objects and and functions by reference. Null is an object.
	 *    Any pair of identical entities failing this test are therefore objects
	 *    (including null), which need a recursive compare by attribute.
	 * 2. Since the only matching entities to get to this test must be objects, if
	 *    a or b is not an object, they're clearly not the same. All unfiltered a
	 *    and b getting are objects (including null).
	 * 3. null is an object, but null === null. All unfiltered a and b are non-null
	 *    objects.
	 * 4. Buffers need to be special-cased because they live partially on the wrong
	 *    side of the C++ / JavaScript barrier. Still, calling this on structures
	 *    that can contain Buffers is a bad idea, because they can contain
	 *    multiple megabytes of data and comparing them byte-by-byte is very
	 *    expensive. buffertools is a better solution here, but this version of
	 *    this code is dependency free.
	 * 5. It's much faster to compare dates by numeric value than by lexical value.
	 * 6. Same goes for Regexps.
	 * 7. The parts of an arguments list most people care about are the arguments
	 *    themselves, not the callee, which you shouldn't be looking at anyway.
	 * 8. Objects are more complex:
	 *    a. ensure that a and b are on the same constructor chain
	 *    b. ensure that a and b have the same number of own properties (which is
	 *       what Object.keys returns).
	 *    c. ensure that cyclical references don't blow up the stack.
	 *    d. ensure that all the key names match (faster)
	 *    e. ensure that all of the associated values match, recursively (slower)
	 *
	 * (SOMEWHAT UNTESTED) ASSUMPTIONS:
	 *
	 * o Functions are only considered identical if they unify to the same
	 *   reference. To anything else is to invite the wrath of the halting problem.
	 * o V8 is smart enough to optimize treating an Array like any other kind of
	 *   object.
	 * o Users of this function are cool with mutually recursive data structures
	 *   that are otherwise identical being treated as the same.
	 */
	function deeper(a, b, ca, cb) {
	  if (a === b) {
	    return true
	  } else if (typeof a !== 'object' || typeof b !== 'object') {
	    return false
	  } else if (a === null || b === null) {
	    return false
	  } else if (Buffer.isBuffer(a) && Buffer.isBuffer(b)) {
	    if (a.length !== b.length) return false
	
	    // potentially incredibly expensive
	    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return false
	
	    return true
	  } else if (a instanceof Date && b instanceof Date) {
	    return a.getTime() === b.getTime()
	  } else if (a instanceof RegExp && b instanceof RegExp) {
	    return a.source === b.source &&
	           a.global === b.global &&
	           a.multiline === b.multiline &&
	           a.lastIndex === b.lastIndex &&
	           a.ignoreCase === b.ignoreCase
	  } else if (isArguments(a) || isArguments(b)) {
	    if (!(isArguments(a) && isArguments(b))) return false
	
	    return deeper(slice(a), slice(b), ca, cb)
	  }
	
	  if (a.constructor !== b.constructor) return false
	
	  var ka = Object.keys(a), kb = Object.keys(b)
	  if (ka.length !== kb.length) return false
	
	  var cal = ca.length
	  while (cal--) if (ca[cal] === a) return cb[cal] === b
	  ca.push(a); cb.push(b)
	
	  ka.sort(); kb.sort()
	  for (var j = ka.length - 1; j >= 0; j--) if (ka[j] !== kb[j]) return false
	
	  var key
	  for (var k = ka.length - 1; k >= 0; k--) {
	    key = ka[k]
	    if (!deeper(a[key], b[key], ca, cb)) return false
	  }
	
	  ca.pop(); cb.pop()
	
	  return true
	}
	
	module.exports = function exports(a, b) {
	  return deeper(a, b, [], [])
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'normalizer_rule'})
	
	
	/**
	 * JavaScript just has to do things slightly differently.
	 */
	var replaceReplacer = function replaceReplacer(input) {
	  return input.replace(/\\/g, '$')
	}
	
	/**
	 * Be liberal about accepting incomplete information, because we don't want
	 * bad rules from the collector to crash client apps. Otherwise, this is a
	 * fairly straightforward mapping of the concepts in metric normalization
	 * rules into an object form.
	 *
	 * @param {Object} json A JavaScript object literal parsed out from the JSON
	 *                      from the collector.
	 */
	function NormalizerRule(json) {
	  if (!json) {
	    logger.debug(
	      "Received incompletely specified metric normalization rule from collector."
	    )
	    json = {}
	  }
	
	  this.eachSegment = json.each_segment || false
	  this.precedence = json.eval_order || 0
	  this.isTerminal = json.terminate_chain || false
	  this.replacement = replaceReplacer(json.replacement || '$0')
	  this.replaceAll = json.replace_all || false
	  this.ignore = json.ignore || false
	  this.matched = false
	
	  var modifiers = 'i'
	  if (this.replaceAll) modifiers += 'g'
	
	  // don't allow this to fail
	  if (json.match_expression instanceof RegExp) {
	    this.pattern = _addRegExpFlags(json.match_expression, modifiers)
	  } else {
	    try {
	      this.pattern = new RegExp(json.match_expression || '^$', modifiers)
	    } catch (error) {
	      logger.warn(error, "Problem compiling metric normalization rule pattern.")
	      this.pattern = /^$/
	    }
	  }
	}
	
	/**
	 * Allow the higher-level functions to operate on input uniformly.
	 *
	 * @param {string} input URL to potentially be split.
	 */
	NormalizerRule.prototype.getSegments = function getSegments(input) {
	  if (this.eachSegment) {
	    return input.split('/')
	  }
	
	  return [input]
	}
	
	/**
	 * Check if a URL matches a rule.
	 *
	 * Does not set {NormalizerRule#matched}.
	 *
	 * @param {string} input - URL to match.
	 *
	 * @return {bool} - True if this rule matches the given input, otherwise false.
	 */
	NormalizerRule.prototype.matches = function matches(input) {
	  var segments = this.getSegments(input)
	
	  for (var i = 0; i < segments.length; ++i) {
	    if (this.pattern.test(segments[i])) {
	      return true
	    }
	  }
	
	  return false
	}
	
	/**
	 * Apply the substitutions, if any, to the input.
	 *
	 * Also sets {NormalizerRule#matched} to true if this rule did match the given
	 * input.
	 *
	 * String.split will return empty segments when the path has a leading slash or
	 * contains a run of slashes. Don't inadvertently substitute or drop these empty
	 * segments, or the normalized path will be wrong.
	 *
	 * XXX In Node v0.8 and Node v0.10, `RegExp#test` advances internal state and
	 * XXX tracks where it left off from the previous match. This has the side
	 * XXX effect that reusing the same object may cause false negatives if you do
	 * XXX not reset that state. The only way to reset the state is to set
	 * XXX `RegExp#lastIndex` to `0`.
	 *
	 * @param {string} input - URL to normalize.
	 *
	 * @return {string?} - The normalized url, or `null` if this is an ignore rule
	 *  that matched this url.
	 */
	NormalizerRule.prototype.apply = function apply(input) {
	  // For ignore rules, just see if we match and return either `null` or the
	  // original input.
	  if (this.ignore) {
	    return (this.matched = this.matches(input)) ? null : input
	  }
	
	  this.matched = false
	  return this.getSegments(input)
	    .map(function applyMap(segment) {
	      // Discussion of why we use `lastIndex` in function documentation to
	      // prevent de-opt due to long function.
	      this.pattern.lastIndex = 0
	      if (segment && this.pattern.test(segment)) {
	        this.matched = true
	        return segment.replace(this.pattern, this.replacement)
	      }
	      return segment
	    }, this)
	    .join('/')
	}
	
	NormalizerRule.prototype.toJSON = function toJSON() {
	  return {
	    eachSegment: this.eachSegment,
	    precedence: this.precedence,
	    isTerminal: this.isTerminal,
	    replacement: this.replacement,
	    replaceAll: this.replaceAll,
	    ignore: this.ignore,
	    pattern: this.pattern.source
	  }
	}
	
	/**
	 * Merges the given flags with those already in a regular expression.
	 *
	 * @param {RegExp} re     - The regular expression to add flags to.
	 * @param {string} flags  - The flags to add to the regex.
	 *
	 * @return {RegExp} - A regular expression with all the given flags added.
	 */
	function _addRegExpFlags(re, flags) {
	  var foundMissing = false
	  var reFlags = _getRegExpFlags(re)
	  for (var i = 0; i < flags.length; ++i) {
	    if (reFlags.indexOf(flags[i]) === -1) {
	      foundMissing = true
	      reFlags += flags[i]
	    }
	  }
	  return foundMissing ? new RegExp(re.source, reFlags) : re
	}
	
	/**
	 * Pulls all the flags for a regular expression.
	 *
	 * @param {RegExp} re - The regular expression to extract the flags of.
	 *
	 * @return {string} - The regex flags.
	 */
	function _getRegExpFlags(re) {
	  // Available in Node >6.
	  if ('flags' in re) {
	    return re.flags
	  }
	
	  // Remove this logic once we've deprecated Node <=4, so in 2030.
	  var flags = ''
	  if (re.global) {
	    flags += 'g'
	  }
	  if (re.ignoreCase) {
	    flags += 'i'
	  }
	  if (re.multiline) {
	    flags += 'm'
	  }
	  if (re.sticky) {
	    flags += 'y'
	  }
	  if (re.unicode) {
	    flags += 'u'
	  }
	  return flags
	}
	
	module.exports = NormalizerRule


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'tx_segment_normalizer'})
	
	module.exports = TxSegmentNormalizer
	
	function TxSegmentNormalizer() {
	  this.terms = []
	}
	
	/**
	 * This normalize method is wicked. The best bet is to read the spec:
	 * https://newrelic.atlassian.net/wiki/pages/viewpage.action?spaceKey=eng&title=Language+agent+transaction+segment+terms+rules
	 *
	 * A copy paste of the rules that were followed:
	 *  1. Find the first rule where the prefix key matches the prefix of the
	 *     transaction name. If no matching rules are found, abort.
	 *  2. Strip the prefix from the transaction name.
	 *  3. Split the rest of the transaction name into segments on slashes ('/').
	 *  4. For each segment:
	 *      If the segment appears in the array of strings given under the terms key,
	 *      keep it unchanged. Else, replace it with a placeholder ('*')
	 *  5. Collapse all adjacent placeholder segments into a single '*' segment.
	 *  6. Join together the modified segments with slashes, and re-prepend the prefix.
	 *
	 * @param {string} path - The transaction metric path to normalize.
	 *
	 * @return {NormalizationResults} - The results of normalizing the given path.
	 */
	TxSegmentNormalizer.prototype.normalize = function normalize(path) {
	  var currentTerm
	  var prefix
	  for (var i = 0; i < this.terms.length; i++) {
	    currentTerm = this.terms[i]
	    prefix = currentTerm.prefix
	    if (path.lastIndexOf(prefix, 0) === -1) {
	      continue
	    }
	    var fragment = path.slice(prefix.length)
	    var parts = fragment.split('/')
	    var result = []
	    var prev
	
	    var segment
	    for (var j = 0; j < parts.length; j++) {
	      segment = parts[j]
	
	      if (segment === '' && j + 1 === parts.length) break
	
	      if (currentTerm.terms.indexOf(segment) === -1) {
	        if (prev === '*') continue
	        result.push(prev = '*')
	      } else {
	        result.push(prev = segment)
	      }
	    }
	    logger.trace('Normalizing %s because of rule: %s', path, currentTerm)
	    return {
	      matched: true, // To match MetricNormalizer
	      ignore: false, // ^^
	      value: prefix + result.join('/')
	    }
	  }
	
	  return {
	    matched: false, // To match MetricNormalizer
	    ignore: false,  // ^^
	    value: path
	  }
	}
	
	TxSegmentNormalizer.prototype.load = function load(json) {
	  if (Array.isArray(json)) {
	    this.terms = filterRules(json)
	  } else {
	    logger.warn(
	      'transaction_segment_terms was not an array got: %s (%s)',
	      typeof json,
	      json
	    )
	  }
	}
	
	function filterRules(rules) {
	  var map = {}
	
	  for (var i = 0, l = rules.length; i < l; ++i) {
	    var prefix = rules[i].prefix
	
	    if (!prefix || typeof prefix !== 'string') continue
	
	    if (prefix[prefix.length - 1] !== '/') {
	      prefix = prefix + '/'
	      rules[i].prefix = prefix
	    }
	
	    var segments = prefix.split('/')
	    if (segments.length !== 3 || !segments[0] || !segments[1] || segments[3]) continue
	
	    if (Array.isArray(rules[i].terms)) {
	      map[prefix] = rules[i]
	    }
	  }
	
	  var keys = Object.keys(map)
	  var filtered = new Array(keys.length)
	
	  for (i = 0, l = keys.length; i < l; ++i) {
	    filtered[i] = map[keys[i]]
	  }
	
	  return filtered
	}


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'mapper'})
	
	
	/**
	 * To tighten up the metrics JSON, the collector will maintain a list of
	 * mappings from metric names (which sometimes include scopes as well) to
	 * numeric IDs. As the agent sends new metric names to the collector, the
	 * collector will return corresponding metric IDs, in the expectation that the
	 * agent will uses those IDs instead of the names going forward.
	 *
	 * @param {Array} raw A list of metric spec -> ID mappings represented as
	 *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]
	 */
	function MetricMapper(raw) {
	  this.unscoped = {}
	  this.scoped = {}
	  this.length = 0
	
	  this.load(raw)
	}
	
	/**
	 * Parse the list of metric mappings returned on metric_data responses from the
	 * collector. These continue to stream in as the agent runs, so keep adding to
	 * the collection rather than resetting.
	 *
	 * https://hudson.newrelic.com/job/collector-master/javadoc/com/nr/collector/datatypes/MetricData.html
	 *
	 * @param {Array} raw A list of metric spec -> ID mappings represented as
	 *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]
	 */
	MetricMapper.prototype.load = function load(raw) {
	  if (!(raw && raw.length)) {
	    logger.debug("No new metric mappings from server.")
	    return
	  }
	
	  for (var i = 0; i < raw.length; i++) {
	    var spec = raw[i][0]
	    var scope = spec.scope
	    var name = spec.name
	    var id = raw[i][1]
	    var resolved
	
	
	    if (scope) {
	      if (!this.scoped[scope]) this.scoped[scope] = {}
	      resolved = this.scoped[scope]
	    } else {
	      resolved = this.unscoped
	    }
	
	    if (!resolved[name]) this.length++
	    resolved[name] = id
	    logger.trace("Metric spec %s has been mapped to ID %s.", spec, id)
	  }
	  logger.debug("Parsed %d metric ids (%d total).", raw.length, this.length)
	}
	
	/**
	 * @param {String} name  The metric name.
	 * @param {String} scope The scope for the metric, if set.
	 *
	 * @returns {object} Either a metric spec based on the parameters, or the
	 *                   server-sent ID.
	 */
	MetricMapper.prototype.map = function map(name, scope) {
	  if (scope) {
	    if (this.scoped[scope] && this.scoped[scope][name]) {
	      return this.scoped[scope][name]
	    }
	    return {name: name, scope: scope}
	  }
	
	  if (this.unscoped[name]) {
	    return this.unscoped[name]
	  }
	
	  return {name: name}
	}
	
	module.exports = MetricMapper


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var logger = __webpack_require__(12).child({component: 'trace-aggregator'})
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var TO_MILLIS = 1e3
	
	/**
	 * Locus for the complicated logic surrounding the selection of slow
	 * transaction traces for submission to the collector.
	 *
	 * @param {object} config Dictionary containing transaction tracing
	 *                        parameters. Required.
	 */
	function TraceAggregator(config) {
	  if (!config) throw new Error("Trace aggregator needs configuration at creation.")
	  /*eslint-disable */
	  /*
	   * From
	   * 
	   * https://newrelic.atlassian.net/wiki/display/eng/Transaction+Trace+Collection+Improvements
	   *
	   * 5 Transaction Trace Guarantee
	   *
	   * For the initial experience problem, the Agent will sample up to 1
	   * transaction per minute until it has sampled 5 transactions. This
	   * guarantees that the agent will always report some transaction traces.
	   * There is no time out for this sampling period - the agent always
	   * samples until it has collected 5 transactions. The agent doesn't
	   * simply report the first 5 transactions that it sees because it's
	   * likely (particularly for a local dev test) that all 5 transactions
	   * would be associated with one request (a single web page and its
	   * resources).
	   */
	  /*eslint-enable */
	
	
	  this.reported = 0
	  this.config = config
	
	  // Setting up top n capacity.
	  this.capacity = 1
	  if (config.transaction_tracer &&
	      config.transaction_tracer.top_n) {
	    this.capacity = config.transaction_tracer.top_n
	  }
	
	  // hidden class optimization
	  this.trace = null
	  this.syntheticsTraces = []
	  this.requestTimes = {}
	  this.noTraceSubmitted = 0
	}
	
	/**
	 * For every five harvest cycles (or "minutes"), if no new slow transactions
	 * have been added, reset the requestTime match and allow a new set of five
	 * to start populating the Top N Slow Trace list.
	 */
	TraceAggregator.prototype.resetTimingTracker = function resetTT() {
	  this.requestTimes = {}
	  this.noTraceSubmitted = 0
	}
	
	/**
	 * Add a trace to the slow trace list, if and only if it fulfills the necessary
	 * criteria.
	 *
	 * @param {Transaction} transaction The transaction, which we need to check
	 *                                  apdexT, as well as getting the trace.
	 */
	TraceAggregator.prototype.add = function add(transaction) {
	  if (this.config.collect_traces &&
	      this.config.transaction_tracer && this.config.transaction_tracer.enabled &&
	      transaction && transaction.metrics) {
	    var trace = transaction.trace
	    var name = transaction.name
	    var duration = trace.getDurationInMillis()
	    var apdexT = transaction.metrics.apdexT
	
	    if (transaction.syntheticsData && this.syntheticsTraces.length < 20) {
	      this.syntheticsTraces.push(trace)
	    } else if (this.isBetter(name, duration, apdexT)) {
	      this.trace = trace
	
	      // because of the "first 5" rule, this may or may not be the slowest
	      if (!this.requestTimes[name] || this.requestTimes[name] < duration) {
	        this.requestTimes[name] = duration
	      }
	    }
	
	    this.config.measureInternal('Transaction/Count', duration)
	  }
	}
	
	/**
	 * If there's a slow trace to be sent, encode it and pass it along
	 * to the callback, otherwise update the relevant trace diversity settings.
	 *
	 * @param Function callback The receiver of the encoded trace or errors.
	 */
	TraceAggregator.prototype.harvest = function harvest(callback) {
	  var tracesToAggregate = 0
	  var encodedTraces = []
	  var errored = false
	  var normalTrace = null
	
	  // Synthetics
	  for (var i = 0, len = this.syntheticsTraces.length; i < len; ++i) {
	    this.syntheticsTraces[i].generateJSON(resultAggregator)
	    tracesToAggregate++
	  }
	
	  if (this.trace) {
	    var max = this.trace.transaction.agent.config.max_trace_segments
	    if (this.trace.segmentsSeen > max) {
	      logger.warn(
	        'transaction %s contained %d segments, only collecting the fist %d',
	        this.trace.transaction.name,
	        this.trace.segmentsSeen,
	        max
	      )
	    }
	    normalTrace = this.trace
	    this.noTraceSubmitted = 0
	    this.trace.generateJSON(resultAggregator)
	    tracesToAggregate++
	  } else {
	    this.noTraceSubmitted++
	    if (this.noTraceSubmitted >= 5) this.resetTimingTracker()
	  }
	
	  if (tracesToAggregate === 0) {
	    process.nextTick(function cb_nextTick() {
	      callback(null, null, null)
	    })
	  }
	
	  function resultAggregator(err, encoded) {
	    if (errored) {
	      return
	    }
	
	    if (err) {
	      errored = true
	      callback(err)
	    }
	
	    encodedTraces.push(encoded)
	
	    if (encodedTraces.length === tracesToAggregate) {
	      callback(null, encodedTraces, normalTrace)
	    }
	  }
	}
	
	/**
	 * Reset the trace diversity settings after a successful harvest.
	 *
	 * @param {Trace} trace Because the harvest cycle can take a while,
	 *                      it's possible a better trace came along
	 *                      in the window between the start and end of
	 *                      the harvest cycle, so don't throw that away.
	 */
	TraceAggregator.prototype.reset = function reset(trace) {
	  this.reported++
	  if (trace === this.trace) this.trace = null
	  this.syntheticsTraces = []
	}
	
	/*eslint-disable */
	/**
	 * Determine whether a new trace is more worth keeping than an old one.
	 * This gets called on every single transactionFinished event, so return as
	 * quickly as possible and call as few external functions as possible. On the
	 * converse, there's some complicated logic here, so spell things out.
	 *
	 * All specifications are from
	 * https://newrelic.atlassian.net/wiki/display/eng/Transaction+Trace+Collection+Improvements
	 *
	 * @param {string} name     Name of this transaction's key metric.
	 * @param {number} duration Time the transaction took, in milliseconds.
	 * @param {number} apdexT   Apdex tolerating threshold, in seconds.
	 */
	/*eslint-enable */
	TraceAggregator.prototype.isBetter = function isBetter(name, duration, apdexT) {
	  /* 1. If the transaction duration is below the tracing threshold, the
	   *    transaction is skipped.
	   *
	   * The threshold for slow traces defaults to apdex_f, which is 4 * apdex_t.
	   */
	  var config = this.config.transaction_tracer
	  var isOverThreshold
	
	  if (config &&
	      config.transaction_threshold &&
	      config.transaction_threshold !== 'apdex_f' &&
	      typeof config.transaction_threshold === 'number') {
	    isOverThreshold = duration > config.transaction_threshold * TO_MILLIS
	  } else {
	    isOverThreshold = duration > 4 * TO_MILLIS * apdexT
	  }
	  if (!isOverThreshold) return false
	
	  /* 2. If the transaction duration is less than the duration of the current
	   *    slow transaction, the transaction is skipped.
	   */
	  var slowerThanExisting = true
	  if (this.trace) {
	    slowerThanExisting = this.trace.getDurationInMillis() < duration
	  }
	  if (!slowerThanExisting) return false
	
	  /* We always gather some slow transactions at the start, regardless of
	   * the size of Top N. This changes the behavior of the rest of the
	   * decision-making process in some subtle ways.
	   */
	  var hasMetGuarantee = this.reported >= 5
	
	  /* 3. If the transaction's name is in the transaction map and its duration
	   *    is less than the response time in the map, it is skipped.
	   */
	  var slowerThanCaptured = true
	  if (hasMetGuarantee) {
	    if (this.requestTimes[name]) {
	      slowerThanCaptured = this.requestTimes[name] < duration
	    }
	  }
	  if (!slowerThanCaptured) return false
	
	  /* Not part of enumerated rules, but necessary for Top N support:
	   * Ensure this name is either already in the request time map
	   * or that the map still hasn't hit capacity.
	   */
	  if (hasMetGuarantee &&
	      !this.requestTimes[name] &&
	      Object.keys(this.requestTimes).length >= this.capacity) {
	    return false
	  }
	
	  /* 4. The transaction is held as the slowest transaction.
	   */
	  return true
	}
	
	module.exports = TraceAggregator
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var path = __webpack_require__(58)
	var logger = __webpack_require__(12)
	var NAMES = __webpack_require__(59)
	var INSTRUMENTATIONS = __webpack_require__(181)()
	
	module.exports = {
	  check: check,
	  createMetrics: createMetrics
	}
	
	
	// Special case since we do some hackish stuff in lib/shimmer.js to make pg.js
	// work
	INSTRUMENTATIONS.push('pg.js')
	
	// Static variable holding list of un-instrumented modules for use in the future
	var uninstrumented = []
	
	// Log a helpful message about un-instrumented modules
	function logUninstrumented() {
	  if (uninstrumented.length > 0) {
	    var message =
	      'The newrelic module must be the first module required.\n' +
	      'The following modules were required before newrelic and are not being ' +
	      'instrumented:'
	
	    uninstrumented.forEach(function buildMessage(module) {
	      message += '\n\t' + module.name + ': ' + module.filename
	    })
	
	    logger.warn(message)
	  }
	}
	
	// Create Supportability/Uninstrumented/<module> metrics
	//
	// @param metrics Agent metrics aggregator
	function createMetrics(metrics) {
	  if (uninstrumented.length > 0) {
	    metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.UNINSTRUMENTED).incrementCallCount()
	  }
	
	  uninstrumented.forEach(function addMetrics(module) {
	    metrics.getOrCreateMetric(
	      NAMES.SUPPORTABILITY.UNINSTRUMENTED + '/' + module.name
	    ).incrementCallCount()
	  })
	}
	
	// Determine module name from filename of module's main script
	//
	// Heuristic: take the first path name that isn't 'index.js' or 'lib'.
	//
	// @param filename Filename of module's main script
	// @return Name of module
	function moduleNameFromFilename(filename) {
	  var name = path.basename(filename, '.js')
	  if (name !== 'index') return name
	
	  var paths = filename.split(path.sep).slice(0, -1)
	  for (var i = paths.length - 1; i >= 0; i--) {
	    if (paths[i] !== 'lib') return paths[i]
	  }
	}
	
	// Check for any instrument-able modules that have already been loaded. This does
	// not check core modules as we don't have access to the core module loader
	// cache. But, users probably are missing instrumentation for other modules if
	// they are missing instrumentation for core modules.
	function check() {
	  for (var filename in __webpack_require__.c) {
	    if (!__webpack_require__.c.hasOwnProperty(filename)) {
	      continue
	    }
	    var name = moduleNameFromFilename(filename)
	
	    if (INSTRUMENTATIONS.indexOf(name) !== -1) {
	      uninstrumented.push({name: name, filename: filename})
	    }
	  }
	
	  logUninstrumented()
	}


/***/ },
/* 181 */
/***/ function(module, exports) {

	'use strict'
	
	// Return a new copy of this array every time we're called
	module.exports = function instrumentations() {
	  return [
	    'connect',
	    'bluebird',
	    'director',
	    'express',
	    'generic-pool',
	    'hapi',
	    'memcached',
	    'mongodb',
	    'mysql',
	    'node-cassandra-cql',
	    'cassandra-driver',
	    'pg',
	    'q',
	    'redis',
	    'ioredis',
	    'restify',
	    'oracle'
	  ]
	}


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname, process) {'use strict'
	
	var logger = __webpack_require__(12).child({component: 'query_tracer'})
	var obfuscate = __webpack_require__(183)
	var Stats = __webpack_require__(171)
	var util = __webpack_require__(16)
	var crypto = __webpack_require__(63)
	var encode = __webpack_require__(184).encode
	var path = __webpack_require__(58)
	
	var NR_ROOT = path.resolve(__dirname, '..')
	
	module.exports = QueryTracer
	
	function QueryTracer(config) {
	  if (!(this instanceof QueryTracer)) {
	    return new QueryTracer(config)
	  }
	  this.samples = {}
	  this.config = config
	}
	
	QueryTracer.prototype.removeShortest = function removeShortest() {
	  var keys = Object.keys(this.samples)
	  var shortest
	
	
	  for (var i = 0, len = keys.length; i < len; ++i) {
	    var sample = this.samples[keys[i]].trace
	    if (!shortest || shortest.duration > sample.duration) {
	      shortest = sample
	    }
	  }
	
	  delete this.samples[shortest.normalized]
	}
	
	QueryTracer.prototype.merge = function merge(tracer) {
	  var keys = Object.keys(tracer.samples)
	
	  for (var i = 0, len = keys.length; i < len; ++i) {
	    if (this.samples[keys[i]]) {
	      this.samples[keys[i]].merge(tracer.samples[keys[i]])
	    } else {
	      this.samples[keys[i]] = tracer.samples[keys[i]]
	    }
	  }
	}
	
	QueryTracer.prototype.addQuery = function addQuery(segment, type, query, trace) {
	  var duration = segment.getDurationInMillis()
	
	  if (duration < this.config.transaction_tracer.explain_threshold) return
	
	  var slowQuery = new SlowQuery(segment, type, query, trace)
	
	  switch (this.config.transaction_tracer.record_sql) {
	    case 'raw':
	      logger.info('recording raw sql')
	      segment.parameters.sql = slowQuery.query
	      break
	    case 'obfuscated':
	      logger.info('recording obfuscated sql')
	      segment.parameters.sql_obfuscated = slowQuery.obfuscated
	      break
	    default:
	      logger.info(
	        'not collecting slow-query because transaction_tracer.record_sql was set to %s',
	        this.config.transaction_tracer.record_sql
	      )
	      return
	  }
	  segment.parameters.backtrace = slowQuery.trace
	
	  if (!this.config.slow_sql.enabled) return
	
	  if (this.samples[slowQuery.normalized]) {
	    return this.samples[slowQuery.normalized].aggregate(slowQuery)
	  }
	
	  this.samples[slowQuery.normalized] = new QuerySample(this, slowQuery)
	
	  if (Object.keys(this.samples).length > this.config.slow_sql.max_samples) {
	    this.removeShortest()
	  }
	}
	
	QueryTracer.prototype.prepareJSON = function prepareJSON(done) {
	  var keys = Object.keys(this.samples)
	  var remaining = keys.length
	  var data = []
	
	  if (!remaining) return done(null, data)
	
	  for (var i = 0; i < keys.length; ++i) {
	    this.samples[keys[i]].prepareJSON(collect)
	  }
	
	  function collect(err, json) {
	    if (err) {
	      done(err)
	      // turn callback into a noop so it can't be called more than once
	      done = noop
	      return
	    }
	
	    data.push(json)
	    if (!--remaining) done(null, data)
	  }
	
	  function noop() {}
	}
	
	function QuerySample(tracer, slowQuery) {
	  Stats.call(this)
	  this.tracer = tracer
	  this.trace = slowQuery
	  this.aggregate(slowQuery)
	}
	
	util.inherits(QuerySample, Stats)
	
	QuerySample.prototype.aggregate = function aggregate(slowQuery) {
	  this.recordValue(slowQuery.duration)
	  if (this.trace && this.trace.duration >= slowQuery.duration) return
	  this.trace = slowQuery
	}
	
	QuerySample.prototype.merge = function merge(sample) {
	  Stats.prototype.merge.call(this, sample)
	  if (this.trace.duration < sample.trace.duration) {
	    this.trace = sample.trace
	  }
	}
	
	QuerySample.prototype.prepareJSON = function prepareJSON(done) {
	  var transaction = this.trace.segment.transaction
	  var sample = this
	  var trace = sample.trace
	
	  var params = sample.getParams()
	  if (!this.tracer.config.simple_compression) {
	    encode(params, respond)
	  } else {
	    process.nextTick(respond.bind(null, null, params))
	  }
	
	  function respond(err, data) {
	    if (err) return done(err)
	
	    done(null, [
	      transaction.name,
	      transaction.url || '<unknown>',
	      trace.id,
	      getQuery(sample.tracer.config, trace),
	      trace.metric,
	      sample.callCount,
	      sample.total,
	      sample.min,
	      sample.max,
	      data
	    ])
	  }
	}
	
	QuerySample.prototype.getParams = function getParams() {
	  var segmentParams = this.trace.segment.parameters
	  var params = {
	    backtrace: this.trace.trace,
	  }
	
	  if (segmentParams.host) {
	    params.host = segmentParams.host
	  }
	
	  if (segmentParams.port_path_or_id) {
	    params.port_path_or_id = segmentParams.port_path_or_id
	  }
	
	  if (segmentParams.database_name) {
	    params.database_name = segmentParams.database_name
	  }
	
	  return params
	}
	
	function SlowQuery(segment, type, query, trace) {
	  this.obfuscated = obfuscate(query, type)
	  this.normalized = this.obfuscated.replace(/\?\s*,\s*|\s*/g, '')
	  this.id = normalizedHash(this.normalized)
	  this.segment = segment
	  this.query = query
	  this.metric = segment.name
	  this.trace = formatTrace(trace)
	  this.duration = segment.getDurationInMillis()
	}
	
	function normalizedHash(value) {
	  return parseInt(crypto.createHash('md5').update(value).digest('hex').slice(-4), 16)
	}
	
	function formatTrace(trace) {
	  // remove error message and instrumentation frames from stack trace
	  return trace ? trace.stack.split('\n').slice(1).filter(notNR).join('\n') : ''
	}
	
	function notNR(frame) {
	  return frame.indexOf(NR_ROOT) === -1
	}
	
	function getQuery(config, trace) {
	  switch (config.transaction_tracer.record_sql) {
	    case 'raw':
	      return trace.query
	    case 'obfuscated':
	      return trace.obfuscated
	    default:
	      return '?'
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/", __webpack_require__(11)))

/***/ },
/* 183 */
/***/ function(module, exports) {

	'use strict'
	
	module.exports = obfuscate
	
	var singleQuote = /'(?:[^']|'')*?(?:\\'.*|'(?!'))/
	var doubleQuote = /"(?:[^"]|"")*?(?:\\".*|"(?!"))/
	var dollarQuote = /(\$(?!\d)[^$]*?\$).*?(?:\1|$)/
	var oracleQuote = /q'\[.*?(?:\]'|$)|q'\{.*?(?:\}'|$)|q'\<.*?(?:\>'|$)|q'\(.*?(?:\)'|$)/
	var comment = /(?:#|--).*?(?=\r|\n|$)/
	var multilineComment = /\/\*(?:[^/]|\/[^*])*?(?:\*\/|\/\*.*)/
	var uuid = /\{?(?:[0-9a-f]\-*){32}\}?/
	var hex = /0x[0-9a-f]+/
	var boolean = /true|false|null/
	var number = /\b-?(?:[0-9]+\.)?[0-9]+([eE][+-]?[0-9]+)?/
	
	var dialects = {}
	
	dialects.mysql = [
	  replacer(join(
	    [doubleQuote, singleQuote, comment, multilineComment, hex, boolean, number],
	    'gi'
	  )),
	  unmatchedPairs(/'|"|\/\*|\*\//)
	]
	
	dialects.postgres = [
	  replacer(join(
	    [dollarQuote, singleQuote, comment, multilineComment, uuid, boolean, number],
	    'gi'
	  )),
	  unmatchedPairs(/'|\/\*|\*\/|\$/)
	]
	
	dialects.cassandra = [
	  replacer(join(
	    [singleQuote, comment, multilineComment, uuid, hex, boolean, number],
	    'gi'
	  )),
	  unmatchedPairs(/'|\/\*|\*\//)
	]
	
	dialects.oracle = [
	  replacer(join(
	    [oracleQuote, singleQuote, comment, multilineComment, number],
	    'gi'
	  )),
	  unmatchedPairs(/'|\/\*|\*\//)
	]
	
	function obfuscate(raw, dialect) {
	  if (!dialects[dialect]) throw new Error('Unknown sql implementation')
	  var replacers = dialects[dialect]
	  var obfuscated = raw
	  for (var i = 0, l = replacers.length; i < l; ++i) {
	    obfuscated = replacers[i](obfuscated)
	  }
	
	  return obfuscated
	}
	
	function join(expressions, flags) {
	  return new RegExp(expressions.map(toPart).join('|'), flags)
	}
	
	function toPart(expressions) {
	  return expressions.toString().slice(1, -1)
	}
	
	function replacer(regex) {
	  return function replace(sql) {
	    return sql.replace(regex, '?')
	  }
	}
	
	function unmatchedPairs(regex) {
	  return function check(sql) {
	    return regex.test(sql) ? '?' : sql
	  }
	}


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict'
	
	var zlib = __webpack_require__(138)
	
	module.exports = {
	  /**
	   * Take in an object literal, and deflate and then Base64 encode it.
	   *
	   * zlib works with streams, so this must be used asynchronously.
	   *
	   * @param {object} data
	   *  The data to encode.
	   *
	   * @param {Function} callback
	   *  The callback to take the results. The first parameter is any errors from
	   *  encoding, and the second parameter is the encoded data object.
	   */
	  encode: function encode(data, callback) {
	    try {
	      zlib.deflate(JSON.stringify(data), function cb_deflate(err, raw) {
	        if (err) return callback(err)
	
	        return callback(null, raw.toString('base64'))
	      })
	    } catch (err) {
	      return callback(err)
	    }
	  },
	
	  /**
	   * Base64 decode a string, decompress it, and then turn the results back into
	   * a JavaScript object.
	   *
	   * zlib works with streams, so this must be used asynchronously.
	   *
	   * @param {object} encoded
	   *  The data to decode.
	   *
	   * @param {Function} callback
	   *  The callback to take the results. The first parameter is any errors from
	   *  decoding, and the second parameter is the decoded data object.
	   */
	  decode: function decode(encoded, callback) {
	    zlib.inflate(new Buffer(encoded, 'base64'), function cb_inflate(err, raw) {
	      if (err) return callback(err)
	
	      try {
	        return callback(null, JSON.parse(raw))
	      } catch (error) {
	        return callback(error)
	      }
	    })
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22).Buffer))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var path = __webpack_require__(58)
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var os = __webpack_require__(56)
	var logger = __webpack_require__(12).child({component: 'environment'})
	var stringifySync = __webpack_require__(14).stringifySync
	
	
	var exists = fs.existsSync || path.existsSync
	
	// As of 1.7.0 you can no longer dynamically link v8
	// https://github.com/nodejs/io.js/commit/d726a177ed
	var remapping = {
	  node_install_npm: "npm installed?",
	  node_install_waf: "WAF build system installed?",
	  node_use_openssl: "OpenSSL support?",
	  node_shared_openssl: "Dynamically linked to OpenSSL?",
	  node_shared_v8: "Dynamically linked to V8?",
	  node_shared_zlib: "Dynamically linked to Zlib?",
	  node_use_dtrace: "DTrace support?",
	  node_use_etw: "Event Tracing for Windows (ETW) support?"
	}
	
	var settings = {}
	
	/**
	 * Fetches the setting of the given name, defaulting to an empty array.
	 *
	 * @param {string} name - The name of the setting to look for.
	 *
	 * @return {Array.<string>} An array of values matching that name.
	 */
	function getSetting(name) {
	  return settings[name] || []
	}
	
	/**
	 * Add a setting to the module's shared settings object.
	 *
	 * @param {string} name   - The name of the setting value being added.
	 * @param {string} value  - The value to add or the setting.
	 */
	function addSetting(name, value) {
	  if (!settings[name]) {
	    settings[name] = [value]
	  } else if (settings[name].indexOf(value) === -1) {
	    settings[name].push(value)
	  }
	}
	
	/**
	 * Remove settings with the given name.
	 *
	 * @param {string} name - The name of the setting to remove.
	 */
	function clearSetting(name) {
	  delete settings[name]
	}
	
	/**
	 * Build up a list of top-level packages available to an application relative to
	 * the provided root.
	 *
	 * @param {string}  root        - Path to start listing packages from.
	 * @param {Array}   [packages]  - Array to append found packages to.
	 *
	 * @return {Array} List of packages.
	 */
	function listPackages(root, packages) {
	  if (!packages) {
	    packages = []
	  }
	
	  try {
	    fs.readdirSync(root).forEach(function forEachReadDirSync(dir) {
	      // Skip npm's binary directory where it stores executables.
	      if (dir === '.bin') {
	        return
	      }
	
	      var version = null
	      try {
	        var pck = path.resolve(root, dir, 'package.json')
	        version = JSON.parse(fs.readFileSync(pck)).version
	      } catch (e) {
	        logger.info('Could not load %s for environment scan', pck || dir)
	      }
	
	      packages.push([dir, version || '<unknown>'])
	    })
	  } catch (e) {
	    logger.trace(e, 'Failed to list packages in %s', root)
	  }
	
	  return packages
	}
	
	/**
	 * Build up a list of dependencies from a given node_module root.
	 *
	 * @param {string}  root        - Path to start listing dependencies from.
	 * @param {Array}   [children]  - Array to append found dependencies to.
	 *
	 * @return {Array} List of dependencies.
	 */
	function listDependencies(root, children) {
	  if (!children) {
	    children = []
	  }
	
	  try {
	    fs.readdirSync(root).forEach(function forEachReadDirSync(entry) {
	      var candidate = path.resolve(root, entry, 'node_modules')
	
	      // Performing this exists check is cheaper than unwinding the stack for
	      // all the failed read attempts.
	      if (exists(candidate)) {
	        listPackages(candidate, children)
	        listDependencies(candidate, children)
	      }
	    })
	  } catch (e) {
	    logger.trace(e, 'Failed to list dependencies in %s', root)
	  }
	
	  return children
	}
	
	/**
	 * Build up a list of packages, starting from the current directory.
	 *
	 * @param {string} start - Root directory to start generation from.
	 *
	 * @return {Object} Two lists, of packages and dependencies, with the
	 *  appropriate names.
	 */
	function getLocalPackages(start) {
	  var packages = []
	  var dependencies = []
	  var candidate = start
	
	  while (candidate) {
	    var root = path.resolve(candidate, 'node_modules')
	    listPackages(root, packages)
	    listDependencies(root, dependencies)
	
	    var last = candidate
	    candidate = path.dirname(candidate)
	    if (last === candidate) break
	  }
	
	  return {packages: packages, dependencies: dependencies}
	}
	
	/**
	 * Generic method for getting packages and dependencies relative to a
	 * provided root directory.
	 *
	 * @param {string} root - Where to start looking -- doesn't add node_modules.
	 *
	 * @return {Object} Two lists, of packages and dependencies, with the
	 *  appropriate names.
	 */
	function getPackages(root) {
	  var packages = []
	  var dependencies = []
	
	  listPackages(root, packages)
	  listDependencies(root, dependencies)
	
	  return {packages: packages, dependencies: dependencies}
	}
	
	/**
	 * Generate a list of globally-installed packages, if available / accessible
	 * via the environment.
	 *
	 * @return {Object} Two lists, of packages and dependencies, with the
	 *  appropriate names.
	 */
	function getGlobalPackages() {
	  if (process.config && process.config.variables) {
	    var prefix = process.config.variables.node_prefix
	    if (prefix) {
	      var root = path.resolve(prefix, 'lib', 'node_modules')
	      return getPackages(root)
	    }
	  }
	
	  return {packages: [], dependencies: []}
	}
	
	/**
	 * Take a list of packages and reduce it to a list of pairs serialized
	 * to JSON (to simplify things on the collector end) where each
	 * package appears at most once, with all the versions joined into a
	 * comma-delimited list.
	 *
	 * @return {Array.<String>[]} Sorted list of [name, version] pairs.
	 */
	function flattenVersions(packages) {
	  var info = Object.create(null)
	  packages.forEach(function cb_forEach(pair) {
	    var p = pair[0]
	    var v = pair[1]
	
	
	    if (info[p]) {
	      if (info[p].indexOf(v) < 0) info[p].push(v)
	    } else {
	      info[p] = [v]
	    }
	  })
	
	  return Object.keys(info)
	    .map(function cb_map(key) {
	      return [key, info[key].join(', ')]
	    })
	    .sort()
	    .map(function cb_map(pair) {
	      return stringifySync(pair)
	    })
	}
	
	/**
	 * There are a bunch of settings generated at build time that are useful to
	 * know for troubleshooting purposes. These settings are only available in 0.7
	 * and up.
	 *
	 * This function works entirely via side effects using the
	 * addSetting function.
	 */
	function remapConfigSettings() {
	  if (process.config && process.config.variables) {
	    var variables = process.config.variables
	    Object.keys(variables).forEach(function cb_forEach(key) {
	      if (remapping[key]) {
	        var value = variables[key]
	
	        if (value === true || value === 1) value = 'yes'
	        if (value === false || value === 0) value = 'no'
	
	        addSetting(remapping[key], value)
	      }
	    })
	  }
	}
	
	/**
	 * Scrape the list of packages, following the algorithm as described in the
	 * node module page:
	 *
	 * http://nodejs.org/docs/latest/api/modules.html
	 *
	 * This function works entirely via side effects using the addSetting
	 * function.
	 */
	function findPackages() {
	  var local = getLocalPackages(process.cwd())
	  var all = getGlobalPackages()
	  var other = {packages: [], dependencies: []}
	
	
	  if (process.env.NODE_PATH) {
	    var paths
	    if (process.platform === 'win32') { // why. WHY.
	      paths = process.env.NODE_PATH.split(';')
	    } else {
	      paths = process.env.NODE_PATH.split(':')
	    }
	
	    paths.forEach(function cb_forEach(nodePath) {
	      if (nodePath[0] !== '/') nodePath = path.resolve(process.cwd(), nodePath)
	      var nextSet = getPackages(nodePath)
	      other.packages.push.apply(other.packages, nextSet.packages)
	      other.dependencies.push.apply(other.dependencies, nextSet.dependencies)
	    })
	  }
	
	  var packages = local.packages
	  packages.push.apply(packages, all.packages)
	  packages.push.apply(packages, other.packages)
	
	  var dependencies = local.dependencies
	  dependencies.push.apply(dependencies, all.dependencies)
	  dependencies.push.apply(dependencies, other.dependencies)
	
	  var home
	  var homeOld
	
	  if (process.platform === 'win32') {
	    if (process.env.USERDIR) {
	      home = getPackages(path.resolve(process.env.USERDIR, '.node_modules'))
	      homeOld = getPackages(path.resolve(process.env.USERDIR, '.node_libraries'))
	    }
	  } else if (process.env.HOME) {
	    home = getPackages(path.resolve(process.env.HOME, '.node_modules'))
	    homeOld = getPackages(path.resolve(process.env.HOME, '.node_libraries'))
	  }
	
	  if (home) {
	    packages.unshift.apply(packages, home.packages)
	    dependencies.unshift.apply(dependencies, home.dependencies)
	  }
	
	  if (homeOld) {
	    packages.unshift.apply(packages, homeOld.packages)
	    dependencies.unshift.apply(dependencies, homeOld.dependencies)
	  }
	
	  addSetting('Packages', flattenVersions(packages))
	  addSetting('Dependencies', flattenVersions(dependencies))
	}
	
	function badOS() {
	  var badVersion = false
	
	  if (!process.versions) {
	    badVersion = true
	  } else {
	    var version = process.versions.node.split('.')
	    if (version[1] <= 8 && version[2] <= 5) badVersion = true
	  }
	
	  return badVersion &&
	         os.arch() === 'x64' &&
	         os.type() === 'SunOS'
	}
	
	/**
	 * Settings actually get scraped below.
	 */
	function gatherEnv() {
	  // in 64-bit SmartOS zones, node <= 0.8.5 pukes on os.cpus()
	  if (!badOS()) addSetting('Processors', os.cpus().length)
	
	  addSetting('OS', os.type())
	  addSetting('OS version', os.release())
	  addSetting('Node.js version', process.version)
	  addSetting('Architecture', process.arch)
	
	  if ('NODE_ENV' in process.env) {
	    addSetting('NODE_ENV', process.env.NODE_ENV)
	  }
	}
	
	/**
	 * Reset settings and gather them, built to minimally refactor this file.
	 */
	function refresh() {
	  // gather persisted settings
	  var framework = getSetting('Framework')
	  var dispatcher = getSetting('Dispatcher')
	  var packages = getSetting('Packages')
	  var dependencies = getSetting('Dependencies')
	
	  // clearing and rebuilding a global variable
	  settings = {}
	  // add persisted settings
	  if (framework.length) {
	    framework.forEach(function addFrameworks(fw) {
	      addSetting('Framework', fw)
	    })
	  }
	
	  if (dispatcher.length) {
	    dispatcher.forEach(function addDispatchers(d) {
	      addSetting('Dispatcher', d)
	    })
	  }
	
	  gatherEnv()
	  remapConfigSettings()
	
	  if (packages.length && dependencies.length) {
	    settings.Packages = packages
	    settings.Dependencies = dependencies
	  } else {
	    findPackages()
	  }
	}
	
	// initialize settings
	// TODO:  Remove this function call and make all environment loading async. At
	//        the moment, removing this causes tests to fail and it is unclear if it
	//        is an issue in the tests or in the agent.
	refresh()
	
	/**
	 * Refreshes settings and returns the settings object.
	 */
	function toJSON() {
	  // TODO:  Do not refresh when JSON-ifying. This takes a _long_ time and blocks
	  //        the event loop. Currently, removing this causes a couple of tests to
	  //        fail (ironically from timing out).
	  refresh()
	  var items = []
	  Object.keys(settings).forEach(function settingKeysForEach(key) {
	    settings[key].forEach(function settingsValuesForEach(setting) {
	      items.push([key, setting])
	    })
	  })
	
	  return items
	}
	
	module.exports = {
	  setFramework: function setFramework(framework) {
	    addSetting('Framework', framework)
	  },
	  setDispatcher: function setDispatcher(dispatcher) {
	    addSetting('Dispatcher', dispatcher)
	  },
	  clearFramework: function clearFramework() {
	    clearSetting('Framework')
	  },
	  clearDispatcher: function clearDispatcher() {
	    clearSetting('Dispatcher')
	  },
	  listPackages: listPackages,
	  toJSON: toJSON,
	  get: getSetting,
	  refresh: refresh
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var Transaction = __webpack_require__(187)
	var logger = __webpack_require__(12).child({component: 'tracer'})
	
	/*
	 * CONSTANTS
	 */
	var ORIGINAL = '__NR_original'
	var SEGMENT = '__NR_segment'
	
	
	module.exports = Tracer
	
	function Tracer(agent) {
	  if (!agent) throw new Error("Must be initialized with an agent.")
	
	  this.agent = agent
	  this._segment = null
	}
	
	Tracer.prototype.getTransaction = getTransaction
	Tracer.prototype.getSegment = getSegment
	Tracer.prototype.createSegment = createSegment
	Tracer.prototype.addSegment = addSegment
	Tracer.prototype.transactionProxy = transactionProxy
	Tracer.prototype.transactionNestProxy = transactionNestProxy
	Tracer.prototype.bindFunction = bindFunction
	Tracer.prototype.bindEmitter = bindEmitter
	Tracer.prototype.getOriginal = getOriginal
	Tracer.prototype.getSegmentFromWrapped = getSegmentFromWrapped
	Tracer.prototype.slice = argSlice
	Tracer.prototype.wrapFunctionNoSegment = wrapFunctionNoSegment
	Tracer.prototype.wrapFunctionFirstNoSegment = wrapFunctionFirstNoSegment
	Tracer.prototype.wrapFunction = wrapFunction
	Tracer.prototype.wrapFunctionLast = wrapFunctionLast
	Tracer.prototype.wrapFunctionFirst = wrapFunctionFirst
	Tracer.prototype.wrapSyncFunction = wrapSyncFunction
	Tracer.prototype.wrapCallback = wrapCallback
	
	Object.defineProperty(Tracer.prototype, 'segment', {
	  get: function segmentGetter() {
	    return this._segment
	  },
	  set: function segmentSetter(segment) {
	    this._segment && this._segment.probe('Segment removed from tracer')
	    segment && segment.probe('Set tracer.segment')
	    return this._segment = segment
	  }
	})
	
	function getTransaction() {
	  if (this.segment && this.segment.transaction && this.segment.transaction.isActive()) {
	    return this.segment.transaction
	  }
	
	  return null
	}
	
	function getSegment() {
	  return this.segment
	}
	
	function createSegment(name, recorder, _parent) {
	  var parent = _parent || this.segment
	  if (!parent || !parent.transaction.isActive()) {
	    logger.trace({
	      hasParent: !!parent,
	      transactionActive: (parent && parent.transaction.isActive())
	    }, 'Not creating segment %s, no parent or active transaction available.', name)
	    return null
	  }
	  return parent.add(name, recorder)
	}
	
	function addSegment(name, recorder, parent, full, task) {
	  if (typeof task !== 'function') {
	    throw new Error('task must be a function')
	  }
	
	  var segment = this.createSegment(name, recorder, parent)
	
	  return this.bindFunction(task, segment, full)(segment)
	}
	
	function transactionProxy(handler) {
	  // if there's no handler, there's nothing to proxy.
	  if (typeof handler !== 'function') return handler
	
	  var tracer = this
	  var wrapped = function wrapTransactionInvocation() {
	    // don't nest transactions, reuse existing ones
	    var transaction = tracer.getTransaction()
	    if (transaction) {
	      if (transaction.traceStacks) {
	        var segment = tracer.segment
	        segment.probe('!!! Nested transaction creation !!!')
	        transaction.traceFlag = true // Will log the stacks when it ends.
	        logger.warn({
	          transaction: {id: transaction.id, name: transaction.getName()},
	          segment: segment.name
	        }, 'Active transaction when creating non-nested transaction')
	      }
	      return handler.apply(this, arguments)
	    }
	    transaction = new Transaction(tracer.agent)
	    return tracer.bindFunction(handler, transaction.trace.root).apply(this, arguments)
	  }
	
	  wrapped[ORIGINAL] = handler
	
	  return wrapped
	}
	
	
	// FLAG: custom_instrumentation
	/**
	 * Use transactionNestProxy to wrap a closure that is a top-level handler that
	 * is meant to start transactions. This wraps the first half of asynchronous
	 * handlers. Use bindFunction to wrap handler callbacks. This detects to see
	 * if there is an in play segment and uses that as the root instead of
	 * transaction.trace.root.
	 *
	 * @param {Function} handler Generator to be proxied.
	 * @returns {Function} Proxy.
	 */
	
	function transactionNestProxy(type, handler) {
	  if (handler === undefined && typeof type === 'function') {
	    handler = type
	    type = undefined
	  }
	  // if there's no handler, there's nothing to proxy.
	  if (typeof handler !== 'function') return handler
	
	  var tracer = this
	  var wrapped = function wrapTransactionInvocation() {
	    // don't nest transactions, reuse existing ones
	    var transaction = tracer.getTransaction()
	    var segment = tracer.segment
	
	    var createNew = false
	
	    if (!transaction) {
	      createNew = true
	    } else if (type === 'web' && transaction.bgSegment) {
	      createNew = true
	    } else if (type === 'bg' && transaction.webSegment) {
	      createNew = true
	    }
	
	    if (createNew) {
	      transaction = new Transaction(tracer.agent)
	      segment = transaction.trace.root
	    }
	
	    return tracer.bindFunction(handler, segment).apply(this, arguments)
	  }
	
	  wrapped[ORIGINAL] = handler
	
	  return wrapped
	}
	
	function bindFunction(handler, segment, full) {
	  if (typeof handler !== 'function') {
	    return handler
	  }
	
	  var tracer = this
	  var active = typeof segment === 'undefined' ? tracer.segment : segment
	
	  wrapped[ORIGINAL] = handler[ORIGINAL] || handler
	  wrapped[SEGMENT] = active
	
	  return wrapped
	
	  function wrapped() {
	    var prev = tracer.segment
	    tracer.segment = active
	    if (active && full) segment.start()
	    try {
	      var result = handler.apply(this, arguments)
	    } catch (err) {
	      logger.trace(err, "Error from wrapped function:")
	
	      if (prev === null && process.domain != null) {
	        process.domain.__NR_transactionSegment = tracer.segment
	      }
	
	      throw err
	    } finally {
	      if (active && full) segment.touch()
	      tracer.segment = prev
	    }
	    return result
	  }
	}
	
	function getOriginal(fn) {
	  return fn && fn[ORIGINAL] ? fn[ORIGINAL] : fn
	}
	
	function getSegmentFromWrapped(fn) {
	  return fn && fn[SEGMENT] ? fn[SEGMENT] : null
	}
	
	function bindEmitter(emitter, segment) {
	  if (!emitter || !emitter.emit) return emitter
	
	  var tracer = this
	  var active = segment || this.segment
	  var emit = emitter.emit[ORIGINAL] || emitter.emit
	  emitter.emit = wrappedEmit
	  emitter.emit[ORIGINAL] = emit
	
	  return emitter
	
	  function wrappedEmit() {
	    return tracer.bindFunction(emit, active).apply(this, arguments)
	  }
	}
	
	function argSlice(args) {
	  /**
	   * Usefully nerfed version of slice for use in instrumentation. Way faster
	   * than using [].slice.call, and maybe putting it in here (instead of the
	   * same module context where it will be used) will make it faster by
	   * defeating inlining.
	   *
	   *   http://jsperf.com/array-slice-call-arguments-2
	   *
	   *  for untrustworthy benchmark numbers. Only useful for copying whole
	   *  arrays, and really only meant to be used with the arguments array like.
	   *
	   *  Also putting this comment inside the function in an effort to defeat
	   *  inlining.
	   *
	   */
	  var length = args.length
	  var array = new Array(length)
	
	  for (var i = 0; i < length; i++) {
	    array[i] = args[i]
	  }
	
	  return array
	}
	
	function wrapFunctionNoSegment(original, name, wrapper) {
	  if (typeof original !== 'function') return original
	
	  logger.trace('Wrapping function %s (no segment)', name || original.name || 'anonymous')
	  var tracer = this
	
	  return wrappedFunction
	
	  function wrappedFunction() {
	    if (!tracer.getTransaction()) return original.apply(this, arguments)
	    var args = tracer.slice(arguments)
	
	    if (wrapper === undefined) {
	      var last = args.length - 1
	      var cb = args[last]
	      if (typeof cb === 'function') {
	        args[last] = tracer.bindFunction(cb)
	      }
	    } else {
	      args = wrapper(args)
	    }
	    return original.apply(this, args)
	  }
	}
	
	function wrapFunctionFirstNoSegment(original, name) {
	  if (typeof original !== 'function') return original
	
	  logger.trace('Wrapping function %s (no segment)', name || original.name || 'anonymous')
	  var tracer = this
	
	  return wrappedFunction
	
	  function wrappedFunction() {
	    if (!tracer.getTransaction()) return original.apply(this, arguments)
	    var args = tracer.slice(arguments)
	    var cb = args[0]
	    if (typeof cb === 'function') {
	      args[0] = tracer.bindFunction(cb)
	    }
	    return original.apply(this, args)
	  }
	}
	
	function wrapFunctionLast(name, recorder, original) {
	  if (typeof original !== 'function') {
	    logger.trace('Not wrapping "%s" because it was not a function', name)
	    return original
	  }
	
	  logger.trace('Wrapping %s as a callback-last function', name)
	  var tracer = this
	
	  return wrappedFunction
	
	  function wrappedFunction() {
	    var transaction = tracer.getTransaction()
	    if (!transaction) {
	      logger.trace('Not creating segment "%s" because no transaction was active', name)
	      return original.apply(this, arguments)
	    }
	
	    logger.trace('Creating "%s" segment for transaction %s.', name, transaction.id)
	    var args = tracer.slice(arguments)
	    var last = args.length - 1
	    var cb = args[last]
	    if (typeof cb !== 'function') return original.apply(this, arguments)
	    var child = tracer.createSegment(name, recorder)
	    args[last] = tracer.wrapCallback(cb, child, wrappedCallback)
	    child.start()
	    return tracer.bindFunction(original, child).apply(this, args)
	
	    function wrappedCallback() {
	      logger.trace('Ending "%s" segment for transaction %s.', name, transaction.id)
	      child.touch()
	      return cb.apply(this, arguments)
	    }
	  }
	}
	
	function wrapFunctionFirst(name, recorder, original) {
	  if (typeof original !== 'function') {
	    logger.trace('Not wrapping "%s" because it was not a function', name)
	    return original
	  }
	
	  logger.trace('Wrapping %s as a callback-first function', name)
	  var tracer = this
	
	  return wrappedFunction
	
	  function wrappedFunction() {
	    var transaction = tracer.getTransaction()
	    if (!transaction) {
	      logger.trace('Not creating segment "%s" because no transaction was active', name)
	      return original.apply(this, arguments)
	    }
	
	    logger.trace('Creating "%s" segment for transaction %s.', name, transaction.id)
	    var args = tracer.slice(arguments)
	    var cb = args[0]
	    if (typeof cb !== 'function') return original.apply(this, arguments)
	    var child = tracer.createSegment(name, recorder)
	    args[0] = tracer.wrapCallback(cb, child, wrappedCallback)
	    child.start()
	    return tracer.bindFunction(original, child).apply(this, args)
	
	    function wrappedCallback() {
	      logger.trace('Ending "%s" segment for transaction %s.', name, transaction.id)
	      child.touch()
	      var result = cb.apply(this, arguments)
	      return result
	    }
	  }
	}
	
	function wrapFunction(name, recorder, original, wrapper, resp) {
	  if (typeof original !== 'function' || !wrapper) {
	    logger.trace('Not wrapping "%s" because it was not a function', name)
	    return original
	  }
	
	  logger.trace('Wrapping %s using a custom wrapper', name)
	
	  var tracer = this
	
	  return wrappedFunction
	
	  function wrappedFunction() {
	    var transaction = tracer.getTransaction()
	    if (!transaction) {
	      logger.trace('Not creating segment "%s" because no transaction was active', name)
	      return original.apply(this, arguments)
	    }
	
	    logger.trace('Creating "%s" segment for transaction %s.', name, transaction.id)
	
	    var child = tracer.createSegment(name, recorder)
	    var args = wrapper.call(this, child, tracer.slice(arguments), bind)
	    child.start()
	    var result = tracer.bindFunction(original, child).apply(this, args)
	    if (resp) result = resp.call(this, child, result, bind)
	    return result
	
	    function bind(fn) {
	      if (!fn) return fn
	      return tracer.wrapCallback(fn, child, function nrWrappedHandler() {
	        logger.trace('Touching "%s" segment for transaction %s.', name, transaction.id)
	        child.touch()
	        return fn.apply(this, arguments)
	      })
	    }
	  }
	}
	
	function wrapSyncFunction(name, recorder, original) {
	  if (typeof original !== 'function') {
	    logger.trace('Not wrapping "%s" because it was not a function', name)
	    return original
	  }
	
	  logger.trace('Wrapping "%s" as a synchronous function', name)
	
	  var tracer = this
	
	  return wrappedFunction
	
	  function wrappedFunction() {
	    var transaction = tracer.getTransaction()
	    if (!transaction) {
	      logger.trace('Not creating segment "%s" because no transaction was active', name)
	      return original.apply(this, arguments)
	    }
	    logger.trace('Creating "%s" sync segment for transaction %s.', name, transaction.id)
	    var child = tracer.createSegment(name, recorder)
	    if (child) child.async = false
	    return tracer.bindFunction(original, child, true).apply(this, arguments)
	  }
	}
	
	function wrapCallback(original, segment, wrapped) {
	  var tracer = this
	
	  if (typeof original !== 'function') return original
	
	  logger.trace(
	    'Wrapping callback for "%s" segment',
	    segment ? segment.name : 'unknown'
	  )
	
	  return tracer.bindFunction(function wrappedCallback() {
	    if (wrapped) wrapped[ORIGINAL] = original
	
	    var child = tracer.createSegment(
	      'Callback: ' + (original.name || 'anonymous'),
	      null,
	      segment
	    )
	
	    if (child) child.async = false
	
	    return tracer.bindFunction(wrapped || original, child, true).apply(this, arguments)
	  }, segment, false)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var urltils = __webpack_require__(168)
	var Metrics = __webpack_require__(170)
	var Timer = __webpack_require__(96)
	var Trace = __webpack_require__(188)
	var NAMES = __webpack_require__(59)
	var hashes = __webpack_require__(62)
	var util = __webpack_require__(16)
	var url = __webpack_require__(108)
	var NameState = __webpack_require__(191)
	var logger = __webpack_require__(12).child({component: 'transaction'})
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var FROM_MILLIS = 1e-3
	/**
	 * Bundle together the metrics and the trace segment for a single agent
	 * transaction.
	 *
	 * @param {Object} agent The agent.
	 */
	function Transaction(agent) {
	  if (!agent) throw new Error('every transaction must be bound to the agent')
	
	  this.traceFlag = false
	  if (agent.config.logging.diagnostics) {
	    this.traceStacks = []
	  } else {
	    this.traceStacks = null
	  }
	
	  this.agent = agent
	  this.metrics = new Metrics(
	    agent.config.apdex_t,
	    agent.mapper,
	    agent.metricNameNormalizer
	  )
	
	  agent.activeTransactions++
	
	  this.numSegments = 0
	
	  // This number needs to be unique so the previous method of picking 1337 then
	  // incrementing it no longer works. 1e17 should always result in a whole
	  // number, but just in case we floor it so we don't end up with decimals. Then
	  // we make it hex because other agents use a hex based transaction id.
	  this.id = Math.floor((Math.random() * 1e17)).toString(16)
	
	  this.trace = new Trace(this)
	  this.exceptions = []
	  this.userErrors = []
	  this.timer = new Timer()
	  this.timer.begin()
	
	  this._recorders = []
	  this._intrinsicAttributes = {}
	  this._partialName = null
	
	  // hidden class optimization
	  this.bgSegment = null
	  this.catResponseTime = 0
	  this.error = null
	  this.forceIgnore = null
	  this.forceName = null
	  this.ignore = false
	  this.incomingCatId = null
	  this.name = null
	  this.nameState = new NameState(null, null, null, null)
	  this.pathHashes = []
	  this.queueTime = 0
	  this.referringPathHash = null
	  this.referringTransactionGuid = null
	  this.invalidIncomingExternalTransaction = false
	  this.statusCode = null
	  this.syntheticsHeader = null
	  this.syntheticsData = null
	  this.url = null
	  this.parsedUrl = null
	  this.verb = null
	  this.webSegment = null
	
	  this.probe('Transaction created', {id: this.id})
	}
	
	Transaction.prototype.probe = function probe(action, extra) {
	  if (this.traceStacks) {
	    this.traceStacks.push({
	      stack: (new Error(action)).stack.split('\n'),
	      extra: extra
	    })
	  }
	}
	
	/**
	 * Add a clear API method for determining whether a transaction is web or
	 * background.
	 *
	 * @returns {boolean} Whether this transaction has a URL.
	 */
	Transaction.prototype.isWeb = function isWeb() {
	  return this.url ? true : false
	}
	
	/**
	 * @return {bool} Is this transaction still alive?
	 */
	Transaction.prototype.isActive = function isActive() {
	  return this.timer.isActive()
	}
	
	/**
	 * Close out the current transaction and its associated trace. Remove any
	 * instances of this transaction annotated onto the call stack.
	 */
	Transaction.prototype.end = function end(done) {
	  if (!this.timer.isActive()) return
	  if (this.traceFlag) {
	    logger.warn(
	      {segment: {name: this.name, stacks: this.traceStacks}},
	      'Flagged transaction ended.'
	    )
	  }
	
	  var transaction = this
	
	  transaction.trace.end()
	  process.nextTick(function nextTickedEnd() {
	    // recorders must be run before the trace is collected
	    if (!transaction.ignore) {
	      transaction.record()
	    }
	
	    transaction.agent.emit('transactionFinished', transaction)
	    if (typeof done === 'function') {
	      done(transaction)
	    }
	  })
	
	  transaction.timer.end()
	}
	
	/**
	 * For web transactions, this represents the time from when the request was received
	 * to when response was sent.  For background transactions, it is equal to duration
	 * of the transaction trace (until last segment ended).
	 */
	Transaction.prototype.getResponseTimeInMillis = function getResponseTimeInMillis() {
	  if (this.isWeb()) {
	    return this.timer.getDurationInMillis()
	  }
	  return this.trace.getDurationInMillis()
	}
	
	Transaction.prototype.applyUserNamingRules = function applyUserNamingRules(requestUrl) {
	  // 1. user normalization rules (set in configuration)
	  var normalized = this.agent.userNormalizer.normalize(requestUrl)
	  if (normalized.ignore) {
	    this.ignore = true
	  }
	  if (normalized.matched) {
	    this._partialName = NAMES.NORMALIZED + normalized.value
	  }
	}
	
	Transaction.prototype.setPartialName = function setPartialName(name) {
	  this._partialName = name
	}
	
	/**
	 * Sets the name of this transaction, figuring out along the way whether the
	 * transaction should be ignored. Should run as late in the transaction's
	 * lifetime as possible.
	 *
	 * Works entirely via side effects.
	 *
	 * @param {string} requestURL The URL to extract the name from.
	 * @param {string} statusCode The HTTP status code from the response.
	 */
	Transaction.prototype.setName = function setName(requestURL, statusCode) {
	  logger.trace({requestURL: requestURL, statusCode: statusCode, transactionId: this.id,
	    transactionName: this.name}, 'Setting transaction name')
	
	  this._partialName = this.nameState.getName()
	  this.url = urltils.scrub(requestURL)
	  this.statusCode = statusCode
	
	  // 1. name set by the api
	  if (this.forceName !== null) {
	    this._partialName = this.forceName
	  }
	
	  // 2. user normalization rules (set in configuration)
	  // can override transaction naming from API
	  this.applyUserNamingRules(this.url)
	
	  // 3. URL normalization rules (sent by server)
	  // Nothing has already set a name for this transaction, so normalize and
	  // potentially apply the URL backstop now. Only do so if no user rules
	  // matched.
	  if (!this._partialName) {
	    var normalized = this.agent.urlNormalizer.normalize(this.url)
	    if (normalized.ignore) {
	      this.ignore = true
	    }
	    this._partialName = normalized.value
	  }
	
	  // 4. transaction name normalization rules (sent by server)
	  var fullName = NAMES.WEB.RESPONSE_TIME + '/' + this._partialName
	  normalized = this.agent.transactionNameNormalizer.normalize(fullName)
	  if (normalized.ignore) {
	    this.ignore = true
	  }
	  this.name = normalized.value
	
	  // 5. transaction segment term normalizer
	  this.name = this.agent.txSegmentNormalizer.normalize(this.name).value
	
	  // Allow the API to explicitly set the ignored status.
	  if (this.forceIgnore !== null) {
	    this.ignore = this.forceIgnore
	  }
	
	  logger.trace({transactionId: this.id, transactionName: this.name},
	    'Finished setting transaction name')
	}
	
	
	Transaction.prototype.setBackgroundName = function setBackgroundName(name, group) {
	  this._partialName = group + NAMES.ACTION_DELIMITER + name
	
	  var fullName = NAMES.BACKGROUND.RESPONSE_TIME
	    + NAMES.ACTION_DELIMITER + this._partialName
	
	  // Transaction normalizers run on the full metric name, not the user facing
	  // transaction name.
	  var normalized = this.agent.transactionNameNormalizer.normalize(fullName)
	  if (normalized.ignore) {
	    this.ignore = true
	  }
	  this.name = normalized.value
	
	  if (this.forceIgnore !== null) {
	    this.ignore = this.forceIgnore
	  }
	}
	
	/**
	 * Gets the transaction name safely.
	 *
	 * Gathering the transaction name for WebTransactions is risky complicated
	 * business. OtherTransactions (aka background) are much simpler as they are
	 * always fully specified by the user at creation time.
	 *
	 * This has the potential of causing the normalizers run extra times, which can
	 * cause extra performance overhead. Once this is refactored we can make the
	 * caching better and eliminate this extra overhead. Be mindful of if/when this
	 * is called.
	 */
	Transaction.prototype.getName = function getName() {
	  // Detect web transactions as they are more complex.
	  if (this.isWeb() && !this.name) {
	    // Save and restore the partial name, as some instrumentation relies on it
	    // not being set to detect if it should set the transaction name.
	    var tempPartialName = this._partialName
	    this.setName(this.url, this.statusCode)
	    this._partialName = tempPartialName
	  }
	  return this.name
	}
	
	/**
	 * Returns the full URL of the transaction with query, search, or hash portions
	 * removed. This is only applicable for web transactions.
	 *
	 * Caches to ._scrubbedUrl, pulls in from .parsedUrl if it is available,
	 * otherwise it will parse .url, store it on .parsedUrl, then scrub the URL and
	 * store it in the cache.
	 *
	 * Returns a string or undefined.
	 */
	Transaction.prototype.getScrubbedUrl = function getScrubbedUrl() {
	  if (!this.isWeb()) return
	  if (this._scrubbedUrl) return this._scrubbedUrl
	
	  // If we don't have a parsedUrl, lets populate it from .url
	  if (!this.parsedUrl) {
	    // At time of writing .url should always be set by the time we get here
	    // because that is what .isWeb() checks against. In the future it may be
	    // instead checking a enum or other property so guard ourselves just in
	    // case.
	    if (!this.url) return
	    this.parsedUrl = url.parse(this.url)
	  }
	
	  var scrubbedParsedUrl = util._extend({}, this.parsedUrl)
	  scrubbedParsedUrl.search = null
	  scrubbedParsedUrl.query = null
	  scrubbedParsedUrl.href = null
	  scrubbedParsedUrl.path = null
	  scrubbedParsedUrl.hash = null
	
	  this._scrubbedUrl = url.format(scrubbedParsedUrl)
	
	  return this._scrubbedUrl
	}
	
	/**
	 * The instrumentation associates metrics with the different kinds of trace
	 * segments. The metrics recorders are dependent on the transaction name to
	 * collect their scoped metrics, and so must wait for the transaction's
	 * name to be finalized before the recording process. Segments are only
	 * responsible for their own life cycle, so responsibility for understanding
	 * when the transaction name has been finalized is handed off to the trace,
	 * which for now defers running these recorders until the trace is ended.
	 *
	 * @param {Function} recorder The callback which records metrics. Takes a
	 *                            single parameter, which is the transaction's
	 *                            name.
	 */
	Transaction.prototype.addRecorder = function addRecorder(recorder) {
	  this._recorders.push(recorder)
	}
	
	/**
	 * Run the metrics recorders for this trace. If the transaction's name /
	 * scope hasn't been set yet, the recorder will be passed an undefined name,
	 * and should be written to handle this.
	 */
	Transaction.prototype.record = function record() {
	  var name = this.name
	  for (var i = 0, l = this._recorders.length; i < l; ++i) {
	    this._recorders[i](name)
	  }
	}
	
	/**
	 * Measure the duration of an operation named by a metric, optionally
	 * belonging to a scope.
	 *
	 * @param {string} name The name of the metric to gather.
	 * @param {string} scope (optional) Scope to which the metric is bound.
	 * @param {number} duration The time taken by the operation, in milliseconds.
	 * @param {number} exclusive The time exclusively taken by an operation, and
	 *                           not its children.
	 */
	Transaction.prototype.measure = function measure(name, scope, duration, exclusive) {
	  this.metrics.measureMilliseconds(name, scope, duration, exclusive)
	}
	
	/**
	 * Based on the status code and the duration of a web transaction, either
	 * mark the transaction as frustrating, or record its time for apdex purposes.
	 *
	 * @param {string} name     Metric name.
	 * @param {number} duration Duration of the transaction, in milliseconds.
	 * @param {number} keyApdex A key transaction apdexT, in milliseconds
	 *                          (optional).
	 */
	Transaction.prototype._setApdex = function _setApdex(name, duration, keyApdexInMillis) {
	  var apdexStats = this.metrics.getOrCreateApdexMetric(name, null, keyApdexInMillis)
	  if (urltils.isError(this.agent.config, this.statusCode)) {
	    apdexStats.incrementFrustrating()
	  } else {
	    apdexStats.recordValueInMillis(duration, keyApdexInMillis)
	  }
	}
	
	/**
	 * Store first 10 unique path hashes calculated for a transaction.
	 *
	 * @param {string} pathHash Path hash
	 */
	Transaction.prototype.pushPathHash = function pushPathHash(pathHash) {
	  if (this.pathHashes.length >= 10 || this.pathHashes.indexOf(pathHash) !== -1) return
	  this.pathHashes.unshift(pathHash)
	}
	
	/**
	 * Return whether transaction spawned any outbound requests.
	 */
	Transaction.prototype.includesOutboundRequests = function includesOutboundRequests() {
	  return this.pathHashes.length > 0
	}
	
	/**
	 * Get unique previous path hashes for a transaction. Does not include
	 * current path hash.
	 */
	Transaction.prototype.alternatePathHashes = function alternatePathHashes() {
	  var curHash = hashes.calculatePathHash(
	    this.agent.config.applications()[0],
	    this.name || this._partialName || this.nameState.getName(),
	    this.referringPathHash
	  )
	  var altHashes = this.pathHashes.slice()
	  var curIndex = altHashes.indexOf(curHash)
	
	  if (curIndex !== -1) altHashes.splice(curIndex, 1)
	
	  return altHashes.length === 0 ? null : altHashes.sort().join(',')
	}
	
	Transaction.prototype.cleanup = function cleanup() {
	  if (this.trace) this.trace.cleanup()
	}
	
	/**
	 * Associate an exception with the transaction.  When the transaction ends,
	 * the exception will be collected along with the transaction details.
	 *
	 * @param {Error}   exception         The exception to be collected.
	 * @param {object}  customParameters  Any custom parameters associated with
	 *                                    the request (optional).
	 * @param {number}  timestamp         The timestamp for when the exception occurred.
	 */
	Transaction.prototype.addException = _addException
	
	function _addException(exception, customParameters, timestamp) {
	  this.exceptions.push([exception, customParameters, timestamp])
	}
	
	/**
	 * Associate a user error (reported using the noticeError() API) with the transaction.
	 * When the transaction ends, the exception will be collected along with the transaction
	 * details.
	 *
	 * @param {Error}   exception         The exception to be collected.
	 * @param {object}  customParameters  Any custom parameters associated with
	 *                                    the request (optional).
	 * @param {number}  timestamp         The timestamp for when the exception occurred.
	 */
	Transaction.prototype.addUserError = _addUserError
	
	function _addUserError(exception, customParameters, timestamp) {
	  this.userErrors.push([exception, customParameters, timestamp])
	}
	
	/**
	 * Returns true if an error happened during the transaction or if the transaction itself
	 * is considered to be an error.
	 */
	Transaction.prototype.hasErrors = function _hasErrors() {
	  var isErroredTransaction = urltils.isError(this.agent.config, this.statusCode)
	  var transactionHasExceptions = this.exceptions.length > 0
	  var transactionHasuserErrors = this.userErrors.length > 0
	  return (transactionHasExceptions || transactionHasuserErrors || isErroredTransaction)
	}
	
	Transaction.prototype.addAgentAttribute = function addAgentAttribute(key, value) {
	  if (this.agent.config.ignored_params.indexOf(key) === -1) {
	    this.trace.addParameter(key, value)
	  }
	}
	
	/**
	 * Returns agent intrinsic attribute for this transaction.
	 */
	Transaction.prototype.getIntrinsicAttributes = function getIntrinsicAttributes() {
	  if (!this._intrinsicAttributes.totalTime) {
	    var config = this.agent.config
	    this._intrinsicAttributes.totalTime =
	      this.trace.getTotalTimeDurationInMillis() * FROM_MILLIS
	
	    // FLAG: cat
	    if (config.feature_flag.cat) {
	      this._intrinsicAttributes.path_hash = hashes.calculatePathHash(
	        config.applications()[0],
	        this.name || this._partialName,
	        this.referringPathHash
	      )
	      this._intrinsicAttributes.trip_id = this.tripId || this.id
	      if (this.referringTransactionGuid) {
	        this._intrinsicAttributes.referring_transaction_guid =
	          this.referringTransactionGuid
	      }
	      if (config.cross_process_id) {
	        this._intrinsicAttributes.client_cross_process_id = config.cross_process_id
	      }
	    }
	
	    // FLAG: synthetics
	    if (config.feature_flag.synthetics) {
	      var data = this.syntheticsData
	
	      if (data) {
	        this._intrinsicAttributes.synthetics_resource_id = data.resourceId
	        this._intrinsicAttributes.synthetics_job_id = data.jobId
	        this._intrinsicAttributes.synthetics_monitor_id = data.monitorId
	      }
	    }
	  }
	  return util._extend({}, this._intrinsicAttributes)
	}
	
	module.exports = Transaction
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var codec = __webpack_require__(184)
	var copy = __webpack_require__(167)
	var Segment = __webpack_require__(189)
	var NAMES = __webpack_require__(59)
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var FROM_MILLIS = 1e-3
	
	/**
	 * A Trace holds the root of the Segment graph and produces the final
	 * serialization of the transaction trace.
	 *
	 * @param {Transaction} transaction The transaction bound to the trace.
	 */
	function Trace(transaction) {
	  if (!transaction) throw new Error('All traces must be associated with a transaction.')
	
	  this.transaction = transaction
	
	  this.root = new Segment(transaction, 'ROOT')
	  this.root.start()
	
	  this.custom = {}
	  this.intrinsics = {}
	  this.segmentsSeen = 0
	  this.totalTimeCache = null
	
	  // hidden class optimization
	  this.parameters = {}
	
	  // sending displayName if set by user
	  var displayName = transaction.agent.config.getDisplayHost()
	  var hostName = transaction.agent.config.getHostnameSafe()
	  if (displayName !== hostName) {
	    this.parameters['host.displayName'] = displayName
	  }
	  this.domain = null
	}
	
	/**
	 * End and close the current trace. Triggers metric recording for trace
	 * segments that support recording.
	 */
	Trace.prototype.end = function end() {
	  var segments = [this.root]
	
	  while (segments.length) {
	    var segment = segments.pop()
	    if (segment.timer.softEnd()) {
	      segment._updateRootTimer()
	      // timer.softEnd() returns true if the timer was ended prematurely, so
	      // in that case we can name the segment as truncated
	      segment.name = NAMES.TRUNCATED.PREFIX + segment.name
	    }
	    segments = segments.concat(segment.getChildren())
	  }
	}
	
	/**
	 * Add a child to the list of segments.
	 *
	 * @param {string} childName Name for the new segment.
	 * @returns {Segment} Newly-created Segment.
	 */
	Trace.prototype.add = function add(childName, callback) {
	  return this.root.add(childName, callback)
	}
	
	/**
	 * Explicitly set a trace's runtime instead of using it as a stopwatch.
	 * (As a byproduct, stops the timer.)
	 *
	 * @param {int} duration Duration of this particular trace.
	 * @param {int} startTimeInMillis (optional) Start of this trace.
	 */
	Trace.prototype.setDurationInMillis = setDurationInMillis
	
	function setDurationInMillis(duration, startTimeInMillis) {
	  this.root.setDurationInMillis(duration, startTimeInMillis)
	}
	
	/**
	 * @return {integer} The amount of time the trace took, in milliseconds.
	 */
	Trace.prototype.getDurationInMillis = function getDurationInMillis() {
	  return this.root.getDurationInMillis()
	}
	
	/**
	 * Trace parameters are used as agent attributes
	 */
	Trace.prototype.addParameter = function addParameter(key, value) {
	  this.parameters[key] = value
	}
	
	/**
	 * The duration of the transaction trace tree that only this level accounts
	 * for.
	 *
	 * @return {integer} The amount of time the trace took, minus any child
	 *                   traces, in milliseconds.
	 */
	Trace.prototype.getExclusiveDurationInMillis = function getExclusiveDurationInMillis() {
	  return this.root.getExclusiveDurationInMillis()
	}
	
	
	/**
	 * The duration of all segments in a transaction trace.  The root is not
	 * accounted for, since it doesn't represent a unit of work.
	 *
	 * @return {integer} The sum of durations for all segments in a trace in
	 *                   milliseconds
	 */
	Trace.prototype.getTotalTimeDurationInMillis = function getTotalTimeDurationInMillis() {
	  if (this.totalTimeCache !== null) return this.totalTimeCache
	  if (this.root.children.length === 0) return 0
	  var segments = this.root.getChildren()
	  var totalTimeInMillis = 0
	
	  while (segments.length !== 0) {
	    var segment = segments.pop()
	    totalTimeInMillis += segment.getExclusiveDurationInMillis()
	    segments = segments.concat(segment.getChildren())
	  }
	
	  if (!this.transaction.isActive()) this.totalTimeCache = totalTimeInMillis
	  return totalTimeInMillis
	}
	
	/**
	 * The serializer is asynchronous, so serialization is as well.
	 *
	 * The transaction trace sent to the collector is a nested set of arrays. The
	 * outermost array has the following fields, in order:
	 *
	 * 0: start time of the trace, in milliseconds
	 * 1: duration, in milliseconds
	 * 2: the path, or root metric name
	 * 3: the URL (fragment) for this trace
	 * 4: an array of segment arrays, deflated and then base64 encoded
	 * 5: FIXME: the guid for this transaction, used to correlate across
	 *    transactions (for now, to correlate with RUM sessions)
	 * 6: reserved for future use, specified to be null for now
	 * 7: FIXME: RUM2 force persist flag
	 *
	 * In addition, there is a "root node" (not the same as the first child, which
	 * is a node with the special name ROOT and contents otherwise identical to the
	 * top-level segment of the actual trace) with the following fields:
	 *
	 * 0: start time IN SECONDS
	 * 1: a dictionary containing request parameters
	 * 2: a dictionary containing custom parameters (currently not user-modifiable)
	 * 3: the transaction trace segments (including the aforementioned root node)
	 * 4: FIXME: a dictionary containing "parameter groups" with special information
	 *    related to this trace
	 *
	 * @param {Function} callback Called after serialization with either
	 *                            an error (in the first parameter) or
	 *                            the serialized transaction trace.
	 */
	Trace.prototype.generateJSON = function generateJSON(callback) {
	  var attributes = {
	    agentAttributes: copy.shallow(this.parameters),
	    userAttributes: this.custom,
	    intrinsics: this.intrinsics
	  }
	  delete attributes.agentAttributes.request_uri
	
	  var rootNode = [
	    this.root.timer.start * FROM_MILLIS,
	    {}, // moved to agentAttributes
	    {
	      // hint to RPM for how to display this trace's segments
	      nr_flatten_leading: false
	    }, // moved to userAttributes
	    this.root.toJSON(),
	    attributes,
	    []  // FIXME: parameter groups
	  ]
	
	  var trace = this
	  if (!this.transaction.agent.config.simple_compression) {
	    codec.encode(rootNode, respond)
	  } else {
	    process.nextTick(respond.bind(null, null, rootNode))
	  }
	
	  function respond(err, data) {
	    if (err) {
	      return callback(err, null, null)
	    }
	
	    var syntheticsResourceId = null
	    // FLAG: synthetics not feature flagged here, but this will only get set if
	    // the flag is on.
	    if (trace.transaction.syntheticsData) {
	      syntheticsResourceId = trace.transaction.syntheticsData.resourceId
	    }
	
	    var json = [
	      trace.root.timer.start, // start
	      trace.transaction.getResponseTimeInMillis(), // response time
	      trace.transaction.name, // path
	      trace.transaction.url,  // uri
	      data,                   // encodedCompressedData
	      '',                     // guid
	      null,                   // reserved for future use
	      false,                  // forcePersist
	      null,                   // xraySessionId
	      syntheticsResourceId    // synthetics resource id
	    ]
	
	    return callback(null, json, trace)
	  }
	}
	
	module.exports = Trace
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'segment'})
	var util = __webpack_require__(16)
	var urltils = __webpack_require__(168)
	var sumChildren = __webpack_require__(190)
	var Timer = __webpack_require__(96)
	
	
	var INSTANCE_UNKNOWN = 'unknown'
	var STATE = {
	  EXTERNAL: 'EXTERNAL',
	  CALLBACK: 'CALLBACK'
	}
	
	/**
	 * Initializes the segment and binds the recorder to itself, if provided.
	 *
	 * @constructor
	 * @classdesc
	 * TraceSegments are inserted to track instrumented function calls. Each one is
	 * bound to a transaction, given a name (used only internally to the framework
	 * for now), and has one or more children (that are also part of the same
	 * transaction), as well as an associated timer.
	 *
	 * @param {Transaction} transaction
	 *  The transaction to which this segment will be bound.
	 *
	 * @param {string} name
	 *  Human-readable name for this segment (e.g. 'http', 'net', 'express',
	 *  'mysql', etc).
	 *
	 * @param {?function} recorder
	 *  Callback that takes a segment and a scope name as parameters (intended to be
	 *  used to record metrics related to the segment).
	 */
	function TraceSegment(transaction, name, recorder) {
	  if (!transaction) throw new Error('All segment must be associated with a transaction.')
	  if (!name) throw new Error('All segment must be named')
	
	  this.name = name
	  this.transaction = transaction
	
	  transaction.numSegments++
	  transaction.agent.totalActiveSegments++
	  transaction.agent.segmentsCreatedInHarvest++
	
	  if (recorder) {
	    transaction.addRecorder(recorder.bind(null, this))
	  }
	
	  this.parameters = {nr_exclusive_duration_millis: null}
	  this.children = []
	
	  this.timer = new Timer()
	
	  // hidden class optimization
	  this.partialName = null
	  this._exclusiveDuration = null
	  this._collect = true
	  this.host = null
	  this.port = null
	  this.state = STATE.EXTERNAL
	  this.async = true
	  this.ignore = false
	
	  this.probe('new TraceSegment')
	}
	
	/**
	 * @param {string} host
	 *  The name of the host of the database. This will be normalized if the string
	 *  represents localhost.
	 *
	 * @param {string|number} port
	 *  The database's port, path to unix socket, or id.
	 *
	 * @param {string|number|bool} database
	 *  The name or ID of the database that was connected to. Or `false` if there is
	 *  no database name (i.e. Redis has no databases, only hosts).
	 */
	TraceSegment.prototype.captureDBInstanceAttributes =
	function captureDBInstanceAttributes(host, port, database) {
	  var config = this.transaction.agent.config
	  var dsTracerConf = config.datastore_tracer
	
	  // Add database name if provided and enabled.
	  if (database !== false && dsTracerConf.database_name_reporting.enabled) {
	    this.parameters.database_name =
	      typeof database === 'number' ? database : (database || INSTANCE_UNKNOWN)
	  }
	
	  // Add instance information if enabled.
	  if (dsTracerConf.instance_reporting.enabled) {
	    // Determine appropriate defaults for host and port.
	    port = port || INSTANCE_UNKNOWN
	    if (host && urltils.isLocalhost(host)) {
	      host = config.getHostnameSafe(host)
	    }
	    if (!host || host === 'UNKNOWN_BOX') { // Config's default name of a host.
	      host = INSTANCE_UNKNOWN
	    }
	    this.parameters.host = host
	    this.parameters.port_path_or_id = String(port)
	  }
	}
	
	TraceSegment.prototype.moveToCallbackState = function moveToCallbackState() {
	  this.state = STATE.CALLBACK
	}
	
	TraceSegment.prototype.isInCallbackState = function isInCallbackState() {
	  return this.state === STATE.CALLBACK
	}
	
	TraceSegment.prototype.probe = function probe(action) {
	  if (this.transaction.traceStacks) {
	    this.transaction.probe(action, {segment: this.name})
	  }
	}
	
	/**
	 * Once a transaction is named, the web segment also needs to be updated to
	 * match it (which implies this method must be called subsequent to
	 * transaction.setName). To properly name apdex metrics during metric
	 * recording, it's also necessary to copy the transaction's partial name. And
	 * finally, marking the trace segment as being a web segment copies the
	 * segment's parameters onto the transaction.
	 *
	 * @param {string} rawURL The URL, as it came in, for parameter extraction.
	 */
	TraceSegment.prototype.markAsWeb = function markAsWeb(rawURL) {
	  var transaction = this.transaction
	
	  // transaction name and web segment name must match
	  this.name = transaction.name
	  // partialName is used to name apdex metrics when recording
	  this.partialName = transaction._partialName
	
	  var config = transaction.agent.config
	
	  // Copy params object so we can modify it before applying it
	  // multiple params places. It eventually runs through copyParameters
	  // so I'm not worried about `ignored_params` or `capture_params`.
	  var params = util._extend({}, this.parameters)
	
	  // This shouldn't be moved from the segment to the trace, so remove it.
	  delete params.nr_exclusive_duration_millis
	
	  // Because we are assured we have the URL here, lets grab query
	  // params. We want to opt for keeping the keys that are already on
	  // params, so we use copyParameters
	  urltils.copyParameters(config, urltils.parseParameters(rawURL), params)
	
	  urltils.copyParameters(config, params, this.parameters)
	  urltils.copyParameters(config, params, this.transaction.trace.parameters)
	}
	
	/**
	 * A segment attached to something evented (such as a database
	 * cursor) just finished an action, so set the timer to mark
	 * the timer as having a stop time.
	 */
	TraceSegment.prototype.touch = function touch() {
	  this.probe('Touched')
	  this.timer.touch()
	  this._updateRootTimer()
	}
	
	TraceSegment.prototype.overwriteDurationInMillis = overwriteDurationInMillis
	function overwriteDurationInMillis(duration, start) {
	  this.timer.overwriteDurationInMillis(duration, start)
	}
	
	
	TraceSegment.prototype.start = function start() {
	  this.timer.begin()
	}
	
	/**
	 * Stop timing the related action.
	 */
	TraceSegment.prototype.end = function end() {
	  if (!this.timer.isActive()) return
	  this.probe('Ended')
	  this.timer.end()
	  this._updateRootTimer()
	}
	
	/**
	 * Helper to set the end of the root timer to this segment's root if it is later
	 * in time.
	 */
	TraceSegment.prototype._updateRootTimer = function _updateRootTimer() {
	  var root = this.transaction.trace.root
	  if (this.timer.endsAfter(root.timer)) {
	    var newDuration = (
	      this.timer.start +
	      this.getDurationInMillis() -
	      root.timer.start
	    )
	    root.overwriteDurationInMillis(newDuration)
	  }
	}
	
	/**
	 * Test to see if underlying timer is still active
	 *
	 * @returns {boolean} true if no longer active, else false.
	 */
	TraceSegment.prototype._isEnded = function _isEnded() {
	  return !this.timer.isActive() || this.timer.touched
	}
	
	/**
	 * Add a new segment to a scope implicitly bounded by this segment.
	 *
	 * @param {string} childName New human-readable name for the segment.
	 * @returns {TraceSegment} New nested TraceSegment.
	 */
	TraceSegment.prototype.add = function add(childName, recorder) {
	  logger.trace('Adding segment %s to %s', childName, this.name)
	  var segment = new TraceSegment(this.transaction, childName, recorder)
	  var config = this.transaction.agent.config
	
	  if (this.transaction.trace.segmentsSeen++ >= config.max_trace_segments) {
	    segment._collect = false
	  }
	  this.children.push(segment)
	
	  if (config.debug && config.debug.double_linked_transactions) {
	    segment.parent = this
	  }
	
	  return segment
	}
	
	/**
	 * Set the duration of the segment explicitly.
	 *
	 * @param {Number} duration Duration in milliseconds.
	 */
	TraceSegment.prototype.setDurationInMillis = setDurationInMillis
	
	function setDurationInMillis(duration, start) {
	  this.timer.setDurationInMillis(duration, start)
	}
	
	TraceSegment.prototype.getDurationInMillis = function getDurationInMillis() {
	  return this.timer.getDurationInMillis()
	}
	
	/**
	 * Only for testing!
	 *
	 * @param {number} duration Milliseconds of exclusive duration.
	 */
	TraceSegment.prototype._setExclusiveDurationInMillis = _setExclusiveDurationInMillis
	
	function _setExclusiveDurationInMillis(duration) {
	  this._exclusiveDuration = duration
	}
	
	/**
	 * The duration of the transaction trace tree that only this level accounts
	 * for.
	 *
	 * @return {integer} The amount of time the trace took, minus any child
	 *                   segments, in milliseconds.
	 */
	TraceSegment.prototype.getExclusiveDurationInMillis = getExclusiveDurationInMillis
	
	function getExclusiveDurationInMillis() {
	  if (this._exclusiveDuration) return this._exclusiveDuration
	
	  var total = this.getDurationInMillis()
	  var end = this.timer.toRange()[1]
	
	  if (this.children.length > 0) {
	    // convert the list of start, duration pairs to start, end pairs
	    total -= sumChildren(this._getChildPairs(end), end)
	  }
	
	  return total
	}
	
	TraceSegment.prototype.getChildren = function getChildren() {
	  var children = []
	  for (var i = 0, len = this.children.length; i < len; ++i) {
	    if (!this.children[i].ignore) {
	      children.push(this.children[i])
	    }
	  }
	  return children
	}
	
	/**
	 * Enumerate the timings of this segment's descendants.
	 *
	 * @param {Number} end The end of this segment, to keep the calculated
	 *                     duration from exceeding the duration of the
	 *                     parent. Defaults to Infinity.
	 *
	 * @returns {Array} Unsorted list of [start, end] pairs, with no pair
	 *                  having an end greater than the passed in end time.
	 */
	TraceSegment.prototype._getChildPairs = function _getChildPairs(end) {
	  // quick optimization
	  if (this.children.length < 1) return []
	  if (!end) end = Infinity
	
	  var children = this.getChildren()
	  var childPairs = []
	  while (children.length) {
	    var child = children.pop()
	    var pair = child.timer.toRange()
	
	    if (pair[0] >= end) continue
	
	    children = children.concat(child.getChildren())
	
	    pair[1] = Math.min(pair[1], end)
	    childPairs.push(pair)
	  }
	
	  return childPairs
	}
	
	/**
	 * This is perhaps the most poorly-documented element of transaction traces:
	 * what do each of the segment representations look like prior to encoding?
	 * Spelunking in the code for the other agents has revealed that each child
	 * node is an array with the following field in the following order:
	 *
	 * 0: entry timestamp relative to transaction start time
	 * 1: exit timestamp
	 * 2: metric name
	 * 3: parameters as a name -> value JSON dictionary
	 * 4: any child segments
	 *
	 * Other agents include further fields in this. I haven't gotten to the bottom
	 * of all of them (and Ruby, of course, sends marshalled Ruby object), but
	 * here's what I know so far:
	 *
	 * in Java:
	 * 5: class name
	 * 6: method name
	 *
	 * in Python:
	 * 5: a "label"
	 *
	 * FIXME: I don't know if it makes sense to add custom fields for Node. TBD
	 */
	TraceSegment.prototype.toJSON = function toJSON() {
	  var start = this.timer.startedRelativeTo(this.transaction.trace.root.timer)
	  var duration = this.getDurationInMillis()
	  if (!this.parameters.nr_exclusive_duration_millis) {
	    this.parameters.nr_exclusive_duration_millis = this.getExclusiveDurationInMillis()
	  }
	
	  var children = this.getChildren()
	  var childrenJson = []
	  for (var i = 0, len = children.length; i < len; i++) {
	    var child = children[i]
	    if (child._collect) {
	      childrenJson.push(child.toJSON())
	    }
	  }
	
	  return [
	    start,
	    start + duration,
	    this.name,
	    this.parameters,
	    childrenJson
	  ]
	}
	
	module.exports = TraceSegment


/***/ },
/* 190 */
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * Given an ordered list of disjoint intervals and a new interval to fold into
	 * it, determine if the new interval is a sub-interval (in which case it's
	 * redundant), an overlapping interval (in which case, replace the most recent
	 * interval on the list with an interval representing the union of the new and
	 * last intervals), or otherwise (it's disjoint to what we already
	 * have, in which case add it to the list). Meant to be used with
	 * Array.reduce().
	 *
	 * Assumes the list being reduced is sorted by interval start time.
	 *
	 * @param {Array} accum  The accumulated list of reduced intervals.
	 * @param {Array} newest A new pair of range start and end to compare to the
	*                        existing intervals.
	 *
	 * @return {Array} A list of intervals updated to include the new interval.
	 */
	
	function sumChildren(pairs, parentEnd) {
	  if (!pairs.length) return 0
	
	  pairs.sort(function cb_sort(a, b) {
	    return a[0] - b[0]
	  })
	
	
	  var start = pairs[0][0]
	  var end = start
	  var diff = 0
	  var segmentEnd
	  var pair
	
	  for (var i = 0, l = pairs.length; i < l; ++i) {
	    pair = pairs[i]
	
	    if (pair[0] > parentEnd) break
	    segmentEnd = pair[1] > parentEnd ? parentEnd : pair[1]
	
	    if (pair[0] > end) {
	      diff += pair[0] - end
	      end = segmentEnd
	    } else if (segmentEnd > end) {
	      end = segmentEnd
	    }
	  }
	
	  return end - start - diff
	}
	
	module.exports = sumChildren


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'name-state'})
	var arrayUtil = __webpack_require__(174)
	
	
	/**
	 * Manages transaction names using a stack of paths.
	 *
	 * @constructor
	 */
	function NameState(prefix, verb, delimiter, path) {
	  this.setName(prefix, verb, delimiter, path)
	}
	
	NameState.prototype.setName = function setName(prefix, verb, delimiter, path) {
	  this.setPrefix(prefix)
	  this.verb = verb
	  this.delimiter = delimiter
	  this.pathStack = path ? [path] : []
	  logger.trace('setName called on name state, path stack now %j', this.pathStack)
	}
	
	/**
	 * Sets the metric prefix (i.e. Expressjs).
	 */
	NameState.prototype.setPrefix = function setPrefix(prefix) {
	  if (prefix === null) {
	    this.prefix = null
	    return
	  }
	  this.prefix = (prefix[prefix.length - 1] === '/') ?
	    prefix.substring(0, prefix.length - 1) : prefix
	}
	
	/**
	 * Sets the HTTP verb (i.e. GET/POST/PUT)
	 */
	NameState.prototype.setVerb = function setVerb(verb) {
	  this.verb = verb
	}
	
	/**
	 * Sets the delimiter character used to separate the http verb from the path.
	 */
	NameState.prototype.setDelimiter = function setDelimiter(delimiter) {
	  this.delimiter = delimiter
	}
	
	/**
	 * Pushes a new path element onto the naming stack.
	 */
	NameState.prototype.appendPath = function appendPath(path) {
	  if (path) {
	    var strPath = path instanceof RegExp ? path.source : String(path)
	    this.pathStack.push(strPath)
	    logger.trace('Appended %s to path stack', strPath)
	  }
	}
	
	/**
	 * Pushes a new path element onto the naming stack if the stack is
	 * empty.
	 */
	NameState.prototype.appendPathIfEmpty = function appendPathIfEmpty(path) {
	  if (path && this.pathStack.length === 0) {
	    var strPath = path instanceof RegExp ? path.source : String(path)
	    this.pathStack.push(strPath)
	    logger.trace('Appended %s to path stack', strPath)
	  }
	}
	
	/**
	 * Pops the last element off the name stack.
	 *
	 * If `path` is provided, the stack is popped back to the first element matching
	 * `path`. If no element matches, the stack is left unchanged.
	 *
	 * @param {string} [path] - Optional. A path piece to pop back to.
	 */
	NameState.prototype.popPath = function popPath(path) {
	  if (this.pathStack.length === 0) {
	    return
	  }
	
	  if (path) {
	    var idx = arrayUtil.findLastIndex(this.pathStack, function pathMatch(a) {
	      return a === path
	    })
	    if (idx !== -1) {
	      this.pathStack.splice(idx)
	    }
	  } else {
	    this.pathStack.pop()
	  }
	}
	
	NameState.prototype.getName = function getName() {
	  if (this.pathStack.length === 0) return null // nameState initialized but never set
	
	  var path = this.pathStack.join('/').replace(/[/]{2,}/g, '/')
	  if (path && path[0] !== '/') {
	    path = '/' + path
	  } // path now looks like /one/two/three
	
	  var verb = this.verb ? '/' + this.verb : ''
	
	  return (this.prefix || '') + verb + (this.delimiter || '') + path
	}
	
	NameState.prototype.reset = function reset() {
	  logger.trace('Reset called on name state, path stack was %j', this.pathStack)
	  this.prefix = null
	  this.verb = null
	  this.delimiter = null
	  this.pathStack = []
	}
	
	module.exports = NameState


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	/**
	 * This file includes all of the configuration variables used by the Node.js
	 * module. If there's a configurable element of the module and it's not
	 * described in here, there's been a terrible mistake.
	 */
	exports.config = {
	  /**
	   * Array of application names.
	   *
	   * @env NEW_RELIC_APP_NAME
	   */
	  app_name: [],
	  /**
	   * The user's license key. Must be set by per-app configuration file.
	   *
	   * @env NEW_RELIC_LICENSE_KEY
	   */
	  license_key: '',
	  /**
	   * Hostname for the New Relic collector proxy.
	   *
	   * You shouldn't need to change this.
	   *
	   * @env NEW_RELIC_HOST
	   */
	  host: 'collector.newrelic.com',
	  /**
	   * The port on which the collector proxy will be listening.
	   *
	   * You shouldn't need to change this.
	   *
	   * @env NEW_RELIC_PORT
	   */
	  port: 443,
	  /**
	   * Whether or not to use SSL to connect to New Relic's servers.
	   *
	   * @env NEW_RELIC_USE_SSL
	   */
	  ssl: true,
	  /**
	   * Proxy url
	   *
	   * A proxy url can be used in place of setting
	   * proxy_host, proxy_port, proxy_user, and proxy_pass.
	   *
	   * e.g. http://user:pass@host:port/
	   *
	   * Setting proxy will override other proxy settings.
	   *
	   * @env NEW_RELIC_PROXY_URL
	   */
	  proxy: '',
	  /**
	   * Proxy host to use to connect to the internet.
	   *
	   * @env NEW_RELIC_PROXY_HOST
	   */
	  proxy_host: '',
	  /**
	   * Proxy port to use to connect to the internet.
	   *
	   * @env NEW_RELIC_PROXY_PORT
	   */
	  proxy_port: '',
	  /**
	   * Proxy user name when required.
	   *
	   * @env NEW_RELIC_PROXY_USER
	   */
	  proxy_user: '',
	  /**
	   * Proxy password when required.
	   *
	   * @env NEW_RELIC_PROXY_PASS
	   */
	  proxy_pass: '',
	  /**
	   * Custom SSL certificates
	   *
	   * If your proxy uses a custom SSL certificate, you can add the CA text to
	   * this array, one entry per certificate.
	   *
	   * The easiest way to do this is with `fs.readFileSync` e.g.
	   *
	   * certificates: [
	   *   require('fs').readFileSync('custom.crt', 'utf8') // don't forget the utf8
	   * ]
	   *
	   */
	  certificates: [],
	  /**
	   * You may want more control over how the module is configured and want to
	   * disallow the use of New Relic's server-side configuration. To do so, set
	   * this parameter to true. Some configuration information is required to make
	   * the module work properly with the rest of New Relic, but settings such as
	   * apdex_t and capture_params will not be override-able by New Relic with this
	   * setting in effect.
	   *
	   * @env NEW_RELIC_IGNORE_SERVER_CONFIGURATION
	   */
	  ignore_server_configuration: false,
	  /**
	   * Whether the module is enabled.
	   *
	   * @env NEW_RELIC_ENABLED
	   */
	  agent_enabled: true,
	  /**
	   * The default Apdex tolerating / threshold value for applications, in
	   * seconds. The default for Node is apdexT to 100 milliseconds, which is
	   * lower than New Relic standard, but Node.js applications tend to be more
	   * latency-sensitive than most.
	   *
	   * @env NEW_RELIC_APDEX
	   */
	  apdex_t: 0.100,
	  /**
	   * Whether to capture parameters in the request URL in slow transaction
	   * traces and error traces. Because this can pass sensitive data, it's
	   * disabled by default. If there are specific parameters you want ignored,
	   * use ignored_params.
	   *
	   * @env NEW_RELIC_CAPTURE_PARAMS
	   */
	  capture_params: false,
	  /**
	   * Array of parameters you don't want captured off request URLs in slow
	   * transaction traces and error traces.
	   *
	   * @env NEW_RELIC_IGNORED_PARAMS
	   */
	  ignored_params: [],
	  logging: {
	    /**
	     * Verbosity of the module's logging. This module uses bunyan
	     * (https://github.com/trentm/node-bunyan) for its logging, and as such the
	     * valid logging levels are 'fatal', 'error', 'warn', 'info', 'debug' and
	     * 'trace'. Logging at levels 'info' and higher is very terse. For support
	     * requests, attaching logs captured at 'trace' level are extremely helpful
	     * in chasing down bugs.
	     *
	     * @env NEW_RELIC_LOG_LEVEL
	     */
	    level: 'info',
	    /**
	     * Where to put the log file -- by default just uses process.cwd +
	     * 'newrelic_agent.log'. A special case is a filepath of 'stdout',
	     * in which case all logging will go to stdout, or 'stderr', in which
	     * case all logging will go to stderr.
	     *
	     * @env NEW_RELIC_LOG
	     */
	    filepath: __webpack_require__(58).join(process.cwd(), 'newrelic_agent.log'),
	    /**
	     * Whether to write to a log file at all
	     *
	     * @env NEW_RELIC_LOG_ENABLED
	     */
	    enabled: true,
	
	    /**
	     * Enables extra debugging at `warn` level. No need to enable except under
	     * specific debugging conditions.
	     */
	    diagnostics: false
	  },
	
	  audit_log: {
	
	    /**
	     * Enables logging of out bound traffic from the Agent to the Collector.
	     * This field is ignored if trace level logging is enabled.
	     * With trace logging, all traffic is logged.
	     *
	     * @env NEW_RELIC_AUDIT_LOG_ENABLED
	     */
	    enabled: false,
	
	    /**
	     * Specify which methods are logged. Used in conjuction with the audit_log flag
	     * If audit_log is enabled and this property is empty, all methods will be logged
	     * Otherwise, if the audit log is enabled, only the methods specified 
	     * in the filter will be logged
	     * Methods include: error_data, metric_data, and analytic_event_data
	     *
	     * @env NEW_RELIC_AUDIT_LOG_ENDPOINTS
	     */
	    endpoints: []
	  },
	  /**
	   * Whether to collect & submit error traces to New Relic.
	   *
	   * @env NEW_RELIC_ERROR_COLLECTOR_ENABLED
	   */
	  error_collector: {
	    /**
	     * Disabling the error tracer just means that errors aren't collected
	     * and sent to New Relic -- it DOES NOT remove any instrumentation.
	     */
	    enabled: true,
	    /**
	     * List of HTTP error status codes the error tracer should disregard.
	     * Ignoring a status code means that the transaction is not renamed to
	     * match the code, and the request is not treated as an error by the error
	     * collector.
	     *
	     * Defaults to 404 NOT FOUND.
	     *
	     * @env NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES
	     */
	    ignore_status_codes: [404],
	    /**
	     * Whether error events are collected.
	     */
	    capture_events: true,
	    /**
	     * The agent will collect all error events up to this number per minute.
	     * If there are more than that, a statistical sampling will be collected.
	     * Currently this uses a reservoir sampling algorithm.
	     *
	     * By increasing this setting you are both increasing the memory
	     * requirements of the agent as well as increasing the payload to the New
	     * Relic servers. The memory concerns are something you should consider for
	     * your own server's sake. The payload of events is compressed, but if it
	     * grows too large the New Relic servers may reject it.
	     */
	    max_event_samples_stored: 100
	  },
	  /**
	   * Options regarding collecting system information. Used for system
	   * utilization based pricing scheme.
	   */
	  utilization: {
	    /**
	     * This flag dictates whether the agent attempts to reach out to AWS
	     * to get info about the vm the process is running on.
	     *
	     * @env NEW_RELIC_UTILIZATION_DETECT_AWS
	     */
	    detect_aws: true,
	    /**
	     * This flag dictates whether the agent attempts to reach out to AWS
	     * to get info about the container the process is running in.
	     *
	     * @env NEW_RELIC_UTILIZATION_DETECT_DOCKER
	     */
	    detect_docker: true
	  },
	  transaction_tracer: {
	    /**
	     * Whether to collect & submit slow transaction traces to New Relic. The
	     * instrumentation is loaded regardless of this setting, as it's necessary
	     * to gather metrics. Disable the agent to prevent the instrumentation from
	     * loading.
	     *
	     * @env NEW_RELIC_TRACER_ENABLED
	     */
	    enabled: true,
	    /**
	     * The duration at below which the slow transaction tracer should collect a
	     * transaction trace. If set to 'apdex_f', the threshold will be set to
	     * 4 * apdex_t, which with a default apdex_t value of 500 milliseconds will
	     * be 2 seconds.
	     *
	     * If a time is provided, it is set in seconds.
	     *
	     * @env NEW_RELIC_TRACER_THRESHOLD
	     */
	    transaction_threshold: 'apdex_f',
	    /**
	     * Increase this parameter to increase the diversity of the slow
	     * transaction traces recorded by your application over time. Confused?
	     * Read on.
	     *
	     * Transactions are named based on the request (see the README for the
	     * details of how requests are mapped to transactions), and top_n refers to
	     * the "top n slowest transactions" grouped by these names. The module will
	     * only replace a recorded trace with a new trace if the new trace is
	     * slower than the previous slowest trace of that name. The default value
	     * for this setting is 20, as the transaction trace view page also defaults
	     * to showing the 20 slowest transactions.
	     *
	     * If you want to record the absolute slowest transaction over the last
	     * minute, set top_n to 0 or 1. This used to be the default, and has a
	     * problem in that it will allow one very slow route to dominate your slow
	     * transaction traces.
	     *
	     * The module will always record at least 5 different slow transactions in
	     * the reporting periods after it starts up, and will reset its internal
	     * slow trace aggregator if no slow transactions have been recorded for the
	     * last 5 harvest cycles, restarting the aggregation process.
	     *
	     * @env NEW_RELIC_TRACER_TOP_N
	     */
	    top_n: 20,
	
	    /**
	     * This option affects both slow-queries and record_sql for transaction
	     * traces.  It can have one of 3 values: 'off', 'obfuscated' or 'raw'
	     * When it is 'off' no slow queries will be captured, and backtraces
	     * and sql will not be included in transaction traces.  If it is 'raw'
	     * or 'obfuscated' and other criteria (slow_sql.enabled etc) are met
	     * for a query. The raw or obfuscated sql will be included in the
	     * transaction trace and a slow query sample will be collected.
	     */
	    record_sql: 'off',
	
	    /**
	     * This option affects both slow-queries and record_sql for transaction
	     * traces.  This is the minimum duration a query must take (in ms) for it
	     * to be considered for for slow query and inclusion in transaction traces.
	     */
	    explain_threshold: 500
	  },
	  /**
	   * Whether to enable internal supportability metrics and diagnostics. You're
	   * welcome to turn these on, but they will probably be most useful to the
	   * New Relic node engineering team.
	   */
	  debug: {
	    /**
	     * Whether to collect and submit internal supportability metrics alongside
	     * application performance metrics.
	     *
	     * @env NEW_RELIC_DEBUG_METRICS
	     */
	    internal_metrics: false,
	    /**
	     * Traces the execution of the transaction tracer. Requires logging.level
	     * to be set to 'trace' to provide any useful output.
	     *
	     * WARNING: The tracer tracing data is likely only to be intelligible to a
	     * small number of people inside New Relic, so you should probably only
	     * enable tracer tracing if asked to by New Relic, because it will affect
	     * performance significantly.
	     *
	     * @env NEW_RELIC_DEBUG_TRACER
	     */
	    tracer_tracing: false
	  },
	  /**
	   * Rules for naming or ignoring transactions.
	   */
	  rules: {
	    /**
	     * A list of rules of the format {pattern: 'pattern', name: 'name'} for
	     * matching incoming request URLs and naming the associated New Relic
	     * transactions. Both pattern and name are required. Additional attributes
	     * are ignored. Patterns may have capture groups (following JavaScript
	     * conventions), and names will use $1-style replacement strings. See
	     * the documentation for addNamingRule for important caveats.
	     *
	     * @env NEW_RELIC_NAMING_RULES
	     */
	    name: [],
	    /**
	     * A list of patterns for matching incoming request URLs to be ignored by
	     * the agent. Patterns may be strings or regular expressions.
	     *
	     * By default, socket.io long-polling is ignored.
	     *
	     * @env NEW_RELIC_IGNORING_RULES
	     */
	    ignore: [
	      '^\/socket\.io\/.*\/xhr-polling/'
	    ]
	  },
	  /**
	   * By default, any transactions that are not affected by other bits of
	   * naming logic (the API, rules, or metric normalization rules) will
	   * have their names set to 'NormalizedUri/*'. Setting this value to
	   * false will set them instead to Uri/path/to/resource. Don't change
	   * this setting unless you understand the implications of New Relic's
	   * metric grouping issues and are confident your application isn't going
	   * to run afoul of them. Your application could end up getting black holed!
	   * Nobody wants that.
	   *
	   * @env NEW_RELIC_ENFORCE_BACKSTOP
	   */
	  enforce_backstop: true,
	  /**
	   * Browser Monitoring
	   *
	   * Browser monitoring lets you correlate transactions between the server and browser
	   * giving you accurate data on how long a page request takes, from request,
	   * through the server response, up until the actual page render completes.
	   */
	  browser_monitoring: {
	
	    /**
	     * Enable browser monitoring header generation.
	     *
	     * This does not auto-instrument, rather it enables the agent to generate headers.
	     * The newrelic module can generate the appropriate <script> header, but you must
	     * inject the header yourself, or use a module that does so.
	     *
	     * Usage:
	     *
	     *     var newrelic = require('newrelic');
	     *
	     *     router.get('/', function (req, res) {
	     *       var header = newrelic.getBrowserTimingHeader();
	     *       res.write(header)
	     *       // write the rest of the page
	     *     });
	     *
	     * This generates the <script>...</script> header necessary for Browser Monitoring
	     * This script must be manually injected into your templates, as high as possible
	     * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.
	     * Otherwise you may hurt IE!
	     *
	     * This method must be called _during_ a transaction, and must be called every
	     * time you want to generate the headers.
	     *
	     * Do *not* reuse the headers between users, or even between requests.
	     *
	     * @env NEW_RELIC_BROWSER_MONITOR_ENABLE
	     */
	    enable: true,
	
	    /**
	     * Request un-minified sources from the server.
	     *
	     * @env NEW_RELIC_BROWSER_MONITOR_DEBUG
	     */
	    debug: false
	  },
	  /**
	   * Transaction Events
	   *
	   * Transaction events are sent to New Relic Insights. This event data
	   * includes transaction timing, transaction name, and any custom parameters.
	   *
	   * Read more here: http://newrelic.com/insights
	   */
	  transaction_events: {
	    /**
	     * If this is disabled, the agent does not collect, nor try to send,
	     * analytic data.
	     */
	    enabled: true,
	
	    /**
	     * The agent will collect all events up to this number per minute. If
	     * there are more than that, a statistical sampling will be collected.
	     */
	    max_samples_per_minute: 10000,
	
	    /**
	     * This is used if the agent is unable to send events to the collector.
	     * The values from the previous harvest cycle will be merged into the next
	     * one with this option as the limit.
	     *
	     * This should be *greater* than max_samples_per_minute or you'll see odd
	     * behavior. You probably want at least double the value, but more is okay
	     * as long as you can handle the memory overhead.
	     */
	    max_samples_stored: 20000
	  },
	
	  /**
	   * Custom Insights Events
	   *
	   * Custom insights events are JSON object that are sent to New Relic
	   * Insights. You can tell the agent to send your custom events via the
	   * `newrelic.recordCustomEvent()` API. These events are sampled once the max
	   * reservoir size is reached. You can tune this setting below.
	   *
	   * Read more here: http://newrelic.com/insights
	   */
	  custom_insights_events: {
	    /**
	     * If this is disabled, the agent does not collect, nor try to send, custom
	     * event data.
	     */
	    enabled: true,
	    /**
	     * The agent will collect all events up to this number per minute. If there
	     * are more than that, a statistical sampling will be collected. Current
	     * this uses a reservoir sampling algorithm.
	     *
	     * By increasing this setting you are both increasing the memory
	     * requirements of the agent as well as increasing the payload to the New
	     * Relic servers. The memory concerns are something you should consider for
	     * your own server's sake. The payload of events is compressed, but if it
	     * grows too large the New Relic servers may reject it.
	     */
	    max_samples_stored: 1000
	  },
	  /**
	   * This is used to configure properties about the user's host name.
	   */
	  process_host: {
	     /**
	     * Configurable display name for hosts
	     *
	     * @env NEW_RELIC_PROCESS_HOST_DISPLAY_NAME
	     */
	    display_name: '',
	    /**
	     * ip address preference when creating hostnames
	     *
	     * @env NEW_RELIC_IPV_PREFERENCE
	     */
	    ipv_preference: '4'
	 },
	
	
	  /**
	   * High Security
	   *
	   * High security mode (v2) is a setting which prevents any sensitive data from
	   * being sent to New Relic. The local setting must match the server setting.
	   * If there is a mismatch the agent will log a message and act as if it is
	   * disabled.
	   *
	   * Attributes of high security mode (when enabled):
	   *  * requires SSL
	   *  * does not allow capturing of http params
	   *  * does not allow custom params
	   *
	   * To read more see: https://docs.newrelic.com/docs/subscriptions/high-security
	   */
	  high_security: false,
	
	  /**
	   * Labels
	   *
	   * An object of label names and values that will be applied to the data sent
	   * from this agent. Both label names and label values have a maximum length of
	   * 255 characters. This object should contain at most 64 labels.
	   */
	  labels: {},
	
	  /**
	   * These options control behavior for slow queries, but do not affect sql
	   * nodes in transaction traces.
	   * slow_sql.enabled enables and disables slow_sql recording
	   * slow_sql.max_samples sets the maximum number of slow query samples that
	   * will be collected in a single harvest cycle.
	   */
	   slow_sql: {
	    enabled: false,
	    max_samples: 10
	  },
	
	  /**
	   * Controls behavior of datastore instance metrics.
	   *
	   * @property {bool} [instance_reporting.enabled=true]
	   *  Enables reporting the host and port/path/id of database servers. Default
	   *  is `true`.
	   *
	   * @property {bool} [database_name_reporting.enabled=true]
	   *  Enables reporting of database/schema names. Default is `true`.
	   */
	  datastore_tracer: {
	    instance_reporting: {enabled: true},
	    database_name_reporting: {enabled: true}
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'parse_sql'})
	var StatementMatcher = __webpack_require__(194)
	var ParsedStatement = __webpack_require__(195)
	var stringifySync = __webpack_require__(14).stringifySync
	
	
	var OPERATIONS = [
	  new StatementMatcher('select', /^\s*select[\S\s]*from[\s\[]+([^\]\s,)(;]*).*/gi),
	  new StatementMatcher('update', /^\s*update\s+([^\s,;]*).*/gi),
	  new StatementMatcher('insert', /^\s*insert(?:\s+ignore)?\s+into\s+([^\s(,;]*).*/gi),
	  new StatementMatcher('delete', /^\s*delete\s+from\s+([^\s,(;]*).*/gi)
	]
	var COMMENT_PATTERN = /\/\\*.*?\\*\//
	
	// This must be called syncronously after the initial db call for backtraces to
	// work correctly
	
	module.exports = function parseSql(type, sql) {
	  // Sometimes we get an object here from MySQL. We have been unable to
	  // reproduce it, so we'll just log what that object is and return a statement
	  // type of `other`.
	  if (typeof sql === 'object' && sql.sql !== undefined) sql = sql.sql
	  if (typeof sql !== 'string') {
	    logger.trace(
	      'parseSQL got an a non-string sql that looks like: %s',
	      stringifySync(sql)
	    )
	    return new ParsedStatement(type, 'other', null, sql)
	  }
	
	  sql = sql.replace(COMMENT_PATTERN, '').trim()
	
	
	  var parsedStatement
	
	  for (var i = 0, l = OPERATIONS.length; i < l; i++) {
	    parsedStatement = OPERATIONS[i].getParsedStatement(type, sql)
	    if (parsedStatement) {
	      return parsedStatement
	    }
	  }
	
	  return new ParsedStatement(type, 'other', null, sql)
	}


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var ParsedStatement = __webpack_require__(195)
	
	
	function StatementMatcher(operation, operationPattern) {
	  this.operation = operation
	  this.operationPattern = operationPattern
	}
	
	StatementMatcher.prototype.getParsedStatement = function getParsedStatement(type, sql) {
	  this.operationPattern.lastIndex = 0
	
	  var match = new RegExp("^\\s*" + this.operation, "ig").test(sql)
	  if (match) {
	    var queryMatch = this.operationPattern.exec(sql)
	    var model = queryMatch ? queryMatch[1] : 'unknown'
	
	    return new ParsedStatement(type, this.operation, model, sql)
	  }
	}
	
	module.exports = StatementMatcher


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var DB = __webpack_require__(59).DB
	var ALL = __webpack_require__(59).ALL
	
	function ParsedStatement(type, operation, model, raw) {
	  this.type = type
	  this.operation = operation
	  this.model = model
	  this.trace = null
	  this.raw = ''
	
	  if (typeof raw === 'string') {
	    this.trace = new Error()
	    this.raw = raw
	  }
	}
	
	ParsedStatement.prototype.recordMetrics = function recordMetrics(segment, scope) {
	  var duration = segment.getDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var transaction = segment.transaction
	  var type = transaction.isWeb() ? DB.WEB : DB.OTHER
	  var thisTypeSlash = this.type + '/'
	  var operation = DB.OPERATION + '/' + thisTypeSlash + this.operation
	
	  // Rollups
	  transaction.measure(operation, null, duration, exclusive)
	  transaction.measure(DB.PREFIX + type, null, duration, exclusive)
	  transaction.measure(DB.PREFIX + thisTypeSlash + type, null, duration, exclusive)
	  transaction.measure(DB.PREFIX + thisTypeSlash + ALL, null, duration, exclusive)
	  transaction.measure(DB.ALL, null, duration, exclusive)
	
	  // If we can parse the SQL statement, create a 'statement' metric, and use it
	  // as the scoped metric for transaction breakdowns. Otherwise, skip the
	  // 'statement' metric and use the 'operation' metric as the scoped metric for
	  // transaction breakdowns.
	  if (this.model) {
	    var model = DB.STATEMENT + '/' + thisTypeSlash + this.model + '/' + this.operation
	    transaction.measure(model, null, duration, exclusive)
	    if (scope) transaction.measure(model, scope, duration, exclusive)
	  } else if (scope) {
	    transaction.measure(operation, scope, duration, exclusive)
	  }
	
	  // This recorder is side-effectful Because we are depending on the recorder
	  // setting the transaction name, recorders must always be run before generating
	  // the final transaction trace
	  segment.name = model || operation
	
	  // Datastore instance metrics.
	  if (segment.parameters.hasOwnProperty('host') &&
	      segment.parameters.hasOwnProperty('port_path_or_id')) {
	    var instanceName = DB.INSTANCE + '/' + thisTypeSlash + segment.parameters.host +
	      '/' + segment.parameters.port_path_or_id
	    transaction.measure(instanceName, null, duration, exclusive)
	  }
	
	  if (this.raw) {
	    transaction.agent.queries.addQuery(
	      segment,
	      this.type.toLowerCase(),
	      this.raw,
	      this.trace
	    )
	  }
	}
	
	module.exports = ParsedStatement


/***/ },
/* 196 */
/***/ function(module, exports) {

	'use strict'
	
	module.exports.extractDatabaseChangeFromUse = extractDatabaseChangeFromUse
	
	function extractDatabaseChangeFromUse(sql) {
	  // The character ranges for this were pulled from
	  // http://dev.mysql.com/doc/refman/5.7/en/identifiers.html
	  var match = /^\s*use[^\w`]+([\w$_\u0080-\uFFFF]+|`[^`]+`)[\s;]*$/i.exec(sql)
	  return match && match[1] || null
	}


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var promInit = __webpack_require__(198)
	
	var BLUEBIRD_SPEC = {
	  name: 'bluebird',
	  constructor: 'Promise',
	  $proto: {
	    then: ['then', 'done', 'spread', 'all', 'asCallback', 'nodeify', 'finally', 'lastly'],
	    catch: ['catch', 'caught', 'error'],
	
	    // _resolveFromResolver is in bluebird 2.x
	    // _execute is in bluebird 3.x
	    executor: ['_execute', '_resolveFromResolver']
	  },
	  $static: {
	    cast: [
	      'resolve', 'fullfilled', 'cast', 'reject', 'rejected', 'fromNode',
	      'fromCallback', 'all'
	    ]
	  }
	}
	
	module.exports = function initialize(agent, bluebird) {
	  promInit(agent, bluebird, BLUEBIRD_SPEC)
	}


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12)
	var util = __webpack_require__(16)
	var shimmer = __webpack_require__(199)
	
	
	/**
	 * @namespace Library.Spec
	 *
	 * @property {string} name
	 *  The name of this promise library.
	 *
	 * @property {?string} constructor
	 *  Optional. The name of the property that is the Promise constructor. Default
	 *  is to use the library itself as the Promise constructor.
	 *
	 * @property {?bool} executor
	 *  Optional. If true, the Promise constructor itself will be wrapped for the
	 *  executor. If false then `_proto`, `_static`, or `_library` must have an
	 *  `executor` field whose value is the name of the executor function. Default
	 *  is false.
	 *
	 * @property {Library.Spec.Mapping} $proto
	 *  The mapping for Promise instance method concepts (i.e. `then`). These are
	 *  mapped on the Promise class' prototype.
	 *
	 * @property {Library.Spec.Mapping} $static
	 *  The mapping for Promise static method concepts (i.e. `all`, `race`). These
	 *  are mapped on the Promise class itself.
	 *
	 * @property {?Library.Spec.Mapping} $library
	 *  The mapping for library-level static method concepts (i.e. `fcall`, `when`).
	 *  These are mapped on the library containing the Promise class. NOTE: in most
	 *  promise implementations, the Promise class is itself the library thus this
	 *  property is unnecessary.
	 */
	
	/**
	 * @namespace Library.Spec.Mapping
	 *
	 * A mapping of promise concepts (i.e. `then`) to this library's implementation
	 * name(s) (i.e. `["then", "chain"]`). Each value can by either a single string
	 * or an array of strings if the concept exists under multiple keys. If any
	 * given concept doesn't exist in this library, it is simply skipped.
	 *
	 * @property {array} $copy
	 *  An array of properties or methods to just directly copy without wrapping.
	 *  This field only matters when `Library.Spec.executor` is `true`.
	 *
	 * @property {string|array} executor
	 *
	 *
	 * @property {string|array} then
	 *
	 *
	 * @property {string|array} all
	 *
	 *
	 * @property {string|array} race
	 *
	 *
	 * @property {string|array} resolve
	 *  Indicates methods to wrap which are resolve factories. This method only
	 *  requires wrapping if the library doesn't use an executor internally to
	 *  implement it.
	 *
	 * @property {string|array} reject
	 *  Indicates methods to wrap which are reject factories. Like `resolve`, this
	 *  method only requires wrapping if the library doesn't use an executor
	 *  internally to implement it.
	 */
	
	/**
	 * Instruments a promise library.
	 *
	 * @param {Agent}         agent   - The New Relic APM agent.
	 * @param {function}      library - The promise library.
	 * @param {?Library.Spec} spec    - Spec for this promise library mapping.
	 */
	module.exports = function initialize(agent, library, spec) {
	  // Wrap library-level methods.
	  wrapStaticMethods(library, spec.name, spec.$library)
	
	  // Wrap prototype methods.
	  var Promise = library[spec.constructor]
	  wrapPrototype(Promise.prototype)
	  wrapStaticMethods(Promise, spec.constructor, spec.$static)
	
	  // See if we are wrapping the class itself.
	  if (spec.executor) {
	    shimmer.wrapMethod(library, spec.name, spec.constructor, wrapPromise)
	  }
	
	  /**
	   * Wraps the Promise constructor as the executor.
	   */
	  function wrapPromise() {
	    // Copy all unwrapped properties over.
	    if (spec.$static && spec.$static.$copy) {
	      spec.$static.$copy.forEach(function copyKeys(key) {
	        if (!wrappedPromise[key]) {
	          wrappedPromise[key] = Promise[key]
	        }
	      })
	    }
	
	    // Inherit to pass `instanceof` checks.
	    util.inherits(wrappedPromise, Promise)
	
	    // Make the wrapper.
	    return wrappedPromise
	    function wrappedPromise(executor) {
	      if (!(this instanceof wrappedPromise)) {
	        return Promise(executor) // eslint-disable-line new-cap
	      }
	
	      if (typeof executor !== 'function') {
	        return new Promise(executor)
	      }
	
	      var context = {
	        promise: null,
	        self: null,
	        args: null
	      }
	
	      var executorName = (executor.name || '<anonymous>')
	      var promise = new Promise(wrapExecutorContext(context))
	      context.promise = promise
	      promise.__NR_segment = _createSegment('Promise ' + executorName)
	
	      try {
	        // Must run after promise is defined so that `__NR_wrapper` can be set.
	        executor.apply(context.self, context.args)
	      } catch (e) {
	        context.args[1](e)
	      }
	
	      // The Promise must be created using the "real" Promise constructor (using
	      // normal Promise.apply(this) method does not work). But the prototype
	      // chain must include the wrappedPromise.prototype, V8's promise
	      // implementation uses promise.constructor to create new Promises for
	      // calls to `then`, `chain` and `catch` which allows these Promises to
	      // also be instrumented.
	      promise.__proto__ = wrappedPromise.prototype  // eslint-disable-line no-proto
	
	      return promise
	    }
	  }
	
	  function wrapPrototype(PromiseProto, name) {
	    // Don't wrap the proto if there is no spec for it.
	    if (!spec.$proto) {
	      return
	    }
	
	    name = name || (spec.constructor + '.prototype')
	
	    // Wrap up instance methods.
	    _safeWrap(PromiseProto, name, spec.$proto.executor, wrapExecutorCaller)
	    _safeWrap(PromiseProto, name, spec.$proto.then, wrapThen)
	    _safeWrap(PromiseProto, name, spec.$proto.catch, wrapCatch)
	  }
	
	  function wrapStaticMethods(lib, name, staticSpec) {
	    // Don't bother with empty specs.
	    if (!staticSpec) {
	      return
	    }
	
	    _safeWrap(lib, name, staticSpec.cast, wrapCast)
	  }
	
	  function wrapExecutorCaller(caller) {
	    return function wrappedExecutorCaller(executor) {
	      if (!(this instanceof Promise)) {
	        return caller.apply(this, arguments)
	      }
	
	      var context = {
	        promise: this,
	        self: null,
	        args: null
	      }
	      if (!this.__NR_segment) {
	        var executorName = executor.name || '<anonymous>'
	        this.__NR_segment = _createSegment('Promise ' + executorName)
	      }
	      var args = [].slice.call(arguments)
	      args[0] = wrapExecutorContext(context, this.__NR_segment)
	      var ret = caller.apply(this, args)
	
	      // Bluebird catches executor errors and auto-rejects when it catches them,
	      // thus we need to do so as well.
	      //
	      // When adding new libraries, make sure to check that they behave the same
	      // way. We may need to enhance the promise spec to handle this variance.
	      try {
	        executor.apply(context.self, context.args)
	      } catch (e) {
	        context.args[1](e)
	      }
	      return ret
	    }
	  }
	
	  /**
	   * Creates a function which will export the context and arguments of its
	   * execution.
	   *
	   * @param {object} context - The object to export the execution context with.
	   *
	   * @return {function} A function which, when executed, will add its context
	   *  and arguments to the `context` parameter.
	   */
	  function wrapExecutorContext(context, segment) {
	    return function contextExporter(resolve, reject) {
	      segment = segment || agent.tracer.segment
	      context.self = this
	      context.args = [].slice.call(arguments)
	      context.args[0] = wrappedResolve
	      context.args[1] = wrappedReject
	
	      // These wrappers create a function that can be passed a function and an
	      // argument to call as a continuation from the resolve or reject.
	      function wrappedResolve(val) {
	        var promise = context.promise
	        if (promise) {
	          linkChain(promise, promise.__NR_segment || segment, true)
	          if (promise.__NR_segment) {
	            promise.__NR_segment.touch()
	          }
	        }
	        return resolve(val)
	      }
	
	      function wrappedReject(val) {
	        var promise = context.promise
	        if (promise) {
	          linkChain(promise, promise.__NR_segment || segment, false)
	          if (promise.__NR_segment) {
	            promise.__NR_segment.touch()
	          }
	        }
	        return reject(val)
	      }
	    }
	  }
	
	  /**
	   * Brings the transaction through a promise to `then`ed continuations.
	   *
	   * @param {Promise}   ctx   The `this` argument for `fn`.
	   * @param {Function}  fn    The handler function
	   * @param {string}    name  The name function that added this link (i.e. then).
	   * @param {Promise}   next  Promise returned from calling `then`
	   * @param {Array}     args  Arguments passed into the `then` handler.
	   * @return {*} The value returned from the `then`ed function.
	   */
	  function linkTransaction(ctx, fn, name, next, args) {
	    if (!next) {
	      return fn.apply(ctx, args)
	    }
	
	    // next needs to have a wrapper function even if the callback throws.
	    try {
	      if (!next.__NR_segment) {
	        var segmentName = 'Promise#' + name + ' ' + (fn.name || '<anonymous>')
	        next.__NR_segment = _createSegment(segmentName)
	      }
	      var segment = next.__NR_segment
	      var result = agent.tracer.bindFunction(fn, segment, true).apply(ctx, args)
	    } finally {
	      if (result instanceof Promise && result !== next) {
	        linkChain(next, segment, null, function proxyWrapper() {
	          if (segment) {
	            segment.touch()
	          }
	          var link = result.__NR_wrapper
	          if (!link) {
	            link = agent.tracer.bindFunction(linkTransaction, segment, true)
	          }
	          return link.apply(this, arguments)
	        })
	      } else {
	        // If we have a result, we know we didn't reject and can bound linking
	        // to just the next resolve handler.
	        //                                          resolved : unknown
	        linkChain(next, segment, result !== undefined ? true : null)
	      }
	    }
	    return result
	  }
	
	  /**
	   * If the promise isn't already bound, this will bind it to the given segment.
	   *
	   * @param {Promise}       promise - The promise to link with the segment.
	   * @param {TraceSegment}  segment - The segment to link the promise with.
	   */
	  function bindLink(promise, segment) {
	    if (!promise.__NR_wrapper) {
	      promise.__NR_wrapper = agent.tracer.bindFunction(linkTransaction, segment, true)
	    }
	  }
	
	  /**
	   * Walks the promise chain, linking each one to the given segment.
	   *
	   * @param {Promise} promise
	   *  The first promise in the chain to link with the segment.
	   *
	   * @param {TraceSegment} segment
	   *  The segment to link the chain with.
	   *
	   * @param {?bool} [resolved]
	   *  Flag indicating if we only need to wrap down to the next resolve handler.
	   *  If true, linking will stop after the first resolve handler is found.
	   *
	   * @param {Function} [wrapper]
	   *  The wrapper to use for the linking. If not provided then `linkTransaction`
	   *  will be used as the wrapper.
	   */
	  function linkChain(promise, segment, resolved, wrapper) {
	    if (!wrapper) {
	      wrapper = agent.tracer.bindFunction(linkTransaction, segment, true)
	    }
	
	    var next = promise
	    while (next instanceof Promise) {
	      _tryAssignWrapper(next, wrapper)
	
	      // If we resolved and this is the resolve handler, stop linking here.
	      if (resolved && next.__NR_resolveHandler) {
	        break
	      }
	
	      // Unfortunately we can't preemptively stop for reject since some Promise
	      // libraries support long jumps on rejection according to error class.
	      // Thanks bluebird!
	
	      // Break when there is an infinite loop.
	      if (next.__NR_nextPromise === next) {
	        break
	      }
	      next = next.__NR_nextPromise
	    }
	  }
	
	  /**
	   * Creates a wrapper for `Promise#then` that extends the transaction context.
	   *
	   * @return {function} A wrapped version of `Promise#then`.
	   */
	  function wrapThen(then, name) {
	    return _wrapThen(then, name, true)
	  }
	
	  /**
	   * Creates a wrapper for `Promise#catch` that extends the transaction context.
	   *
	   * @return {function} A wrapped version of `Promise#catch`.
	   */
	  function wrapCatch(cach, name) {
	    return _wrapThen(cach, name, false)
	  }
	
	  /**
	   * Creates a wrapper for promise chain extending methods.
	   *
	   * @param {function} then
	   *  The function we are to wrap as a chain extender.
	   *
	   * @param {bool} useAllParams
	   *  When true, all parameters which are functions will be wrapped. Otherwise,
	   *  only the last parameter will be wrapped.
	   *
	   * @return {function} A wrapped version of the function.
	   */
	  function _wrapThen(then, name, useAllParams) {
	    // Don't wrap non-functions.
	    if (!(then instanceof Function) || then.name === '__NR_wrappedThen') {
	      return then
	    }
	
	    return function __NR_wrappedThen() {
	      if (!(this instanceof Promise)) {
	        return then.apply(this, arguments)
	      }
	
	      var thenSegment = agent.tracer.getSegment()
	      var promise = this
	
	      // Wrap up the arguments and execute the real then.
	      var hasResolve = false
	      var args = [].map.call(arguments, wrapHandler)
	      var next = then.apply(this, args)
	
	      // Make sure we got a promise and then return it.
	      if (next instanceof Promise && next !== promise) {
	        promise.__NR_resolveHandler = hasResolve
	        promise.__NR_nextPromise = next
	      }
	      return next
	
	      // Wrap callbacks (success, error) so that the callbacks will be called as
	      // a continuations of the accept or reject call using the __asl__wrapper
	      // created above.
	      function wrapHandler(fn, i, arr) {
	        if (
	          !(fn instanceof Function) ||              // Not a function
	          fn.name === '__NR_wrappedThenHandler' ||  // Already wrapped
	          (!useAllParams && i !== (arr.length - 1)) // Don't want all and not last
	        ) {
	          return fn
	        }
	
	        hasResolve = (hasResolve || (i === 0))
	
	        return function __NR_wrappedThenHandler() {
	          // Even though success/error handlers should have just one argument
	          // (value or error), internal implementations could be passing in more
	          // arguments.
	          if (!promise.__NR_wrapper) {
	            // The currently running segment is the least likely to be the
	            // correct one when working with Bluebird due to the way it queues
	            // all promise resolutions and executes them all at once.
	            //
	            // An option may be to prioritize the current segment, but compare
	            // its transaction ID to the transaction ID of the `thenSegment`. If
	            // they are the same, use the current segment, otherwise use the
	            // `thenSegment`. I'd prefer to wait for the simpler method to be
	            // proven invalid.
	            var segment =
	              promise.__NR_segment || thenSegment || agent.tracer.getSegment()
	            if (segment) {
	              bindLink(promise, segment)
	            } else {
	              return fn.apply(this, arguments)
	            }
	          }
	
	          // invoke linkTransaction()
	          return promise.__NR_wrapper(this, fn, name, next, arguments, promise)
	        }
	      }
	    }
	  }
	
	  /**
	   * Creates a wrapper around the static `Promise` factory method.
	   */
	  function wrapCast(cast, name) {
	    if (!(cast instanceof Function) || cast.name === '__NR_wrappedCast') {
	      return cast
	    }
	
	    var CAST_SEGMENT_NAME = 'Promise.' + name
	    return function __NR_wrappedCast() {
	      var segment = _createSegment(CAST_SEGMENT_NAME)
	      var prom = cast.apply(this, arguments)
	      if (segment) {
	        bindLink(prom, segment)
	      }
	      return prom
	    }
	  }
	
	  function _createSegment(name, parent) {
	    return agent.config.feature_flag.promise_segments === true
	      ? agent.tracer.createSegment(name, null, parent)
	      : (parent || agent.tracer.getSegment())
	  }
	}
	
	/**
	 * Performs a `wrapMethod` if and only if `methods` is truthy and has a length
	 * greater than zero.
	 *
	 * @param {object}        obj     - The source of the methods to wrap.
	 * @param {string}        name    - The name of this source.
	 * @param {string|array}  methods - The names of the methods to wrap.
	 * @param {function}      wrapper - The function which wraps the methods.
	 */
	function _safeWrap(obj, name, methods, wrapper) {
	  if (methods && methods.length) {
	    shimmer.wrapMethod(obj, name, methods, wrapper)
	  }
	}
	
	/**
	 * Attempts to add the given wrapper to the promise.
	 *
	 * This can fail if `prom` has been sealed.
	 */
	function _tryAssignWrapper(prom, wrapper) {
	  try {
	    prom.__NR_wrapper = wrapper
	  } catch (err) {
	    logger.info({err: err}, 'Failed to add wrapper to promise')
	  }
	}


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname, global) {'use strict'
	
	var path = __webpack_require__(58)
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var logger = __webpack_require__(12).child({component: 'shimmer'})
	var INSTRUMENTATION = __webpack_require__(181)()
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	
	var CORE_INSTRUMENTATION = {
	  child_process: 'child_process.js',
	  crypto: 'crypto.js',
	  domain: 'domain.js',
	  dns: 'dns.js',
	  fs: 'fs.js',
	  http: 'http.js',
	  https: 'http.js',
	  net: 'net.js',
	  timers: 'timers.js',
	  zlib: 'zlib.js'
	}
	
	/**
	 * Unwrapping is only likely to be used by test code, and is a fairly drastic
	 * maneuver, but it should be pretty safe if there's a desire to reboot the
	 * agent in flight.
	 *
	 * All of the wrapped methods are tracked in this variable and used by unwrapAll
	 * below.
	 */
	var instrumented = []
	
	/**
	 * All instrumentation files must export the same interface: a single
	 * initialization function that takes the agent and the module to be
	 * instrumented.
	 */
	function instrument(agent, shortName, fileName, nodule, moduleName) {
	  var fullPath = path.resolve(fileName)
	  if (!fs.existsSync(fileName)) {
	    return logger.warn(
	      'Tried to load instrumentation from %s, but file does not exist',
	      fullPath
	    )
	  }
	  try {
	    __webpack_require__(92)(fileName)(agent, nodule, moduleName)
	  } catch (error) {
	    logger.warn(
	      error,
	      'Failed to instrument module %s using %s',
	      path.basename(shortName, '.js'),
	      fullPath
	    )
	  }
	}
	
	function _postLoad(agent, nodule, name) {
	  var instrumentation
	  var base = path.basename(name)
	
	  // to allow for instrumenting both 'pg' and 'pg.js'.
	  if (name === 'pg.js') {
	    instrumentation = 'pg'
	  } if (name === 'mysql2') {
	    // mysql2 (https://github.com/sidorares/node-mysql2) is a drop in replacement for
	    // mysql which conforms to the existing mysql API. If we see mysql2, treat it as
	    // mysql
	    instrumentation = 'mysql'
	  } else {
	    instrumentation = base
	  }
	
	  // necessary to prevent instrument() from causing an infinite loop
	  if (INSTRUMENTATION.indexOf(instrumentation) !== -1) {
	    logger.trace('Instrumenting %s.', base)
	    var filename = path.join(__dirname, 'instrumentation', instrumentation + '.js')
	    instrument(agent, base, filename, nodule)
	  }
	
	  return nodule
	}
	
	var shimmer = module.exports = {
	  /**
	   * If debug isn't false, the agent will retain references to wrapped methods
	   * for the entire lifetime of the agent. Some instrumentation depends on
	   * wrapping functions on individual objects, and this will cause the agent
	   * to retain references to a large number of dead objects.
	   */
	  debug: false,
	
	  /**
	   * Detects if the given function has already been wrapped.
	   *
	   * @param {function} fn - The function to look for a wrapper on.
	   *
	   * @return {bool} True if `fn` exists and has an attached original, else false.
	   */
	  isWrapped: function isWrapped(fn) {
	    return !!(fn && fn.__NR_original)
	  },
	
	  /**
	   * Don't throw, but do log and bail out if wrapping fails.
	   *
	   * Provide an escape hatch by creating a closure around the original method
	   * and object / module wrapped into a helper function that will restore the
	   * original function / method. See Sinon for a systematic use of this
	   * pattern.
	   *
	   * @param {object} nodule Class or module containing the function to wrap.
	   * @param {object} noduleName Human-readable module / Class name. More
	   *                            helpful than you'd think.
	   * @param {string} methods One or more names of methods or functions to extract
	   *                         and wrap.
	   * @param {function} wrapper A generator that, when called, returns a
	   *                           wrapped version of the original function.
	   */
	  wrapMethod: function wrapMethod(nodule, noduleName, methods, wrapper) {
	    if (!methods) {
	      return logger.warn(new Error(),
	                         "Must include a method name to wrap. Called from:")
	    }
	
	    if (!noduleName) noduleName = '[unknown]'
	    if (!Array.isArray(methods)) methods = [methods]
	
	    methods.forEach(function cb_forEach(method) {
	      var fqmn = noduleName + '.' + method
	
	      if (!nodule) return logger.debug("Can't wrap %s from nonexistent object.",
	                                       fqmn)
	      if (!wrapper) return logger.debug("Can't wrap %s without a wrapper generator.",
	                                        fqmn)
	
	      var original = nodule[method]
	
	      if (!original) return logger.trace("%s not defined, so not wrapping.", fqmn)
	      if (original.__NR_unwrap) return logger.debug("%s already wrapped by agent.", fqmn)
	
	      var wrapped = wrapper(original, method)
	      wrapped.__NR_original = original
	      wrapped.__NR_unwrap = function __NR_unwrap() {
	        nodule[method] = original
	        logger.trace("Removed instrumentation from %s.", fqmn)
	      }
	
	      nodule[method] = wrapped
	      if (shimmer.debug) instrumented.push(wrapped)
	      logger.trace("Instrumented %s.", fqmn)
	    })
	  },
	
	  /**
	   * Sometimes you gotta do some crazy stuff to get the job done. Instead of using
	   * regular monkeypatching, wrapDeprecated allows you to pass in a getter and setter
	   * and then uses defineProperty to replace the original property with an
	   * accessor. Note that responsibility for unwrapping is not handled by this
	   * function.
	   *
	   * @param {object}   nodule     Class or module containing the property to
	   *                              wrap.
	   * @param {object}   noduleName Human-readable module / Class name. More
	   *                              helpful than you'd think.
	   * @param {string}   property   The property to replace with the accessor.
	   * @param {function} options    Optional getter and setter to use for the accessor.
	   *
	   * @returns {object} The original value of the property.
	   */
	  wrapDeprecated: function wrapDeprecated(nodule, noduleName, property, options) {
	    if (!property) {
	      logger.warn(new Error(), "Must include a function name to wrap. Called from:")
	      return
	    }
	
	    if (!noduleName) noduleName = '[unknown]'
	
	    var fqmn = noduleName + '.' + property
	    if (!nodule) {
	      logger.debug("Can't wrap %s from nonexistent object.", fqmn)
	      return
	    }
	
	    var original = nodule[property]
	    if (!original) {
	      logger.trace("%s not defined, so not wrapping.", fqmn)
	      return
	    }
	
	    delete nodule[property]
	
	    var descriptor = {
	      configurable: true,
	      enumerable: true
	    }
	    if (options.get) descriptor.get = options.get
	    if (options.set) descriptor.set = options.set
	    Object.defineProperty(nodule, property, descriptor)
	    logger.trace("Instrumented %s.", fqmn)
	
	    if (shimmer.debug) {
	      instrumented.push({
	        __NR_unwrap: function unwrapDeprecated() {
	          delete nodule[property]
	          nodule[property] = original
	        }
	      })
	    }
	
	    return original
	  },
	
	  unwrapMethod: function unwrapMethod(nodule, noduleName, method) {
	    if (!noduleName) noduleName = '[unknown]'
	    if (!method) return logger.debug("Must include a method name to unwrap. " +
	                                     "Called from: %s", new Error().stack)
	
	    var fqmn = noduleName + '.' + method
	
	    if (!nodule) return logger.debug("Can't unwrap %s from nonexistent object.",
	                                     fqmn)
	    var wrapped = nodule[method]
	
	    // keep instrumented up to date
	    var pos = instrumented.indexOf(wrapped)
	    if (pos !== -1) instrumented.splice(pos, 1)
	
	    if (!wrapped) return logger.debug("%s not defined, so not unwrapping.", fqmn)
	    if (!wrapped.__NR_unwrap) return logger.debug("%s isn't unwrappable.", fqmn)
	
	    wrapped.__NR_unwrap()
	  },
	
	  unwrapAll: function unwrapAll() {
	    instrumented.forEach(function cb_forEach(wrapper) {
	      wrapper.__NR_unwrap()
	    })
	    instrumented = []
	  },
	
	  /**
	   * Patch the module.load function so that we see modules loading and
	   * have an opportunity to patch them with instrumentation.
	   */
	  patchModule: function patchModule(agent) {
	    logger.trace("Wrapping module loader.")
	    var Module = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"module\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	    shimmer.wrapMethod(Module, 'Module', '_load', function cb_wrapMethod(load) {
	      return function cls_wrapMethod(file) {
	        return _postLoad(agent, load.apply(this, arguments), file)
	      }
	    })
	  },
	
	  unpatchModule: function unpatchModule() {
	    logger.trace("Unwrapping to previous module loader.")
	    var Module = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"module\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	    shimmer.unwrapMethod(Module, 'Module', '_load')
	  },
	
	  bootstrapInstrumentation: function bootstrapInstrumentation(agent) {
	    var globalsFilepath = path.join(__dirname, 'instrumentation', 'core', 'globals.js')
	    instrument(agent, 'globals', globalsFilepath, global)
	
	    Object.keys(CORE_INSTRUMENTATION).forEach(function cb_forEach(mojule) {
	      var filename = CORE_INSTRUMENTATION[mojule]
	      var filepath = path.join(__dirname, 'instrumentation/core', filename)
	      var uninstrumented
	
	      try {
	        uninstrumented = __webpack_require__(92)(mojule)
	      } catch (err) {
	        logger.trace(
	          'Could not load core module %s got error %s',
	          mojule,
	          err
	        )
	      }
	
	      instrument(agent, filename, filepath, uninstrumented, mojule)
	    })
	  },
	
	  /**
	   * NOT FOR USE IN PRODUCTION CODE
	   *
	   * If an instrumented module has a dependency on another instrumented module,
	   * and multiple tests are being run in a single test suite with their own
	   * setup and teardown between tests, it's possible transitive dependencies
	   * will be unwrapped in the module cache in-place (which needs to happen to
	   * prevent stale closures from channeling instrumentation data to incorrect
	   * agents, but which means the transitive dependencies won't get re-wrapped
	   * the next time the parent module is required).
	   *
	   * Since this only applies in test code, it's not worth the drastic
	   * monkeypatching to Module necessary to walk the list of child modules and
	   * re-wrap them.
	   *
	   * Use this to re-apply any applicable instrumentation.
	   */
	  reinstrument: function reinstrument(agent, modulePath) {
	    return _postLoad(agent, __webpack_require__(92)(modulePath), modulePath)
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/", (function() { return this; }())))

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var shimmer = __webpack_require__(199)
	var CASSANDRA = __webpack_require__(59).CASSANDRA
	var parseSql = __webpack_require__(193)
	
	module.exports = function initialize(agent, cassandra) {
	  var tracer = agent.tracer
	  var proto = cassandra.Client.prototype
	
	  shimmer.wrapMethod(proto, 'Cassandra.Client.prototype', ['_innerExecute'], wrapExec)
	  shimmer.wrapMethod(proto, 'Cassandra.Client.prototype', ['batch'], wrapBatch)
	
	  shimmer.wrapMethod(
	    proto,
	    'Cassandra.Client.prototype',
	    ['connect'],
	    tracer.wrapFunctionLast.bind(tracer, CASSANDRA.OPERATION + '/connect', null)
	  )
	
	  shimmer.wrapMethod(
	    proto,
	    'Cassandra.Client.prototype',
	    ['shutdown'],
	    tracer.wrapFunctionLast.bind(tracer, CASSANDRA.OPERATION + '/shutdown', null)
	  )
	
	  function wrapExec(original) {
	    return tracer.wrapFunction(
	      CASSANDRA.STATEMENT + 'Unknown',
	      null,
	      original,
	      wrappedExec
	    )
	
	    function wrappedExec(segment, args, bind) {
	      var ps = parseSql(CASSANDRA.PREFIX, args[0])
	
	      var model = (ps.model || 'unknown')
	      if (this.keyspace && model.indexOf('.') === -1) model = this.keyspace + '.' + model
	      segment.name = CASSANDRA.STATEMENT + model + '/' + ps.operation
	
	      segment.transaction.addRecorder(ps.recordMetrics.bind(ps, segment))
	      var last = args.length - 1
	      args[last] = bind(args[last])
	      return args
	    }
	  }
	
	  function wrapBatch(original) {
	    return tracer.wrapFunction(
	      CASSANDRA.STATEMENT + 'Unknown',
	      null,
	      original,
	      wrappedBatch
	    )
	
	    function wrappedBatch(segment, args, bind) {
	      var sql = (args[0] && args[0][0]) || ''
	      if (sql.query) sql = sql.query
	      var ps = parseSql(CASSANDRA.PREFIX, sql)
	
	      var model = (ps.model || 'unknown')
	      if (this.keyspace && model.indexOf('.') === -1) model = this.keyspace + '.' + model
	      segment.name = CASSANDRA.STATEMENT + model + '/' + ps.operation + '/batch'
	
	      segment.transaction.addRecorder(ps.recordMetrics.bind(ps, segment))
	      var last = args.length - 1
	      args[last] = bind(args[last])
	      return args
	    }
	  }
	}


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var shimmer = __webpack_require__(199)
	var logger = __webpack_require__(12).child({component: 'connect'})
	
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	
	var ORIGINAL = '__NR_original'
	var RESERVED = [ // http://es5.github.io/#x7.6.1.2
	  // always (how would these even get here?)
	  'class', 'enum', 'extends', 'super', 'const', 'export', 'import',
	  // strict
	  'implements', 'let', 'private', 'public', 'yield', 'interface',
	  'package', 'protected', 'static'
	]
	
	/**
	 * ES5 strict mode disallows some identifiers that are allowed in non-strict
	 * code. Mangle function names that are on that list of keywords so they're
	 * non-objectionable in strict mode (which is currently enabled everywhere
	 * inside the agent, as well as at many customer sites).
	 *
	 * If you really need to crawl your Express apps middleware stack, change
	 * your test to use name.indexOf('whatever') === 0 as the predicate instead
	 * of name === 'whatever'. It's a little slower, but you shouldn't be doing
	 * that anyway.
	 *
	 * @param {string} name The candidate function name
	 *
	 * @returns {string} A safe (potentially mangled) function name.
	 */
	function mangle(name) {
	  var parts = name.split(' ')
	  name = parts[parts.length - 1]
	
	  if (RESERVED.indexOf(name) !== -1) return name + '_'
	
	  return name
	}
	
	module.exports = function initialize(agent, connect) {
	  var tracer = agent.tracer
	
	  var interceptor = {
	    route: '',
	    handle: function sentinel(error, req, res, next) {
	      if (error) {
	        var transaction = agent.tracer.getTransaction()
	        agent.errors.add(transaction, error)
	      }
	
	      return next(error)
	    }
	  }
	
	  /**
	   * Problem:
	   *
	   * 1. Connect determines whether middleware functions are error handlers by
	   *    testing their arity. Not cool.
	   * 2. Downstream Express users rely upon being able to iterate over their
	   *    middleware stack to find specific middleware functions. Sorta less
	   *    uncool, but still a pain.
	   *
	   * Solution:
	   *
	   * Use eval. This once. For this one specific purpose. Not anywhere else for
	   * any reason.
	   */
	  function wrapHandle(__NR_handle) {
	    // jshint -W061
	    var arglist
	    var name = ''
	
	
	    // reiterated: testing function arity is stupid
	    switch (__NR_handle.length) {
	      case 2:
	        arglist = '(req, res)'
	        break
	
	      case 3:
	        arglist = '(req, res, next)'
	        break
	
	      // don't break other error handlers
	      case 4:
	        arglist = '(err, req, res, next)'
	        break
	
	      default:
	        arglist = '()'
	    }
	
	    if (__NR_handle.name) name = mangle(__NR_handle.name)
	
	    // leave this function anonymous
	    // it's connect madness
	    /* eslint-disable func-names */
	    var template = function() {
	      var args = tracer.slice(arguments)
	      var last = args.length - 1
	
	
	      if (typeof args[last] === 'function') {
	        args[last] = tracer.bindFunction(args[last])
	      }
	
	      __NR_handle.apply(this, args)
	    }
	    /* eslint-enable func-names */
	
	    // I am a bad person and this makes me feel bad.
	    // We use eval because we need to insert the function with a specific name to
	    // allow for lookup.
	    /* eslint-disable no-eval */
	    var wrapped = eval(
	      '(function(){return function ' + name + arglist +
	      template.toString().substring(11) + '}())'
	    )
	    /* eslint-enable no-eval */
	    wrapped[ORIGINAL] = __NR_handle
	
	    return wrapped
	  }
	
	  function wrapUse(use) {
	    return function cls_wrapUse() {
	      if (!this.stack) return use.apply(this, arguments)
	
	      this.stack = this.stack.filter(function cb_filter(m) {
	        return m !== interceptor
	      })
	
	      /* We allow `use` to go through the arguments so it can reject bad things
	       * for us so we don't have to also do argument type checking.
	       */
	      var app = use.apply(this, arguments)
	
	      // wrap most recently added unwrapped handler
	      var top = this.stack.pop()
	      if (top) {
	          if (top.handle &&
	              typeof top.handle === 'function' &&
	              !top.handle[ORIGINAL]) {
	            top.handle = wrapHandle(top.handle)
	          }
	          this.stack.push(top)
	      }
	
	      /* Give the error tracer a better chance of intercepting errors by
	       * putting it before the first error handler (a middleware that takes 4
	       * parameters, in Connects world). Error handlers tend to be placed
	       * towards the end of the middleware chain and sometimes don't pass
	       * errors along. Don't just put the interceptor at the beginning because
	       * we want to allow as many middleware functions to execute as possible
	       * before the interceptor is run, to increase error coverage.
	       *
	       * NOTE: This is heuristic, and works because interceptor propagates
	       *       errors instead of terminating the middleware chain.
	       *       Ignores routes.
	       */
	      var spliced = false
	      for (var i = 0; i < this.stack.length; i++) {
	        var middleware = this.stack[i]
	        // Check to see if it is an error handler middleware
	        if (middleware &&
	            middleware.handle &&
	            middleware.handle.length === 4) {
	          this.stack.splice(i, 0, interceptor)
	          spliced = true
	          break
	        }
	      }
	      if (!spliced) this.stack.push(interceptor)
	
	      // don't break chaining
	      return app
	    }
	  }
	
	  /**
	   * Connect 1 and 2 are very different animals, but like Express, it mostly
	   * comes down to factoring.
	   */
	  var version = connect && connect.version && connect.version[0]
	  switch (version) {
	    case '1':
	      shimmer.wrapMethod(connect && connect.HTTPServer && connect.HTTPServer.prototype,
	                         'connect.HTTPServer.prototype',
	                         'use',
	                         wrapUse)
	      break
	
	    case '2':
	      shimmer.wrapMethod(connect && connect.proto,
	                         'connect.proto',
	                         'use',
	                         wrapUse)
	      break
	
	    default:
	      logger.debug("Unrecognized version %s of Connect detected; not instrumenting.",
	                   version)
	  }
	}


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var wrap = __webpack_require__(199).wrapMethod
	
	module.exports = initialize
	
	function initialize(agent, childProcess) {
	  var methods = ['exec', 'execFile']
	
	  wrap(childProcess, 'childProcess', methods, wrapMethod)
	
	  function wrapMethod(fn, method) {
	    return agent.tracer.wrapFunctionLast('child_process.' + method, null, fn)
	  }
	}


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var wrap = __webpack_require__(199).wrapMethod
	
	module.exports = initialize
	
	function initialize(agent, crypto) {
	  wrap(crypto, 'crypto', ['pbkdf2', 'randomBytes', 'pseudoRandomBytes'], wrapCryptoMethod)
	
	  function wrapCryptoMethod(fn, method) {
	    return agent.tracer.wrapFunctionLast('crypto.' + method, null, wrappedCrypto)
	
	    function wrappedCrypto() {
	      return fn.apply(this, arguments)
	    }
	  }
	}


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var wrap = __webpack_require__(199).wrapMethod
	
	module.exports = initialize
	
	function initialize(agent, dns) {
	  var methods = [
	    'lookup',
	    'resolve',
	    'resolve4',
	    'resolve6',
	    'resolveCname',
	    'resolveMx',
	    'resolveNaptr',
	    'resolveNs',
	    'resolvePtr',
	    'resolveSrv',
	    'resolveTxt',
	    'reverse'
	  ]
	
	  wrap(dns, 'dns', methods, wrapDns)
	
	  function wrapDns(fn, method) {
	    return agent.tracer.wrapFunctionLast('dns.' + method, null, fn)
	  }
	}


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var wrap = __webpack_require__(199).wrapMethod
	
	module.exports = initialize
	
	function initialize(agent, domain) {
	  var proto = domain.Domain.prototype
	  wrap(
	    proto,
	    'domain.Domain.prototype',
	    'emit',
	    wrapEmit
	  )
	
	  function wrapEmit(original) {
	    return function wrappedEmit(ev) {
	      var shouldRestoreContext = ev === 'error' &&
	          agent.tracer.segment === null &&
	          this.__NR_transactionSegment
	
	      if (shouldRestoreContext) {
	        agent.tracer.segment = this.__NR_transactionSegment
	      }
	
	      var result = original.apply(this, arguments)
	
	      if (shouldRestoreContext) {
	        agent.tracer.segment = null
	        this.__NR_transactionSegment = null
	      }
	
	      return result
	    }
	  }
	}


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var record = __webpack_require__(207)
	var NAMES = __webpack_require__(59)
	var wrap = __webpack_require__(199).wrapMethod
	
	module.exports = initialize
	
	function initialize(agent, fs) {
	  var methods = [
	    'rename',
	    'truncate',
	    'chown',
	    'lchown',
	    'fchown',
	    'chmod',
	    'lchmod',
	    'fchmod',
	    'stat',
	    'lstat',
	    'fstat',
	    'link',
	    'symlink',
	    'readlink',
	    'realpath',
	    'unlink',
	    'rmdir',
	    'mkdir',
	    'mkdtemp',
	    'readdir',
	    'close',
	    'open',
	    'utimes',
	    'futimes',
	    'fsync',
	    'readFile',
	    'writeFile',
	    'appendFile',
	    'exists',
	    'ftruncate'
	  ]
	
	  var uninstrumented = [
	    'write',
	    'read'
	  ]
	
	  wrap(fs, 'fs', methods, segment)
	  wrap(fs, 'fs', uninstrumented, agent.tracer.wrapFunctionNoSegment.bind(agent.tracer))
	  wrap(fs, 'fs', ['watch'], wrapWatch)
	  wrap(fs, 'fs', ['watchFile'], wrapWatchFile)
	
	  function segment(fn, method) {
	    return agent.tracer.wrapFunctionLast(NAMES.FS.PREFIX + method, record, fn)
	  }
	
	  function wrapWatch(fn) {
	    return function wrappedWatch() {
	      var args = agent.tracer.slice(arguments)
	      var last = args.length - 1
	
	      if (typeof args[last] === 'function') {
	        var cb = args[last]
	        args[last] = agent.tracer.bindFunction(cb)
	      }
	
	      return agent.tracer.bindEmitter(fn.apply(this, args))
	    }
	  }
	
	  function wrapWatchFile(fn) {
	    return function wrappedWatchFile() {
	      var args = agent.tracer.slice(arguments)
	      var last = args.length - 1
	
	      if (typeof args[last] === 'function') {
	        var cb = args[last]
	        args[last] = agent.tracer.bindFunction(cb)
	        // allow unwatchFile to work despite cb being wrapped
	        args[last].listener = cb
	      }
	
	      return fn.apply(this, args)
	    }
	  }
	}


/***/ },
/* 207 */
/***/ function(module, exports) {

	'use strict'
	
	function record(segment, scope) {
	  var duration = segment.getDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var transaction = segment.transaction
	
	
	  if (scope) transaction.measure(segment.name, scope, duration, exclusive)
	
	  transaction.measure(segment.name, null, duration, exclusive)
	}
	
	module.exports = record


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict'
	
	var events = __webpack_require__(26)
	var wrap = __webpack_require__(199).wrapMethod
	var promInit = __webpack_require__(198)
	
	module.exports = initialize
	
	/**
	 * The spec for the native `Promise` class.
	 */
	var STATIC_PROMISE_METHODS = ['accept', 'all', 'defer', 'race', 'reject', 'resolve']
	var NATIVE_PROMISE_SPEC = {
	  name: 'global',
	  constructor: 'Promise',
	  executor: true,
	  $proto: {
	    then: ['then', 'chain'],
	    catch: ['catch']
	  },
	  $static: {
	    $copy: STATIC_PROMISE_METHODS,
	    cast: STATIC_PROMISE_METHODS
	  }
	}
	
	function initialize(agent) {
	  // Add handler for uncaught/fatal exceptions to record them.
	  // _fatalException is an undocumented feature of domains, introduced in
	  // Node.js v0.8. We use _fatalException when possible because wrapping it will
	  // not potentially change the behavior of the server.
	  if (process._fatalException) {
	    wrap(process, 'process', '_fatalException', function wrapper(original) {
	      return function wrappedFatalException(error) {
	        // Only record the error if we are not currently within an instrumented
	        // domain.
	        if (!process.domain) {
	          agent.errors.add(null, error)
	          agent.tracer.segment = null
	        }
	        return original.apply(this, arguments)
	      }
	    })
	  } else {
	    wrap(
	      process,
	      'process',
	      'emit',
	      function wrapEmit(original) {
	        return function wrappedEmit(ev, error) {
	          if (ev === 'uncaughtException' && error && !process.domain) {
	            agent.errors.add(null, error)
	            agent.tracer.segment = null
	          }
	
	          return original.apply(this, arguments)
	        }
	      }
	    )
	  }
	
	  // Add a handler for unhandled promise rejections.
	  process.on('unhandledRejection', function __NR_unhandledRejectionHandler(err, promise) {
	    // If we're the only listener for this event, report the error.
	    if (listenerCount(process, 'unhandledRejection') < 2) {
	      var transaction = promise.__NR_segment && promise.__NR_segment.transaction
	      agent.errors.add(transaction, err)
	    }
	  })
	
	  promInit(agent, global, NATIVE_PROMISE_SPEC)
	}
	
	function listenerCount(emitter, evnt) {
	  if (events.EventEmitter.listenerCount) {
	    return events.EventEmitter.listenerCount(emitter, evnt)
	  }
	  return emitter.listeners(evnt).length
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), (function() { return this; }())))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var shimmer = __webpack_require__(199)
	var logger = __webpack_require__(12).child({component: 'http'})
	var recordWeb = __webpack_require__(210)
	var hashes = __webpack_require__(62)
	var cat = __webpack_require__(211)
	var instrumentOutbound = __webpack_require__(212)
	var util = __webpack_require__(16)
	var url = __webpack_require__(108)
	var semver = __webpack_require__(214)
	
	var NAMES = __webpack_require__(59)
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var NR_CONNECTION_PROP = '__NR__connection'
	var DEFAULT_HOST = 'localhost'
	var DEFAULT_PORT = 80
	var REQUEST_HEADER = 'x-request-start'
	var QUEUE_HEADER = 'x-queue-start'
	var NEWRELIC_ID_HEADER = 'x-newrelic-id'
	var NEWRELIC_APP_DATA_HEADER = 'x-newrelic-app-data'
	var NEWRELIC_TRANSACTION_HEADER = 'x-newrelic-transaction'
	var NEWRELIC_SYNTHETICS_HEADER = 'x-newrelic-synthetics'
	var CONTENT_LENGTH_REGEX = /^Content-Length$/i
	
	
	// For incoming requests this instrumentation functions by wrapping
	// `http.createServer` and `http.Server#addListener`. The former merely sets the
	// agent dispatcher to 'http' and the latter wraps any event handlers bound to
	// `request`.
	//
	// The `request` event listener wrapper creates a transaction proxy which will
	// start a new transaction whenever a new request comes in. It also scans the
	// headers of the incoming request looking for CAT and synthetics headers.
	
	function wrapListener(agent, listener) {
	  if (!listener) {
	    logger.debug('No request listener defined, not wrapping.')
	    return listener
	  }
	
	  var tracer = agent.tracer
	  var serverPort = null
	
	  return tracer.transactionProxy(function wrappedHandler(request, response) {
	    var transaction = tracer.getTransaction()
	    if (!transaction) return listener.apply(this, arguments)
	
	    transaction.nameState.setPrefix(NAMES.NODEJS.PREFIX)
	
	    var collectedRequestHeaders = [
	      'accept',
	      'contentLength',
	      'contentType',
	      'referer',
	      'host'
	    ]
	
	    if (request) {
	      for (var i = 0; i < collectedRequestHeaders.length; i++) {
	        var headerKey = collectedRequestHeaders[i]
	        var header = request.headers[headerKey.toLowerCase()]
	        if (header !== undefined) {
	          // If any more processing of the headers is required consider refactoring this.
	          if (headerKey === 'referer') {
	            var queryParamIndex = header.indexOf('?')
	            if (queryParamIndex !== -1) {
	              header = header.substring(0, queryParamIndex)
	            }
	          }
	
	          var attributeName = 'request.headers.' + headerKey
	          transaction.addAgentAttribute(attributeName, header)
	        }
	      }
	
	      if (request.method !== undefined) {
	        transaction.addAgentAttribute('request.method', request.method)
	      }
	      if (request.headers['user-agent'] !== undefined) {
	          transaction.addAgentAttribute('request.headers.userAgent',
	              request.headers['user-agent'])
	      }
	    }
	
	    // Create the transaction segment using the request URL for now. Once a
	    // better name can be determined this segment will be renamed to that.
	    var segment = tracer.createSegment(request.url, recordWeb)
	    segment.start()
	
	    if (agent.config.feature_flag.custom_instrumentation) {
	      transaction.webSegment = segment
	    }
	
	    /* Needed for Connect and Express middleware that monkeypatch request
	     * and response via listeners.
	     */
	    tracer.bindEmitter(request, segment)
	    tracer.bindEmitter(response, segment)
	
	    // the error tracer needs a URL for tracing, even though naming overwrites
	    transaction.parsedUrl = url.parse(request.url, true)
	    transaction.url = transaction.parsedUrl.pathname
	    transaction.verb = request.method
	
	    // URL is sent as an agent attribute with transaction events
	    if (agent.config.feature_flag.send_request_uri_attribute) {
	      transaction.addAgentAttribute('request_uri', transaction.url)
	    }
	
	    // store the port on which this transaction runs
	    if (this.address instanceof Function) {
	      var address = this.address()
	      if (address) {
	        serverPort = address.port
	      }
	    }
	    transaction.port = serverPort
	
	    // need to set any config-driven names early for RUM
	    logger.trace({url: request.url, transaction: transaction.id},
	      'Applying user naming rules for RUM.')
	    transaction.applyUserNamingRules(request.url)
	
	    /**
	     * Calculate Queue Time
	     *
	     * Queue time is provided by certain providers by stamping the request
	     * header with the time the request arrived at the router.
	     *
	     * Units for queue time are
	     */
	    var qtime = request.headers[REQUEST_HEADER] || request.headers[QUEUE_HEADER]
	    if (qtime) {
	      var split = qtime.split('=')
	      if (split.length > 1) {
	        qtime = split[1]
	      }
	
	      var start = parseFloat(qtime)
	
	      if (isNaN(start)) {
	        logger.warn('Queue time header parsed as NaN (' + qtime + ')')
	      } else {
	        // nano seconds
	        if (start > 1e18) start = start / 1e6
	        // micro seconds
	        else if (start > 1e15) start = start / 1e3
	        // seconds
	        else if (start < 1e12) start = start * 1e3
	
	        transaction.queueTime = Date.now() - start
	      }
	    }
	    if (agent.config.feature_flag.cat) {
	      var encKey = agent.config.encoding_key
	      var incomingCatId = request.headers[NEWRELIC_ID_HEADER]
	      var obfTransaction = request.headers[NEWRELIC_TRANSACTION_HEADER]
	      var synthHeader = request.headers[NEWRELIC_SYNTHETICS_HEADER]
	      if (encKey) {
	        cat.handleCatHeaders(incomingCatId, obfTransaction, encKey, transaction)
	        if (transaction.incomingCatId) {
	          logger.trace('Got inbound request CAT headers in transaction %s',
	            transaction.id)
	        }
	        if (synthHeader && agent.config.trusted_account_ids) {
	          handleSyntheticsHeader(
	            synthHeader,
	            encKey,
	            agent.config.trusted_account_ids,
	            transaction
	          )
	        }
	      }
	    }
	
	    function instrumentedFinish() {
	      // Remove listeners so this doesn't get called twice.
	      response.removeListener('finish', instrumentedFinish)
	      request.removeListener('aborted', instrumentedFinish)
	
	      // Naming must happen before the segment and transaction are ended,
	      // because metrics recording depends on naming's side effects.
	      transaction.setName(transaction.parsedUrl, response.statusCode)
	
	      if (response) {
	        if (response.statusCode !== undefined) {
	          var statusCode = response.statusCode
	          if (typeof statusCode.toString === 'function') {
	            var responseCode = statusCode.toString()
	            if (typeof responseCode === 'string') {
	              transaction.addAgentAttribute('httpResponseCode', responseCode)
	            }
	          }
	
	          var responseStatus = parseInt(statusCode, 10)
	          if (!isNaN(responseStatus)) {
	            transaction.addAgentAttribute('response.status', responseStatus)
	          }
	        }
	        if (response.statusMessage !== undefined) {
	          transaction.addAgentAttribute('httpResponseMessage', response.statusMessage)
	        }
	
	        var contentLength = response.getHeader('content-length')
	        if (contentLength) {
	          transaction.addAgentAttribute(
	            'response.headers.contentLength',
	            parseInt(contentLength, 10)
	          )
	        }
	
	        var contentType = response.getHeader('content-type')
	        if (contentType) {
	          transaction.addAgentAttribute(
	            'response.headers.contentType',
	            contentType
	          )
	        }
	      }
	      // This should be the last thing called before the web segment finishes.
	      segment.markAsWeb(transaction.parsedUrl)
	      segment.end()
	      transaction.end()
	    }
	    response.once('finish', instrumentedFinish)
	    request.once('aborted', instrumentedFinish)
	
	    return tracer.bindFunction(listener, segment).apply(this, arguments)
	  })
	}
	
	// FLAG: cat this wont be used unless cat is enabled, see below where we
	// actually do the shimmer stuff if you'd like to verify.
	function wrapWriteHead(agent, writeHead) {
	  return function wrappedWriteHead() {
	    var transaction = agent.tracer.getTransaction()
	    if (!transaction) {
	      logger.trace('No transaction - not adding response CAT headers')
	      return writeHead.apply(this, arguments)
	    }
	    // FLAG: synthetics
	    if (agent.config.feature_flag.synthetics && transaction.syntheticsHeader) {
	      this.setHeader(NEWRELIC_SYNTHETICS_HEADER, transaction.syntheticsHeader)
	    }
	
	    if (!transaction.incomingCatId) {
	      logger.trace('No incoming CAT ID - not adding response CAT headers')
	      return writeHead.apply(this, arguments)
	    }
	
	    if (!agent.config.trusted_account_ids) {
	      logger.trace('No account IDs defined in config.trusted_account_ids - ' +
	        'not adding response CAT headers')
	      return writeHead.apply(this, arguments)
	    }
	
	    var accountId = transaction.incomingCatId.split('#')[0]
	    accountId = parseInt(accountId, 10)
	    if (agent.config.trusted_account_ids.indexOf(accountId) === -1) {
	      logger.trace('Request from untrusted CAT header account id: %s - ' +
	        'not adding response CAT headers', accountId)
	      return writeHead.apply(this, arguments)
	    }
	
	    // Not sure this could ever happen, but should guard against it anyway
	    // otherwise exception we blow up the user's app.
	    if (!agent.config.cross_process_id || !agent.config.encoding_key) {
	      logger.trace(
	        'Managed to have agent.config.trusted_account_ids but not cross_process_id ' +
	          '(%s) or encoding_key (%s) - not adding response CAT headers',
	        agent.config.cross_process_id,
	        agent.config.encoding_key
	      )
	      return writeHead.apply(this, arguments)
	    }
	
	    // -1 means no content length header was sent. We should only send this
	    // value in the appData if the header is set.
	    var contentLength = -1
	    var new_headers = arguments[arguments.length - 1]
	
	    if (typeof new_headers === 'object') {
	      for (var header in new_headers) {  // jshint ignore: line
	        if (CONTENT_LENGTH_REGEX.test(header)) {
	          contentLength = new_headers[header]
	          break
	        }
	      }
	    }
	
	    if (contentLength === -1 && this._headers) {
	      // JSHint complains about ownProperty stuff, but since we are looking
	      // for a specific name that doesn't matter so I'm disabling it.
	      // Outbound headers can be capitalized in any way, use regex instead
	      // of direct lookup.
	      for (var userHeader in this._headers) {  // jshint ignore: line
	        if (CONTENT_LENGTH_REGEX.test(userHeader)) {
	          contentLength = this._headers[userHeader]
	          break
	        }
	      }
	    }
	    // Stored on the tx so we can push a metric with this time instead of
	    // actual duration.
	    transaction.catResponseTime = transaction.timer.getDurationInMillis()
	
	    var appData
	    var txName = transaction.name || transaction.nameState.getName() || ''
	
	    try {
	      if (txName) {
	        txName = NAMES.WEB.RESPONSE_TIME + '/' + txName
	      }
	
	      appData = JSON.stringify([
	        agent.config.cross_process_id, // cross_process_id
	        txName, // transaction name
	        transaction.queueTime / 1000, // queue time (s)
	        transaction.catResponseTime / 1000, // response time (s)
	        contentLength, // content length (if content-length header is also being sent)
	        transaction.id, // TransactionGuid
	        false // force a transaction trace to be recorded
	      ])
	    } catch (err) {
	      logger.trace(err, 'Failed to serialize transaction: %s - ' +
	          'not adding CAT response headers',
	        txName)
	      return writeHead.apply(this, arguments)
	    }
	
	    var encKey = agent.config.encoding_key
	    var obfAppData = hashes.obfuscateNameUsingKey(appData, encKey)
	    this.setHeader(NEWRELIC_APP_DATA_HEADER, obfAppData)
	    logger.trace('Added outbound response CAT headers in transaction %s', transaction.id)
	
	    return writeHead.apply(this, arguments)
	  }
	}
	
	function wrapRequest(agent, request) {
	  // TODO: early return in the !transaction || internalOnly case
	  return function wrappedRequest(options) {
	    var tracer = agent.tracer
	    var transaction = tracer.getTransaction()
	    var outboundHeaders = {}
	    var args = tracer.slice(arguments)
	    var context = this
	    var needsHeaders = false
	
	    // don't pollute metrics and calls with NR connections
	    var internalOnly = options && options[NR_CONNECTION_PROP]
	
	    if (internalOnly) options[NR_CONNECTION_PROP] = undefined
	
	    if (transaction && !internalOnly && agent.config.encoding_key) {
	      // FLAG: synthetics
	      if (agent.config.feature_flag.synthetics && transaction.syntheticsHeader) {
	        outboundHeaders[NEWRELIC_SYNTHETICS_HEADER] = transaction.syntheticsHeader
	      }
	
	      // FLAG: cat
	      if (agent.config.feature_flag.cat) {
	        if (agent.config.obfuscatedId) {
	          outboundHeaders[NEWRELIC_ID_HEADER] = agent.config.obfuscatedId
	        }
	
	        var pathHash = hashes.calculatePathHash(
	          agent.config.applications()[0],
	          transaction.name || transaction.nameState.getName() || '',
	          transaction.referringPathHash
	        )
	        transaction.pushPathHash(pathHash)
	        var txData = [
	          transaction.id,
	          false,
	          transaction.tripId || transaction.id,
	          pathHash
	        ]
	        try {
	          txData = JSON.stringify(txData)
	          var txHeader = hashes.obfuscateNameUsingKey(txData, agent.config.encoding_key)
	          outboundHeaders[NEWRELIC_TRANSACTION_HEADER] = txHeader
	          logger.trace('Added outbound request CAT headers in transaction %s',
	            transaction.id)
	        } catch (err) {
	          logger.trace(err, 'Failed to serialize outbound response header')
	        }
	      }
	    }
	
	    var headers = Object.keys(outboundHeaders)
	    var i, l
	    if (transaction && !internalOnly) {
	      if (util.isArray(options.headers)) {
	        options = util._extend({}, options)
	        options.headers = options.headers.slice()
	        args[0] = options
	        for (i = 0, l = headers.length; i < l; ++i) {
	          options.headers.push([headers[i], outboundHeaders[headers[i]]])
	        }
	      } else if (typeof options === 'object' &&
	                 options.headers && options.headers.expect) {
	        options = util._extend({}, options)
	        options.headers = util._extend({}, options.headers)
	        options.headers = util._extend(options.headers, outboundHeaders)
	        args[0] = options
	      } else {
	        needsHeaders = true
	      }
	
	      var request_url = options
	      // If the request options are a string, parse it as a URL object.
	      if (typeof options === 'string') {
	        request_url = url.parse(options)
	      }
	      // hostname & port logic pulled directly from node's 0.10 lib/http.js
	      var hostname = request_url.hostname || request_url.host || DEFAULT_HOST
	      var port = request_url.port || request_url.defaultPort || DEFAULT_PORT
	      return instrumentOutbound(agent, hostname, port, makeRequest)
	    }
	
	    return makeRequest()
	
	    function makeRequest() {
	      var requested = request.apply(context, args)
	      if (!needsHeaders) return requested
	
	      try {
	        for (i = 0, l = headers.length; i < l; ++i) {
	          requested.setHeader(headers[i], outboundHeaders[headers[i]])
	        }
	      } catch (err) {
	        if (options && options.headers && typeof options.headers === 'object') {
	          logger.warn(
	            'Could not set cat header, header written with: ',
	            Object.keys(options.headers)
	          )
	        } else {
	          logger.warn('Could not set cat header, header already written')
	        }
	      }
	
	      return requested
	    }
	  }
	}
	
	function wrapLegacyRequest(agent, request) {
	  return function wrappedLegacyRequest(method, path, headers) {
	    var makeRequest = request.bind(this, method, path, headers)
	
	    if (agent.tracer.getTransaction()) {
	      return instrumentOutbound(agent, this.host, this.port, makeRequest)
	    }
	
	    return makeRequest()
	  }
	}
	
	function wrapLegacyClient(agent, proto) {
	  shimmer.wrapMethod(
	    proto,
	    'http.Client.prototype',
	    'request',
	    wrapLegacyRequest.bind(null, agent)
	  )
	}
	
	module.exports = function initialize(agent, http, moduleName) {
	  // FIXME: will this ever not be called?
	  shimmer.wrapMethod(http, 'http', 'createServer', function cb_wrapMethod(createServer) {
	    return function setDispatcher(requestListener) { // eslint-disable-line no-unused-vars
	      agent.environment.setDispatcher('http')
	      return createServer.apply(this, arguments)
	    }
	  })
	
	  /**
	   * It's not a great idea to monkeypatch EventEmitter methods given how hot
	   * they are, but this method is simple and works with all versions of
	   * node supported by the module.
	   */
	  shimmer.wrapMethod(
	    http && http.Server && http.Server.prototype,
	    'http.Server.prototype',
	    ['on', 'addListener'],
	    function cb_wrapMethod(addListener) {
	      return function cls_wrapMethod(type, listener) {
	        if (type === 'request' && listener instanceof Function) {
	          return addListener.call(this, type, wrapListener(agent, listener))
	        }
	
	        return addListener.apply(this, arguments)
	      }
	    }
	  )
	
	
	  // FLAG: cat
	  if (agent.config.feature_flag.cat) {
	    shimmer.wrapMethod(http && http.ServerResponse && http.ServerResponse.prototype,
	                       'http.ServerResponse.prototype',
	                       'writeHead',
	                       wrapWriteHead.bind(null, agent))
	  }
	
	  /**
	   * As of node 0.8, http.request() is the right way to originate outbound
	   * requests.
	   */
	  if (http && http.Agent && http.Agent.prototype && http.Agent.prototype.request) {
	    // Node 0.11+ always uses an Agent.
	    shimmer.wrapMethod(
	      http.Agent.prototype,
	      'http.Agent.prototype',
	      'request',
	      wrapRequest.bind(null, agent)
	    )
	  } else if (moduleName !== 'https' || semver.satisfies(process.version, '<=0.10.x')) {
	    shimmer.wrapMethod(
	      http,
	      'http',
	      'request',
	      wrapRequest.bind(null, agent)
	    )
	  }
	
	  // http.Client is deprecated, but still in use
	  var DeprecatedClient, deprecatedCreateClient
	  function clearGetters() {
	    if (DeprecatedClient) {
	      delete http.Client
	      http.Client = DeprecatedClient
	    }
	    if (deprecatedCreateClient) {
	      delete http.createClient
	      http.createClient = deprecatedCreateClient
	    }
	  }
	
	  DeprecatedClient = shimmer.wrapDeprecated(
	    http,
	    'http',
	    'Client',
	    {
	      get: function get() {
	        var example = new DeprecatedClient(80, 'localhost')
	        wrapLegacyClient(agent, example.constructor.prototype)
	        clearGetters()
	
	        return DeprecatedClient
	      },
	      set: function set(NewClient) {
	        DeprecatedClient = NewClient
	      }
	    }
	  )
	
	  deprecatedCreateClient = shimmer.wrapDeprecated(
	    http,
	    'http',
	    'createClient',
	    {
	      get: function get() {
	        var example = deprecatedCreateClient(80, 'localhost')
	        wrapLegacyClient(agent, example.constructor.prototype)
	        clearGetters()
	
	        return deprecatedCreateClient
	      },
	      set: function set(newCreateClient) {
	        deprecatedCreateClient = newCreateClient
	      }
	    }
	  )
	}
	
	/**
	 * Take the X-NewRelic-Synthetics header and apply any appropriate data to the
	 * transaction for later use. This is the gate keeper for attributes being
	 * added onto the transaction object for synthetics.
	 *
	 * @param {string} header - The raw X-NewRelic-Synthetics header
	 * @param {string} encKey - Encoding key handed down from the server
	 * @param {̄Array} trustedIds - Array of accounts to trust the header from.
	 * @param {Transaction} transaction - Where the synthetics data is attached to.
	 */
	function handleSyntheticsHeader(header, encKey, trustedIds, transaction) {
	  var synthData = parseSyntheticsHeader(header, encKey, trustedIds)
	  if (!synthData) {
	    return
	  }
	
	  transaction.syntheticsData = synthData
	  transaction.syntheticsHeader = header
	}
	
	/**
	 * Parse out and verify the the pieces of the X-NewRelic-Synthetics header.
	 *
	 * @param {string} header - The raw X-NewRelic-Synthetics header
	 * @param {string} encKey - Encoding key handed down from the server
	 * @param {̄Array} trustedIds - Array of accounts to trust the header from.
	 * @return {Object or null} - On successful parse and verification an object of
	 *                            synthetics data is returned, otherwise null is
	 *                            returned.
	 */
	function parseSyntheticsHeader(header, encKey, trustedIds) {
	  // Eagerly declare this object because we know what it should look like and
	  // can use that for header verification.
	  var parsedData = {
	    version: null,
	    accountId: null,
	    resourceId: null,
	    jobId: null,
	    monitorId: null
	  }
	  var synthData = null
	  try {
	    synthData = JSON.parse(
	      hashes.deobfuscateNameUsingKey(header, encKey)
	    )
	  } catch (e) {
	    logger.trace(e, 'Got unparsable synthetics header: %s', header)
	    return
	  }
	
	  if (!util.isArray(synthData)) {
	    logger.trace(
	      'Synthetics data is not an array: %s (%s)',
	      synthData,
	      typeof synthData
	    )
	    return
	  }
	
	
	  if (synthData.length < Object.keys(parsedData).length) {
	    logger.trace(
	      'Synthetics header length is %s, expected at least %s',
	      synthData.length,
	      Object.keys(parsedData).length
	    )
	  }
	
	  parsedData.version = synthData[0]
	  if (parsedData.version !== 1) {
	    logger.trace(
	      'Synthetics header version is not 1, got: %s (%s)',
	      parsedData.version,
	      synthData
	    )
	    return
	  }
	
	  parsedData.accountId = synthData[1]
	  if (parsedData.accountId) {
	    if (trustedIds.indexOf(parsedData.accountId) === -1) {
	      logger.trace(
	        'Synthetics header account ID is not in trusted account IDs: %s (%s)',
	        parsedData.accountId,
	        trustedIds
	      )
	      return
	    }
	  } else {
	    logger.trace('Synthetics header account ID missing.')
	    return
	  }
	
	  parsedData.resourceId = synthData[2]
	  if (!parsedData.resourceId) {
	    logger.trace('Synthetics resource ID is missing.')
	    return
	  }
	
	  parsedData.jobId = synthData[3]
	  if (!parsedData.jobId) {
	    logger.trace('Synthetics job ID is missing.')
	  }
	
	  parsedData.monitorId = synthData[4]
	  if (!parsedData.monitorId) {
	    logger.trace('Synthetics monitor ID is missing.')
	  }
	
	  return parsedData
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var NAMES = __webpack_require__(59)
	
	// CONSTANTS
	var TO_MILLIS = 1e3
	
	function recordWeb(segment, scope) {
	  // in web metrics, scope is required
	  if (!scope) return
	
	  var transaction = segment.transaction
	  // if there was a nested webTransaction use its recorder instead
	  if (transaction.webSegment && segment !== transaction.webSegment) return
	
	  var duration = segment.getDurationInMillis()
	  var totalTime = transaction.trace.getTotalTimeDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var partial = segment.partialName
	  var config = segment.transaction.agent.config
	  // named / key transaction support requires per-name apdexT
	  var keyApdexInMillis = config.web_transactions_apdex[scope] * TO_MILLIS || 0
	
	  transaction.measure(NAMES.WEB.RESPONSE_TIME, null, duration, exclusive)
	  transaction.measure(NAMES.WEB.TOTAL_TIME, null, totalTime, exclusive)
	  transaction.measure(NAMES.HTTP, null, duration, exclusive)
	  transaction.measure(scope, null, duration, exclusive)
	  transaction.measure(NAMES.WEB.TOTAL_TIME + '/' + partial, null, totalTime, exclusive)
	
	  if (transaction.queueTime > 0) {
	    transaction.measure(NAMES.QUEUETIME, null, transaction.queueTime)
	  }
	
	  if (transaction.incomingCatId) {
	    transaction.measure(
	        NAMES.CLIENT_APPLICATION + '/' + transaction.incomingCatId + "/all",
	        null,
	        transaction.catResponseTime
	      )
	  }
	  transaction._setApdex(NAMES.APDEX + '/' + partial, duration, keyApdexInMillis)
	  transaction._setApdex(NAMES.APDEX, duration, keyApdexInMillis)
	}
	
	module.exports = recordWeb


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var util = __webpack_require__(16)
	var hashes = __webpack_require__(62)
	var logger = __webpack_require__(12).child({component: 'cat'})
	
	module.exports.handleCatHeaders = handleCatHeaders
	module.exports.parsedHeadersToTrans = parsedHeadersToTrans
	
	function handleCatHeaders(incomingCatId, obfTransaction, encKey, transaction) {
	  var parsedCatId = null
	  if (incomingCatId) {
	    parsedCatId = hashes.deobfuscateNameUsingKey(
	      incomingCatId,
	      encKey
	    )
	  }
	
	  var externalTrans = null
	  if (obfTransaction) {
	    try {
	      externalTrans = JSON.parse(
	        hashes.deobfuscateNameUsingKey(obfTransaction, encKey)
	      )
	    } catch (e) {
	      logger.trace(
	        'Got an unparsable CAT header x-newrelic-transaction: %s',
	        obfTransaction
	      )
	    }
	  }
	
	  parsedHeadersToTrans(parsedCatId, externalTrans, transaction)
	}
	
	function parsedHeadersToTrans(parsedCatId, externalTrans, transaction) {
	  if (typeof parsedCatId === 'string') {
	    transaction.incomingCatId = parsedCatId
	  }
	
	  if (util.isArray(externalTrans)) {
	    transaction.referringTransactionGuid = externalTrans[0]
	    if (typeof externalTrans[2] === 'string') {
	      transaction.tripId = externalTrans[2]
	    } else if (externalTrans[2]) {
	      transaction.invalidIncomingExternalTransaction = true
	    }
	
	    if (_isValidReferringHash(externalTrans[3])) {
	      transaction.referringPathHash = externalTrans[3]
	    } else if (externalTrans[3]) {
	      transaction.invalidIncomingExternalTransaction = true
	    }
	  }
	}
	
	function _isValidReferringHash(hash) {
	  return (typeof hash === 'string')
	}


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var recordExternal = __webpack_require__(213)
	var NAMES = __webpack_require__(59)
	var urltils = __webpack_require__(168)
	var hashes = __webpack_require__(62)
	var logger = __webpack_require__(12).child({component: 'outbound'})
	
	var DEFAULT_PORT = 80
	
	function instrumentOutbound(agent, hostname, port, makeRequest) {
	  if (!hostname) throw new Error('hostname must be defined!')
	  if (!port || port < 1) throw new Error('port must be defined!')
	  if (port && port !== DEFAULT_PORT) hostname = hostname + ':' + port
	
	  var transaction = agent.tracer.getTransaction()
	  var name = NAMES.EXTERNAL.PREFIX + hostname
	
	  return agent.tracer.addSegment(
	    name,
	    recordExternal(hostname, 'http'),
	    null,
	    false,
	    instrumentRequest
	  )
	
	  function instrumentRequest(segment) {
	    var request = makeRequest()
	    segment.start()
	    segment.name += urltils.scrub(request.path)
	
	    var params = urltils.parseParameters(request.path)
	    urltils.copyParameters(agent.config, params, segment.parameters)
	
	    // may trace errors multiple times, make that the error tracer's problem
	    request.once('error', function handleError(error) {
	      segment.end()
	
	      var hasListener = (
	        (Array.isArray(request._events.error) && request._events.error.length)
	        || (!Array.isArray(request._events.error) && request._events.error)
	      )
	
	      if (hasListener) {
	        logger.trace(
	          error,
	          'Not capturing outbound error because user has already handled it.'
	        )
	        return
	      }
	
	      /* we should be calling request.emit('error', error) here. We currently
	       * do not do this because the agent has historically swallowed these
	       * errors, re enabling them may cause unexpected errors to buble up in
	       * code that depends on this behavior.
	       */
	      logger.trace(
	        error,
	        'Captured outbound error on behalf of the user (normally an uncaught exception).'
	      )
	      agent.errors.add(transaction, error)
	    })
	
	    // Pop off the listeners so we can make sure our response handler happens
	    // first. This is to prevent a case where the transaction ends before our
	    // response handler has had a chance to pull data it needs for segment
	    // metrics.
	    var existingListeners = request.listeners('response').slice()
	    request.removeAllListeners('response')
	
	    request.on('response', function handle_response(res) {
	      // FLAG: cat
	      if (agent.config.feature_flag.cat) {
	        pullCatHeaders(
	          agent.config,
	          segment,
	          hostname,
	          res.headers['x-newrelic-app-data']
	        )
	      }
	      agent.tracer.bindEmitter(res)
	      res.on('end', segment.end.bind(segment))
	    })
	
	    // Push the listeners we popped off back onto the event. See above for
	    // explanation of why.
	    for (var i = 0; i < existingListeners.length; i++) {
	      request.on('response', existingListeners[i])
	    }
	
	    // ensure listeners are evaluated in correct transactional scope
	    agent.tracer.bindEmitter(request)
	    return request
	  }
	}
	
	function pullCatHeaders(config, segment, host, obfAppData) {
	  if (!config.encoding_key) {
	    logger.trace('config.encoding_key is not set - not parsing response CAT headers')
	    return
	  }
	
	  if (!config.trusted_account_ids) {
	    logger.trace('config.trusted_account_ids is not set - not parsing response ' +
	      'CAT headers')
	    return
	  }
	
	  // is our downstream request CAT-aware?
	  if (!obfAppData) {
	    logger.trace('Got no CAT app data in response header x-newrelic-app-data')
	  } else {
	    var appData = null
	    try {
	      appData = JSON.parse(hashes.deobfuscateNameUsingKey(obfAppData,
	                                                          config.encoding_key))
	    } catch (e) {
	      logger.warn('Got an unparsable CAT header x-newrelic-app-data: %s', obfAppData)
	      return
	    }
	    // Make sure it is a trusted account
	    if (appData.length && typeof appData[0] === 'string') {
	      var accountId = appData[0].split('#')[0]
	      accountId = parseInt(accountId, 10)
	      if (config.trusted_account_ids.indexOf(accountId) === -1) {
	        logger.trace('Response from untrusted CAT header account id: %s', accountId)
	      } else {
	        segment.catId = appData[0]
	        segment.catTransaction = appData[1]
	        segment.name = NAMES.EXTERNAL.TRANSACTION + host + '/' +
	                       segment.catId + '/' + segment.catTransaction
	        if (appData.length >= 6) {
	          segment.parameters.transaction_guid = appData[5]
	        }
	        logger.trace('Got inbound response CAT headers in transaction %s',
	          segment.transaction.id)
	      }
	    }
	  }
	}
	
	module.exports = instrumentOutbound


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var EXTERNAL = __webpack_require__(59).EXTERNAL
	
	
	function recordExternal(host, library) {
	  if (!host) {
	    throw new Error(
	      'External request metrics need to be associated with a host. ' +
	      'Not measuring.'
	    )
	  }
	
	  return function cls_recordExternal(segment, scope) {
	    var duration = segment.getDurationInMillis()
	    var exclusive = segment.getExclusiveDurationInMillis()
	    var transaction = segment.transaction
	    var metricName = EXTERNAL.PREFIX + host + '/' + library
	    var rollupType = transaction.isWeb() ? EXTERNAL.WEB : EXTERNAL.OTHER
	    var rollupHost = EXTERNAL.PREFIX + host + '/all'
	
	    if (segment.catId && segment.catTransaction) {
	      transaction.measure(
	        EXTERNAL.APP + host + '/' + segment.catId + '/all',
	        null,
	        duration,
	        exclusive
	      )
	
	      transaction.measure(
	        EXTERNAL.TRANSACTION + host + '/' + segment.catId + '/' + segment.catTransaction,
	        null,
	        duration,
	        exclusive
	      )
	
	      // This CAT metric replaces scoped External/{host}/{method}
	      if (scope) {
	        transaction.measure(
	          EXTERNAL.TRANSACTION + host + '/' + segment.catId +
	            '/' + segment.catTransaction,
	          scope,
	          duration,
	          exclusive
	        )
	      }
	    } else if (scope) {
	      transaction.measure(metricName, scope, duration, exclusive)
	    }
	
	    transaction.measure(metricName, null, duration, exclusive)
	    transaction.measure(rollupType, null, duration, exclusive)
	    transaction.measure(rollupHost, null, duration, exclusive)
	    transaction.measure(EXTERNAL.ALL, null, duration, exclusive)
	  }
	}
	
	module.exports = recordExternal


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer;
	
	// The debug function is excluded entirely from the minified version.
	/* nomin */ var debug;
	/* nomin */ if (typeof process === 'object' &&
	    /* nomin */ process.env &&
	    /* nomin */ process.env.NODE_DEBUG &&
	    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
	  /* nomin */ debug = function() {
	    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
	    /* nomin */ args.unshift('SEMVER');
	    /* nomin */ console.log.apply(console, args);
	    /* nomin */ };
	/* nomin */ else
	  /* nomin */ debug = function() {};
	
	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	exports.SEMVER_SPEC_VERSION = '2.0.0';
	
	var MAX_LENGTH = 256;
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	
	// The actual regexps go on exports.re
	var re = exports.re = [];
	var src = exports.src = [];
	var R = 0;
	
	// The following Regular Expressions can be used for tokenizing,
	// validating, and parsing SemVer version strings.
	
	// ## Numeric Identifier
	// A single `0`, or a non-zero digit followed by zero or more digits.
	
	var NUMERICIDENTIFIER = R++;
	src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
	var NUMERICIDENTIFIERLOOSE = R++;
	src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
	
	
	// ## Non-numeric Identifier
	// Zero or more digits, followed by a letter or hyphen, and then zero or
	// more letters, digits, or hyphens.
	
	var NONNUMERICIDENTIFIER = R++;
	src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
	
	
	// ## Main Version
	// Three dot-separated numeric identifiers.
	
	var MAINVERSION = R++;
	src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
	                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
	                   '(' + src[NUMERICIDENTIFIER] + ')';
	
	var MAINVERSIONLOOSE = R++;
	src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
	                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
	                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
	
	// ## Pre-release Version Identifier
	// A numeric identifier, or a non-numeric identifier.
	
	var PRERELEASEIDENTIFIER = R++;
	src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
	                            '|' + src[NONNUMERICIDENTIFIER] + ')';
	
	var PRERELEASEIDENTIFIERLOOSE = R++;
	src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
	                                 '|' + src[NONNUMERICIDENTIFIER] + ')';
	
	
	// ## Pre-release Version
	// Hyphen, followed by one or more dot-separated pre-release version
	// identifiers.
	
	var PRERELEASE = R++;
	src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
	                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
	
	var PRERELEASELOOSE = R++;
	src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
	                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
	
	// ## Build Metadata Identifier
	// Any combination of digits, letters, or hyphens.
	
	var BUILDIDENTIFIER = R++;
	src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
	
	// ## Build Metadata
	// Plus sign, followed by one or more period-separated build metadata
	// identifiers.
	
	var BUILD = R++;
	src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
	             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
	
	
	// ## Full Version String
	// A main version, followed optionally by a pre-release version and
	// build metadata.
	
	// Note that the only major, minor, patch, and pre-release sections of
	// the version string are capturing groups.  The build metadata is not a
	// capturing group, because it should not ever be used in version
	// comparison.
	
	var FULL = R++;
	var FULLPLAIN = 'v?' + src[MAINVERSION] +
	                src[PRERELEASE] + '?' +
	                src[BUILD] + '?';
	
	src[FULL] = '^' + FULLPLAIN + '$';
	
	// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
	// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
	// common in the npm registry.
	var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
	                 src[PRERELEASELOOSE] + '?' +
	                 src[BUILD] + '?';
	
	var LOOSE = R++;
	src[LOOSE] = '^' + LOOSEPLAIN + '$';
	
	var GTLT = R++;
	src[GTLT] = '((?:<|>)?=?)';
	
	// Something like "2.*" or "1.2.x".
	// Note that "x.x" is a valid xRange identifer, meaning "any version"
	// Only the first item is strictly required.
	var XRANGEIDENTIFIERLOOSE = R++;
	src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
	var XRANGEIDENTIFIER = R++;
	src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
	
	var XRANGEPLAIN = R++;
	src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
	                   '(?:' + src[PRERELEASE] + ')?' +
	                   src[BUILD] + '?' +
	                   ')?)?';
	
	var XRANGEPLAINLOOSE = R++;
	src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
	                        '(?:' + src[PRERELEASELOOSE] + ')?' +
	                        src[BUILD] + '?' +
	                        ')?)?';
	
	var XRANGE = R++;
	src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
	var XRANGELOOSE = R++;
	src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
	
	// Tilde ranges.
	// Meaning is "reasonably at or greater than"
	var LONETILDE = R++;
	src[LONETILDE] = '(?:~>?)';
	
	var TILDETRIM = R++;
	src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
	re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
	var tildeTrimReplace = '$1~';
	
	var TILDE = R++;
	src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
	var TILDELOOSE = R++;
	src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
	
	// Caret ranges.
	// Meaning is "at least and backwards compatible with"
	var LONECARET = R++;
	src[LONECARET] = '(?:\\^)';
	
	var CARETTRIM = R++;
	src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
	re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
	var caretTrimReplace = '$1^';
	
	var CARET = R++;
	src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
	var CARETLOOSE = R++;
	src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
	
	// A simple gt/lt/eq thing, or just "" to indicate "any version"
	var COMPARATORLOOSE = R++;
	src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
	var COMPARATOR = R++;
	src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
	
	
	// An expression to strip any whitespace between the gtlt and the thing
	// it modifies, so that `> 1.2.3` ==> `>1.2.3`
	var COMPARATORTRIM = R++;
	src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
	                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
	
	// this one has to use the /g flag
	re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
	var comparatorTrimReplace = '$1$2$3';
	
	
	// Something like `1.2.3 - 1.2.4`
	// Note that these all use the loose form, because they'll be
	// checked against either the strict or loose comparator form
	// later.
	var HYPHENRANGE = R++;
	src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
	                   '\\s+-\\s+' +
	                   '(' + src[XRANGEPLAIN] + ')' +
	                   '\\s*$';
	
	var HYPHENRANGELOOSE = R++;
	src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
	                        '\\s+-\\s+' +
	                        '(' + src[XRANGEPLAINLOOSE] + ')' +
	                        '\\s*$';
	
	// Star ranges basically just allow anything at all.
	var STAR = R++;
	src[STAR] = '(<|>)?=?\\s*\\*';
	
	// Compile to actual regexp objects.
	// All are flag-free, unless they were created above with a flag.
	for (var i = 0; i < R; i++) {
	  debug(i, src[i]);
	  if (!re[i])
	    re[i] = new RegExp(src[i]);
	}
	
	exports.parse = parse;
	function parse(version, loose) {
	  if (version instanceof SemVer)
	    return version;
	
	  if (typeof version !== 'string')
	    return null;
	
	  if (version.length > MAX_LENGTH)
	    return null;
	
	  var r = loose ? re[LOOSE] : re[FULL];
	  if (!r.test(version))
	    return null;
	
	  try {
	    return new SemVer(version, loose);
	  } catch (er) {
	    return null;
	  }
	}
	
	exports.valid = valid;
	function valid(version, loose) {
	  var v = parse(version, loose);
	  return v ? v.version : null;
	}
	
	
	exports.clean = clean;
	function clean(version, loose) {
	  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
	  return s ? s.version : null;
	}
	
	exports.SemVer = SemVer;
	
	function SemVer(version, loose) {
	  if (version instanceof SemVer) {
	    if (version.loose === loose)
	      return version;
	    else
	      version = version.version;
	  } else if (typeof version !== 'string') {
	    throw new TypeError('Invalid Version: ' + version);
	  }
	
	  if (version.length > MAX_LENGTH)
	    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
	
	  if (!(this instanceof SemVer))
	    return new SemVer(version, loose);
	
	  debug('SemVer', version, loose);
	  this.loose = loose;
	  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
	
	  if (!m)
	    throw new TypeError('Invalid Version: ' + version);
	
	  this.raw = version;
	
	  // these are actually numbers
	  this.major = +m[1];
	  this.minor = +m[2];
	  this.patch = +m[3];
	
	  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
	    throw new TypeError('Invalid major version')
	
	  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
	    throw new TypeError('Invalid minor version')
	
	  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
	    throw new TypeError('Invalid patch version')
	
	  // numberify any prerelease numeric ids
	  if (!m[4])
	    this.prerelease = [];
	  else
	    this.prerelease = m[4].split('.').map(function(id) {
	      if (/^[0-9]+$/.test(id)) {
	        var num = +id;
	        if (num >= 0 && num < MAX_SAFE_INTEGER)
	          return num;
	      }
	      return id;
	    });
	
	  this.build = m[5] ? m[5].split('.') : [];
	  this.format();
	}
	
	SemVer.prototype.format = function() {
	  this.version = this.major + '.' + this.minor + '.' + this.patch;
	  if (this.prerelease.length)
	    this.version += '-' + this.prerelease.join('.');
	  return this.version;
	};
	
	SemVer.prototype.toString = function() {
	  return this.version;
	};
	
	SemVer.prototype.compare = function(other) {
	  debug('SemVer.compare', this.version, this.loose, other);
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);
	
	  return this.compareMain(other) || this.comparePre(other);
	};
	
	SemVer.prototype.compareMain = function(other) {
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);
	
	  return compareIdentifiers(this.major, other.major) ||
	         compareIdentifiers(this.minor, other.minor) ||
	         compareIdentifiers(this.patch, other.patch);
	};
	
	SemVer.prototype.comparePre = function(other) {
	  if (!(other instanceof SemVer))
	    other = new SemVer(other, this.loose);
	
	  // NOT having a prerelease is > having one
	  if (this.prerelease.length && !other.prerelease.length)
	    return -1;
	  else if (!this.prerelease.length && other.prerelease.length)
	    return 1;
	  else if (!this.prerelease.length && !other.prerelease.length)
	    return 0;
	
	  var i = 0;
	  do {
	    var a = this.prerelease[i];
	    var b = other.prerelease[i];
	    debug('prerelease compare', i, a, b);
	    if (a === undefined && b === undefined)
	      return 0;
	    else if (b === undefined)
	      return 1;
	    else if (a === undefined)
	      return -1;
	    else if (a === b)
	      continue;
	    else
	      return compareIdentifiers(a, b);
	  } while (++i);
	};
	
	// preminor will bump the version up to the next minor release, and immediately
	// down to pre-release. premajor and prepatch work the same way.
	SemVer.prototype.inc = function(release, identifier) {
	  switch (release) {
	    case 'premajor':
	      this.prerelease.length = 0;
	      this.patch = 0;
	      this.minor = 0;
	      this.major++;
	      this.inc('pre', identifier);
	      break;
	    case 'preminor':
	      this.prerelease.length = 0;
	      this.patch = 0;
	      this.minor++;
	      this.inc('pre', identifier);
	      break;
	    case 'prepatch':
	      // If this is already a prerelease, it will bump to the next version
	      // drop any prereleases that might already exist, since they are not
	      // relevant at this point.
	      this.prerelease.length = 0;
	      this.inc('patch', identifier);
	      this.inc('pre', identifier);
	      break;
	    // If the input is a non-prerelease version, this acts the same as
	    // prepatch.
	    case 'prerelease':
	      if (this.prerelease.length === 0)
	        this.inc('patch', identifier);
	      this.inc('pre', identifier);
	      break;
	
	    case 'major':
	      // If this is a pre-major version, bump up to the same major version.
	      // Otherwise increment major.
	      // 1.0.0-5 bumps to 1.0.0
	      // 1.1.0 bumps to 2.0.0
	      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
	        this.major++;
	      this.minor = 0;
	      this.patch = 0;
	      this.prerelease = [];
	      break;
	    case 'minor':
	      // If this is a pre-minor version, bump up to the same minor version.
	      // Otherwise increment minor.
	      // 1.2.0-5 bumps to 1.2.0
	      // 1.2.1 bumps to 1.3.0
	      if (this.patch !== 0 || this.prerelease.length === 0)
	        this.minor++;
	      this.patch = 0;
	      this.prerelease = [];
	      break;
	    case 'patch':
	      // If this is not a pre-release version, it will increment the patch.
	      // If it is a pre-release it will bump up to the same patch version.
	      // 1.2.0-5 patches to 1.2.0
	      // 1.2.0 patches to 1.2.1
	      if (this.prerelease.length === 0)
	        this.patch++;
	      this.prerelease = [];
	      break;
	    // This probably shouldn't be used publicly.
	    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
	    case 'pre':
	      if (this.prerelease.length === 0)
	        this.prerelease = [0];
	      else {
	        var i = this.prerelease.length;
	        while (--i >= 0) {
	          if (typeof this.prerelease[i] === 'number') {
	            this.prerelease[i]++;
	            i = -2;
	          }
	        }
	        if (i === -1) // didn't increment anything
	          this.prerelease.push(0);
	      }
	      if (identifier) {
	        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	        if (this.prerelease[0] === identifier) {
	          if (isNaN(this.prerelease[1]))
	            this.prerelease = [identifier, 0];
	        } else
	          this.prerelease = [identifier, 0];
	      }
	      break;
	
	    default:
	      throw new Error('invalid increment argument: ' + release);
	  }
	  this.format();
	  this.raw = this.version;
	  return this;
	};
	
	exports.inc = inc;
	function inc(version, release, loose, identifier) {
	  if (typeof(loose) === 'string') {
	    identifier = loose;
	    loose = undefined;
	  }
	
	  try {
	    return new SemVer(version, loose).inc(release, identifier).version;
	  } catch (er) {
	    return null;
	  }
	}
	
	exports.diff = diff;
	function diff(version1, version2) {
	  if (eq(version1, version2)) {
	    return null;
	  } else {
	    var v1 = parse(version1);
	    var v2 = parse(version2);
	    if (v1.prerelease.length || v2.prerelease.length) {
	      for (var key in v1) {
	        if (key === 'major' || key === 'minor' || key === 'patch') {
	          if (v1[key] !== v2[key]) {
	            return 'pre'+key;
	          }
	        }
	      }
	      return 'prerelease';
	    }
	    for (var key in v1) {
	      if (key === 'major' || key === 'minor' || key === 'patch') {
	        if (v1[key] !== v2[key]) {
	          return key;
	        }
	      }
	    }
	  }
	}
	
	exports.compareIdentifiers = compareIdentifiers;
	
	var numeric = /^[0-9]+$/;
	function compareIdentifiers(a, b) {
	  var anum = numeric.test(a);
	  var bnum = numeric.test(b);
	
	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }
	
	  return (anum && !bnum) ? -1 :
	         (bnum && !anum) ? 1 :
	         a < b ? -1 :
	         a > b ? 1 :
	         0;
	}
	
	exports.rcompareIdentifiers = rcompareIdentifiers;
	function rcompareIdentifiers(a, b) {
	  return compareIdentifiers(b, a);
	}
	
	exports.major = major;
	function major(a, loose) {
	  return new SemVer(a, loose).major;
	}
	
	exports.minor = minor;
	function minor(a, loose) {
	  return new SemVer(a, loose).minor;
	}
	
	exports.patch = patch;
	function patch(a, loose) {
	  return new SemVer(a, loose).patch;
	}
	
	exports.compare = compare;
	function compare(a, b, loose) {
	  return new SemVer(a, loose).compare(b);
	}
	
	exports.compareLoose = compareLoose;
	function compareLoose(a, b) {
	  return compare(a, b, true);
	}
	
	exports.rcompare = rcompare;
	function rcompare(a, b, loose) {
	  return compare(b, a, loose);
	}
	
	exports.sort = sort;
	function sort(list, loose) {
	  return list.sort(function(a, b) {
	    return exports.compare(a, b, loose);
	  });
	}
	
	exports.rsort = rsort;
	function rsort(list, loose) {
	  return list.sort(function(a, b) {
	    return exports.rcompare(a, b, loose);
	  });
	}
	
	exports.gt = gt;
	function gt(a, b, loose) {
	  return compare(a, b, loose) > 0;
	}
	
	exports.lt = lt;
	function lt(a, b, loose) {
	  return compare(a, b, loose) < 0;
	}
	
	exports.eq = eq;
	function eq(a, b, loose) {
	  return compare(a, b, loose) === 0;
	}
	
	exports.neq = neq;
	function neq(a, b, loose) {
	  return compare(a, b, loose) !== 0;
	}
	
	exports.gte = gte;
	function gte(a, b, loose) {
	  return compare(a, b, loose) >= 0;
	}
	
	exports.lte = lte;
	function lte(a, b, loose) {
	  return compare(a, b, loose) <= 0;
	}
	
	exports.cmp = cmp;
	function cmp(a, op, b, loose) {
	  var ret;
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      ret = a === b;
	      break;
	    case '!==':
	      if (typeof a === 'object') a = a.version;
	      if (typeof b === 'object') b = b.version;
	      ret = a !== b;
	      break;
	    case '': case '=': case '==': ret = eq(a, b, loose); break;
	    case '!=': ret = neq(a, b, loose); break;
	    case '>': ret = gt(a, b, loose); break;
	    case '>=': ret = gte(a, b, loose); break;
	    case '<': ret = lt(a, b, loose); break;
	    case '<=': ret = lte(a, b, loose); break;
	    default: throw new TypeError('Invalid operator: ' + op);
	  }
	  return ret;
	}
	
	exports.Comparator = Comparator;
	function Comparator(comp, loose) {
	  if (comp instanceof Comparator) {
	    if (comp.loose === loose)
	      return comp;
	    else
	      comp = comp.value;
	  }
	
	  if (!(this instanceof Comparator))
	    return new Comparator(comp, loose);
	
	  debug('comparator', comp, loose);
	  this.loose = loose;
	  this.parse(comp);
	
	  if (this.semver === ANY)
	    this.value = '';
	  else
	    this.value = this.operator + this.semver.version;
	
	  debug('comp', this);
	}
	
	var ANY = {};
	Comparator.prototype.parse = function(comp) {
	  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	  var m = comp.match(r);
	
	  if (!m)
	    throw new TypeError('Invalid comparator: ' + comp);
	
	  this.operator = m[1];
	  if (this.operator === '=')
	    this.operator = '';
	
	  // if it literally is just '>' or '' then allow anything.
	  if (!m[2])
	    this.semver = ANY;
	  else
	    this.semver = new SemVer(m[2], this.loose);
	};
	
	Comparator.prototype.toString = function() {
	  return this.value;
	};
	
	Comparator.prototype.test = function(version) {
	  debug('Comparator.test', version, this.loose);
	
	  if (this.semver === ANY)
	    return true;
	
	  if (typeof version === 'string')
	    version = new SemVer(version, this.loose);
	
	  return cmp(version, this.operator, this.semver, this.loose);
	};
	
	
	exports.Range = Range;
	function Range(range, loose) {
	  if ((range instanceof Range) && range.loose === loose)
	    return range;
	
	  if (!(this instanceof Range))
	    return new Range(range, loose);
	
	  this.loose = loose;
	
	  // First, split based on boolean or ||
	  this.raw = range;
	  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
	    return this.parseRange(range.trim());
	  }, this).filter(function(c) {
	    // throw out any that are not relevant for whatever reason
	    return c.length;
	  });
	
	  if (!this.set.length) {
	    throw new TypeError('Invalid SemVer Range: ' + range);
	  }
	
	  this.format();
	}
	
	Range.prototype.format = function() {
	  this.range = this.set.map(function(comps) {
	    return comps.join(' ').trim();
	  }).join('||').trim();
	  return this.range;
	};
	
	Range.prototype.toString = function() {
	  return this.range;
	};
	
	Range.prototype.parseRange = function(range) {
	  var loose = this.loose;
	  range = range.trim();
	  debug('range', range, loose);
	  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
	  range = range.replace(hr, hyphenReplace);
	  debug('hyphen replace', range);
	  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
	  debug('comparator trim', range, re[COMPARATORTRIM]);
	
	  // `~ 1.2.3` => `~1.2.3`
	  range = range.replace(re[TILDETRIM], tildeTrimReplace);
	
	  // `^ 1.2.3` => `^1.2.3`
	  range = range.replace(re[CARETTRIM], caretTrimReplace);
	
	  // normalize spaces
	  range = range.split(/\s+/).join(' ');
	
	  // At this point, the range is completely trimmed and
	  // ready to be split into comparators.
	
	  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
	  var set = range.split(' ').map(function(comp) {
	    return parseComparator(comp, loose);
	  }).join(' ').split(/\s+/);
	  if (this.loose) {
	    // in loose mode, throw out any that are not valid comparators
	    set = set.filter(function(comp) {
	      return !!comp.match(compRe);
	    });
	  }
	  set = set.map(function(comp) {
	    return new Comparator(comp, loose);
	  });
	
	  return set;
	};
	
	// Mostly just for testing and legacy API reasons
	exports.toComparators = toComparators;
	function toComparators(range, loose) {
	  return new Range(range, loose).set.map(function(comp) {
	    return comp.map(function(c) {
	      return c.value;
	    }).join(' ').trim().split(' ');
	  });
	}
	
	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	function parseComparator(comp, loose) {
	  debug('comp', comp);
	  comp = replaceCarets(comp, loose);
	  debug('caret', comp);
	  comp = replaceTildes(comp, loose);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, loose);
	  debug('xrange', comp);
	  comp = replaceStars(comp, loose);
	  debug('stars', comp);
	  return comp;
	}
	
	function isX(id) {
	  return !id || id.toLowerCase() === 'x' || id === '*';
	}
	
	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
	function replaceTildes(comp, loose) {
	  return comp.trim().split(/\s+/).map(function(comp) {
	    return replaceTilde(comp, loose);
	  }).join(' ');
	}
	
	function replaceTilde(comp, loose) {
	  var r = loose ? re[TILDELOOSE] : re[TILDE];
	  return comp.replace(r, function(_, M, m, p, pr) {
	    debug('tilde', comp, _, M, m, p, pr);
	    var ret;
	
	    if (isX(M))
	      ret = '';
	    else if (isX(m))
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    else if (isX(p))
	      // ~1.2 == >=1.2.0 <1.3.0
	      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	    else if (pr) {
	      debug('replaceTilde pr', pr);
	      if (pr.charAt(0) !== '-')
	        pr = '-' + pr;
	      ret = '>=' + M + '.' + m + '.' + p + pr +
	            ' <' + M + '.' + (+m + 1) + '.0';
	    } else
	      // ~1.2.3 == >=1.2.3 <1.3.0
	      ret = '>=' + M + '.' + m + '.' + p +
	            ' <' + M + '.' + (+m + 1) + '.0';
	
	    debug('tilde return', ret);
	    return ret;
	  });
	}
	
	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
	// ^1.2.3 --> >=1.2.3 <2.0.0
	// ^1.2.0 --> >=1.2.0 <2.0.0
	function replaceCarets(comp, loose) {
	  return comp.trim().split(/\s+/).map(function(comp) {
	    return replaceCaret(comp, loose);
	  }).join(' ');
	}
	
	function replaceCaret(comp, loose) {
	  debug('caret', comp, loose);
	  var r = loose ? re[CARETLOOSE] : re[CARET];
	  return comp.replace(r, function(_, M, m, p, pr) {
	    debug('caret', comp, _, M, m, p, pr);
	    var ret;
	
	    if (isX(M))
	      ret = '';
	    else if (isX(m))
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    else if (isX(p)) {
	      if (M === '0')
	        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	      else
	        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (pr.charAt(0) !== '-')
	        pr = '-' + pr;
	      if (M === '0') {
	        if (m === '0')
	          ret = '>=' + M + '.' + m + '.' + p + pr +
	                ' <' + M + '.' + m + '.' + (+p + 1);
	        else
	          ret = '>=' + M + '.' + m + '.' + p + pr +
	                ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        ret = '>=' + M + '.' + m + '.' + p + pr +
	              ' <' + (+M + 1) + '.0.0';
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0')
	          ret = '>=' + M + '.' + m + '.' + p +
	                ' <' + M + '.' + m + '.' + (+p + 1);
	        else
	          ret = '>=' + M + '.' + m + '.' + p +
	                ' <' + M + '.' + (+m + 1) + '.0';
	      } else
	        ret = '>=' + M + '.' + m + '.' + p +
	              ' <' + (+M + 1) + '.0.0';
	    }
	
	    debug('caret return', ret);
	    return ret;
	  });
	}
	
	function replaceXRanges(comp, loose) {
	  debug('replaceXRanges', comp, loose);
	  return comp.split(/\s+/).map(function(comp) {
	    return replaceXRange(comp, loose);
	  }).join(' ');
	}
	
	function replaceXRange(comp, loose) {
	  comp = comp.trim();
	  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
	  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    var xM = isX(M);
	    var xm = xM || isX(m);
	    var xp = xm || isX(p);
	    var anyX = xp;
	
	    if (gtlt === '=' && anyX)
	      gtlt = '';
	
	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // replace X with 0
	      if (xm)
	        m = 0;
	      if (xp)
	        p = 0;
	
	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        // >1.2.3 => >= 1.2.4
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else if (xp) {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm)
	          M = +M + 1;
	        else
	          m = +m + 1;
	      }
	
	      ret = gtlt + M + '.' + m + '.' + p;
	    } else if (xm) {
	      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
	    } else if (xp) {
	      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
	    }
	
	    debug('xRange return', ret);
	
	    return ret;
	  });
	}
	
	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	function replaceStars(comp, loose) {
	  debug('replaceStars', comp, loose);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp.trim().replace(re[STAR], '');
	}
	
	// This function is passed to string.replace(re[HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0
	function hyphenReplace($0,
	                       from, fM, fm, fp, fpr, fb,
	                       to, tM, tm, tp, tpr, tb) {
	
	  if (isX(fM))
	    from = '';
	  else if (isX(fm))
	    from = '>=' + fM + '.0.0';
	  else if (isX(fp))
	    from = '>=' + fM + '.' + fm + '.0';
	  else
	    from = '>=' + from;
	
	  if (isX(tM))
	    to = '';
	  else if (isX(tm))
	    to = '<' + (+tM + 1) + '.0.0';
	  else if (isX(tp))
	    to = '<' + tM + '.' + (+tm + 1) + '.0';
	  else if (tpr)
	    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
	  else
	    to = '<=' + to;
	
	  return (from + ' ' + to).trim();
	}
	
	
	// if ANY of the sets match ALL of its comparators, then pass
	Range.prototype.test = function(version) {
	  if (!version)
	    return false;
	
	  if (typeof version === 'string')
	    version = new SemVer(version, this.loose);
	
	  for (var i = 0; i < this.set.length; i++) {
	    if (testSet(this.set[i], version))
	      return true;
	  }
	  return false;
	};
	
	function testSet(set, version) {
	  for (var i = 0; i < set.length; i++) {
	    if (!set[i].test(version))
	      return false;
	  }
	
	  if (version.prerelease.length) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (var i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === ANY)
	        continue;
	
	      if (set[i].semver.prerelease.length > 0) {
	        var allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch)
	          return true;
	      }
	    }
	
	    // Version has a -pre, but it's not one of the ones we like.
	    return false;
	  }
	
	  return true;
	}
	
	exports.satisfies = satisfies;
	function satisfies(version, range, loose) {
	  try {
	    range = new Range(range, loose);
	  } catch (er) {
	    return false;
	  }
	  return range.test(version);
	}
	
	exports.maxSatisfying = maxSatisfying;
	function maxSatisfying(versions, range, loose) {
	  return versions.filter(function(version) {
	    return satisfies(version, range, loose);
	  }).sort(function(a, b) {
	    return rcompare(a, b, loose);
	  })[0] || null;
	}
	
	exports.minSatisfying = minSatisfying;
	function minSatisfying(versions, range, loose) {
	  return versions.filter(function(version) {
	    return satisfies(version, range, loose);
	  }).sort(function(a, b) {
	    return compare(a, b, loose);
	  })[0] || null;
	}
	
	exports.validRange = validRange;
	function validRange(range, loose) {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, loose).range || '*';
	  } catch (er) {
	    return null;
	  }
	}
	
	// Determine if version is less than all the versions possible in the range
	exports.ltr = ltr;
	function ltr(version, range, loose) {
	  return outside(version, range, '<', loose);
	}
	
	// Determine if version is greater than all the versions possible in the range.
	exports.gtr = gtr;
	function gtr(version, range, loose) {
	  return outside(version, range, '>', loose);
	}
	
	exports.outside = outside;
	function outside(version, range, hilo, loose) {
	  version = new SemVer(version, loose);
	  range = new Range(range, loose);
	
	  var gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break;
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break;
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"');
	  }
	
	  // If it satisifes the range it is not outside
	  if (satisfies(version, range, loose)) {
	    return false;
	  }
	
	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.
	
	  for (var i = 0; i < range.set.length; ++i) {
	    var comparators = range.set[i];
	
	    var high = null;
	    var low = null;
	
	    comparators.forEach(function(comparator) {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0')
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, loose)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, loose)) {
	        low = comparator;
	      }
	    });
	
	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false;
	    }
	
	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false;
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	exports.prerelease = prerelease;
	function prerelease(version, loose) {
	  var parsed = parse(version, loose);
	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var wrap = __webpack_require__(199).wrapMethod
	
	module.exports = initialize
	
	function initialize(agent, net) {
	  wrap(net.Server.prototype, 'net.Server.prototype', '_listen2', wrapListen2)
	  wrap(net.Socket.prototype, 'net.Socket.prototype', 'connect', wrapConnect)
	
	  function wrapListen2(original) {
	    return function wrappedListen2() {
	      var segment = agent.tracer.getSegment()
	      var emit = this.emit
	
	      if (!segment || !emit) return original.apply(this, arguments)
	
	      this.emit = wrappedEmit
	
	      return original.apply(this, arguments)
	
	      function wrappedEmit(ev, socket) {
	        if (ev !== 'connection' || !socket || !socket._handle) {
	          return emit.apply(this, arguments)
	        }
	
	        var child = agent.tracer.createSegment('net.Server.onconnection', null, segment)
	
	        if (socket._handle.onread) {
	          socket._handle.onread = agent.tracer.bindFunction(socket._handle.onread, child)
	        }
	
	        return agent.tracer.bindFunction(emit, child, true).apply(this, arguments)
	      }
	    }
	  }
	
	  function wrapConnect(original) {
	    return function connectWrapper() {
	      if (!agent.getTransaction()) return original.apply(this, arguments)
	      var socket = this
	      var args = normalizeConnectArgs(arguments)
	      return agent.tracer.addSegment(
	        'net.Socket.connect',
	        null,
	        null,
	        true,
	        wrappedConnect
	      )
	
	      function wrappedConnect(child) {
	        if (args[1]) args[1] = agent.tracer.bindFunction(args[1], child)
	        var result = original.apply(socket, args)
	        if (socket._handle) {
	          socket._handle.onread = agent.tracer.bindFunction(socket._handle.onread, child)
	        }
	        agent.tracer.bindEmitter(socket, child)
	        return result
	      }
	    }
	  }
	}
	
	// taken from node master on 2013/10/30
	function normalizeConnectArgs(args) {
	  var options = {}
	
	  function toNumber(x) {
	    return (x = Number(x)) >= 0 ? x : false
	  }
	  if (typeof args[0] === 'object' && args[0] !== null) {
	    // connect(options, [cb])
	    options = args[0]
	  } else if (typeof args[0] === 'string' && toNumber(args[0]) === false) {
	    // connect(path, [cb]);
	    options.path = args[0]
	  } else {
	    // connect(port, [host], [cb])
	    options.port = args[0]
	    if (typeof args[1] === 'string') {
	      options.host = args[1]
	    }
	  }
	
	  var cb = args[args.length - 1]
	  return typeof cb === 'function' ? [options, cb] : [options]
	}


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict'
	
	var wrap = __webpack_require__(199).wrapMethod
	var semver = __webpack_require__(214)
	
	module.exports = initialize
	
	function initialize(agent, timers) {
	  // As of iojs 1.6.3 all timers are on the global object, and do
	  // not need a require('timers') call to access them
	  if (timers !== global && semver.satisfies(process.version, '>=1.6.3') &&
	      global.setTimeout && !global.setTimeout.__NR_original) {
	    initialize(agent, global)
	  }
	
	  var processMethods = ['nextTick', '_nextDomainTick', '_tickDomainCallback']
	
	  wrap(process, 'process', processMethods, function bindProcess(original, method) {
	    return agent.tracer.wrapFunctionFirstNoSegment(original, method)
	  })
	
	  var asynchronizers = [
	    'setTimeout',
	    'setInterval'
	  ]
	
	  wrap(timers, 'timers', asynchronizers, function wrapTimers(original, method) {
	    return agent.tracer.wrapFunctionFirst('timers.' + method, null, original)
	  })
	
	  // We don't want to create segments for setImmediate calls, as the
	  // object allocation may incur too much overhead in some situations
	  var uninstrumented = [
	    'setImmediate'
	  ]
	
	  wrap(timers, 'timers', uninstrumented, function wrapUninstrumented(original, method) {
	    return agent.tracer.wrapFunctionFirstNoSegment(original, method)
	  })
	
	  var clearTimeouts = ['clearTimeout']
	
	  wrap(timers, 'timers', clearTimeouts, function wrapClear(original) {
	    return function wrappedClear(timer) {
	      var segment
	      if (timer && timer._onTimeout) {
	        segment = agent.tracer.getSegmentFromWrapped(timer._onTimeout)
	        timer._onTimeout = agent.tracer.getOriginal(timer._onTimeout)
	      }
	
	      if (timer && timer._onImmediate) {
	        timer._onImmediate = agent.tracer.getOriginal(timer._onImmediate)
	      }
	
	      if (segment) segment.ignore = true
	
	      return original.apply(this, arguments)
	    }
	  })
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(11)))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var wrap = __webpack_require__(199).wrapMethod
	
	module.exports = initialize
	
	var methods = [
	  'deflate',
	  'deflateRaw',
	  'gzip',
	  'gunzip',
	  'inflate',
	  'inflateRaw',
	  'unzip'
	]
	
	function initialize(agent, zlib) {
	  var noSegment = agent.tracer.wrapFunctionNoSegment.bind(agent.tracer)
	  if (zlib.Deflate && zlib.Deflate.prototype) {
	    var proto = Object.getPrototypeOf(zlib.Deflate.prototype)
	    if (proto._transform) {
	      // streams2
	      wrap(proto, 'zlib', '_transform', noSegment)
	    } else if (proto.write && proto.flush && proto.end) {
	      // plain ol' streams
	      wrap(proto, 'zlib', ['write', 'flush', 'end'], noSegment)
	    }
	  }
	
	  wrap(zlib, 'zlib', methods, segment)
	
	  function segment(fn, method) {
	    return agent.tracer.wrapFunctionLast('zlib.' + method, null, fn)
	  }
	}


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var shimmer = __webpack_require__(199)
	var logger = __webpack_require__(12).child({component: 'director'})
	var NAMES = __webpack_require__(59)
	
	function nameTransaction(segment, partialName, res) {
	  if (!segment) return logger.error("No New Relic context to set Director route name on.")
	  if (!partialName) return logger.error("No partialName to use for naming.")
	  if (res.finished) return // no need to update transaction name if response has ended
	
	  var transaction = segment.transaction
	  var nameState = transaction.nameState
	
	  if (res.__NR_directored) { // not first route
	    nameState.pathStack.pop() // replace latest path name, preserving the last path name
	  }
	  nameState.appendPath(partialName)
	
	  nameState.setVerb(transaction.verb)
	  nameState.setDelimiter(NAMES.ACTION_DELIMITER) 
	  res.__NR_directored = true
	}
	
	module.exports = function initialize(agent, director) {
	  var tracer = agent.tracer
	
	  shimmer.wrapMethod(
	    director.Router.prototype,
	    'director.Router.prototype',
	    'mount',
	    function wrapMount(mount) {
	      return function wrappedMount(routes, path) {
	        if (!routes) {
	          return mount.call(this, routes, path)
	        }
	
	        Object.keys(director.http.methods).forEach(function wrapMethod(methodKey) {
	          var method = director.http.methods[methodKey]
	          if (routes[method]) { // method exists as attribute
	            var route = routes[method] // wrapping associated cb function
	            routes[method] = createWrapped(method, path, route)
	          }
	        })
	
	        function createWrapped(method, path, route) {
	          if (route.__NR_original) {
	            route = route.__NR_original
	          } 
	
	          var wrapped = function wrappedRoute() {
	            var transaction = tracer.getTransaction()
	            if (!transaction) {
	              return route.apply(this, arguments)
	            }
	
	            var response = this.res // hang directored attr, and check if res is finished
	
	            var pathName = path.join('/')
	            var partialName = pathName
	            var segment = tracer.createSegment('Function/' + (route.name || "anonymous"))
	            
	            nameTransaction(tracer.segment, partialName, response)
	            return tracer.bindFunction(route, segment, true).apply(this, arguments)
	          }
	
	          wrapped.__NR_original = route
	          return wrapped
	        }
	
	        return mount.call(this, routes, path)
	      }
	    }
	  )
	
	  shimmer.wrapMethod(
	    director.Router.prototype,
	    'director.Router.prototype',
	    ['on', 'route'],
	    function wrapOn(on) {
	      return function wrappedOn(method, path, route) {
	        // if we are handed unexpected argument types pass them through
	        // and let director handle the error case
	        if (!route) {
	          return on.call(this, method, path, route)
	        }
	
	        var partialName = this.scope.join('/') + path
	
	        if (route.__NR_original) {
	          route = route.__NR_original
	        } 
	
	        var wrapped = function wrappedRoute() {
	          var transaction = tracer.getTransaction()
	          if (!transaction) {
	            return route.apply(this, arguments)
	          }
	
	          var response = this.res // hang directored attr, and check if res is finished
	
	          var segment = tracer.createSegment('Function/' + (route.name || "anonymous"))
	          nameTransaction(tracer.segment, partialName, response)
	          return tracer.bindFunction(route, segment, true).apply(this, arguments)
	        }
	
	        wrapped.__NR_original = route
	
	        return on.call(this, method, path, wrapped)
	      }
	    }
	  )
	}


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var shimmer = __webpack_require__(199)
	var urltils = __webpack_require__(168)
	var logger = __webpack_require__(12).child({component: 'express'})
	var record = __webpack_require__(207)
	var middlewareRecorder = __webpack_require__(220)
	var NAMES = __webpack_require__(59)
	
	var express2 = __webpack_require__(221)
	var ensurePartialName = __webpack_require__(222).ensurePartialName
	
	var VIEW = NAMES.VIEW
	var ORIGINAL = '__NR_original'
	var RESERVED = [ // http://es5.github.io/#x7.6.1.2
	  // always (how would these even get here?)
	  'class', 'enum', 'extends', 'super', 'const', 'export', 'import',
	  // strict
	  'implements', 'let', 'private', 'public', 'yield', 'interface',
	  'package', 'protected', 'static'
	]
	
	/**
	 * ES5 strict mode disallows some identifiers that are allowed in non-strict
	 * code. Mangle function names that are on that list of keywords so they're
	 * non-objectionable in strict mode (which is currently enabled everywhere
	 * inside the agent, as well as at many customer sites).
	 *
	 * If you really need to crawl your Express apps middleware stack, change
	 * your test to use name.indexOf('whatever') === 0 as the predicate instead
	 * of name === 'whatever'. It's a little slower, but you shouldn't be doing
	 * that anyway.
	 *
	 * @param {string} name The candidate function name
	 *
	 * @returns {string} A safe (potentially mangled) function name.
	 */
	function mangle(name) {
	  var parts = name.split(' ')
	  name = parts[parts.length - 1]
	
	  if (RESERVED.indexOf(name) !== -1) return name + '_'
	
	  return name
	}
	
	
	function generateMiddlewarePath(routerStack, layer) {
	  var res = ''
	  for (var i = 0; i < routerStack.length; ++i) {
	    appendToPath(routerStack[i].path)
	  }
	
	  if (layer && layer.handle && layer.handle.__NR_path) {
	    appendToPath(layer.handle.__NR_path)
	    if (res[res.length - 1] === '/') {
	      res = res.substr(0, res.length - 1)
	    }
	  }
	
	  return res || '/'
	
	  function appendToPath(path) {
	    if (!path) return
	
	    var resTrailingSlash = res[res.length - 1] === '/'
	    if (path[0] === '/') {
	      path = path.substr(1)
	    }
	
	    if (resTrailingSlash) {
	      res += path
	    } else {
	      res += '/' + path
	    }
	  }
	}
	
	
	var transactionInfoById = {}
	function onTransactionFinished(transaction) {
	  delete transactionInfoById[transaction.id]
	}
	
	module.exports = function initialize(agent, express) {
	  var tracer = agent.tracer
	
	  var registered =
	    agent.listeners('transactionFinished')
	    .indexOf(onTransactionFinished) !== -1
	
	  if (!registered) {
	    agent.on('transactionFinished', onTransactionFinished)
	  }
	
	  function setDispatcher(app) {
	    return function wrappedCreateServer() {
	      agent.environment.setDispatcher('express')
	      agent.environment.setFramework('express')
	
	      return app.apply(this, arguments)
	    }
	  }
	
	  /**
	   * This needs to be kept up to date with Express to ensure that it's using
	   * the same logic to decide where the callback is hiding.
	   */
	  function wrapRender(version, render) {
	    /* jshint maxparams:5 */ // follow Express as closely as possible
	    return function cls_wrapRender(view, options, cb, parent, sub) {
	      logger.trace("Rendering Express %d view %s.", version, view)
	      if (!tracer.getTransaction()) {
	        logger.trace(
	          'Express %d view %s rendered outside transaction, not measuring.',
	          version,
	          view
	        )
	        return render.apply(this, arguments)
	      }
	
	      var name = VIEW.PREFIX + view + VIEW.RENDER
	      var segment = tracer.createSegment(name, record)
	      var wrapped
	
	
	      if (typeof options === 'function') {
	        cb = options
	        options = null
	      }
	
	      if (cb === null || cb === undefined) {
	        /* CAUTION: Need this to generate a metric, but adding a callback
	         * changes Express's control flow.
	         */
	        wrapped = tracer.bindFunction(function syntheticCallback(err, rendered) {
	          if (err) {
	            segment.end()
	            logger.trace(err,
	                         "Express %d rendering for metric %s failed for transaction %s:",
	                         version,
	                         name,
	                         segment.transaction.id)
	
	            return this.req.next(err)
	          }
	
	          segment.end()
	          var returned = this.send(rendered)
	
	          logger.trace("Rendered Express %d view with metric %s for transaction %s.",
	                       version,
	                       name,
	                       segment.transaction.id)
	
	          return returned
	        }.bind(this))
	      } else {
	        wrapped = tracer.bindFunction(function renderWrapper() {
	          segment.end()
	          var returned = cb.apply(this, arguments)
	
	          return returned
	        }, segment)
	      }
	
	      return render.call(this, view, options, wrapped, parent, sub)
	    }
	  }
	
	
	  // wrap express.Router.process_params() in order to get to the Layer class, which
	  // we need to wrap
	  function wrapProcessParams(version, process_params) {
	    return function cls_wrapProcessParams(layer) {
	      var transaction = tracer.getTransaction()
	      if (!transaction) {
	        logger.trace(
	          'Express %d router called outside transaction (wrapProcessParams).',
	          version
	        )
	        return process_params.apply(this, arguments)
	      }
	
	      // process_params is the first place (I think) where we have access to a Layer
	      // instance.  Layer is basically the interface for (req, res, next) - could be
	      // a container for actual route handler, or an instance of Router, or an instance
	      // of an Express sub-app.
	      // Layers are called in the order they are defined.  The method
	      // Layer.handle_request(req, res, next) is the method called in the chain.
	      // If we wrap it, we know exactly when each handler in the chain is called. Based on
	      // that we can build the path from nested route handlers.
	      if (layer) {
	        if (layer.constructor) {
	          var layerProto = layer.constructor.prototype
	          if (
	            layerProto.handle_request &&
	            !shimmer.isWrapped(layerProto.handle_request)
	          ) {
	            shimmer.wrapMethod(layerProto,
	                              'express.Layer',
	                              'handle_request',
	                              wrapLayerHandleRequest)
	          }
	          if (
	            layerProto.handle_error &&
	            !shimmer.isWrapped(layerProto.handle_error)
	          ) {
	            shimmer.wrapMethod(layerProto,
	                              'express.Layer',
	                              'handle_error',
	                              wrapLayerHandleError)
	          }
	        }
	      }
	
	      function wrapLayerHandleError(handleError) {
	        return function wrappedLayerHandleError(error, req, res, next) {
	          var parent = tracer.segment
	          if (!parent) {
	            return handleError.apply(this, arguments)
	          }
	
	          var transaction = parent.transaction
	
	          if (!transaction.isActive()) {
	            return handleError.apply(this, arguments)
	          }
	
	          var transactionInfo = getTransactionInfo(transaction)
	
	          if (agent.config.feature_flag.express_segments) {
	            var handlerName = (this.handle.name || 'anonymous')
	            if (this.handle.length === 4) {
	              var prefix = NAMES.EXPRESS.ERROR_HANDLER
	              var segment = tracer.createSegment(prefix + handlerName, record)
	
	              logger.trace(
	                'Creating segment for middleware %s. Transaction id: %s, name: %s',
	                segment.name,
	                transaction.id,
	                transaction.nameState.getName()
	
	              )
	
	              if (segment) {
	                segment.start()
	              }
	            }
	
	            transactionInfo.lastMiddlewareSegment = segment
	          }
	
	          if (next) {
	            arguments[3] = endErrorHandlerRecorder
	          }
	
	          this.__NR_parent = parent
	
	          handleError.apply(this, arguments)
	
	          function endErrorHandlerRecorder() {
	            if (parent.transaction.isActive()) {
	              tracer.segment = parent
	            }
	
	            if (agent.config.feature_flag.express_segments) {
	              if (segment && segment.transaction.isActive()) {
	                segment.end()
	              }
	            }
	            next.apply(this, arguments)
	          }
	        }
	      }
	
	      function wrapLayerHandleRequest(handleRequest) {
	        return function wrappedLayerHandleRequest(req, res, next) {
	          var segment
	          var parent = tracer.getSegment()
	          if (!parent) {
	            return handleRequest.apply(this, arguments)
	          }
	
	          var transaction = parent.transaction
	          var transactionInfo = getTransactionInfo(transaction)
	
	          if (!transaction.isActive()) {
	            return handleRequest.apply(this, arguments)
	          }
	
	          var isErrorHandler = (this.handle.length === 4)
	          var isMountedApp = (this.name === 'mounted_app' ||
	                              (this.handle != null && this.handle.lazyrouter != null))
	          var isRouter = (this.handle[ORIGINAL] != null && this.handle[ORIGINAL].stack) ||
	                          this.handle.stack != null
	          var isRoute = (this.route != null)
	          var stack = (this.handle &&
	                        (this.handle[ORIGINAL] && this.handle[ORIGINAL].stack) ||
	                          this.handle.stack) ||
	                      (this.route && this.route.stack)
	
	          var routerStack = transactionInfo.routerStack
	          if (agent.config.feature_flag.express_segments) {
	            var parentSegment
	            if (routerStack.length > 0) {
	              parentSegment = routerStack[routerStack.length - 1].segment
	            }
	
	            if (!isErrorHandler) {
	              var segmentName
	              var recorder
	
	              if (isMountedApp) {
	                segmentName = NAMES.EXPRESS.PREFIX + 'Mounted App: ' +
	                  this.handle.__NR_path
	              } else if (isRouter) {
	                segmentName = NAMES.EXPRESS.PREFIX + 'Router: '
	                if (this.handle.__NR_path) {
	                  segmentName += this.handle.__NR_path
	                } else {
	                  segmentName += '/'
	                }
	              } else if (isRoute) {
	                segmentName = NAMES.EXPRESS.PREFIX + 'Route Path: ' +
	                  this.handle.__NR_path
	              } else {
	                var middlewareName = (this.handle.name || 'anonymous')
	                segmentName = NAMES.EXPRESS.MIDDLEWARE + middlewareName
	                var middlewarePath = generateMiddlewarePath(routerStack, this)
	                recorder = middlewareRecorder.bind(null, middlewarePath)
	              }
	
	              segment = tracer.createSegment(segmentName, recorder, parentSegment)
	
	              logger.trace(
	                'Creating segment for middleware %s. Transaction id: %s, name: %s',
	                segment.name,
	                transaction.id,
	                transaction.nameState.getName()
	              )
	
	              tracer.segment = segment
	              segment.start()
	            }
	          }
	          // END FEATURE FLAG
	
	          if (isRouter || isRoute) {
	            routerStack.push({
	              length: stack.length,
	              path: this.handle.__NR_path,
	              segment: segment
	            })
	          } else if (isMountedApp) {
	            routerStack.push({
	              length: null,
	              path: this.handle.__NR_path,
	              segment: segment
	            })
	          } else {
	            transactionInfo.lastMiddlewareSegment = segment
	          }
	
	          // call cleanup before next middleware function in order to restore
	          // transaction.partialName
	          if (next) {
	            arguments[2] = cleanup
	          }
	
	          this.__NR_parent = parent
	
	          return handleRequest.apply(this, arguments)
	
	          function cleanup() {
	            var parentRouter
	            if (!transactionInfo.responded && routerStack.length > 0) {
	              parentRouter = routerStack[routerStack.length - 1]
	              if (isMountedApp || isRouter || isRoute) {
	                routerStack.pop()
	              }
	            }
	
	            // end current middleware segment
	            if (agent.config.feature_flag.express_segments) {
	              if (segment) {
	                segment.end()
	              }
	
	              if (parentRouter) {
	                parentRouter.segment.touch()
	              }
	            }
	
	            // restore previous segment
	            if (parent.transaction.isActive()) {
	              tracer.segment = parent
	            }
	
	            next.apply(this, arguments)
	          }
	        }
	      }
	
	      return process_params.apply(this, arguments)
	    }
	  }
	
	  /**
	   * Problem:
	   *
	   * 1. Express determines whether middleware functions are error handlers by
	   *    testing their arity. Not cool.
	   * 2. Downstream Express users rely upon being able to iterate over their
	   *    middleware stack to find specific middleware functions. Sorta less
	   *    uncool, but still a pain.
	   *
	   * Solution:
	   *
	   * Use eval. This once. For this one specific purpose. Not anywhere else for
	   * any reason.
	   */
	  function wrapHandle(__NR_handle, path) {
	    var name = ''
	    var arglist
	
	    // reiterated: testing function arity is stupid
	    switch (__NR_handle.length) {
	      case 2:
	        arglist = '(req, res)'
	        break
	
	      case 3:
	        arglist = '(req, res, next)'
	        break
	
	      // don't break other error handlers
	      case 4:
	        arglist = '(err, req, res, next)'
	        break
	
	      default:
	        arglist = '()'
	    }
	
	    if (__NR_handle.name) name = mangle(__NR_handle.name)
	
	    // All closure scope variables used in templates must be passed
	    // in as formal arguments to the wrapped function constructor
	
	    /* eslint-disable func-names */
	    /* eslint-disable no-undef */
	    var routerTemplate = function() {
	      return wrappedHandle.call(layer, path, __NR_handle, [].slice.call(arguments))
	    }
	    /* eslint-enable no-undef */
	    /* eslint-enable func-names */
	
	    // I am a bad person and this makes me feel bad.
	    // We use eval because we need to insert the function with a specific
	    // name to allow for lookup.
	    /* eslint-disable no-new-func */
	    var wrapped = new Function(
	      'tracer', '__NR_handle', 'wrappedHandle', 'path', 'layer',
	      'return function ' + name + arglist + routerTemplate.toString().substring(11)
	    )(tracer, __NR_handle, wrappedHandle, path, this)
	    /* eslint-enable no-new-func */
	
	    wrapped[ORIGINAL] = __NR_handle
	
	    // pull the attributes from the original handle up to the wrapped one
	    var handleKeys = Object.keys(__NR_handle)
	    for (var i = 0; i < handleKeys.length; i++) {
	      var key = handleKeys[i]
	      wrapped[key] = __NR_handle[key]
	    }
	
	    wrapped.__NR_path = path
	    return wrapped
	  }
	
	  function wrapMiddlewareStack(route, original) {
	    return function cls_wrapMiddlewareStack() {
	      /* We allow `use` to go through the arguments so it can reject bad things
	       * for us so we don't have to also do argument type checking.
	       */
	
	      var app = original.apply(this, arguments)
	      var path = typeof arguments[0] === 'string' ? arguments[0] : '/'
	      if (arguments[0] instanceof RegExp) {
	        path = arguments[0].toString()
	      }
	
	      /* Express adds routes to the same stack as middleware. We need to wrap
	       * that adder too but we only want to wrap the middleware that are
	       * added, not the Router.
	       */
	      // wrap most recently added unwrapped handler
	      var i = this.stack.length
	      var top
	      /* eslint-disable no-cond-assign */
	      while (top = this.stack[--i]) {
	        if (!top.handle || typeof top.handle !== 'function' || top.handle[ORIGINAL]) {
	          break
	        }
	
	        top.handle = wrapHandle.call(top, top.handle, path)
	      }
	      /* eslint-enable no-cond-assign */
	
	      return app
	    }
	  }
	
	  function wrappedHandle(path, handle, args) {
	    var transaction = agent.tracer.getTransaction()
	
	    if (!transaction) {
	      logger.trace(
	        'Express %d handle for path %s called outside transaction (wrappedHandle).',
	        version,
	        path
	      )
	      return handle.apply(this, args)
	    }
	
	    var isErrorHandler = handle.length === 4
	    var transactionInfo = getTransactionInfo(transaction)
	
	    var req = args[0]
	    var isRouter = this.handle[ORIGINAL] != null && this.handle[ORIGINAL].stack ||
	                   this.handle.stack != null
	    var isRoute = this.route != null
	    var segment = this.__NR_parent || tracer.getSegment()
	
	    if (req && segment && (isRoute || isRouter)) {
	      if (req.params) {
	        // Express 4.3.0 changed where params live. On newer versions of Express
	        // params should be populated, on older it shouldn't be.
	        urltils.copyParameters(
	          transaction.agent.config,
	          req.params,
	          segment.parameters
	        )
	      }
	    }
	
	    if (!transactionInfo.error || transactionInfo.errorHandled) {
	      ensurePartialName(transaction)
	      transaction.nameState.appendPath(path)
	    }
	
	    // Update the namestate if we have a callback that we can unwind with.
	    var last = args.length - 1
	    var cb = args[last]
	
	    if (cb instanceof Function) {
	      if (isErrorHandler && transactionInfo.error) {
	        transactionInfo.errorHandled = true
	      }
	
	      args[last] = function wrappedHandleCallback(err) {
	        // if an error is passed to the next function, we do not want
	        // to mutate the name path so the transaction will be named
	        // after the location the error was generated.
	        if (err && err !== 'route') {
	          transactionInfo.error = err
	        } else if (!transactionInfo.responded) {
	          transaction.nameState.popPath(path)
	          transaction.nameState.appendPathIfEmpty('/')
	        }
	        return cb.apply(this, arguments)
	      }
	    }
	
	    // wrap res.end to mark the transaction as responded
	    var res = args[1]
	
	    if (res && res.end && !res.end[ORIGINAL]) {
	      var oldEnd = res.end
	
	      res.end = function wrappedEnd() {
	        // end the current middleware segment
	        if (transactionInfo.lastMiddlewareSegment) {
	          transactionInfo.lastMiddlewareSegment.end()
	        }
	
	        // end all router segments
	        var routerStack = transactionInfo.routerStack
	        if (routerStack.length > 0) {
	          for (var i = (routerStack.length - 1); i >= 0; i--) {
	            if (routerStack[i].segment) {
	              routerStack[i].segment.end()
	            }
	          }
	        }
	        transactionInfo.responded = true
	
	        var err = transactionInfo.error
	        var errHandled = transactionInfo.errorHandled
	        var isHttpError = urltils.isError(agent.config, this.statusCode)
	        // report error if it was not handled by an error handler, or when
	        // the status code is an HTTP error (more useful to report the actual error
	        // than a generic HTTP status error)
	        if (err && (!errHandled || isHttpError)) {
	          agent.errors.add(transaction, err)
	        }
	
	        logger.trace(
	          'res.end called, transaction id: %s, name: %s.',
	          transaction.id,
	          transaction.nameState.getName()
	        )
	
	        return oldEnd.apply(res, arguments)
	      }
	
	      res.end[ORIGINAL] = oldEnd
	    }
	
	
	    return handle.apply(this, args)
	  }
	
	  function wrapParamware(param) {
	    return function wrappedParam(paramName, fn) {
	      if (fn instanceof Function && typeof paramName === 'string') {
	        return param.call(this, paramName, paramwareWrapper)
	      }
	      return param.apply(this, arguments)
	
	      /* eslint-disable no-unused-vars */
	      function paramwareWrapper(req, res, next, value, name) {
	        /* eslint-enable no-unused-vars */
	        // Make sure we are correct about which parameter is the callback and
	        // that we have a transaction which is currently active!
	        var transaction = tracer.getTransaction()
	        if (!(next instanceof Function && transaction)) {
	          return fn.apply(this, arguments)
	        }
	
	        // Create the param handler segment.
	        transaction.nameState.appendPath('[param handler :' + paramName + ']')
	        var transactionInfo = getTransactionInfo(transaction)
	        var middlewarePath = generateMiddlewarePath(transactionInfo.routerStack, this)
	        var recorder = middlewareRecorder.bind(null, middlewarePath)
	        var segmentName = NAMES.EXPRESS.PREFIX + 'Param Handler: ' + paramName
	        var segment = tracer.createSegment(segmentName, recorder)
	
	        // Out of an excess of caution, make sure the segment was actually
	        // created. In theory since we have an active transaction this should
	        // not fail, but I don't trust anything anymore.
	        if (!segment) {
	          return fn.apply(this, arguments)
	        }
	        transactionInfo.lastMiddlewareSegment = segment
	
	        // Wrap next with some cleanup.
	        var args = tracer.slice(arguments)
	        args[2] = tracer.bindFunction(function wrappedNext() {
	          segment.touch()
	          transaction.nameState.popPath()
	          return next.apply(this, arguments)
	        }, segment)
	
	        // Call the paramware.
	        segment.start()
	        return tracer.bindFunction(fn, segment).apply(this, args)
	      }
	    }
	  }
	
	  function getTransactionInfo(transaction) {
	    if (!transactionInfoById[transaction.id]) {
	      transactionInfoById[transaction.id] = {
	        // since Layer.handleRequest isn't scoped to a transaction we need to
	        // track the transaction state outside in these maps.
	
	        // routerStacks is transaction.id -> a stack of the last seen routers
	        // and their segments. this is for reconstructing the call tree while
	        // we traverse using next
	        routerStack: [],
	
	        // if a handler responds asynchronously and calls next synchronously,
	        // which is the usual case, we will incorrectly name the segment as a
	        // middleware rather than a responder.  this tracks whether a response
	        // has gone out for the transaction yet.
	        responded: false,
	
	        // we don't want to send errors that a user is handling themselves, so
	        // we stash the errors we see for a transaction till we know they
	        // aren't handling it themselves
	        error: null,
	
	        // if we see an error handler in the middleware tree we consider the
	        // error handled
	        errorHandled: false,
	
	        // when res.end() is called from a middleware handler, we need to end
	        // the middleware segment that contains it
	        lastMiddlewareSegment: null
	      }
	    }
	    return transactionInfoById[transaction.id]
	  }
	
	  /**
	   * Major versions of express have very different factoring,
	   * even though the core instrumentation is the same.
	   */
	  var version = express && express.version && express.version[0]
	
	  /* TJ decided he didn't want to deal with the hassle of updating a
	   * version field. Thanks, TJ!
	   */
	  if (!version && express && express.application &&
	      express.application.init && express.response &&
	      express.response.render && express.Router &&
	      express.Router.prototype.matchRequest) {
	    version = '3'
	  } else if (!version && express && express.application &&
	           express.application.init && express.response &&
	           express.response.render && express.Router &&
	           express.Router.process_params && express.application.del) {
	    version = '4'
	  } else if (!version && express && express.application &&
	             !express.application.del) {
	    version = '5'
	  }
	
	  switch (version) {
	    case '2':
	      /* Express 2 doesn't directly expose its Router constructor, so create an
	       * app and grab the constructor off it. Do it before instrumenting
	       * createServer so the agent doesn't automatically set the dispatcher
	       * to Express.
	       */
	      var oneoff = express.createServer()
	      var Router = oneoff.routes.constructor
	
	
	      shimmer.wrapMethod(express,
	                         'express',
	                         'createServer',
	                         setDispatcher)
	
	      /* Express 2 squirts its functionality directly onto http.ServerResponse,
	       * leaving no clean way to wrap its functionality without pulling in the
	       * http module ourselves.
	       */
	      var http = __webpack_require__(101)
	      shimmer.wrapMethod(http.ServerResponse.prototype,
	                         'http.ServerResponse.prototype',
	                         'render',
	                         wrapRender.bind(null, 2))
	
	      shimmer.wrapMethod(Router.prototype,
	                         'Router.prototype',
	                         '_match',
	                         express2.wrapMatchRequest.bind(null, tracer, 2))
	      break
	
	    case '3':
	      shimmer.wrapMethod(express.application,
	                         'express.application',
	                         'init',
	                         setDispatcher)
	
	      shimmer.wrapMethod(express.response,
	                         'express.response',
	                         'render',
	                         wrapRender.bind(null, 3))
	
	      shimmer.wrapMethod(express.Router.prototype,
	                         'express.Router.prototype',
	                         'matchRequest',
	                         express2.wrapMatchRequest.bind(null, tracer, 3))
	
	      shimmer.wrapMethod(express.Router,
	                         'express.Router',
	                         'param',
	                         wrapParamware)
	      break
	
	    case '4':
	      shimmer.wrapMethod(express.application,
	                         'express.application',
	                         'init',
	                         setDispatcher)
	
	      shimmer.wrapMethod(express.response,
	                         'express.response',
	                         'render',
	                         wrapRender.bind(null, 4))
	
	      shimmer.wrapMethod(express.Router,
	                         'express.Router',
	                         'process_params',
	                         wrapProcessParams.bind(null, 4))
	
	      shimmer.wrapMethod(express.Router,
	                         'express.Router',
	                         'use',
	                         wrapMiddlewareStack.bind(null, false))
	
	      shimmer.wrapMethod(express.Router,
	                         'express.Router',
	                         'route',
	                         wrapMiddlewareStack.bind(null, true))
	
	      shimmer.wrapMethod(express.Router,
	                         'express.Router',
	                         'param',
	                         wrapParamware)
	
	      break
	    case '5':
	      // FLAG: express5 instrumentation
	      if (agent.config.feature_flag.express5) {
	        shimmer.wrapMethod(express.application,
	                          'express.application',
	                          'init',
	                          setDispatcher)
	
	        shimmer.wrapMethod(express.response,
	                          'express.response',
	                          'render',
	                          wrapRender.bind(null, 5))
	
	        shimmer.wrapMethod(express.Router.prototype,
	                          'express.Router.prototype',
	                          'process_params',
	                          wrapProcessParams.bind(null, 5))
	
	        shimmer.wrapMethod(express.Router.prototype,
	                          'express.Router.prototype',
	                          'use',
	                          wrapMiddlewareStack.bind(null, false))
	
	        shimmer.wrapMethod(express.Router.prototype,
	                          'express.Router.prototype',
	                          'route',
	                          wrapMiddlewareStack.bind(null, true))
	
	        shimmer.wrapMethod(express.Router,
	                           'express.Router',
	                           'param',
	                           wrapParamware)
	      }
	      break
	    default:
	      logger.warn("Unrecognized version %s of Express detected; not instrumenting",
	                  version)
	  }
	}


/***/ },
/* 220 */
/***/ function(module, exports) {

	'use strict'
	
	function record(path, segment, scope) {
	  var duration = segment.getDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var transaction = segment.transaction
	
	  var metricName = segment.name + '/' + path
	
	  if (scope) transaction.measure(metricName, scope, duration, exclusive)
	
	  transaction.measure(metricName, null, duration, exclusive)
	}
	
	module.exports = record


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'express'})
	var urltils = __webpack_require__(168)
	var ensurePartialName = __webpack_require__(222).ensurePartialName
	var NAMES = __webpack_require__(59)
	
	
	module.exports.wrapMatchRequest = wrapMatchRequest
	
	
	function wrapMatchRequest(tracer, version, original) {
	  return function cls_wrapMatchRequest() {
	    if (!tracer.getTransaction()) {
	      logger.trace(
	        'Express %d router called outside transaction (wrapMatchRequest).',
	        version
	      )
	      return original.apply(this, arguments)
	    }
	    var route = original.apply(this, arguments)
	
	    nameFromRoute(tracer.getSegment(), route)
	    return route
	  }
	}
	
	function nameFromRoute(segment, route, params, append) {
	  if (!segment) return logger.error("No New Relic context to set Express route name on.")
	  if (!route) return logger.debug("No Express route to use for naming.")
	
	  params = route.params
	
	  var trans = segment.transaction
	  var path = route.path || route.regexp
	
	  if (!path) return logger.debug({route: route}, "No path found on Express route.")
	
	  // when route is a regexp, route.path will be a regexp
	  if (path instanceof RegExp) path = path.source
	
	  urltils.copyParameters(trans.agent.config, params, segment.parameters)
	
	  if (append) {
	    ensurePartialName(trans)
	    trans.nameState.appendPath(path)
	  } else {
	    trans.nameState.setName(
	      NAMES.EXPRESS.PREFIX, 
	      trans.verb, 
	      NAMES.ACTION_DELIMITER,
	      path
	    )
	  }
	}


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var NAMES = __webpack_require__(59)
	
	
	module.exports.ensurePartialName = ensurePartialName
	
	
	// Ensures that partialName begins with the express prefix
	// http instrumentation will set partialName before passing the request off to express
	function ensurePartialName(trans) {
	  if (trans.nameState.getName() == null ||
	      trans.nameState.prefix !== NAMES.EXPRESS.PREFIX) {
	    trans.nameState.setPrefix(NAMES.EXPRESS.PREFIX)
	    trans.nameState.setVerb(trans.verb)
	    trans.nameState.setDelimiter(NAMES.ACTION_DELIMITER)
	  }
	}


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var shimmer = __webpack_require__(199)
	
	
	module.exports = function initialize(agent, generic) {
	  shimmer.wrapMethod(generic, 'generic-pool', 'Pool', function cb_wrapMethod(Pool) {
	    return function cls_wrapMethod() {
	      var pooler = Pool.apply(this, arguments)
	
	      shimmer.wrapMethod(pooler, 'Pool', 'acquire', function cb_wrapMethod(acquire) {
	        return function propagateTransactionThroughPool(callback, priority) {
	          if (typeof callback === 'function') {
	            /* See adjustCallback in generic-pool.js for the motivation behind
	             * this grotesque hack. Tl;dr: depending on Function.length is evil.
	             */
	            var proxied = agent.tracer.bindFunction(callback)
	            switch (callback.length) {
	              case 2:
	                callback = function moveAlongNothingToSeeHere(error, client) {
	                  return proxied.call(this, error, client)
	                }
	                break
	              case 1:
	                callback = function moveAlongNothingToSeeHere(client) {
	                  return proxied.call(this, client)
	                }
	                break
	              default:
	                callback = proxied
	            }
	          }
	
	          return acquire.call(this, callback, priority)
	        }
	      })
	
	      return pooler
	    }
	  })
	}


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var shimmer = __webpack_require__(199)
	var urltils = __webpack_require__(168)
	var logger = __webpack_require__(12).child({component: 'hapi'})
	var record = __webpack_require__(207)
	var NAMES = __webpack_require__(59)
	var VIEW = NAMES.VIEW
	
	
	function nameFromRequest(segment, request) {
	  if (!segment) return logger.error("No New Relic context to set Hapi route name on.")
	  if (!request) return logger.debug("No Hapi request to use for naming.")
	
	  var transaction = segment.transaction
	  var path = request.route && request.route.path
	
	
	  if (!path) return logger.debug({request: request}, "No path found on Hapi route.")
	
	  urltils.copyParameters(transaction.agent.config, request.params, segment.parameters)
	
	  transaction.nameState.setName(NAMES.HAPI.PREFIX, transaction.verb, 
	      NAMES.ACTION_DELIMITER, path)
	}
	
	function setDispatcher(agent) {
	  agent.environment.setDispatcher('hapi')
	  agent.environment.setFramework('hapi')
	}
	
	module.exports = function initialize(agent, hapi) {
	  if (!agent) return logger.error("Hapi instrumentation bootstrapped without agent")
	  if (!hapi) return logger.error("Hapi instrumentation applied without module")
	
	  var tracer = agent.tracer
	
	  function wrapRender(render) {
	    return function wrappedRender(filename, context, options, callback) {
	      var wrapped = callback
	
	      // FIXME: this is going to be the most recent segment, which may not be right
	      var segment = tracer.getSegment()
	      if (segment && callback) {
	        wrapped = tracer.bindFunction(function cb_bindFunction() {
	          segment.end()
	
	          return callback.apply(this, arguments)
	        })
	      }
	
	      return render.call(this, filename, context, options, wrapped)
	    }
	  }
	
	  function wrapStart(start) {
	    return function wrappedStart() {
	      setDispatcher(agent)
	
	      /* The patched module loader doesn't access the filesystem itself, so
	       * lazily apply the patch to Views.prototype.render only once a Views
	       * object has been assigned as the view manager.
	       */
	      if (this._views) {
	        logger.debug('Hapi view manager set; instrumenting render.')
	        var proto = this._views.constructor.prototype
	        shimmer.wrapMethod(proto, 'hapi.Views.prototype', 'render', wrapRender)
	      }
	
	      return start.apply(this, arguments)
	    }
	  }
	
	  function wrapViews(views) {
	    return function wrappedViews() {
	      var returned = views.apply(this, arguments)
	
	      /* The patched module loader doesn't access the filesystem itself, so
	       * lazily apply the patch to Views.prototype.render only once a Views
	       * object has been assigned as the view manager.
	       */
	      if (this._views) {
	        var proto = this._views.constructor.prototype
	        shimmer.wrapMethod(proto, 'hapi.Views.prototype', 'render', wrapRender)
	      } else {
	        logger.warn('Hapi view manager set without manager actually being created.')
	      }
	
	      return returned
	    }
	  }
	
	  function wrapReplyView(reply) {
	    reply.view = tracer.wrapFunction(VIEW.PREFIX, record, reply.view, wrapper)
	
	    function wrapper(segment, args) {
	      segment.name = VIEW.PREFIX + args[0] + VIEW.RENDER
	      return args
	    }
	  }
	
	  function wrapHandler(handler) {
	    return function cls_wrapHandler(request, reply) {
	      if (!tracer.getTransaction()) {
	        logger.trace("Hapi route handler called outside transaction.")
	        return handler.apply(this, arguments)
	      }
	
	      nameFromRequest(tracer.getSegment(), request)
	      if (reply && reply.view) wrapReplyView(reply)
	
	      return handler.apply(this, arguments)
	    }
	  }
	
	  /**
	   * Compare the before and after state of the router and apply the route wrapper
	   * to the new routes.
	   *
	   * @param  {object} before - State of the router before the new routes were added.
	   * @param  {object} after - State of the router after the new routes were added.
	   * @param  {string} vhost - If the user is letting hapi route its vhosts, use
	   *                          it in logging for debugging.
	   * @param  {function} visit  - Function used to wrap up the new routes.
	   */
	  function tableVisitor(before, after, vhost, visit) {
	    if (!vhost) vhost = '*'
	
	    if (after) {
	      Object.keys(after).forEach(function cb_forEach(method) {
	        var beforeHandlers = before && before[method]
	        var afterHandlers = after[method]
	        // hapi 8 nested routes a little deeper.
	        if (afterHandlers.routes) {
	          afterHandlers = afterHandlers.routes
	        }
	        for (var i = 0; i < afterHandlers.length; i++) {
	          var route = afterHandlers[i]
	          logger.debug('Instrumented hapi route [host %s] %s %s',
	                       vhost, method, route.path)
	          if (!beforeHandlers || beforeHandlers.indexOf(route) === -1) {
	            // hapi@6.9.0 started nesting the route handler 1 layer deeper
	            if (route.route) {
	              route = route.route
	            }
	
	            if (route.settings && route.settings.handler) {
	              route.settings.handler = visit(route.settings.handler)
	            } else {
	              logger.warn(
	                'Could not find handler to instrument for hapi route [host %s] %s %s',
	                vhost,
	                method,
	                route.path
	              )
	            }
	          }
	        }
	      })
	    }
	  }
	
	  /**
	   * This is pretty slow but only happens at route add time so optimizing it
	   * is of limited benefit. It is also moderately complex so lets go through
	   * what it does:
	   *
	   * 1. Gather the state of the router into `before*` variables.
	   * 2. Apply the new route(s) that are being added (which could be an array of
	   *    routes, and cover a number of different methods).
	   * 3. Get the new state of the router.
	   * 4. Pass it all to the table vistor which applies the route wrapper to all
	   *    the of individual routes that were just added.
	   */
	  function wrapRoute(_route) {
	    return function wrappedRoute(configs, env) {
	      var server = this
	
	      var router = server._router
	      if (!router) return logger.warn("no router found on hapi server")
	
	      var vhosts = router.vhosts
	      var beforeHosts = {}
	      if (vhosts) {
	        logger.debug("capturing vhosts on hapi router")
	
	        Object.keys(vhosts).forEach(function cb_forEach(host) {
	          beforeHosts[host] = {}
	          Object.keys(vhosts[host]).forEach(function cb_forEach(method) {
	            var routes = vhosts[host][method]
	            // hapi 8 nested routes a little deeper.
	            if (routes && routes.routes) {
	              routes = routes.routes
	            }
	            beforeHosts[host][method] = routes.slice()
	          })
	        })
	      }
	
	      var symbol
	      if (typeof router.table === 'function') {
	      // hapi 2: router.table -> router.routes & router.table is a function
	        symbol = 'routes'
	      } else {
	      // hapi 1: when vhosts aren't used, router.table contains the routes
	        symbol = 'table'
	      }
	
	      var table = router[symbol]
	      var beforeTable = {}
	      if (table) {
	        Object.keys(table).forEach(function cb_forEach(method) {
	          // hapi 8 nested routes a little deeper.
	          var routes = table[method]
	          if (routes.routes) {
	            routes = routes.routes
	          }
	          beforeTable[method] = routes.slice()
	        })
	      }
	
	      var returned = _route.call(this, configs, env)
	
	      vhosts = router.vhosts
	      if (vhosts) {
	        Object.keys(vhosts).forEach(function cb_forEach(host) {
	          tableVisitor(beforeHosts[host], vhosts[host], host, wrapHandler)
	        })
	      }
	
	      // Object could have been switched out, make sure to get a fresh one.
	      table = router[symbol]
	      if (table) tableVisitor(beforeTable, table, undefined, wrapHandler)
	
	      return returned
	    }
	  }
	
	  function wrapCreateServer(createServer) {
	    return function createServerWrapper() {
	      var server = createServer.apply(this, arguments)
	      shimServerPrototype(
	        server.constructor.prototype,
	        'hapi.Server.constructor.prototype'
	      )
	      // Now that we have instrumented the server prototype, un-instrument
	      // createServer as it serves no purpose.
	      shimmer.unwrapMethod(hapi, 'hapi', 'createServer')
	      return server
	    }
	  }
	
	  function shimServerPrototype(proto, name) {
	    shimmer.wrapMethod(proto, name, 'start', wrapStart)
	    shimmer.wrapMethod(proto, name, 'views', wrapViews)
	    shimmer.wrapMethod(proto, name, '_route', wrapRoute)
	  }
	
	  function wrapConnection(connection) {
	    return function wrappedConnection() {
	      setDispatcher(agent)
	      // Server.prototype returns a connection object
	      var plugin = connection.apply(this, arguments)
	
	      // Defensive against the possiblity that there isn't a connection for some
	      // reason.
	      if (plugin && plugin.connections && plugin.connections.length > 0) {
	        shimmer.wrapMethod(
	          plugin.connections[0].constructor.prototype,
	          'hapi.Connection.constructor.prototype',
	          '_route',
	          wrapRoute
	        )
	
	        shimmer.wrapMethod(
	          plugin.connections[0].server._replier.constructor.prototype,
	          'hapi.Connection.server._replier.constructor.prototype',
	          'interface',
	          wrapInterface
	        )
	
	        // Unwrap connection now that we've managed to patch the prototype
	        shimmer.unwrapMethod(
	          hapi.Server.prototype,
	          'hapi.Server.prototype',
	          'connection'
	        )
	      }
	
	      return plugin
	    }
	  }
	
	  function wrapInterface(replier) {
	    return function wrappedInterface() {
	      var reply = replier.apply(this, arguments)
	      shimmer.wrapMethod(
	        reply,
	        'hapi.Reply',
	        'response',
	        wrapResponse
	      )
	      return reply
	    }
	  }
	
	  function wrapResponse(response) {
	    return function wrappedResponse() {
	      var segment = agent.tracer.getSegment()
	      if (segment) segment.touch()
	      return response.apply(this, arguments)
	    }
	  }
	
	  var proto = hapi && hapi.Server && hapi.Server.prototype
	  if (proto && proto.start && proto.views && proto._route) { // Hapi 1 - 7.1.1
	    shimServerPrototype(proto, 'hapi.Server.prototype')
	  } else if (proto && Object.keys(proto).length === 0) { // Hapi 7.2 - 7.5.2
	    // This gets removed on first invocation as it is just used to patch a
	    // deeper prototype.
	    shimmer.wrapMethod(hapi, 'hapi', 'createServer', wrapCreateServer)
	  } else if (proto && proto.start && proto.route && proto.connection) { // Hapi 8+
	    shimmer.wrapMethod(proto, 'hapi.Server.prototype', 'connection', wrapConnection)
	  } else { // Some unknown future or hacked up version
	    logger.warn('hapi Server constructor not found; can\'t instrument')
	  }
	}


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var stringifySync = __webpack_require__(14).stringifySync
	var shimmer = __webpack_require__(199)
	var urltils = __webpack_require__(168)
	var recordRedis = __webpack_require__(226)
	var REDIS = __webpack_require__(59).REDIS
	
	
	module.exports = function initialize(agent, redis) {
	  var tracer = agent.tracer
	
	  shimmer.wrapMethod(
	    redis && redis.prototype,
	    'redis.prototype',
	    'sendCommand',
	    function wrapSendCommand(original) {
	      return tracer.wrapFunction(
	        REDIS.OPERATION + 'Unknown',
	        recordRedis,
	        original,
	        wrapper
	      )
	    }
	  )
	
	  function wrapper(segment, args) {
	    var command = args[0]
	
	    var keys = command.args
	    segment.name = REDIS.OPERATION + (command.name || 'unknown')
	    if (keys && typeof keys !== 'function') {
	      urltils.copyParameters(agent.config,
	        {key: stringifySync(keys[0], 'Unknown')}, segment.parameters)
	    }
	
	    // capture connection info for datastore instance metric
	    segment.port = this.connector.options.port
	    segment.host = this.connector.options.host
	
	    // record duration when promise resolves
	    command.promise.finally(function cb_resolved() {
	      segment.touch()
	    })
	
	    return args
	  }
	}


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var NAMES = __webpack_require__(59)
	var DB = NAMES.DB
	var REDIS = NAMES.REDIS
	
	
	function recordRedis(segment, scope) {
	  var duration = segment.getDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var transaction = segment.transaction
	  var type = transaction.isWeb() ? DB.WEB : DB.OTHER
	  var operation = segment.name
	
	
	  if (scope) transaction.measure(operation, scope, duration, exclusive)
	
	  transaction.measure(operation, null, duration, exclusive)
	  transaction.measure(DB.PREFIX + type, null, duration, exclusive)
	  transaction.measure(DB.PREFIX + REDIS.PREFIX + '/' + type, null, duration, exclusive)
	  transaction.measure(DB.ALL, null, duration, exclusive)
	  transaction.measure(REDIS.ALL, null, duration, exclusive)
	
	  // Datastore instance metrics.
	  if (segment.parameters.hasOwnProperty('host') &&
	      segment.parameters.hasOwnProperty('port_path_or_id')) {
	    var instanceName =
	      DB.INSTANCE + '/' + REDIS.PREFIX + '/' + segment.parameters.host + '/' +
	      segment.parameters.port_path_or_id
	    transaction.measure(instanceName, null, duration, exclusive)
	  }
	}
	// disabled until metric explosions can be handled by server
	/*
	  if (segment.port > 0) {
	  var hostname = segment.host || 'localhost'
	  var location = hostname + ':' + segment.port
	  var instance = DB.INSTANCE + '/' + REDIS.PREFIX + '/' + location
	
	  transaction.measure(instance, null, duration, exclusive)
	  }
	*/
	
	
	module.exports = recordRedis


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var stringifySync = __webpack_require__(14).stringifySync
	var shimmer = __webpack_require__(199)
	var urltils = __webpack_require__(168)
	var recordMemcache = __webpack_require__(228)
	var MEMCACHE = __webpack_require__(59).MEMCACHE
	
	function wrapKeys(metacall) {
	  if (metacall.key) {
	    return [metacall.key]
	  } else if (metacall.multi) {
	    return metacall.command.split(' ').slice(1)
	  }
	
	  return []
	}
	
	/**
	 * Thanks to Hernan Silberman!
	 *
	 * instrument the memcached driver to intercept calls and keep stats on them.
	 */
	module.exports = function initialize(agent, memcached) {
	  var tracer = agent.tracer
	
	  shimmer.wrapMethod(
	    memcached && memcached.prototype,
	    'memcached.prototype',
	    'command',
	    function commandWrapper(original) {
	      return tracer.wrapFunction(
	        MEMCACHE.OPERATION + 'Unknown',
	        recordMemcache,
	        original,
	        wrapCommand
	      )
	    }
	  )
	
	  function wrapCommand(segment, args, bind) {
	    // The `command` method takes two arguments: a query generator and a server
	    // address. The query generator returns a simple object describing the
	    // memcached call. The server parameter is only provided for multi-calls.
	    // When not provided, it can be derived from the key being interacted with.
	    var metacall = args[0]()
	    var server = args[1]
	    var keys = wrapKeys(metacall)
	    segment.name = MEMCACHE.OPERATION + (metacall.type || 'Unknown')
	
	    // Capture connection info for datastore instance metric.
	    var location = null
	    if (typeof server === 'string') {
	      location = server.split(':')
	    } else if (this.HashRing && this.HashRing.get && metacall.key) {
	      location = this.HashRing.get(metacall.key).split(':')
	    }
	    if (location) {
	      segment.captureDBInstanceAttributes(location[0], location[1], false)
	    }
	
	    urltils.copyParameters(
	      agent.config,
	      {
	        key: stringifySync(keys[0], 'Unknown')
	      },
	      segment.parameters
	    )
	
	    /* Memcache call description includes a callback to apply when the
	     * operation is concluded. Wrap that to trace the duration of the
	     * operation.
	     */
	    shimmer.wrapMethod(
	      metacall,
	      'metacall',
	      'callback',
	      function wrapMetacallCallback(callback) {
	        return bind(callback, true, true)
	      }
	    )
	
	    // rewrap the metacall for the command object
	    args[0] = function rewrapped() {
	      return metacall
	    }
	
	    // finally, execute the original command
	    return args
	  }
	}


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var NAMES = __webpack_require__(59)
	var DB = NAMES.DB
	var MEMCACHE = NAMES.MEMCACHE
	
	
	function recordMemcache(segment, scope) {
	  var duration = segment.getDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var transaction = segment.transaction
	  var type = transaction.isWeb() ? DB.WEB : DB.OTHER
	  var operation = segment.name
	
	
	  if (scope) transaction.measure(operation, scope, duration, exclusive)
	
	  transaction.measure(operation, null, duration, exclusive)
	  transaction.measure(DB.PREFIX + type, null, duration, exclusive)
	  transaction.measure(DB.PREFIX + MEMCACHE.PREFIX + '/' + type, null, duration, exclusive)
	  transaction.measure(DB.ALL, null, duration, exclusive)
	  transaction.measure(MEMCACHE.ALL, null, duration, exclusive)
	
	  // Datastore instance metrics.
	  if (segment.parameters.hasOwnProperty('host') &&
	      segment.parameters.hasOwnProperty('port_path_or_id')) {
	    var instanceName =
	      DB.INSTANCE + '/' + MEMCACHE.PREFIX + '/' + segment.parameters.host + '/' +
	      segment.parameters.port_path_or_id
	    transaction.measure(instanceName, null, duration, exclusive)
	  }
	}
	// disabled until metric explosions can be handled by server
	/*
	  if (segment.port > 0) {
	  var hostname = segment.host || 'localhost'
	  var location = hostname + ':' + segment.port
	  var instance = DB.INSTANCE + '/' + MEMCACHE.PREFIX + '/' + location
	
	  transaction.measure(instance, null, duration, exclusive)
	  }
	*/
	
	
	module.exports = recordMemcache


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var ParsedStatement = __webpack_require__(195)
	var shimmer = __webpack_require__(199)
	var logger = __webpack_require__(12).child({component: 'mongodb'})
	var MONGODB = __webpack_require__(59).MONGODB
	
	var MONGO_SEGMENT_RE = /^Datastore\/(?:statement|operation)\/MongoDB\//
	
	// legacy endpoint enumerations
	var DB_OPS = [
	  'addUser',
	  'authenticate',
	  'collection',
	  'collectionNames',
	  'collections',
	  'command',
	  'createCollection',
	  'createIndex',
	  'cursorInfo',
	  'dereference',
	  'dropCollection',
	  'dropDatabase',
	  'dropIndex',
	  'ensureIndex',
	  'eval',
	  'executeDbAdminCommand',
	  'indexInformation',
	  'logout',
	  'open',
	  'reIndex',
	  'removeUser',
	  'renameCollection',
	  'stats',
	  '_executeInsertCommand',
	  '_executeQueryCommand'
	]
	
	var COLLECTION_OPS = [
	  'aggregate',
	  'bulkWrite',
	  'count',
	  'createIndex',
	  'deleteMany',
	  'deleteOne',
	  'distinct',
	  'drop',
	  'dropAllIndexes',
	  'dropIndex',
	  'ensureIndex',
	  'findAndModify',
	  'findAndRemove',
	  'findOne',
	  'findOneAndDelete',
	  'findOneAndReplace',
	  'findOneAndUpdate',
	  'geoHaystackSearch',
	  'geoNear',
	  'group',
	  'indexes',
	  'indexExists',
	  'indexInformation',
	  'insert',
	  'insertMany',
	  'insertOne',
	  'isCapped',
	  'mapReduce',
	  'options',
	  'parallelCollectionScan',
	  'reIndex',
	  'remove',
	  'rename',
	  'replaceOne',
	  'save',
	  'stats',
	  'update',
	  'updateMany',
	  'updateOne'
	]
	
	var GRID_OPS = [
	  'put',
	  'get',
	  'delete'
	]
	
	var CURSOR_OPS = [
	  'nextObject',
	  'next',
	  'toArray',
	  'count',
	  'explain'
	]
	
	module.exports = initialize
	
	function initialize(agent, mongodb) {
	  if (!mongodb) return
	  var tracer = agent.tracer
	  var moduleNameToWrapFunction = {
	    'GridStore': wrapGrid,
	    'OrderedBulkOperation': wrapQuery,
	    'UnorderedBulkOperation': wrapQuery,
	    'CommandCursor': wrapQuery,
	    'AggregationCursor': wrapQuery,
	    'Cursor': wrapQuery,
	    'Collection': wrapQuery,
	    'Db': wrapDb
	  }
	
	  function instrumentModules(err, instrumentations) {
	    if (err) {
	      logger.trace('Unable to instrument mongo using the apm api due to error: %s', err)
	      // fallback to legacy instrumentation?
	      return
	    }
	    instrumentations.forEach(instrumentModule)
	  }
	
	  function applyInstrumentation(objectName, object, instrumentation) {
	    var methods = instrumentation.methods
	    var methodOptions = instrumentation.options
	    if (methodOptions.callback) {
	      for (var j = 0; j < methods.length; j++) {
	        var method = methods[j]
	
	        var wrapFunction
	        if (method === 'each') {
	          wrapFunction = wrapEach
	        } else {
	          wrapFunction = moduleNameToWrapFunction[objectName]
	        }
	
	        if (wrapFunction) {
	          shimmer.wrapMethod(
	            object.prototype,
	            'mongodb.' + objectName + '.' + method,
	            method,
	            wrapFunction
	          )
	        } else {
	          logger.trace('No wrapping method found for %s', objectName)
	        }
	      }
	    }
	  }
	
	  function instrumentModule(module) {
	    var object = module.obj
	    var instrumentations = module.instrumentations
	    for (var i = 0; i < instrumentations.length; i++) {
	      applyInstrumentation(module.name, object, instrumentations[i])
	    }
	  }
	
	  // instrument using the apm api
	  if (mongodb.instrument) {
	    var instrumenter = mongodb.instrument({}, instrumentModules)
	    instrumenter.on('started', function onMongoEventStarted(evnt) {
	      // This assumes that this `started` event is fired _after_ our wrapper
	      // starts and creates the segment. We perform a check of the segment name
	      // out of an excess of caution.
	      var segment = tracer.getSegment()
	      var connId = evnt.connectionId
	      if (connId && segment && MONGO_SEGMENT_RE.test(segment.name)) {
	        logger.trace('Adding db instance attributes to segment %j', segment.name)
	        // Mongo sticks the path to the domain socket in the "host" slot, but we
	        // want it in the "port", so if we have a domain socket we need to change
	        // the order of our parameters.
	        if (connId.domainSocket) {
	          segment.captureDBInstanceAttributes('localhost', connId.host, evnt.databaseName)
	        } else {
	          segment.captureDBInstanceAttributes(connId.host, connId.port, evnt.databaseName)
	        }
	      } else {
	        logger.trace(
	          'Not adding db instance metric attributes to segment %j',
	          segment && segment.name
	        )
	      }
	    })
	    return
	  }
	
	  // fallback to legacy enumerations
	  if (mongodb.Cursor && mongodb.Cursor.prototype) {
	    // should wrapup stream aswell
	    shimmer.wrapMethod(
	      mongodb.Cursor.prototype,
	      'mongodb.Cursor.prototype',
	      CURSOR_OPS,
	      wrapQuery
	    )
	
	    shimmer.wrapMethod(
	      mongodb.Cursor.prototype,
	      'mongodb.Cursor.prototype',
	      'each',
	      wrapEach
	    )
	  }
	
	  if (mongodb.Collection && mongodb.Collection.prototype) {
	    shimmer.wrapMethod(
	      mongodb.Collection.prototype,
	      'mongodb.Cursor.prototype',
	      COLLECTION_OPS,
	      wrapQuery
	    )
	  }
	
	  if (mongodb.Grid && mongodb.Grid.prototype) {
	    shimmer.wrapMethod(
	      mongodb.Grid.prototype,
	      'mongodb.Grid.prototype',
	      GRID_OPS,
	      wrapGrid
	    )
	  }
	
	  if (mongodb.Db && mongodb.Db.prototype) {
	    for (var i = 0, l = DB_OPS.length; i < l; ++i) {
	      shimmer.wrapMethod(
	        mongodb.Db.prototype,
	        'mongodb.Db.prototype',
	        DB_OPS[i],
	        wrapDb
	      )
	    }
	
	    shimmer.wrapMethod(mongodb.Db, 'mongodb.Db', 'connect', wrapDb)
	  }
	
	  function wrapOp(original, name, wrapper) {
	    return function wrapped() {
	      var args = tracer.slice(arguments)
	      var last = args.length - 1
	      var callback = typeof args[last] === 'function' ? args[last] : null
	      var transaction = tracer.getTransaction()
	      var collection = this.collectionName || 'unknown'
	
	      if (this.collection && this.collection.collectionName) {
	        collection = this.collection.collectionName
	      } else if (this.s && this.s.name) {
	        collection = this.s.name || collection
	      } else if (this.ns) {
	        collection = this.ns.split(/\./)[1] || collection
	      }
	
	      if (!callback) {
	        logger.trace(
	          'Not tracing MongoDB %s.%s(); no callback.',
	          collection,
	          name
	        )
	
	        return original.apply(this, args)
	      } else if (!transaction) {
	        logger.trace(
	          'Not tracing MongoDB %s.%s(); no New Relic transaction.',
	          collection,
	          name
	        )
	
	        return original.apply(this, args)
	      } else if (inMongoSegment(tracer)) {
	        logger.trace(
	          'Not tracing MongoDB %s.%s(); Already in a mongo segment',
	           collection,
	           name
	        )
	
	        return original.apply(this, args)
	      }
	
	      return wrapper.call(this, args, last, collection)
	    }
	  }
	
	  function wrapQuery(original, opName) {
	    return wrapOp(original, opName, function wrappedQuery(args, last, collection) {
	      var segment = addMongoStatement(tracer, collection, opName)
	      var callback = args[last]
	
	      logger.trace(
	        'Tracing MongoDB %s.%s().',
	        collection,
	        opName
	      )
	
	      // capture configuration information if available
	      captureInstanceAttributes(segment, this)
	
	      args[last] = tracer.wrapCallback(callback, segment, function wrappedCallback() {
	        segment.touch()
	        logger.trace('Tracing MongoDB %s.%s() ended.', collection, opName)
	        return callback.apply(this, arguments)
	      })
	
	      return tracer.bindFunction(original, segment).apply(this, args)
	    })
	  }
	
	  function wrapEach(original, opName) {
	    return wrapOp(original, opName, function wrappedEach(args, last, collectionName) {
	      var segment = addMongoStatement(tracer, collectionName, opName)
	      var callbackBatch = null
	      var callback = args[last]
	      var collection = this
	
	      logger.trace('Tracing MongoDB %s.%s().', collection, opName)
	
	      // capture configuration information if available
	      captureInstanceAttributes(segment, this)
	
	      args[args.length - 1] = wrappedCallback
	
	      return tracer.bindFunction(original, segment).apply(this, args)
	
	      function wrappedCallback(err, item) {
	        segment.touch()
	
	        if (err || item === null) {
	          logger.trace('Tracing MongoDB %s.%s(%s) ended.', collection, opName)
	        }
	
	        if (!callbackBatch) {
	          callbackBatch = tracer.wrapCallback(
	            callback,
	            segment,
	            function wrapBatch() {
	              if (!collection.items || !collection.items.length) {
	                callbackBatch = null
	              }
	              return callback.apply(this, arguments)
	            }
	          )
	        }
	
	        return callbackBatch.apply(this, arguments)
	      }
	    })
	  }
	
	  function wrapGrid(original, opName) {
	    return wrapOp(original, opName, function wrappedGridOp(args, last) {
	      var name = MONGODB.OPERATION + 'GridFS-' + opName
	      var callback = args[last]
	      var grid = this
	
	      // TODO: should look into adding a recorder for this
	      return tracer.addSegment(name, null, null, false, segmentWrapper)
	
	      function segmentWrapper(segment) {
	        args[last] = tracer.wrapCallback(callback, segment, nrCallbackWrap)
	
	        return original.apply(grid, args)
	
	        function nrCallbackWrap() {
	          segment.touch()
	          logger.trace('Tracing MongoDB Grid.%s() ended.', opName)
	          return callback.apply(this, arguments)
	        }
	      }
	    })
	  }
	
	  function wrapDb(original, opName) {
	    return wrapOp(original, opName, function wrappedGridOp(args, last) {
	      var name = MONGODB.OPERATION + opName
	      var callback = args[last]
	      var db = this
	
	      // TODO: should look into adding a recorder for this
	
	      return tracer.addSegment(name, null, null, false, segmentWrapper)
	
	      function segmentWrapper(segment) {
	        args[last] = tracer.wrapCallback(callback, segment, nrCallbackWrap)
	        return tracer.bindFunction(original, segment).apply(db, args)
	
	        function nrCallbackWrap() {
	          segment.touch()
	          logger.trace('Tracing MongoDB %s() ended.', opName)
	          return callback.apply(this, arguments)
	        }
	      }
	    })
	  }
	}
	
	
	var MONGO_RE = new RegExp(
	  '^(?:' + MONGODB.STATEMENT + ')|(?:' + MONGODB.OPERATION + ')'
	)
	function inMongoSegment(tracer) {
	  return MONGO_RE.test(tracer.getSegment().name)
	}
	
	function addMongoStatement(tracer, collection, opName) {
	  var statement = new ParsedStatement(MONGODB.PREFIX, opName, collection)
	  var recorder = statement.recordMetrics.bind(statement)
	  var name = MONGODB.STATEMENT + collection + '/' + opName
	
	  var segment = tracer.createSegment(name, recorder)
	  segment.start()
	  return segment
	}
	
	function captureInstanceAttributes(segment, obj) {
	  if (obj.db && obj.db.serverConfig) {
	    logger.trace('Adding datastore instance attributes from obj.db.serverConfig')
	    var databaseName = (
	      obj.db.serverConfig.db || obj.db.serverConfig.dbInstance || {}
	    ).databaseName
	    doCapture(obj.db.serverConfig, databaseName)
	  } else {
	    logger.trace('Could not find datastore instance attributes.')
	  }
	
	  function doCapture(conf, database) {
	    var host = conf.host
	    var port = conf.port
	
	    // If using a domain socket, mongo stores the path as the host name, but we
	    // pass it through the port value.
	    if (conf.socketOptions && conf.socketOptions.domainSocket) {
	      port = host
	      host = 'localhost'
	    }
	
	    segment.captureDBInstanceAttributes(host, port, database)
	  }
	}


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'mysql'})
	var shimmer = __webpack_require__(199)
	var parseSql = __webpack_require__(193)
	var MYSQL = __webpack_require__(59).MYSQL
	var dbutil = __webpack_require__(196)
	
	
	module.exports = function initialize(agent, mysql) {
	  var tracer = agent.tracer
	
	  function wrapQueriable(queriable, name, poolQuery) {
	    // may not always be a queriable object, but anything with a .query
	    // you should pass the appropriate name in for shimmer
	    if (!queriable) {
	      return
	    }
	
	    shimmer.wrapMethod(
	      queriable,
	      name,
	      'query',
	      function nrQueryWrapper(original) {
	        return tracer.wrapFunction(
	          poolQuery ? 'MySQL pool.query' : MYSQL.STATEMENT + 'Unknown',
	          null,
	          original,
	          cb_wrapMethod,      // wrap arguments
	          bindStreamingEvents // wrap return value
	        )
	      }
	    )
	
	    // we bind the streaming event emitters to track the query's
	    // progress update the query's segment.
	    function bindStreamingEvents(segment, queryObject) {
	      if (queryObject && queryObject.emit) {
	        queryObject.emit = tracer.bindFunction(queryObject.emit, segment, true)
	      }
	      return queryObject
	    }
	    var databaseName = null
	
	    function cb_wrapMethod(segment, args, bind) {
	      var sqlString = ''
	
	      // This is just a massive argument hunt
	      // because you can call .query in many ways.
	      //
	      // You should populate `userCallback` after this block with a callback.
	      // Optionally you may populate `queryVals` and `sqlString`.
	      // The value in `sqlString` will show up in the UI
	      var vargs = []
	
	      if (args.length === 1 && typeof args[0] === 'object') {
	        // .query(query)
	        // query query is a Query object and contains ._callback and .sql
	        args[0]._callback = bind(args[0]._callback)
	        sqlString = args[0].sql
	        vargs.push(args[0])
	      } else if (args.length === 1) {
	        // either .query(callback) or .query(sql)
	        // in the latter case we rely on the streaming interface
	        if (typeof args[0] !== 'function') {
	          sqlString = args[0].sql
	          vargs.push(args[0])
	        } else {
	          vargs.push(bind(args[0]))
	        }
	      } else if (args.length === 2) {
	        // .query(sql, callback) or .query(sql, values)
	        // in the latter case we rely on the streaming interface
	        vargs.push(sqlString = args[0])
	        if (typeof args[1] !== 'function') {
	          vargs.push(args[1])
	        } else {
	          vargs.push(bind(args[1]))
	        }
	      } else {
	        // .query(sql, values, callback) or unknown
	        // in the latter case, we just omit measuring
	        vargs.push(sqlString = args[0])
	        vargs.push(args[1])
	        if (typeof args[2] !== 'function') {
	          vargs.push(args[2])
	          vargs.push(segment.touch.bind(segment))
	        } else {
	          vargs.push(bind(args[2]))
	        }
	      }
	
	
	      // name the metric
	      if (!poolQuery) {
	        var ps = parseSql(MYSQL.PREFIX, sqlString)
	        var model = ps.model
	        var operation = ps.operation
	
	        var segmentName = MYSQL.STATEMENT + (model || 'unknown') + '/' + operation
	        logger.trace(
	          'capturing mysql query in %s. model: %s, Operation: %s',
	          name,
	          model,
	          operation
	        )
	
	        // we will end the segment in onEnd above
	        tracer.getTransaction().addRecorder(ps.recordMetrics.bind(ps, segment))
	        segment.name = segmentName
	
	        if (queriable.config && queriable.config.connectionConfig) {
	          var queryConfig = queriable.config.connectionConfig
	        } else if (queriable.config) {
	          var queryConfig = queriable.config
	        }
	
	        if (queryConfig) {
	          databaseName = databaseName || queryConfig.database
	
	          if (queryConfig.socketPath) {
	            // in the unix domain socket case we force the host to be
	            // localhost
	            segment.captureDBInstanceAttributes(
	              'localhost',
	              queryConfig.socketPath,
	              databaseName
	            )
	          } else {
	            segment.captureDBInstanceAttributes(
	              queryConfig.host,
	              queryConfig.port,
	              databaseName
	            )
	          }
	        } else {
	          logger.trace('No query config detected, not collecting db instance data')
	        }
	
	        databaseName = dbutil.extractDatabaseChangeFromUse(sqlString) || databaseName
	      }
	
	      return vargs
	    }
	  }
	
	  function getVargs(args) {
	    var callback
	
	    var vargs = []
	
	    switch (args.length) {
	      case 1:
	        callback = args[0]
	        break
	      case 2:
	        vargs.push(args[0])
	        callback = args[1]
	        break
	      default:
	        vargs.push(args[0])
	        vargs.push(args[1])
	        callback = args[2]
	        break
	    }
	
	    logger.trace({args: args, vargs: vargs}, 'parsed getConnection arguments')
	
	    return {
	      vargs: vargs,
	      callback: callback
	    }
	  }
	
	  function getConnectionHandler(dbObject, getConnectionMethod) {
	    return function wrap_getConnection() { // getConnection
	      var args = getVargs(arguments)
	      var getConnectionCallback
	
	      // let's verify that we actually have a callback,
	      // otherwise we should just pass on wrapping it
	      //
	      // TODO: test case where no callback is supplied
	      var isCallback = args.callback && typeof args.callback === 'function'
	
	      // The mysql module has internal retry logic that will call
	      // getConnection again with our wrapped callback.
	      // We should avoid re-wrapping the callback when possible,
	      // although nothing bad happens when we fail this, it just
	      // makes stack traces a little better in errors.
	      if (!isCallback || !args.callback.__NR_original_callback) {
	        var proxiedCallback = tracer.bindFunction(args.callback)
	        getConnectionCallback = function getConnectionCallback(err, connection) {
	          // we need to patch the connection objects .query method
	          wrapQueriable(connection, 'connection')
	          proxiedCallback(err, connection)
	        }
	        // tag so we can avoid re-wrapping
	        getConnectionCallback.__NR_original_callback = args.callback
	      } else {
	        // the connection is already wrapped
	        logger.trace('getConnection callback already wrapped')
	        getConnectionCallback = args.callback
	      }
	
	      args.vargs.push(getConnectionCallback)
	
	      return getConnectionMethod.apply(dbObject, args.vargs)
	    }
	  }
	
	  // FIXME: need a more general way of differentiating between driver versions
	  if (mysql && mysql.createConnection) {
	    // congratulations, you have node-mysql 2.0
	
	    shimmer.wrapMethod(mysql, 'mysql.prototype', 'createPoolCluster',
	    function cb_wrapMethod(createPoolCluster) {
	      // this is generally called outside of a transaction,
	      // so we don't need/care about preserving
	      // the continuation, but we do need to patch the returned object
	      return function not_in_transaction() {
	        var poolCluster = createPoolCluster.apply(mysql, arguments)
	
	        shimmer.wrapMethod(poolCluster, 'poolCluster', 'of',
	        function cb_wrapMethod(of) {
	          return function nrWrappedMethod() {
	            var ofCluster = of.apply(poolCluster, arguments)
	
	            shimmer.wrapMethod(ofCluster, 'poolCluster', 'getConnection',
	            function cb_wrapMethod(getConnection) {
	              return getConnectionHandler(ofCluster, getConnection)
	            })
	
	            return ofCluster
	          }
	        })
	
	        shimmer.wrapMethod(poolCluster, 'poolCluster', 'getConnection',
	        function cb_wrapMethod(getConnection) {
	          return getConnectionHandler(poolCluster, getConnection)
	        })
	
	        return poolCluster
	      }
	    })
	
	    shimmer.wrapMethod(mysql, 'mysql', 'createPool',
	    function cb_wrapMethod(createPool) {
	      return function cb_wrapFunction() {
	        var pool = createPool.apply(mysql, arguments)
	
	        shimmer.wrapMethod(pool, 'pool', 'getConnection',
	        function cb_wrapMethod(getConnection) {
	          return getConnectionHandler(pool, getConnection)
	        })
	
	        // patch the pools .query method
	        wrapQueriable(pool, 'pool', true)
	
	        return pool
	      }
	    })
	
	    shimmer.wrapMethod(
	      mysql,
	      'mysql',
	      'createConnection',
	      function cb_wrapMethod(createConnection) {
	        return function wrappedCreateConnection() {
	          var connection = createConnection.apply(this, arguments)
	          wrapQueriable(connection, 'connection')
	          return connection
	        }
	      }
	    )
	  } else if (mysql && mysql.Client) {
	    // congratulations, you have node-mysql 0.9
	    shimmer.wrapMethod(
	      mysql && mysql.Client && mysql.Client.prototype,
	      'mysql.Client.prototype',
	      'query',
	      function nrQueryWrapper(original) {
	        return tracer.wrapFunction(
	          MYSQL.STATEMENT + 'Unknown',
	          null,
	          original,
	          wrapQuery09
	        )
	      }
	    )
	  }
	
	  var databaseName09 = null
	  function wrapQuery09(segment, args, bind) {
	    var transaction = tracer.getTransaction()
	
	    var sqlString = args[0]
	    var ps = parseSql(MYSQL.PREFIX, sqlString)
	    transaction.addRecorder(ps.recordMetrics.bind(ps, segment))
	    segment.name = MYSQL.STATEMENT + (ps.model || 'unknown') + '/' + ps.operation
	
	
	    // capture connection info for datastore instance metric
	    databaseName09 = databaseName09 || this.database
	    if (this.socketPath) {
	      // in the unix domain socket case we force the host to be
	      // localhost
	      segment.captureDBInstanceAttributes(
	        agent.config.getHostnameSafe(),
	        this.socketPath,
	        databaseName09
	      )
	    } else {
	      segment.captureDBInstanceAttributes(
	        this.host,
	        this.port,
	        databaseName09
	      )
	    }
	    databaseName09 = dbutil.extractDatabaseChangeFromUse(sqlString) || databaseName09
	
	    // find and wrap the callback
	    if (args.length > 1 && typeof args[args.length - 1] === 'function') {
	      args[args.length - 1] = bind(args[args.length - 1])
	    }
	
	    // FIXME: need to grab error events as well, as they're also emitted on
	    // the client
	
	    return args
	  }
	}


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var shimmer = __webpack_require__(199)
	var record = __webpack_require__(232)
	var CASSANDRA = __webpack_require__(59).CASSANDRA
	
	var INSTRUMENTED_OPERATIONS = [
	  'execute',
	  'executeAsPrepared',
	  'executeBatch'
	]
	
	module.exports = function initialize(agent, cassandracql) {
	  var tracer = agent.tracer
	
	  INSTRUMENTED_OPERATIONS.forEach(function cb_forEach(operation) {
	    shimmer.wrapMethod(
	      cassandracql && cassandracql.Client && cassandracql.Client.prototype,
	      'node-cassandra-cql.Client.prototype',
	      operation,
	      function wrapOperation(original) {
	        return tracer.wrapFunction(
	          CASSANDRA.OPERATION + operation,
	          record,
	          original,
	          wrapper
	        )
	      }
	    )
	
	    function wrapper(segment, args, bind) {
	      var position = args.length - 1
	      var last = args[position]
	
	      // capture connection info for datastore instance metric
	      segment.port = this.port
	      segment.host = this.host
	
	      if (typeof last === 'function') {
	        args[position] = bind(last, true, true)
	      } else if (Array.isArray(last) && typeof last[last.length - 1] === 'function') {
	        last[last.length - 1] = tracer.bindFunction(
	          bind(last[last.length - 1], true, true)
	        )
	      } else { // let's shove a callback in there for fun
	        args.push(bind(null, null))
	      }
	
	      return args
	    }
	  })
	}


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var NAMES = __webpack_require__(59)
	var DB = NAMES.DB
	var CASSANDRA = NAMES.CASSANDRA
	
	
	function record(segment, scope) {
	  var duration = segment.getDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var transaction = segment.transaction
	  var type = transaction.isWeb() ? DB.WEB : DB.OTHER
	  var operation = segment.name
	
	
	  if (scope) transaction.measure(operation, scope, duration, exclusive)
	
	  transaction.measure(operation, null, duration, exclusive)
	  transaction.measure(DB.PREFIX + type, null, duration, exclusive)
	  transaction.measure(DB.ALL, null, duration, exclusive)
	  transaction.measure(
	    DB.PREFIX + CASSANDRA.PREFIX + '/' + type,
	    null,
	    duration,
	    exclusive
	  )
	  transaction.measure(CASSANDRA.ALL, null, duration, exclusive)
	}
	// disabled until metric explosions can be handled by server
	/*
	  if (segment.port > 0) {
	  var hostname = segment.host || 'localhost'
	  var location = hostname + ':' + segment.port
	  var instance = DB.INSTANCE + '/' + CASSANDRA.PREFIX + '/' + location
	
	  transaction.measure(instance, null, duration, exclusive)
	  }
	*/
	
	module.exports = record


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'oracle'})
	var shimmer = __webpack_require__(199)
	var parseSql = __webpack_require__(193)
	var ORACLE = __webpack_require__(59).ORACLE
	
	module.exports = function initialize(agent, oracle) {
	  var tracer = agent.tracer
	  var wrapped = false
	
	  logger.trace('wrapping oracle.connect and oracle.connectSync')
	
	  shimmer.wrapMethod(oracle, 'Oracle', 'connect', function cb_wrapMethod(connect) {
	    return function wrappedConnect(connectData, cb) {
	      return connect.call(
	        this,
	        connectData,
	        tracer.bindFunction(wrapConnection)
	      )
	
	      function wrapConnection(err, connection) {
	        if (!err) ensureConnectionWrapped(connection)
	        return cb(err, connection)
	      }
	    }
	  })
	
	  shimmer.wrapMethod(oracle, 'Oracle', 'connectSync', function wrapSyncConnect(connect) {
	    return function wrappedSyncConnect() {
	      var connection = connect.apply(this, arguments)
	      ensureConnectionWrapped(connection)
	      return connection
	    }
	  })
	
	  function ensureConnectionWrapped(connection) {
	    // return early in case called from an async connect after wrapping
	    if (wrapped) return
	    logger.trace('wrapping oracle connection prototype')
	    wrapped = true
	
	    oracle.connectSync.__NR_unwrap()
	    oracle.connect.__NR_unwrap()
	    shimmer.wrapMethod(oracle, 'Oracle', 'connect', function wrapMethod(connect) {
	      return tracer.wrapFunctionNoSegment(connect, 'connect')
	    })
	
	    var proto = Object.getPrototypeOf(connection)
	    wrapConnectionExecute(proto, tracer)
	    wrapConnectionPrepare(proto, tracer)
	
	    shimmer.wrapMethod(proto, 'Oracle', 'reader', function wrapMethod(createReader) {
	      return function wrappedConnect(sql) {
	        var reader = createReader.apply(this, arguments)
	        wrapReader(reader, tracer, sql)
	        return reader
	      }
	    })
	  }
	}
	
	function wrapConnectionExecute(connection, tracer) {
	  shimmer.wrapMethod(connection, 'Oracle.connection', 'execute', wrapExecute)
	
	  function wrapExecute(execute) {
	    return tracer.wrapFunction(ORACLE.STATEMENT + 'other/', null, execute, wrappedExecute)
	  }
	
	  function wrappedExecute(segment, args, bind) {
	    var ps = parseSql(ORACLE.PREFIX, args[0])
	    var model = ps.model
	    var operation = ps.operation
	
	    segment.name = ORACLE.STATEMENT + model + '/Connection.execute/' + operation
	    logger.trace(
	      'capturing oracle query. model: %s, Operation: %s',
	      model,
	      operation
	    )
	
	    segment.transaction.addRecorder(ps.recordMetrics.bind(ps, segment))
	    args[2] = bind(args[2])
	    return args
	  }
	}
	
	function wrapReader(reader, tracer, sql) {
	  var ps = parseSql(ORACLE.PREFIX, sql)
	  shimmer.wrapMethod(reader, 'Oracle.Reader', 'nextRow', wrapNextRow)
	  shimmer.wrapMethod(reader, 'Oracle.Reader', 'nextRows', wrapNextRows)
	
	  function wrapNextRow(nextRow) {
	    return tracer.wrapFunctionLast(
	      ORACLE.STATEMENT + ps.model + '/Reader.nextRow/' + ps.operation,
	      ps.recordMetrics.bind(ps),
	      nextRow
	    )
	  }
	
	  function wrapNextRows(nextRows) {
	    return tracer.wrapFunctionLast(
	      ORACLE.STATEMENT + ps.model + '/Reader.nextRows/' + ps.operation,
	      ps.recordMetrics.bind(ps),
	      nextRows
	    )
	  }
	}
	
	function wrapConnectionPrepare(connection, tracer) {
	  shimmer.wrapMethod(connection, 'Oracle.connection', 'prepare', wrapPrepare)
	
	  function wrapPrepare(prepare) {
	    return function wrappedPrepare(sql) {
	      var ps = parseSql(ORACLE.PREFIX, sql)
	      var prepared = prepare.apply(this, arguments)
	      shimmer.wrapMethod(prepared, 'Oracle', 'execute', wrapExecute)
	      return prepared
	
	      function wrapExecute(execute) {
	        return tracer.wrapFunctionLast(
	          ORACLE.STATEMENT + ps.model + '/Statement.execute/' + ps.operation,
	          ps.recordMetrics.bind(ps),
	          execute
	        )
	      }
	    }
	  }
	}


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var shimmer = __webpack_require__(199)
	var logger = __webpack_require__(12).child({component: 'pg'})
	var parseSql = __webpack_require__(193)
	var POSTGRES = __webpack_require__(59).POSTGRES
	var util = __webpack_require__(16)
	
	
	// Adds a segment
	// The `config` argument is either a statement string template or a pg statement
	// config object with a `text` property holding the statement string template.
	function initializeSegment(tracer, segment, client, config) {
	  var statement
	  if (config && (typeof config === 'string' || config instanceof String)) {
	    statement = config
	  } else if (config && config.text) {
	    statement = config.text
	  } else {
	    // Won't be matched by parser, but should be handled properly
	    statement = 'Other'
	  }
	
	  var ps = parseSql(POSTGRES.PREFIX, statement)
	  var model = ps.model
	  var operation = ps.operation
	
	  segment.name = POSTGRES.STATEMENT + (model || 'other') + '/' + operation
	  segment.captureDBInstanceAttributes(client.host, client.port, client.database)
	
	  logger.trace(
	    'capturing postgresql query. model: %s, operation: %s',
	    model,
	    operation
	  )
	
	  tracer.getTransaction().addRecorder(ps.recordMetrics.bind(ps, segment))
	}
	
	module.exports = function initialize(agent, pgsql) {
	  if (!pgsql) return
	
	  var tracer = agent.tracer
	
	  // allows for native wrapping to not happen if not necessary
	  // when env var is true
	
	  if (process.env.NODE_PG_FORCE_NATIVE) {
	    return instrumentPGNative('pg', pgsql)
	  }
	
	  // The pg module defines "native" getter which sets up the native client lazily
	  // (only when called).  We replace the getter, so that we can instrument the native
	  // client.  The original getter replaces itself with the instance of the native
	  // client, so only instrument if the getter exists (otherwise assume already
	  // instrumented).
	  var origGetter = pgsql.__lookupGetter__('native')
	  if (origGetter) {
	    delete pgsql.native
	    pgsql.__defineGetter__('native', function getNative() {
	      var temp = origGetter()
	      instrumentPGNative('pg.native', temp)
	      return temp
	    })
	  }
	
	  // wrapping for native
	  function instrumentPGNative(eng, pg) {
	    shimmer.wrapMethod(pg, 'pg', 'Client', wrapClient)
	    shimmer.wrapMethod(pg.pools, 'pg.pools', 'Client', wrapClient)
	    shimmer.wrapMethod(pg, 'pg', 'Pool', wrapPool)
	
	    function newApply(Cls) {
	      return new (Cls.bind.apply(Cls, arguments))()
	    }
	
	    function wrapPool(Pool) {
	      if (shimmer.isWrapped(Pool)) {
	        return Pool
	      }
	
	      util.inherits(WrappedPool, Pool)
	      WrappedPool.__NR_original = Pool
	      return WrappedPool
	
	      /* eslint-disable no-unused-vars */
	      function WrappedPool(options, Client) {
	        /* eslint-enable no-unused-vars */
	        if (!(this instanceof WrappedPool)) {
	          return newApply(WrappedPool, arguments)
	        }
	
	        Pool.apply(this, arguments)
	        this.Client = wrapClient(this.Client)
	      }
	    }
	
	    function wrapClient(Client) {
	      if (shimmer.isWrapped(Client)) {
	        return Client
	      }
	
	      util.inherits(WrappedClient, Client)
	      Object.keys(Client).forEach(function forEachClientKey(k) {
	        WrappedClient[k] = Client[k]
	      })
	      WrappedClient.__NR_original = Client
	      return WrappedClient
	
	      // -------------------------------------------------------------------- //
	
	      /* eslint-disable no-unused-vars */
	      function WrappedClient(options) {
	        /* eslint-enable no-unused-vars */
	        // NOTE:  This is an instance of PG's `Client` class, _not_ its
	        //        `Connection` class. This is an important distinction as the
	        //        latter does not have the host/port/database meta data.
	
	        // Apply the constructor. JavaScript really needs a better way to do this.
	        // This logic is the same as `newApply`, however for some reason `newApply`
	        // does not work on Node v0.8 or v0.10. For `WrappedPool` this doesn't
	        // matter since the versions of PG it is in don't support those ancient
	        // versions of Node either, but here we must do it ourselves.
	        var args = tracer.slice(arguments)
	        args.unshift(Client) // `unshift` === `push_front`
	        var client = new (Client.bind.apply(Client, args))()
	
	        // Wrap the methods we care about.
	        shimmer.wrapMethod(client, 'Client', 'connect', wrapConnect)
	        shimmer.wrapMethod(client, 'Client', 'query', wrapNativeQuery)
	        return client
	      }
	
	      function wrapConnect(connect) {
	        return function wrappedConnect(callback) {
	          if (typeof callback === 'function') {
	            callback = tracer.bindFunction(callback)
	          }
	          return connect.call(this, callback)
	        }
	      }
	
	      function wrapNativeQuery(original) {
	        return tracer.wrapFunction(
	          POSTGRES.STATEMENT + 'Unknown',
	          null,
	          original,
	          nativeQueryWrapper,
	          nativeResponseWrapper
	        )
	      }
	
	      function nativeQueryWrapper(segment, args, bindCallback) {
	        initializeSegment(tracer, segment, this, args[0])
	
	        var pos = args.length - 1
	        var last = args[pos]
	
	        // Proxy callback in case they start new segments
	        args[pos] = bindCallback(last)
	
	        return args
	      }
	
	      function nativeResponseWrapper(segment, result, bindCallback) {
	        // Wrap end and error events too, in case they start new segments
	        // within them. Use end and error events to end segments.
	        result.on('error', end)
	        result.on('end', end)
	
	        function end() {
	          segment.touch()
	          logger.trace(
	            'postgres command trace segment ended by event for transaction %s.',
	            segment.transaction.id
	          )
	        }
	
	        // TODO: Maybe .on and .addListener shouldn't be different
	        // Proxy events too, in case they start new segments within handlers
	        shimmer.wrapMethod(result, 'query.on', 'on', function queryOnWrapper(on) {
	          return function queryOnWrapped() {
	            if (arguments[1]) {
	              if (arguments[0] !== 'row') {
	                arguments[1] = bindCallback(arguments[1])
	              } else {
	                arguments[1] = tracer.bindFunction(arguments[1], segment, true)
	              }
	            }
	            return on.apply(this, arguments)
	          }
	        })
	
	        shimmer.wrapMethod(
	          result,
	          'query.addListener',
	          'addListener',
	          queryAddListenerWrapper
	        )
	
	        function queryAddListenerWrapper(addL) {
	          return function queryAddListenerWrapped() {
	            if (arguments[1]) {
	              if (arguments[0] !== 'row') {
	                arguments[1] = bindCallback(arguments[1])
	              } else {
	                arguments[1] = tracer.bindFunction(arguments[1], segment, true)
	              }
	            }
	            addL.apply(this, arguments)
	          }
	        }
	
	        return result
	      }
	    }
	  }
	
	  // wrapping for JS
	  shimmer.wrapMethod(
	    pgsql && pgsql.Client && pgsql.Client.prototype,
	    'pg.Client.prototype',
	    'query',
	    wrapQuery
	  )
	
	  function wrapQuery(original) {
	    return tracer.wrapFunction(
	      POSTGRES.STATEMENT + 'Unknown',
	      null,
	      original,
	      queryWrapper,
	      responseWrapper
	    )
	  }
	
	  function queryWrapper(segment, args, bindCallback) {
	    var position = args.length - 1
	    var last = args[position]
	
	    initializeSegment(tracer, segment, this, args[0])
	
	    // Proxy callbacks in case they start new segments
	    if (typeof last === 'function') {
	      args[position] = bindCallback(last, true, true)
	    } else if (Array.isArray(last) && typeof last[last.length - 1] === 'function') {
	      var callback = last[last.length - 1]
	      last[last.length - 1] = bindCallback(callback)
	    }
	
	    return args
	  }
	
	  function responseWrapper(segment, query, bindCallback) {
	    // Use end and error events to end segments
	    query.on('error', end)
	    query.on('end', end)
	
	    function end() {
	      segment.end()
	      logger.trace(
	        'postgres command trace segment ended by event for transaction %s.',
	        segment.transaction.id
	      )
	    }
	
	    // Proxy events too, in case they start new segments within handlers
	    shimmer.wrapMethod(query, 'query.on', 'on', function queryOnWrapper(on) {
	      return function queryOnWrapped() {
	        if (arguments[1]) {
	          if (arguments[0] !== 'row') {
	            arguments[1] = bindCallback(arguments[1])
	          } else {
	            arguments[1] = tracer.bindFunction(arguments[1], segment, true)
	          }
	        }
	        return on.apply(this, arguments)
	      }
	    })
	
	    shimmer.wrapMethod(query, 'query.addListener', 'addListener', addListenerWrapper)
	
	    function addListenerWrapper(addL) {
	      return function wrappedAddListener() {
	        if (arguments[1]) {
	          if (arguments[0] !== 'row') {
	            arguments[1] = bindCallback(arguments[1])
	          } else {
	            arguments[1] = tracer.bindFunction(arguments[1], segment, true)
	          }
	        }
	        addL.apply(this, arguments)
	      }
	    }
	
	    return query
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var wrap = __webpack_require__(199).wrapMethod
	
	module.exports = initialize
	
	function initialize(agent, Q) {
	  function wrapUninstrumented(original, method) {
	    return agent.tracer.wrapFunctionFirstNoSegment(original, method)
	  }
	
	  if (Q.nextTick) {
	    // The wrap() call for nextTick wipes the sub-function.  Save a reference
	    // now so it can be restored later
	    var savedRunAfter = Q.nextTick.runAfter
	
	    wrap(Q, 'Q', 'nextTick', wrapUninstrumented)
	
	    if (savedRunAfter) {
	      Q.nextTick.runAfter = savedRunAfter
	      wrap(Q.nextTick, 'Q.nextTick', 'runAfter', wrapUninstrumented)
	    }
	  }
	}


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(12).child({component: 'redis'})
	var stringifySync = __webpack_require__(14).stringifySync
	var shimmer = __webpack_require__(199)
	var urltils = __webpack_require__(168)
	var recordRedis = __webpack_require__(226)
	var REDIS = __webpack_require__(59).REDIS
	
	
	module.exports = function initialize(agent, redis) {
	  var tracer = agent.tracer
	
	  var redisPrototype = redis && redis.RedisClient && redis.RedisClient.prototype
	  if (redisPrototype) {
	    if (redisPrototype.internal_send_command) {
	      shimmer.wrapMethod(
	        redisPrototype,
	        'redis.RedisClient.prototype',
	        'internal_send_command',
	        function wrapSendCommand(original) {
	          return tracer.wrapFunction(
	            REDIS.OPERATION + 'Unknown',
	            recordRedis,
	            original,
	            internalSendCommandWrapper
	          )
	        }
	      )
	    } else {
	      shimmer.wrapMethod(
	        redisPrototype,
	        'redis.RedisClient.prototype',
	        'send_command',
	        function wrapSendCommand(original) {
	          return tracer.wrapFunction(
	            REDIS.OPERATION + 'Unknown',
	            recordRedis,
	            original,
	            sendCommandWrapper
	          )
	        }
	      )
	    }
	  }
	
	  function sendCommandWrapper(segment, args, bind) {
	    var position = args.length - 1
	    var keys = args[1]
	    var last = args[position]
	
	    segment.name = REDIS.OPERATION + (args[0] || 'unknown')
	
	    if (keys && typeof keys !== 'function') {
	      urltils.copyParameters(agent.config,
	        {key: stringifySync(keys[0], 'Unknown')}, segment.parameters)
	    }
	
	    // capture connection info for datastore instance metric
	    captureInstanceAttributes(segment, this)
	
	    if (typeof last === 'function') {
	      args[position] = bind(last, true, true)
	    } else if (Array.isArray(last) && typeof last[last.length - 1] === 'function') {
	      last[last.length - 1] = bind(last[last.length - 1], true, true)
	    } else { // let's shove a callback in there for fun
	      args.push(bind(null, true, true))
	    }
	
	    return args
	  }
	
	  function internalSendCommandWrapper(segment, args, bind) {
	    var keys = args[0].args
	    var command = args[0].command
	    args[0].callback = bind(args[0].callback, true, true)
	
	    segment.name = REDIS.OPERATION + (command || 'unknown')
	
	    if (keys && typeof keys !== 'function') {
	      urltils.copyParameters(agent.config,
	        {key: stringifySync(keys[0], 'Unknown')}, segment.parameters)
	    }
	
	    // capture connection info for datastore instance metric
	    captureInstanceAttributes(segment, this)
	
	    return args
	  }
	}
	
	function captureInstanceAttributes(segment, client) {
	  if (client.hasOwnProperty('port') && client.hasOwnProperty('host')) {
	    // for redis <=0.11
	    doCapture(client)
	  } else if (client.hasOwnProperty('connection_options')) {
	    // for redis 2.4.0 - 2.6.2
	    doCapture(client.connection_options)
	  } else if (client.hasOwnProperty('connectionOption')) {
	    // for redis 0.12 - 2.2.5
	    doCapture(client.connectionOption)
	  } else if (client.hasOwnProperty('options')) {
	    // for redis 2.3.0 - 2.3.1
	    doCapture(client.options)
	  } else {
	    logger.debug('Could not access instance attributes on connection.')
	  }
	
	  function doCapture(opts) {
	    var db = (client.hasOwnProperty('selected_db') ? client.selected_db : opts.db) || 0
	
	    segment.captureDBInstanceAttributes(
	      opts.host || 'localhost',
	      opts.path || opts.port || '6379',
	      db
	    )
	  }
	}


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var shimmer = __webpack_require__(199)
	var logger = __webpack_require__(12).child({component: 'restify'})
	var urltils = __webpack_require__(168)
	var NAMES = __webpack_require__(59)
	
	
	function nameFromRoute(segment, route, context) {
	  if (!segment) return logger.error("No New Relic context to set Restify route name on.")
	  if (!route) return logger.error("No Restify route to use for naming.")
	
	  var transaction = segment.transaction
	  var path = (route.spec && (route.spec.path || route.spec.name)) || route.name
	
	
	  var params = context || route.params
	  if (params) {
	    urltils.copyParameters(transaction.agent.config, params, segment.parameters)
	  }
	
	  if (!path) return logger.warn({route: route}, "No path found on Restify route.")
	
	  // when route is a regexp, route.spec.path will be a regexp
	  if (path instanceof RegExp) path = path.source
	
	  transaction.nameState.setName(NAMES.RESTIFY.PREFIX, transaction.verb, 
	      NAMES.ACTION_DELIMITER, path)
	}
	
	module.exports = function initialize(agent, restify) {
	  /* Restify doesn't directly expose its Router constructor. We need to wait
	   * until a server is created, and then grab the constructor off of it.
	   *
	   * Unfortunately, we can't create a server ourselves as doing so causes
	   * Restify's req.query extension to override express' req.query extension of
	   * IncomingMessage. This is an issue if an app uses express for serving while
	   * using Restify only for client-side REST requests.
	   */
	  shimmer.wrapMethod(
	    restify,
	    'restify',
	    'createServer',
	    function cb_wrapMethod(createServer) {
	      return function wrappedCreateServer() {
	        agent.environment.setDispatcher('restify')
	        agent.environment.setFramework('restify')
	
	        var server = createServer.apply(this, arguments)
	        var Router = server.router.constructor
	
	        /* Now that we have created a server, we have access to the Router
	         * constructor and can instrument it.
	         */
	        shimmer.wrapMethod(
	          Router.prototype,
	          'Router.prototype',
	          'find',
	          function cb_wrapMethod(find) {
	            return function wrappedFind(req, res, callback) {
	              var tracer = agent.tracer
	
	              if (!tracer.getTransaction()) {
	                logger.trace("Restify router invoked outside transaction.")
	                return find.apply(this, arguments)
	              }
	
	              var wrapped = function wrappedRoute(error, route, context) {
	                nameFromRoute(tracer.getSegment(), route, context)
	                return callback(error, route, context)
	              }
	
	              return find.call(this, req, res, wrapped)
	            }
	          }
	        )
	
	        return server
	      }
	    }
	  )
	}


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var NAMES = __webpack_require__(59)
	
	function record(segment, scope) {
	  var duration = segment.getDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var transaction = segment.transaction
	  var name = NAMES.CUSTOM + NAMES.ACTION_DELIMITER + segment.name
	
	  if (scope) transaction.measure(name, scope, duration, exclusive)
	
	  transaction.measure(name, null, duration, exclusive)
	}
	
	module.exports = record


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var NAMES = __webpack_require__(59)
	
	function recordBackground(segment, scope) {
	  var duration = segment.getDurationInMillis()
	  var exclusive = segment.getExclusiveDurationInMillis()
	  var totalTime = segment.transaction.trace.getTotalTimeDurationInMillis()
	  var transaction = segment.transaction
	  var group = segment.partialName
	  var name = group + '/' + segment.name
	
	  if (scope) {
	    transaction.measure(scope, null, duration, exclusive)
	    transaction.measure(
	      NAMES.BACKGROUND.TOTAL_TIME + '/' + name,
	      null,
	      totalTime,
	      exclusive
	    )
	  }
	  // rollup for background total time doesn't have `/all` where the response
	  // time version does.
	  transaction.measure(
	    NAMES.BACKGROUND.RESPONSE_TIME + '/all',
	    null,
	    duration,
	    exclusive
	  )
	  transaction.measure(NAMES.BACKGROUND.TOTAL_TIME, null, totalTime, exclusive)
	}
	
	module.exports = recordBackground


/***/ },
/* 240 */,
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var util = __webpack_require__(16)
	var logger = __webpack_require__(12).child({component: 'api'})
	var NAMES = __webpack_require__(59)
	var recordWeb = __webpack_require__(210)
	var recordBackground = __webpack_require__(239)
	var customRecorder = __webpack_require__(238)
	var hashes = __webpack_require__(62)
	var stringify = __webpack_require__(15)
	
	
	/*
	 *
	 * CONSTANTS
	 *
	 */
	var RUM_STUB = "<script type='text/javascript'>window.NREUM||(NREUM={});" +
	                "NREUM.info = %s; %s</script>"
	
	// these messages are used in the _gracefail() method below in getBrowserTimingHeader
	var RUM_ISSUES = [
	  'NREUM: no browser monitoring headers generated; disabled',
	  'NREUM: transaction missing while generating browser monitoring headers',
	  'NREUM: config.browser_monitoring missing, something is probably wrong',
	  'NREUM: browser_monitoring headers need a transaction name',
	  'NREUM: browser_monitoring requires valid application_id',
	  'NREUM: browser_monitoring requires valid browser_key',
	  'NREUM: browser_monitoring requires js_agent_loader script',
	  'NREUM: browser_monitoring disabled by browser_monitoring.loader config'
	]
	
	// can't overwrite internal parameters or all heck will break loose
	var CUSTOM_BLACKLIST = [
	  'nr_flatten_leading'
	]
	
	var CUSTOM_EVENT_TYPE_REGEX = /^[a-zA-Z0-9:_ ]+$/
	
	/**
	 * The exported New Relic API. This contains all of the functions meant to be
	 * used by New Relic customers. For now, that means transaction naming.
	 */
	function API(agent) {
	  this.agent = agent
	}
	
	/**
	 * Give the current transaction a custom name. Overrides any New Relic naming
	 * rules set in configuration or from New Relic's servers.
	 *
	 * IMPORTANT: this function must be called when a transaction is active. New
	 * Relic transactions are tied to web requests, so this method may be called
	 * from within HTTP or HTTPS listener functions, Express routes, or other
	 * contexts where a web request or response object are in scope.
	 *
	 * @param {string} name The name you want to give the web request in the New
	 *                      Relic UI. Will be prefixed with 'Custom/' when sent.
	 */
	API.prototype.setTransactionName = function setTransactionName(name) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/setTransactionName'
	  )
	  metric.incrementCallCount()
	
	  var transaction = this.agent.tracer.getTransaction()
	  if (!transaction) {
	    return logger.warn("No transaction found when setting name to '%s'.", name)
	  }
	
	  if (!name) {
	    if (transaction && transaction.url) {
	      logger.error("Must include name in setTransactionName call for URL %s.",
	                   transaction.url)
	    } else {
	      logger.error("Must include name in setTransactionName call.")
	    }
	
	    return
	  }
	
	  transaction.forceName = NAMES.CUSTOM + '/' + name
	}
	
	/**
	 * Give the current transaction a name based on your own idea of what
	 * constitutes a controller in your Node application. Also allows you to
	 * optionally specify the action being invoked on the controller. If the action
	 * is omitted, then the API will default to using the HTTP method used in the
	 * request (e.g. GET, POST, DELETE). Overrides any New Relic naming rules set
	 * in configuration or from New Relic's servers.
	 *
	 * IMPORTANT: this function must be called when a transaction is active. New
	 * Relic transactions are tied to web requests, so this method may be called
	 * from within HTTP or HTTPS listener functions, Express routes, or other
	 * contexts where a web request or response object are in scope.
	 *
	 * @param {string} name   The name you want to give the controller in the New
	 *                        Relic UI. Will be prefixed with 'Controller/' when
	 *                        sent.
	 * @param {string} action The action being invoked on the controller. Defaults
	 *                        to the HTTP method used for the request.
	 */
	API.prototype.setControllerName = function setControllerName(name, action) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/setControllerName'
	  )
	  metric.incrementCallCount()
	
	  var transaction = this.agent.tracer.getTransaction()
	  if (!transaction) {
	    return logger.warn("No transaction found when setting controller to %s.", name)
	  }
	
	  if (!name) {
	    if (transaction && transaction.url) {
	      logger.error("Must include name in setControllerName call for URL %s.",
	                   transaction.url)
	    } else {
	      logger.error("Must include name in setControllerName call.")
	    }
	
	    return
	  }
	
	  action = action || transaction.verb || 'GET'
	  transaction.forceName = NAMES.CONTROLLER + '/' + name + '/' + action
	}
	
	/**
	 * Add a custom parameter to the current transaction. Some parameters are
	 * reserved (see CUSTOM_BLACKLIST for the current, very short list), and
	 * as with most API methods, this must be called in the context of an
	 * active transaction. Most recently set value wins.
	 *
	 * @param {string} name  The name you want displayed in the RPM UI.
	 * @param {string} value The value you want displayed. Must be serializable.
	 */
	API.prototype.addCustomParameter = function addCustomParameter(name, value) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/addCustomParameter'
	  )
	  metric.incrementCallCount()
	
	  // If high security mode is on, custom params are disabled.
	  if (this.agent.config.high_security === true) {
	    logger.warnOnce(
	      "Custom params",
	      "Custom parameters are disabled by high security mode."
	    )
	    return false
	  }
	
	  var ignored = this.agent.config.ignored_params || []
	
	  var transaction = this.agent.tracer.getTransaction()
	  if (!transaction) {
	    return logger.warn("No transaction found for custom parameters.")
	  }
	
	  var trace = transaction.trace
	  if (!trace.custom) {
	    return logger.warn(
	      "Couldn't add parameter %s to nonexistent custom parameters.",
	      name
	    )
	  }
	
	  if (CUSTOM_BLACKLIST.indexOf(name) !== -1) {
	    return logger.warn("Not overwriting value of NR-only parameter %s.", name)
	  }
	
	  if (ignored.indexOf(name) !== -1) {
	    return logger.warn("Not setting ignored parameter name %s.", name)
	  }
	
	  if (name in trace.custom) {
	    logger.debug(
	      "Changing custom parameter %s from %s to %s.",
	      name,
	      trace.custom[name],
	      value
	    )
	  }
	
	  trace.custom[name] = value
	}
	
	/**
	 * Adds all custom parameters in an object to the current transaction.
	 *
	 * See documentation for newrelic.addCustomParameter for more information on
	 * setting custom parameters.
	 *
	 * An example of setting a custom parameter object:
	 *
	 *    newrelic.addCustomParameters({test: 'value', test2: 'value2'});
	 *
	 * @param {object} [params]
	 * @param {string} [params.KEY] The name you want displayed in the RPM UI.
	 * @param {string} [params.KEY.VALUE] The value you want displayed. Must be serializable.
	 */
	API.prototype.addCustomParameters = function addCustomParameters(params) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/addCustomParameters'
	  )
	  metric.incrementCallCount()
	
	  for (var key in params) {
	    if (!params.hasOwnProperty(key)) {
	      continue
	    }
	
	    this.addCustomParameter(key, params[key])
	  }
	}
	
	/**
	 * Tell the tracer whether to ignore the current transaction. The most common
	 * use for this will be to mark a transaction as ignored (maybe it's handling
	 * a websocket polling channel, or maybe it's an external call you don't care
	 * is slow), but it's also useful when you want a transaction that would
	 * otherwise be ignored due to URL or transaction name normalization rules
	 * to *not* be ignored.
	 *
	 * @param {boolean} ignored Ignore, or don't ignore, the current transaction.
	 */
	API.prototype.setIgnoreTransaction = function setIgnoreTransaction(ignored) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/setIgnoreTransaction'
	  )
	  metric.incrementCallCount()
	
	  var transaction = this.agent.tracer.getTransaction()
	  if (!transaction) {
	    return logger.warn("No transaction found to ignore.")
	  }
	
	  transaction.forceIgnore = ignored
	}
	
	/**
	 * Send errors to New Relic that you've already handled yourself. Should
	 * be an Error or one of its subtypes, but the API will handle strings
	 * and objects that have an attached .message or .stack property.
	 *
	 * @param {Error}  error            The error to be traced.
	 * @param {object} customParameters Any custom parameters to be displayed in
	 *                                  the New Relic UI.
	 */
	API.prototype.noticeError = function noticeError(error, customParameters) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/noticeError'
	  )
	  metric.incrementCallCount()
	
	
	  if (typeof error === 'string') error = new Error(error)
	  var transaction = this.agent.tracer.getTransaction()
	
	  this.agent.errors.addUserError(transaction, error, customParameters)
	}
	
	/**
	 * If the URL for a transaction matches the provided pattern, name the
	 * transaction with the provided name. If there are capture groups in the
	 * pattern (which is a standard JavaScript regular expression, and can be
	 * passed as either a RegExp or a string), then the substring matches ($1, $2,
	 * etc.) are replaced in the name string. BE CAREFUL WHEN USING SUBSTITUTION.
	 * If the replacement substrings are highly variable (i.e. are identifiers,
	 * GUIDs, or timestamps), the rule will generate too many metrics and
	 * potentially get your application blacklisted by New Relic.
	 *
	 * An example of a good rule with replacements:
	 *
	 *   newrelic.addNamingRule('^/storefront/(v[1-5])/(item|category|tag)',
	 *                          'CommerceAPI/$1/$2')
	 *
	 * An example of a bad rule with replacements:
	 *
	 *   newrelic.addNamingRule('^/item/([0-9a-f]+)', 'Item/$1')
	 *
	 * Keep in mind that the original URL and any query parameters will be sent
	 * along with the request, so slow transactions will still be identifiable.
	 *
	 * Naming rules can not be removed once added. They can also be added via the
	 * agent's configuration. See configuration documentation for details.
	 *
	 * @param {RegExp} pattern The pattern to rename (with capture groups).
	 * @param {string} name    The name to use for the transaction.
	 */
	API.prototype.addNamingRule = function addNamingRule(pattern, name) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/addNamingRule'
	  )
	  metric.incrementCallCount()
	
	
	  if (!name) return logger.error("Simple naming rules require a replacement name.")
	
	  this.agent.userNormalizer.addSimple(pattern, '/' + name)
	}
	
	/**
	 * If the URL for a transaction matches the provided pattern, ignore the
	 * transaction attached to that URL. Useful for filtering socket.io connections
	 * and other long-polling requests out of your agents to keep them from
	 * distorting an app's apdex or mean response time. Pattern may be a (standard
	 * JavaScript) RegExp or a string.
	 *
	 * Example:
	 *
	 *   newrelic.addIgnoringRule('^/socket\\.io/')
	 *
	 * @param {RegExp} pattern The pattern to ignore.
	 */
	API.prototype.addIgnoringRule = function addIgnoringRule(pattern) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/addIgnoringRule'
	  )
	  metric.incrementCallCount()
	
	  if (!pattern) return logger.error("Must include a URL pattern to ignore.")
	
	  this.agent.userNormalizer.addSimple(pattern, null)
	}
	
	/**
	 * Get the <script>...</script> header necessary for Browser Monitoring
	 * This script must be manually injected into your templates, as high as possible
	 * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.
	 * Otherwise you may hurt IE!
	 *
	 * This method must be called _during_ a transaction, and must be called every
	 * time you want to generate the headers.
	 *
	 * Do *not* reuse the headers between users, or even between requests.
	 *
	 * @returns {string} the <script> header to be injected
	 */
	API.prototype.getBrowserTimingHeader = function getBrowserTimingHeader() {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/getBrowserTimingHeader'
	  )
	  metric.incrementCallCount()
	
	  var config = this.agent.config
	
	  /* Gracefully fail.
	   *
	   * Output an HTML comment and log a warning the comment is meant to be
	   * innocuous to the end user.
	   */
	  function _gracefail(num) {
	    logger.warn(RUM_ISSUES[num])
	    return '<!-- NREUM: (' + num + ') -->'
	  }
	
	  var browser_monitoring = config.browser_monitoring
	
	  // config.browser_monitoring should always exist, but we don't want the agent to bail
	  // here if something goes wrong
	  if (!browser_monitoring) return _gracefail(2)
	
	  /* Can control header generation with configuration this setting is only
	   * available in the newrelic.js config file, it is not ever set by the
	   * server.
	   */
	  if (!browser_monitoring.enable) return _gracefail(0)
	
	  var trans = this.agent.getTransaction()
	
	  // bail gracefully outside a transaction
	  if (!trans) return _gracefail(1)
	
	  var name = trans.getName()
	
	  /* If we're in an unnamed transaction, add a friendly warning this is to
	   * avoid people going crazy, trying to figure out why browser monitoring is
	   * not working when they're missing a transaction name.
	   */
	  if (!name) return _gracefail(3)
	
	  var time = trans.timer.getDurationInMillis()
	
	  /*
	   * Only the first 13 chars of the license should be used for hashing with
	   * the transaction name.
	   */
	  var key = config.license_key.substr(0, 13)
	  var appid = config.application_id
	
	  /* This is only going to work if the agent has successfully handshaked with
	   * the collector. If the networks is bad, or there is no license key set in
	   * newrelis.js, there will be no application_id set.  We bail instead of
	   * outputting null/undefined configuration values.
	   */
	  if (!appid) return _gracefail(4)
	
	  /* If there is no browser_key, the server has likely decided to disable
	   * browser monitoring.
	   */
	  var licenseKey = browser_monitoring.browser_key
	  if (!licenseKey) return _gracefail(5)
	
	  /* If there is no agent_loader script, there is no point
	   * in setting the rum data
	   */
	  var js_agent_loader = browser_monitoring.js_agent_loader
	  if (!js_agent_loader) return _gracefail(6)
	
	  /* If rum is enabled, but then later disabled on the server,
	   * this is the only parameter that gets updated.
	   *
	   * This condition should only be met if rum is disabled during
	   * the lifetime of an application, and it should be picked up
	   * on the next ForceRestart by the collector.
	   */
	  var loader = browser_monitoring.loader
	  if (loader === 'none') return _gracefail(7)
	
	  // This hash gets written directly into the browser.
	  var rum_hash = {
	    agent: browser_monitoring.js_agent_file,
	    beacon: browser_monitoring.beacon,
	    errorBeacon: browser_monitoring.error_beacon,
	    licenseKey: licenseKey,
	    applicationID: appid,
	    applicationTime: time,
	    transactionName: hashes.obfuscateNameUsingKey(name, key),
	    queueTime: trans.queueTime,
	    ttGuid: trans.id,
	
	    // we don't use these parameters yet
	    agentToken: null
	  }
	
	  // if debugging, do pretty format of JSON
	  var tabs = config.browser_monitoring.debug ? 2 : 0
	  var json = JSON.stringify(rum_hash, null, tabs)
	
	
	  // the complete header to be written to the browser
	  var out = util.format(
	    RUM_STUB,
	    json,
	    js_agent_loader
	  )
	
	  logger.trace('generating RUM header', out)
	
	  return out
	}
	
	/**
	 * This creates a new tracer with the passed in name. It then wraps the
	 * callback and binds it to the current transaction and segment so any further
	 * custom instrumentation as well as auto instrumentation will also be able to
	 * find the current transaction and segment.
	 */
	API.prototype.createTracer = function createTracer(name, callback) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/createTracer'
	  )
	  metric.incrementCallCount()
	
	  // FLAG: custom_instrumentation
	  if (!this.agent.config.feature_flag.custom_instrumentation) {
	    return callback
	  }
	
	  var fail = false
	  if (!name) {
	    logger.warn('createTracer called without a name')
	    fail = true
	  }
	
	  if (typeof callback !== 'function') {
	    logger.warn('createTracer called with a callback arg that is not a function')
	    fail = true
	  }
	
	  if (fail) {
	    // If name is undefined but callback is defined we should make a best effort
	    // to return it so things don't crash.
	    return callback
	  }
	
	  var tracer = this.agent.tracer
	  var txn = tracer.getTransaction()
	  if (!txn) {
	    logger.debug(
	      'createTracer called with %s (%s) outside of a transaction, ' +
	        'unable to create tracer.',
	      name,
	      callback && callback.name
	    )
	    return callback
	  }
	
	  logger.debug(
	    'creating tracer %s (%s) on transaction %s.',
	    name,
	    callback && callback.name,
	    txn.id
	  )
	
	  var segment = tracer.createSegment(name, customRecorder)
	  segment.start()
	  return tracer.bindFunction(callback, segment, true)
	}
	
	/**
	 * Creates a function that represents a web transaction. It does not start the
	 * transaction automatically - the returned function needs to be invoked to start it.
	 * Inside the handler function, the transaction must be ended by calling endTransaction().
	 *
	 * @example
	 * var newrelic = require('newrelic')
	 * var transaction = newrelic.createWebTransaction('/some/url/path', function() {
	 *   // do some work
	 *   newrelic.endTransaction()
	 * })
	 *
	 * @param {string}    url       The URL of the transaction.  It is used to name and group
	                                related transactions in APM, so it should be a generic
	                                name and not iclude any variable parameters.
	 * @param {Function}  handle    Function that represents the transaction work.
	 */
	API.prototype.createWebTransaction = function createWebTransaction(url, handle) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/createWebTransaction'
	  )
	  metric.incrementCallCount()
	
	  // FLAG: custom_instrumentation
	  if (!this.agent.config.feature_flag.custom_instrumentation) {
	    return handle
	  }
	
	  var fail = false
	  if (!url) {
	    logger.warn('createWebTransaction called without an url')
	    fail = true
	  }
	
	  if (typeof handle !== 'function') {
	    logger.warn('createWebTransaction called with a handle arg that is not a function')
	    fail = true
	  }
	
	  if (fail) {
	    // If name is undefined but handle is defined we should make a best effort
	    // to return it so things don't crash.
	    return handle
	  }
	
	  logger.debug(
	    'creating web transaction generator %s (%s).',
	    url,
	    handle && handle.name
	  )
	
	  var tracer = this.agent.tracer
	
	  return tracer.transactionNestProxy('web', function createWebSegment() {
	    var tx = tracer.getTransaction()
	
	    logger.debug(
	      'creating web transaction %s (%s) with transaction id: %s',
	      url,
	      handle && handle.name,
	      tx.id
	    )
	    tx.nameState.setName(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url)
	    tx.url = url
	    tx.applyUserNamingRules(tx.url)
	    tx.webSegment = tracer.createSegment(url, recordWeb)
	    tx.webSegment.start()
	
	    return tracer.bindFunction(handle, tx.webSegment).apply(this, arguments)
	  })
	}
	
	/**
	 * Creates a function that represents a background transaction. It does not start the
	 * transaction automatically - the returned function needs to be invoked to start it.
	 * Inside the handler function, the transaction must be ended by calling endTransaction().
	 *
	 * @example
	 * var newrelic = require('newrelic')
	 * var transaction = newrelic.createBackgroundTransaction('myTransaction', function() {
	 *   // do some work
	 *   newrelic.endTransaction()
	 * })
	 *
	 * @param {string}    name      The name of the transaction.  It is used to name and group
	                                related transactions in APM, so it should be a generic
	                                name and not iclude any variable parameters.
	 * @param {string}    [group]   Optional, used for grouping background transactions in
	 *                              APM.  For more information see:
	 *                              https://docs.newrelic.com/docs/apm/applications-menu/monitoring/transactions-page#txn-type-dropdown
	 * @param {Function}  handle    Function that represents the background work.
	 */
	API.prototype.createBackgroundTransaction = createBackgroundTransaction
	
	function createBackgroundTransaction(name, group, handle) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/createBackgroundTransaction'
	  )
	  metric.incrementCallCount()
	
	  if (handle === undefined && typeof group === 'function') {
	    handle = group
	    group = 'Nodejs'
	  }
	  // FLAG: custom_instrumentation
	  if (!this.agent.config.feature_flag.custom_instrumentation) {
	    return handle
	  }
	
	  var fail = false
	  if (!name) {
	    logger.warn('createBackgroundTransaction called without an url')
	    fail = true
	  }
	
	  if (typeof handle !== 'function') {
	    logger.warn(
	      'createBackgroundTransaction called with a handle arg that is not a function'
	    )
	    fail = true
	  }
	
	  if (fail) {
	    // If name is undefined but handle is defined we should make a best effort
	    // to return it so things don't crash.
	    return handle
	  }
	
	  logger.debug(
	    'creating background transaction generator %s:%s (%s)',
	    name,
	    group,
	    handle && handle.name
	  )
	
	  var tracer = this.agent.tracer
	
	  return tracer.transactionNestProxy('bg', function createBackgroundSegment() {
	    var tx = tracer.getTransaction()
	
	    logger.debug(
	      'creating background transaction %s:%s (%s) with transaction id: %s',
	      name,
	      group,
	      handle && handle.name,
	      tx.id
	    )
	
	    tx.setBackgroundName(name, group)
	    tx.bgSegment = tracer.createSegment(name, recordBackground)
	    tx.bgSegment.partialName = group
	    tx.bgSegment.start()
	
	    return tracer.bindFunction(handle, tx.bgSegment).apply(this, arguments)
	  })
	}
	
	API.prototype.endTransaction = function endTransaction() {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/endTransaction'
	  )
	  metric.incrementCallCount()
	
	  // FLAG: custom_instrumentation
	  if (!this.agent.config.feature_flag.custom_instrumentation) {
	    return
	  }
	
	  var tracer = this.agent.tracer
	  var tx = tracer.getTransaction()
	
	  if (tx) {
	    if (tx.webSegment) {
	      tx.setName(tx.url, 0)
	      tx.webSegment.markAsWeb(tx.url)
	      tx.webSegment.end()
	    } else if (tx.bgSegment) {
	      tx.bgSegment.end()
	    }
	    logger.debug('ending transaction with id: %s and name: %s', tx.id, tx.name)
	    tx.end()
	  } else {
	    logger.debug('endTransaction() called while not in a transaction.')
	  }
	}
	
	API.prototype.recordMetric = function recordMetric(name, value) {
	  var supportMetric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/recordMetric'
	  )
	  supportMetric.incrementCallCount()
	
	  // FLAG: custom_metrics
	  if (!this.agent.config.feature_flag.custom_metrics) {
	    return
	  }
	
	  if (typeof name !== 'string') {
	    logger.warn('Metric name must be a string')
	    return
	  }
	
	  var metric = this.agent.metrics.getOrCreateMetric(name)
	
	  if (typeof value === 'number') {
	    metric.recordValue(value)
	    return
	  }
	
	  if (typeof value !== 'object') {
	    logger.warn('Metric value must be either a number, or a metric object')
	    return
	  }
	
	  var stats = {}
	  var required = ['count', 'total', 'min', 'max', 'sumOfSquares']
	  var keyMap = {count: 'callCount'}
	
	  for (var i = 0, l = required.length; i < l; ++i) {
	    if (typeof value[required[i]] !== 'number') {
	      logger.warn('Metric object must include ' + required[i] + ' as a number')
	      return
	    }
	
	    var key = keyMap[required[i]] || required[i]
	    stats[key] = value[required[i]]
	  }
	
	  if (typeof value.totalExclusive === 'number') {
	    stats.totalExclusive = value.totalExclusive
	  } else {
	    stats.totalExclusive = value.total
	  }
	
	  metric.merge(stats)
	}
	
	API.prototype.incrementMetric = function incrementMetric(name, value) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/incrementMetric'
	  )
	  metric.incrementCallCount()
	
	  // FLAG: custom_metrics
	  if (!this.agent.config.feature_flag.custom_metrics) {
	    return
	  }
	
	  if (!value && value !== 0) {
	    value = 1
	  }
	
	  if (typeof value !== 'number' || value % 1 !== 0) {
	    logger.warn('Metric Increment value must be an integer')
	    return
	  }
	
	  this.recordMetric(name, {
	    count: value,
	    total: 0,
	    min: 0,
	    max: 0,
	    sumOfSquares: 0
	  })
	}
	
	API.prototype.recordCustomEvent = function recordCustomEvent(eventType, attributes) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/recordCustomEvent'
	  )
	  metric.incrementCallCount()
	
	  if (!this.agent.config.custom_insights_events.enabled) {
	    return
	  }
	  // Check all the arguments before bailing to give maximum information in a
	  // single invocation.
	  var fail = false
	
	  if (!eventType || typeof eventType !== 'string') {
	    logger.warn(
	      'recordCustomEvent requires a string for its first argument, got %s (%s)',
	      stringify(eventType),
	      typeof eventType
	    )
	    fail = true
	  } else if (!CUSTOM_EVENT_TYPE_REGEX.test(eventType)) {
	    logger.warn(
	      'recordCustomEvent eventType of %s is invalid, it must match /%s/',
	      eventType,
	      CUSTOM_EVENT_TYPE_REGEX.source
	    )
	    fail = true
	  } else if (eventType.length > 255) {
	    logger.warn(
	      'recordCustomEvent eventType must have a length less than 256, got %s (%s)',
	      eventType,
	      eventType.length
	    )
	    fail = true
	  }
	  // If they don't pass an attributes object, or the attributes argument is not
	  // an object, or if it is an object and but is actually an array, log a
	  // warning and set the fail bit.
	  if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {
	    logger.warn(
	      'recordCustomEvent requires an object for its second argument, got %s (%s)',
	      stringify(attributes),
	      typeof attributes
	    )
	    fail = true
	  } else if (_checkKeyLength(attributes, 255)) {
	    fail = true
	  }
	
	  if (fail) {
	    return
	  }
	
	  var instrinics = {
	    type: eventType,
	    timestamp: Date.now()
	  }
	
	  this.agent.customEvents.add([instrinics, attributes])
	}
	
	/**
	 * Shuts down the agent.
	 *
	 * @param {object}  [options]                           object with shut down options
	 * @param {boolean} [options.collectPendingData=false]  If true, the agent will send any
	 *                                                      pending data to the collector
	 *                                                      before shutting down.
	 * @param {number}  [options.timeout]                   time in ms to wait before
	 *                                                      shutting down
	 * @param {function} [callback]                         callback function that runs when
	 *                                                      agent stopped
	 */
	API.prototype.shutdown = function shutdown(options, cb) {
	  var metric = this.agent.metrics.getOrCreateMetric(
	    NAMES.SUPPORTABILITY.API + '/shutdown'
	  )
	  metric.incrementCallCount()
	
	  var callback = cb
	  if (!callback) {
	    if (typeof options === 'function') {
	      callback = options
	    } else {
	      callback = function noop() {}
	    }
	  }
	
	  var agent = this.agent
	
	  function cb_harvest(error) {
	    if (error) {
	      logger.error(
	        error,
	        'An error occurred while running last harvest before shutdown.'
	      )
	    }
	    agent.stop(callback)
	  }
	
	  if (options && options.collectPendingData && agent._state !== 'started') {
	    if (typeof options.timeout === 'number') {
	      var shutdownTimeout = setTimeout(function shutdownTimeout() {
	        agent.stop(callback)
	      }, options.timeout)
	      // timer.unref only in 0.9+
	      if (shutdownTimeout.unref) {
	        shutdownTimeout.unref()
	      }
	    } else if (options.timeout) {
	      logger.warn(
	        'options.timeout should be of type "number". Got %s',
	        typeof options.timeout
	      )
	    }
	
	    agent.on('started', function shutdownHarvest() {
	      agent.harvest(cb_harvest)
	    })
	    agent.on('errored', function logShutdownError(error) {
	      agent.stop(callback)
	      if (error) {
	        logger.error(
	          error,
	          'The agent encountered an error after calling shutdown.'
	        )
	      }
	    })
	  } else if (options && options.collectPendingData) {
	    agent.harvest(cb_harvest)
	  } else {
	    agent.stop(callback)
	  }
	}
	
	function _checkKeyLength(object, maxLength) {
	  var keys = Object.keys(object)
	  var badKey = false
	  var len = keys.length
	  var key = '' // init to string because gotta go fast
	  for (var i = 0; i < len; i++) {
	    key = keys[i]
	    if (key.length > maxLength) {
	      logger.warn(
	        'recordCustomEvent requires keys to be less than 256 chars got %s (%s)',
	        key,
	        key.length
	      )
	      badKey = true
	    }
	  }
	  return badKey
	}
	
	module.exports = API


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'
	
	var logger = __webpack_require__(12)
	var RealAPI = __webpack_require__(241)
	
	
	/* eslint-disable no-eval */
	function stubFunction(name) {
	  return eval("(function () {return function " + name + "() {" +
	              "logger.debug('Not calling " + name + " because New Relic is disabled.');" +
	              "}}())")
	}
	/* eslint-enable no-eval */
	
	function Stub() {}
	
	var keys = Object.keys(RealAPI.prototype)
	var length = keys.length
	
	
	/* This way the stub API doesn't have to be updated in lockstep with the regular
	 * API.
	 */
	for (var i = 0; i < length; i++) {
	  var functionName = keys[i]
	  Stub.prototype[functionName] = stubFunction(functionName)
	}
	
	Stub.prototype.createTracer = createTracer
	Stub.prototype.createWebTransaction = createWebTransaction
	Stub.prototype.createBackgroundTransaction = createBackgroundTransaction
	Stub.prototype.getBrowserTimingHeader = getBrowserTimingHeader
	Stub.prototype.shutdown = shutdown
	
	// This code gets injected into HTML templates
	// and we don't want it to return undefined/null.
	function getBrowserTimingHeader() {
	  logger.debug('Not calling getBrowserTimingHeader because New Relic is disabled.')
	  return ''
	}
	
	// Normally the following 3 calls return a wrapped callback, instead we
	// should just return the callback in its unwrapped state.
	function createTracer(name, callback) {
	  logger.debug('Not calling createTracer because New Relic is disabled.')
	  return callback
	}
	
	function createWebTransaction(url, callback) {
	  logger.debug('Not calling createWebTransaction because New Relic is disabled.')
	  return callback
	}
	
	function createBackgroundTransaction(name, group, callback) {
	  logger.debug('Not calling createBackgroundTransaction because New Relic is disabled.')
	  return (callback === undefined) ? group : callback
	}
	
	// Normally the following call executes callback asynchronously
	function shutdown(options, cb) {
	  logger.debug('Not calling shutdown because New Relic is disabled.')
	  
	  var callback = cb
	  if (!callback) {
	    if (typeof options === 'function') {
	      callback = options
	    } else {
	      callback = new Function()
	    }
	  }
	  
	  process.nextTick(callback)
	}
	
	module.exports = Stub
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ }
/******/ ]);
//# sourceMappingURL=bundle.js.map