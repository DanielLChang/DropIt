{"version":3,"sources":["webpack:///webpack/bootstrap 0bc1273c071303230340","webpack:///./frontend/dropit.js","webpack:///./frontend/animations.js","webpack:///./~/animejs/anime.js","webpack:///./frontend/sounds/sound_set_1.js","webpack:///./frontend/sounds/sound_set_2.js","webpack:///./frontend/sounds/sound_set_3.js","webpack:///./frontend/sounds/sound_set_4.js","webpack:///./frontend/howler.min.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./frontend/start.js","webpack:///./~/newrelic/index.js","webpack:///./~/process/browser.js","webpack:///./~/newrelic/lib/logger.js","webpack:///./~/newrelic/lib/util/logger.js","webpack:///./~/newrelic/lib/util/safe-json.js","webpack:///./~/newrelic/~/json-stringify-safe/stringify.js","webpack:///./~/util/util.js","webpack:///./~/util/support/isBufferBrowser.js","webpack:///./~/util/~/inherits/inherits_browser.js","webpack:///./~/newrelic/~/readable-stream/readable.js","webpack:///./~/newrelic/~/readable-stream/lib/_stream_readable.js","webpack:///./~/newrelic/~/readable-stream/~/isarray/index.js","webpack:///./~/buffer/index.js","webpack:///./~/base64-js/index.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js","webpack:///./~/events/events.js","webpack:///./~/stream-browserify/index.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/readable-stream/readable.js","webpack:///./~/readable-stream/lib/_stream_readable.js","webpack:///./~/process-nextick-args/index.js","webpack:///./~/buffer-shims/index.js","webpack:///./~/core-util-is/lib/util.js","webpack:///util (ignored)","webpack:///./~/readable-stream/lib/internal/streams/BufferList.js","webpack:///./~/readable-stream/lib/_stream_duplex.js","webpack:///./~/readable-stream/lib/_stream_writable.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/util-deprecate/browser.js","webpack:///./~/string_decoder/index.js","webpack:///./~/readable-stream/lib/_stream_transform.js","webpack:///./~/readable-stream/lib/_stream_passthrough.js","webpack:///./~/readable-stream/writable.js","webpack:///./~/readable-stream/duplex.js","webpack:///./~/readable-stream/transform.js","webpack:///./~/readable-stream/passthrough.js","webpack:///./~/newrelic/~/readable-stream/~/core-util-is/lib/util.js","webpack:///./~/newrelic/~/readable-stream/~/inherits/inherits_browser.js","webpack:///util (ignored)?56dd","webpack:///./~/newrelic/~/readable-stream/lib/_stream_duplex.js","webpack:///./~/newrelic/~/readable-stream/lib/_stream_writable.js","webpack:///./~/newrelic/~/readable-stream/~/string_decoder/index.js","webpack:///./~/newrelic/~/readable-stream/lib/_stream_transform.js","webpack:///./~/newrelic/~/readable-stream/lib/_stream_passthrough.js","webpack:///./~/os-browserify/browser.js","webpack:///./~/newrelic/lib/config.js","webpack:///./~/path-browserify/index.js","webpack:///./~/newrelic/lib/metrics/names.js","webpack:///./~/newrelic/lib/feature_flags.js","webpack:///./~/newrelic/lib/util/flatten.js","webpack:///./~/newrelic/lib/util/hashes.js","webpack:///./~/crypto-browserify/index.js","webpack:///./~/crypto-browserify/rng.js","webpack:///crypto (ignored)","webpack:///./~/crypto-browserify/create-hash.js","webpack:///./~/sha.js/index.js","webpack:///./~/sha.js/hash.js","webpack:///./~/sha.js/sha1.js","webpack:///./~/sha.js/sha256.js","webpack:///./~/sha.js/sha512.js","webpack:///./~/crypto-browserify/md5.js","webpack:///./~/crypto-browserify/helpers.js","webpack:///./~/ripemd160/lib/ripemd160.js","webpack:///./~/crypto-browserify/create-hmac.js","webpack:///./~/crypto-browserify/pbkdf2.js","webpack:///./~/pbkdf2-compat/pbkdf2.js","webpack:///./~/browserify-aes/inject.js","webpack:///./~/browserify-aes/encrypter.js","webpack:///./~/browserify-aes/aes.js","webpack:///./~/browserify-aes/cipherBase.js","webpack:///./~/browserify-aes/modes.js","webpack:///./~/browserify-aes/EVP_BytesToKey.js","webpack:///./~/browserify-aes/streamCipher.js","webpack:///./~/browserify-aes/modes/ecb.js","webpack:///./~/browserify-aes/modes/cbc.js","webpack:///./~/browserify-aes/xor.js","webpack:///./~/browserify-aes/modes/cfb.js","webpack:///./~/browserify-aes/modes/ofb.js","webpack:///./~/browserify-aes/modes/ctr.js","webpack:///./~/browserify-aes/decrypter.js","webpack:///./~/newrelic/lib ^\\.\\/.*$","webpack:///./~/newrelic/lib/agent.js","webpack:///./~/newrelic/lib/reservoir.js","webpack:///./~/newrelic/lib/sampler.js","webpack:///./~/newrelic/lib/timer.js","webpack:///./~/newrelic/lib/collector/api.js","webpack:///./~/newrelic/lib/collector/facts.js","webpack:///./~/newrelic/lib/system-info.js","webpack:///./~/newrelic/lib/aws-info.js","webpack:///./~/stream-http/index.js","webpack:///./~/stream-http/lib/request.js","webpack:///./~/stream-http/lib/capability.js","webpack:///./~/stream-http/lib/response.js","webpack:///./~/to-arraybuffer/index.js","webpack:///./~/xtend/immutable.js","webpack:///./~/builtin-status-codes/browser.js","webpack:///./~/url/url.js","webpack:///./~/url/~/punycode/punycode.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/url/util.js","webpack:///./~/querystring/index.js","webpack:///./~/querystring/decode.js","webpack:///./~/querystring/encode.js","webpack:///./~/newrelic/~/concat-stream/index.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/readable.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_readable.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/~/process-nextick-args/index.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/~/isarray/index.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/~/buffer-shims/index.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/~/core-util-is/lib/util.js","webpack:///./~/newrelic/~/concat-stream/~/inherits/inherits_browser.js","webpack:///util (ignored)?ca48","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/lib/internal/streams/BufferList.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_duplex.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_writable.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/~/util-deprecate/browser.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/~/string_decoder/index.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_transform.js","webpack:///./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_passthrough.js","webpack:///./~/newrelic/~/concat-stream/~/typedarray/index.js","webpack:///./~/newrelic/lib/parse-proc-cpuinfo.js","webpack:///./~/newrelic/lib/parse-dockerinfo.js","webpack:///./~/newrelic/lib/parse-proc-meminfo.js","webpack:///./~/newrelic/lib/util/label-parser.js","webpack:///./~/newrelic/lib/collector/remote-method.js","webpack:///./~/https-browserify/index.js","webpack:///./~/browserify-zlib/src/index.js","webpack:///./~/browserify-zlib/src/binding.js","webpack:///./~/pako/lib/zlib/messages.js","webpack:///./~/pako/lib/zlib/zstream.js","webpack:///./~/pako/lib/zlib/deflate.js","webpack:///./~/pako/lib/utils/common.js","webpack:///./~/pako/lib/zlib/trees.js","webpack:///./~/pako/lib/zlib/adler32.js","webpack:///./~/pako/lib/zlib/crc32.js","webpack:///./~/pako/lib/zlib/inflate.js","webpack:///./~/pako/lib/zlib/inffast.js","webpack:///./~/pako/lib/zlib/inftrees.js","webpack:///./~/pako/lib/zlib/constants.js","webpack:///./~/assert/assert.js","webpack:///./~/newrelic/lib/collector/parse-response.js","webpack:///./~/newrelic/lib/util/stream-sink.js","webpack:///./~/newrelic/lib/collector/http-agents.js","webpack:///./~/newrelic/~/yakaa/index.js","webpack:///./~/newrelic/~/yakaa/http.js","webpack:///./~/newrelic/~/yakaa/lib/debuglog.js","webpack:///./~/newrelic/~/yakaa/https.js","webpack:///./~/newrelic/~/https-proxy-agent/https-proxy-agent.js","webpack:///./~/newrelic/~/https-proxy-agent/~/extend/index.js","webpack:///./~/newrelic/~/https-proxy-agent/~/agent-base/agent.js","webpack:///./~/newrelic/~/https-proxy-agent/~/debug/src/browser.js","webpack:///./~/newrelic/~/https-proxy-agent/~/debug/src/debug.js","webpack:///./~/newrelic/~/https-proxy-agent/~/debug/~/ms/index.js","webpack:///./~/newrelic/lib/collector/ssl/certificates.js","webpack:///./~/newrelic/lib/errors/aggregator.js","webpack:///./~/newrelic/lib/util/copy.js","webpack:///./~/newrelic/lib/util/urltils.js","webpack:///./~/newrelic/lib/errors/index.js","webpack:///./~/newrelic/lib/metrics/index.js","webpack:///./~/newrelic/lib/stats/index.js","webpack:///./~/newrelic/lib/stats/apdex.js","webpack:///./~/newrelic/lib/metrics/normalizer.js","webpack:///./~/newrelic/lib/util/arrays.js","webpack:///./~/newrelic/lib/util/deep-equal.js","webpack:///./~/newrelic/lib/metrics/normalizer/rule.js","webpack:///./~/newrelic/lib/metrics/normalizer/tx_segment.js","webpack:///./~/newrelic/lib/metrics/mapper.js","webpack:///./~/newrelic/lib/transaction/trace/aggregator.js","webpack:///./~/newrelic/lib/uninstrumented.js","webpack:///./~/newrelic/lib/instrumentations.js","webpack:///./~/newrelic/lib/db/tracer.js","webpack:///./~/newrelic/lib/util/sql/obfuscate.js","webpack:///./~/newrelic/lib/util/codec.js","webpack:///./~/newrelic/lib/environment.js","webpack:///./~/newrelic/lib/transaction/tracer/index.js","webpack:///./~/newrelic/lib/transaction/index.js","webpack:///./~/newrelic/lib/transaction/trace/index.js","webpack:///./~/newrelic/lib/transaction/trace/segment.js","webpack:///./~/newrelic/lib/util/sum-children.js","webpack:///./~/newrelic/lib/transaction/name-state.js","webpack:///./~/newrelic/lib/config.default.js","webpack:///./~/newrelic/lib/db/parse-sql.js","webpack:///./~/newrelic/lib/db/statement-matcher.js","webpack:///./~/newrelic/lib/db/parsed-statement.js","webpack:///./~/newrelic/lib/db/util.js","webpack:///./~/newrelic/lib/instrumentation/bluebird.js","webpack:///./~/newrelic/lib/instrumentation/promise.js","webpack:///./~/newrelic/lib/shimmer.js","webpack:///./~/newrelic/lib/instrumentation/cassandra-driver.js","webpack:///./~/newrelic/lib/instrumentation/connect.js","webpack:///./~/newrelic/lib/instrumentation/core/child_process.js","webpack:///./~/newrelic/lib/instrumentation/core/crypto.js","webpack:///./~/newrelic/lib/instrumentation/core/dns.js","webpack:///./~/newrelic/lib/instrumentation/core/domain.js","webpack:///./~/newrelic/lib/instrumentation/core/fs.js","webpack:///./~/newrelic/lib/metrics/recorders/generic.js","webpack:///./~/newrelic/lib/instrumentation/core/globals.js","webpack:///./~/newrelic/lib/instrumentation/core/http.js","webpack:///./~/newrelic/lib/metrics/recorders/http.js","webpack:///./~/newrelic/lib/util/cat.js","webpack:///./~/newrelic/lib/transaction/tracer/instrumentation/outbound.js","webpack:///./~/newrelic/lib/metrics/recorders/http_external.js","webpack:///./~/newrelic/~/semver/semver.js","webpack:///./~/newrelic/lib/instrumentation/core/net.js","webpack:///./~/newrelic/lib/instrumentation/core/timers.js","webpack:///./~/newrelic/lib/instrumentation/core/zlib.js","webpack:///./~/newrelic/lib/instrumentation/director.js","webpack:///./~/newrelic/lib/instrumentation/express.js","webpack:///./~/newrelic/lib/metrics/recorders/express.js","webpack:///./~/newrelic/lib/instrumentation/express/express-2.js","webpack:///./~/newrelic/lib/instrumentation/express/common.js","webpack:///./~/newrelic/lib/instrumentation/generic-pool.js","webpack:///./~/newrelic/lib/instrumentation/hapi.js","webpack:///./~/newrelic/lib/instrumentation/ioredis.js","webpack:///./~/newrelic/lib/metrics/recorders/redis.js","webpack:///./~/newrelic/lib/instrumentation/memcached.js","webpack:///./~/newrelic/lib/metrics/recorders/memcached.js","webpack:///./~/newrelic/lib/instrumentation/mongodb.js","webpack:///./~/newrelic/lib/instrumentation/mysql.js","webpack:///./~/newrelic/lib/instrumentation/node-cassandra-cql.js","webpack:///./~/newrelic/lib/metrics/recorders/cassandra.js","webpack:///./~/newrelic/lib/instrumentation/oracle.js","webpack:///./~/newrelic/lib/instrumentation/pg.js","webpack:///./~/newrelic/lib/instrumentation/q.js","webpack:///./~/newrelic/lib/instrumentation/redis.js","webpack:///./~/newrelic/lib/instrumentation/restify.js","webpack:///./~/newrelic/lib/metrics/recorders/custom.js","webpack:///./~/newrelic/lib/metrics/recorders/other.js","webpack:///./~/newrelic/api.js","webpack:///./~/newrelic/stub_api.js"],"names":["require","document","addEventListener","canvas","getElementById","ctx","getContext","width","window","innerWidth","height","innerHeight","modal","e","preventDefault","$","addClass","footer","style","zIndex","onclick","target","Animations","numOfCircles","distance","actions","sound","colorSets","fillSets","soundSets","fontSize","parseFloat","getComputedStyle","documentElement","resizeCanvas","removeAction","action","idx","indexOf","splice","changeColorSet","temp","shift","push","changeSoundSet","drawRipple","x","y","colorSet","ripple","color","random","length","radius","alpha","lineWidth","draw","globalAlpha","beginPath","arc","Math","PI","strokeStyle","stroke","drawCircle","circle","fillStyle","fill","drawCircles","circles","i","animateRipple","size","targets","value","easing","duration","complete","animateCircles","ripple1","ripple2","ripple3","circleAnimation","ripple1Animation","ripple2Animation","ripple3Animation","animate","Infinity","update","clearRect","forEach","animatables","animatable","updateCoords","removeContainer","removeClass","pulseContainer","setTimeout","removeLogo","pulseLogo","keyCode","el","offset","left","top","Howl","src","play","soundSet1","soundSet2","soundSet3","soundSet4","init","prototype","n","_codecs","_howls","_muted","_volume","_canPlayEvent","_navigator","navigator","masterGain","noAudio","usingWebAudio","autoSuspend","mobileAutoEnable","_setup","volume","t","_","gain","o","_webAudio","r","_getSoundIds","u","a","_soundById","_node","mute","muted","unload","close","codecs","replace","state","_autoSuspend","Audio","oncanplaythrough","_setupCodecs","canPlayType","userAgent","match","parseInt","split","mp3","mpeg","opus","ogg","oga","wav","aac","caf","m4a","mp4","weba","webm","dolby","flac","_enableMobileAudio","test","maxTouchPoints","msMaxTouchPoints","_mobileEnabled","_mobileUnloaded","sampleRate","_scratchBuffer","createBuffer","createBufferSource","buffer","connect","destination","start","noteOn","onended","disconnect","removeEventListener","suspend","_sounds","_paused","_suspendTimer","clearTimeout","then","_resumeAfterSuspend","_autoResume","resume","_emit","console","error","_autoplay","autoplay","_format","format","_html5","html5","_loop","loop","_pool","pool","_preload","preload","_rate","rate","_sprite","sprite","_src","_duration","_state","_endTimers","_queue","_onend","onend","fn","_onfade","onfade","_onload","onload","_onloaderror","onloaderror","_onpause","onpause","_onplay","onplay","_onstop","onstop","_onmute","onmute","_onvolume","onvolume","_onrate","onrate","_onseek","onseek","_onresume","event","load","d","exec","toLowerCase","location","protocol","slice","_ended","_id","_inactiveSound","max","_seek","s","abs","_start","_stop","l","f","_refreshBuffer","setValueAtTime","currentTime","_playStart","bufferSource","noteGrainOn","bind","c","once","_clearTimer","p","playbackRate","m","ejecta","readyState","isCocoonJS","v","pause","seek","_rateSeek","_stopFade","stop","noteOff","_cleanBuffer","isNaN","arguments","apply","fade","ceil","linearRampToValueAtTime","_interval","setInterval","min","round","clearInterval","cancelScheduledValues","loopStart","loopEnd","playing","_errorFn","_loadFn","on","id","off","Object","keys","Array","isArray","call","_loadQueue","_drain","reset","_panner","_parent","Date","now","create","createGain","createGainNode","paused","_errorListener","_loadListener","code","__default","atob","Uint8Array","charCodeAt","XMLHttpRequest","open","responseType","status","response","onerror","send","decodeAudioData","AudioContext","webkitAudioContext","platform","appVersion","standalone","Howler","exports","HowlerGlobal","Sound","global","_pos","_orientation","stereo","listener","pos","setPosition","orientation","setOrientation","_stereo","_pannerAttr","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","panningModel","refDistance","rolloffFactor","_onstereo","onstereo","_onpos","onpos","_onorientation","onorientation","createStereoPanner","pan","pannerAttr","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_distanceModel","_maxDistance","_panningModel","_refDistance","_rolloffFactor","createPanner","Start","showModal","display"],"mappings":"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CAAiC;AACvD,uBAAsB,iCAAiC;AACvD,uBAAsB,6BAA6B;AACnD,uBAAsB,+BAA+B;AACrD,uBAAsB,iCAAiC;AACvD,uBAAsB,kCAAkC;AACxD,uBAAsB,6BAA6B;AACnD,uBAAsB,qBAAqB,EAAE,eAAe,EAAE,cAAc;AAC5E,uBAAsB,wBAAwB;AAC9C,uBAAsB,wBAAwB;AAC9C,uBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB,oDAAoD,EAAE;AAC/E,0BAAyB,mCAAmC,EAAE;AAC9D;AACA;AACA;AACA;AACA,QAAO;AACP,0BAAyB,8BAA8B,EAAE;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,iDAAgD,6BAA6B;AAC7E,mDAAkD,uEAAuE;AACzH,mDAAkD,kFAAkF;AACpI,MAAK;AACL,iCAAgC,UAAU;AAC1C;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,kBAAkB,EAAE;AACrD;;AAEA;AACA;AACA;AACA,4DAA2D,aAAa,EAAE;AAC1E;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sDAAqD,8BAA8B,EAAE;AACrF,4BAA2B,EAAE,UAAU,EAAE,UAAU,EAAE;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,0BAA0B,EAAE;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,eAAc;AACd,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uDAAsD,uBAAuB;AAC7E;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,4DAA2D,4BAA4B,EAAE;AACzF;;AAEA;AACA,4DAA2D,oBAAoB,EAAE;AACjF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,6BAA6B,EAAE;AACvF;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA,sBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA,qDAAoD;AACpD,iEAAgE;AAChE,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,4BAA2B,mCAAmC;AAC9D;AACA;AACA,wBAAuB,uBAAuB;AAC9C;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,sCAAqC,QAAQ;AAC7C;AACA;AACA,oCAAmC,QAAQ;AAC3C;AACA,2CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC;;;;;;;;;;;;AC9nBM,KAAMsF,gCAAY;AACvB,OAAI,CAAC,+EAAD,CADmB;AAEvB,OAAI,CAAC,4EAAD,CAFmB;AAGvB,OAAI,CAAC,4EAAD,CAHmB;AAIvB,OAAI,CAAC,4EAAD,CAJmB;AAKvB,OAAI,CAAC,4EAAD,CALmB;AAMvB,OAAI,CAAC,4EAAD,CANmB;AAOvB,OAAI,CAAC,4EA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AAEA;AACA;;AAEA;AACA;AACA,mDAAkD;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;;;;;;;AChHA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;ACnLtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+DAA8D,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;;;;;;;ACrDA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAqC;AACrC;;AAEA;AACA;;AAEA;AACA;AACA,oCAAmC;;AAEnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA,sBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtNA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;;;;;;AC5BA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,wBAAuB,SAAS;AAChC;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA,YAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACzkBA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAsC,gBAAgB;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA;;;;;;;;ACt7BA;AACA;AACA;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,yBAAwB,QAAQ;AAChC;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA,IAAG;AACH;AACA,gBAAe,SAAS;AACxB;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5vDA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,UAAU;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,SAAQ,WAAW;;AAEnB;AACA;AACA,SAAQ,UAAU;;AAElB;AACA;;;;;;;ACnFA,kBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA,oCAAkC;AAClC,IAAG;AACH,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG,aAAa;AAChB;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,4EAA2E,6EAA6E;AACxJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,uDAAsD;;AAEtD;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAsC;;AAEtC;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gDAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,SAAS;AAC5B;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA,6EAA4E;;AAE5E;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAmD;AACnD;AACA,oDAAmD,iEAAiE;AACpH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA,wCAAuC;AACvC,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA,E;;;;;;;AC56BA;;AAEA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;;;;;AC1CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;AC1GA,gB;;;;;;ACAA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe;AACf,+CAA8C;AAC9C;AACA;AACA;;AAEA;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAsD;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;AC/DA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA,E;;;;;;AC1EA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG,aAAa;AAChB;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAkD;;AAElD;;AAEA,4CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;;AAEA;AACA;AACA,qCAAoC;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,E;;;;;;;ACziBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACpDA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAU;AACV;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;;;;;;;ACxLD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,cAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAQ,OAAO;AACf;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK,EAAE;AACP,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,E;;;;;;ACrLA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,G;;;;;;ACzBA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA,gB;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,yBAAyB;AAC5C;;AAEA;AACA;AACA;AACA;AACA,sBAAqB,gBAAgB;AACrC;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,IAAG;AACH;AACA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAQ,OAAO;AACf;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;AC7CA,mCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B;;AAE/B,+BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA4B;;AAE5B,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,UAAU;;AAEzB,6BAA4B;;AAE5B,iCAAgC;;AAEhC;AACA;AACA;;AAEA;;;;;;;AC5CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA,gDAA+C;;AAE/C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,kBAAiB,kCAAkC;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAmB,kCAAkC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B;AAC3B,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/mCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9NA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC9BA;;AAEA;AACA;AACA;AACA,SAAQ,UAAU,eAAe,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;AC3BA;;AAEA;;AAEA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK,cAAc;AACnB,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;;AChDD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;;ACzBD,gB;;;;;;ACAA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;ACXA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,QAAQ;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA,aAAY,OAAO,OAAO,YAAY,OAAO,OAAO,OAAO;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;AClJA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,QAAQ;AAC3B;;AAEA;;AAEA;AACA;AACA;;AAEA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC1JA;AACA,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;;;;;;;;;AChClB;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kdAAid,+BAA+B;AAChf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,YAAY;AAC5B;AACA;;AAEA;AACA,kBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AC1MA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA,iBAAgB,eAAe;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;ACzCA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAmB,QAAQ;AAC3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sBAAqB,gBAAgB;AACrC;;AAEA,wBAAuB,UAAU;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,mCAAmC;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,qBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAoB,UAAU;AAC9B;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA,0BAAyB,yCAAyC;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA4C,mCAAmC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAKA,qB;;;;;;;ACnMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;ACxDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,E;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,uDAAuD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjNA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA,YAAW,SAAS;AACpB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAuC;AACvC,QAAO;AACP,sDAAqD;;AAErD;AACA;AACA;AACA;;AAEA,wBAAuB,mBAAmB;AAC1C,QAAO;AACP;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC,QAAO;AACP;AACA;AACA,mDAAkD;;AAElD,wBAAuB,mCAAmC;AAC1D;AACA;AACA;;AAEA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAuC;AACvC,QAAO;AACP,kDAAiD;AACjD;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA;AACA;AACA;AACA,mBAAkB,0CAA0C;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;;AAEA;;;;;;;;ACj/BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnDA;;AAEA;AACA,6CAAwC,qBAAqB;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA,cAAa,QAAQ,wCAAwC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA2B;AAC3B;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACvNA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;ACtNA;;AAEA,6CAAyC,2BAA2B;AACpE;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG,0BAA0B;AAC7B,IAAG,0BAA0B;AAC7B,IAAG,0BAA0B;AAC7B,IAAG,yBAAyB;AAC5B,IAAG,2BAA2B;AAC9B,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,6DAA4D;AAC5D;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,oEAAmE;AACnE;AACA;AACA;AACA,QAAO;AACP;AACA,oEAAmE;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAO;AACP,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uDAAsD;AACtD;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,4DAA2D;AAC3D;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,qDAAoD;AACpD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC3bA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;;;;;;ACpDA;;AAEA;AACA;AACA;AACA,6CAA2C,yBAAyB;AACpE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;;;;;;ACxOA;;AAEA,6CAA2C,sBAAsB;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACnGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;AC9EA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,GAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,4CAA2C;AAC3C,KAAI;AACJ,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrSA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACpEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;;AAEA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,yCAAwC,eAAe,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,oBAAoB;AACxC;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACrLA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;;;;;;AC1BA;;AAEA;;AAEA;AACA;;AAEA,oBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAgB,KAAK;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,4CAA2C,KAAK;AAChD,2CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B,QAAQ;AACtC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;mCC3tBA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,SAAS;AACrB;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,SAAS;AACrB;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,MAAK;AACL,6BAA4B;AAC5B;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc,OAAO;AACrB;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,mCAAmC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;;AAExB,0CAAyC,qBAAqB;;AAE9D;AACA;AACA;AACA;AACA;AACA,mCAAkC,oBAAoB;;AAEtD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAc,iBAAiB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAEA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF,uCAAsC;AACtC;AACA,IAAG,OAAO;AACV;AACA;AACA;AACA;AACA,GAAE,OAAO;AACT;AACA;;AAEA,EAAC;;;;;;;;ACjhBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;;;;;ACfA;;AAEA;AACA;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;;;;;;;AC/DA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,mBAAmB;;AAE1C;AACA;;AAEA,0CAAyC,qBAAqB;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,kBAAkB;AAC/C;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;AC9IA;AACA;AACA,oCAAkC;AAClC,IAAG;AACH,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG,aAAa;AAChB;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,4EAA2E,6EAA6E;AACxJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,uDAAsD;;AAEtD;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAsC;;AAEtC;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gDAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,SAAS;AAC5B;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA,6EAA4E;;AAE5E;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAmD;AACnD;AACA,oDAAmD,iEAAiE;AACpH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA,wCAAuC;AACvC,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA,E;;;;;;;AC56BA;;AAEA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;;;;;AC1CA,kBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA,gB;;;;;;ACAA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe;AACf,+CAA8C;AAC9C;AACA;AACA;;AAEA;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAsD;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;AC/DA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA,E;;;;;;AC1EA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG,aAAa;AAChB;AACA;AACA,EAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAkD;;AAElD;;AAEA,4CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;;AAEA;AACA;AACA,qCAAoC;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,E;;;;;;;;ACxiBA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,cAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAQ,OAAO;AACf;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK,EAAE;AACP,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,E;;;;;;ACrLA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,G;;;;;;ACzBA,0BAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,qDAAqD,EAAE;AAC/E,kCAAiC,eAAe,EAAE;AAClD,qCAAoC,yBAAyB,EAAE;AAC/D,8BAA6B,gCAAgC,EAAE;AAC/D,2BAA0B,eAAe,EAAE;AAC3C,4BAA2B,gBAAgB;AAC3C;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,SAAS;AACzC;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA,EAAC;AACD;AACA;AACA,oFAAmF,wDAAwD;AAC3I,oFAAmF,wDAAwD;AAC3I,iDAAgD,mBAAmB;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,QAAQ;;AAE5B;;AAEA;AACA;AACA,0BAAyB,2BAA2B,EAAE;AACtD,2BAA0B,uBAAuB,EAAE;AACnD;AACA;AACA,MAAK;AACL;;AAEA;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAiC,mBAAmB,0BAA0B;AAC9E,oCAAmC,mBAAmB,2BAA2B;;AAEjF,qBAAoB,mBAAmB;AACvC,2BAA0B,+BAA+B;;AAEzD,qBAAoB,mBAAmB;AACvC,2BAA0B,iCAAiC;;AAE3D,4BAA2B,sBAAsB,iDAAiD;;AAElG,sBAAqB,oCAAoC;AACzD,4BAA2B,gDAAgD;;AAE3E,sBAAqB,oCAAoC;AACzD,4BAA2B,kDAAkD;;AAE7E,sBAAqB,wEAAwE;AAC7F,4BAA2B,kFAAkF;;AAE7G,sBAAqB,wEAAwE;AAC7F,4BAA2B,oFAAoF;;AAE/G;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB,uBAAuB;AAChD,IAAG;AACH,0BAAyB,OAAO;AAChC,IAAG;AACH,WAAU,OAAO;AACjB,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,GAAG,UAAU,0BAA0B,kBAAkB;AAC1E,kBAAiB,GAAG,UAAU,0BAA0B,kBAAkB;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,yBAAwB,GAAG;AAC3B;AACA,gBAAe,GAAG;AAClB,gCAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA,wBAAuB,iCAAiC;AACxD,sBAAqB,+BAA+B;AACpD,wBAAuB,gCAAgC;AACvD,sBAAqB,8BAA8B;;;AAGnD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAe,qBAAqB;AACpC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAmB,iBAAiB;AACpC;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA2C,gBAAgB;AAC3D;AACA;AACA,sCAAqC,gBAAgB;AACrD;AACA;AACA,UAAS;AACT;AACA,+BAA8B;AAC9B;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,oCAAmC,0CAA0C;;AAE7E;AACA;;AAEA,kCAAiC,WAAW;AAC5C,kCAAiC,mBAAmB;;AAEpD,uBAAsB,6BAA6B;AACnD,qBAAoB,yBAAyB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,iCAAiC;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,iCAAiC;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC;;;;;;;ACrnBD;;AAEA,6CAA2C,0BAA0B;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAsC,GAAG;AACzC,UAAS;AACT,MAAK;;AAEL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;;;;;;;ACtHA;;AAEA,6CAA2C,wBAAwB;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;;;;;;ACxDA;;AAEA,6CAA2C,0BAA0B;;AAErE;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;ACbA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,6CAAyC,0BAA0B;AACnE;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA,aAAY;AACZ;;AAEA,2BAA0B;AAC1B;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAmC,OAAO;AAC1C;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,qCAAqC;AACtD,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAU;AACV;;AAEA;AACA;AACA;AACA,kCAAiC,OAAO;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC/HA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA4C,kCAAkC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,WAAW;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL,IAAG;AACH,mBAAkB,WAAW;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACtUA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD;;AAEhD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjmBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3OA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACZA;;;AAGA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC5BA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC;AAChC;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA0B;AAC1B,2BAA0B;AAC1B,2BAA0B;AAC1B,2BAA0B;;AAE1B,oBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAoB,sBAAsB,qBAAqB,cAAc,EAAE;;;AAG/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAkB,QAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,YAAY;AAC/B,mBAAkB,UAAU;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC,yBAAwB;AACxB,aAAY;AACZ,WAAU;AACV,gCAA+B;AAC/B,iCAAgC;AAChC;AACA;;AAEA,uBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,0BAA0B;;AAE3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,cAAa;;AAEb,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAmE;;AAEnE;AACA,0DAAyD;AACzD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,2DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,cAAa;;AAEb;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,OAAO,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,6DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX,oBAAmB;;AAEnB;;AAEA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,OAAO,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qEAAoE;AACpE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,2DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB;AACrB,gBAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,oBAAmB;AACnB,mBAAkB;AAClB,2BAA0B;AAC1B,6BAA4B;AAC5B,wBAAuB;AACvB,oBAAmB;AACnB,iBAAgB;AAChB,sBAAqB;AACrB,oBAAmB;AACnB,4BAA2B;AAC3B,wBAAuB;;AAEvB,mBAAkB;AAClB,mBAAkB;AAClB,mBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB;;AAEnB,kBAAiB;AACjB,sBAAqB;AACrB,sBAAqB;AACrB,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAwB;AACxB,uBAAsB;AACtB,4BAA2B;AAC3B,qBAAoB;AACpB,wBAAuB;AACvB,sBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB;AACjB,qBAAoB;;AAEpB;AACA;;AAEA,uBAAsB;;AAEtB;;AAEA;;AAEA,4CAA2C;AAC3C,8CAA6C;AAC7C,6CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB;AACvB,wBAAuB;AACvB,wBAAuB;;AAEvB;AACA;AACA;;AAEA,2BAA0B;AAC1B,gDAA+C;AAC/C;;AAEA,qBAAoB;AACpB,qBAAoB;AACpB;AACA;AACA;;AAEA,iDAAgD;AAChD;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA;;AAEA,oBAAmB;AACnB,uBAAsB;AACtB,oBAAmB;AACnB,mBAAkB;;;AAGlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,8BAA6B,uBAAuB;AACpD,+BAA8B,uBAAuB;AACrD;AACA;AACA;;;AAGA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAqB;;AAErB,uCAAsC;;AAEtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,gBAAe;;AAEf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA,wBAAuB;AACvB,sBAAqB;AACrB;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,8BAA6B,uBAAuB;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,wBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,+BAA8B;;AAE9B,4BAA2B,aAAa;AACxC,qBAAoB,qBAAqB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qDAAoD;AACpD;AACA;;AAEA,cAAa;;AAEb;AACA;AACA,sBAAqB;AACrB,0BAAyB;AACzB,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9zDA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,mBAAkB,UAAU;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,6BAA4B,YAAY;AACxC,sBAAqB,8BAA8B;AACnD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrGA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B;AAC9B;;AAEA;;;AAGA,qBAAoB,sBAAsB,qBAAqB,cAAc,EAAE;;AAE/E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA,mCAAkC;AAClC,kCAAiC;AACjC,kCAAiC;AACjC,6BAA4B;AAC5B,kCAAiC;;AAEjC;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA,4BAA2B;AAC3B,qBAAoB;AACpB,8BAA6B;AAC7B;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR,YAAW;AACX,YAAW;AACX,aAAY;AACZ,SAAQ;AACR,oBAAmB;;AAEnB,iBAAgB,kBAAkB;AAClC;AACA;;AAEA;AACA;AACA;AACA,gDAA+C;;AAE/C,2BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,UAAU,EAAE;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,QAAQ;AAC5C,wBAAuB;AACvB,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,0BAAyB,YAAY;AACrC;AACA;AACA;AACA,0BAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,oBAAmB;AACnB,sBAAqB;AACrB;AACA,2CAA0C;AAC1C,gBAAe;AACf,YAAW;AACX,SAAQ;;AAER;AACA;AACA;AACA,iBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,gBAAgB;AAC7B;AACA,qBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;AACR,YAAW;AACX,cAAa;AACb,YAAW;AACX,YAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,yBAAyB;AACzC;AACA,gBAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,WAAW;AAC3B;AACA,gBAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA,cAAa;AACb,SAAQ,gBAAgB;AACxB;AACA,gBAAe,oCAAoC;AACnD;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,kBAAkB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,aAAa;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAQ;;AAER;AACA,cAAa,aAAa,QAAQ,iCAAiC;AACnE,cAAa,aAAa,QAAQ,iCAAiC;AACnE,cAAa,cAAc,OAAO,+BAA+B;;AAEjE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,gBAAe;AACf,mBAAkB;AAClB;AACA,gBAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,aAAY;AACZ;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,OAAO;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B,4BAA2B;AAC3B;AACA,YAAW;AACX,UAAS;AACT,cAAa;AACb,YAAW;AACX,aAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAgC;AAChC;AACA,QAAO;AACP;AACA;AACA,kDAAiD;AACjD;AACA;AACA;AACA,mCAAkC;AAClC;AACA,gBAAe;AACf;AACA;;AAEA,mCAAkC;AAClC;AACA;AACA;AACA,qCAAoC;AACpC;AACA,QAAO;;AAEP;AACA;AACA;;AAEA,MAAK;AACL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,qBAAoB;AACpB,YAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,WAAW;AACxB;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAuC,QAAQ,OAAO,wBAAwB;;AAE9E;AACA;AACA;AACA,gBAAe;AACf;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA,+BAA8B;;AAE9B,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,oBAAmB;AACnB;AACA,SAAQ;AACR,oBAAmB;AACnB,cAAa;;AAEb,yCAAwC;;AAExC,iBAAgB;AAChB,qBAAoB;AACpB,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA,iDAAgD;;AAEhD,cAAa,eAAe;AAC5B;AACA;;AAEA;AACA;;AAEA,MAAK;AACL;;AAEA,MAAK;;AAEL,gCAA+B,kCAAkC;AACjE;;AAEA,MAAK;AACL;;AAEA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,oBAAmB;AACnB;AACA,SAAQ;AACR,oBAAmB;AACnB,cAAa;;AAEb,yCAAwC;;AAExC,iBAAgB;AAChB,qBAAoB;AACpB,qBAAoB;;AAEpB,gCAA+B;AAC/B;AACA;AACA;AACA;;AAEA,cAAa,eAAe;AAC5B;AACA;;AAEA;AACA;;AAEA,MAAK;AACL,WAAU,iCAAiC,EAAE;;AAE7C,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,mBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA,YAAW;;AAEX;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA,iCAAgC;AAChC,iBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;;AAEA,yCAAwC;AACxC;;AAEA,yCAAwC;AACxC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,IAAI,MAAM,GAAG,MAAM,GAAG;AAChD;AACA;AACA;AACA,UAAS,IAAI,KAAK,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,IAAI,MAAM,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,kBAAiB;AACjB,YAAW;AACX;AACA,yDAAwD;AACxD,wCAAuC;AACvC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,kBAAiB;AACjB,YAAW;AACX;AACA,6BAA4B;AAC5B,uBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAkC,wBAAwB;;AAE1D,IAAG;AACH;AACA,6CAA4C;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,mBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACjrCA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;AC/BA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA,oBAAmB,SAAS;AAC5B;AACA;;AAEA,uBAAsB;AACtB;;;AAGA;;;;;;;ACxCA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA,iBAAgB;AAChB,kBAAiB;AACjB,iBAAgB;AAChB,eAAc;AACd,kBAAiB;AACjB,kBAAiB;AACjB,iBAAgB;AAChB,oBAAmB;AACnB,iBAAgB;AAChB,oBAAmB;AACnB,kBAAiB;AACjB,sBAAqB;AACrB,wBAAuB;AACvB,wBAAuB;AACvB,uBAAsB;AACtB,sBAAqB;AACrB,uBAAsB;AACtB,yBAAwB;AACxB,0BAAyB;AACzB,0BAAyB;AACzB,yBAAwB;AACxB,4BAA2B;AAC3B,0BAAyB;AACzB,6BAA4B;AAC5B,2BAA0B;AAC1B,yBAAwB;AACxB,mBAAkB;AAClB,oBAAmB;AACnB,kBAAiB;AACjB,iBAAgB;AAChB,iBAAgB;AAChB,kBAAiB;;AAEjB;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,iBAAgB;AAChB,qBAAoB;AACpB,iBAAgB;AAChB,yBAAwB;AACxB,kBAAiB;AACjB,iBAAgB;AAChB,kBAAiB;AACjB,kBAAiB;AACjB;AACA,oBAAmB;;AAEnB;AACA,kBAAiB;AACjB,kBAAiB;AACjB,kBAAiB;AACjB,kBAAiB;AACjB,sBAAqB;;AAErB;AACA,iBAAgB;AAChB,iBAAgB;;AAEhB;AACA,mBAAkB;AAClB,mBAAkB;;AAElB;AACA,kBAAiB;;AAEjB;AACA,uBAAsB;AACtB,wBAAuB;AACvB,oBAAmB;AACnB,qBAAoB;;AAEpB;AACA,kBAAiB;AACjB,iBAAgB;AAChB,kBAAiB;AACjB,iBAAgB;AAChB,oBAAmB;;AAEnB,oCAAmC;AACnC,oCAAmC;;AAEnC;AACA;AACA;AACA;AACA,0CAAyC;AACzC,sBAAqB;AACrB,uBAAsB;AACtB,iBAAgB;AAChB,iBAAgB;AAChB,gBAAe;AACf;;AAEA;AACA;;AAEA,8BAA6B,uBAAuB;AACpD;AACA;AACA,iBAAgB;AAChB,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B,uBAAuB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAc,uBAAuB;AACrC,uBAAsB;;AAEtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAuB,uBAAuB;AAC9C,wBAAuB,uBAAuB;AAC9C,wBAAuB,uBAAuB;AAC9C,wBAAuB,uBAAuB;;AAE9C,wEAAuE,UAAU;;AAEjF;AACA;AACA,uBAAsB,uBAAuB;;AAE7C,wEAAuE,UAAU;;AAEjF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,iBAAiB;AACzD,uCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB;AACpB,YAAW;AACX,WAAU;AACV,kBAAiB;AACjB,YAAW;AACX,YAAW;AACX,iBAAgB;AAChB,YAAW;AACX,YAAW;AACX;AACA,gBAAe;AACf,oCAAmC;AACnC,cAAa;AACb,oCAAmC;AACnC,WAAU;AACV,WAAU;AACV,gCAA+B;AAC/B;;AAEA,SAAQ;;AAER;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,qBAAqB,EAAE;;;AAGnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,aAAa;AACvC,2BAA0B,aAAa;AACvC,0BAAyB,iBAAiB;AAC1C,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,mEAAkE;AAClE;AACA;AACA;;AAEA,qCAAoC,OAAO;AAC3C;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,OAAO;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,iEAAgE;AAChE;AACA;AACA;;AAEA,iCAAgC,OAAO;AACvC;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;;AAEA,iDAAgD,OAAO;AACvD;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,mEAAkE;AAClE;AACA;AACA;;AAEA,mCAAkC,OAAO;AACzC;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;;AAEA,iDAAgD,OAAO;AACvD;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,qBAAqB;AAC3D,+BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA,cAAa;AACb,sCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,qBAAqB;AACvD;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,yBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,QAAO;AACP,gCAA+B,kBAAkB;AACjD;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA6B,uBAAuB;AACpD;AACA,gCAA+B,uBAAuB;;AAEtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8DAA6D,uBAAuB;AACpF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAe;AACf,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjgDA;;AAEA;AACA,cAAa;AACb,eAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV,YAAW;AACX,YAAW;AACX,WAAU;AACV,WAAU;AACV;AACA,YAAW;AACX;AACA,aAAY;AACZ,aAAY;AACZ,aAAY;AACZ;AACA,gBAAe;AACf,YAAW;AACX,YAAW;AACX,aAAY;AACZ,aAAY;AACZ,aAAY;AACZ,aAAY;AACZ,YAAW;AACX,UAAS;AACT;AACA,WAAU;AACV,YAAW;AACX,YAAW;AACX;;;AAGA,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAW,GAAG;AACd;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA,yBAAwB;AACxB;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B,6BAA4B;AAC5B,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA,iCAAgC;AAChC;AACA,gCAA+B;AAC/B;AACA;AACA;AACA,oBAAmB;AACnB,sCAAqC;AACrC;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA,oBAAmB;AACnB;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA,sBAAqB;AACrB,wCAAuC;AACvC;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,gCAA+B;AAC/B;AACA;AACA;AACA,oBAAmB;AACnB,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,mBAAkB;AAClB;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB;AAChB;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAY;AACZ;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrUA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB;;AAEzB,eAAc;AACd,eAAc;AACd,wBAAuB;AACvB,gBAAe;AACf,gBAAe;AACf,gBAAe;AACf,gBAAe;AACf,gBAAe;AACf,gBAAe;AACf,YAAW;AACX,YAAW;AACX,WAAU;AACV,YAAW;AACX,YAAW;AACX,mBAAkB;AAClB;AACA,kBAAiB;AACjB,WAAU;AACV,4CAA2C,eAAe;AAC1D,2CAA0C,eAAe;AACzD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,gBAAgB;AAC/B;AACA;AACA,gBAAe,aAAa;AAC5B;AACA;;AAEA;AACA;AACA,sBAAqB,UAAU;AAC/B,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,mBAAkB;AAClB,uCAAsC,2BAA2B;AACjE,wCAAuC;AACvC,yCAAwC;AACxC;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA,gBAAe,WAAW;AAC1B,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,eAAc;AACd;;AAEA;AACA;AACA,gBAAe,eAAe;AAC9B;AACA;;AAEA;AACA,gBAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,IAAG,OAAO;AACV;AACA;AACA;AACA;;AAEA;AACA,YAAW;AACX,WAAU;AACV,aAAY;AACZ,sBAAqB;AACrB,eAAc;AACd,YAAW;AACX,YAAW;AACX,oBAAmB;AACnB,mBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,yBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACtUA;;;AAGA;;AAEA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACjDA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+BAA8B;AAC9B;AACA,oDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,iDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,0BAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAgC,oBAAoB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzeA;;AAEA;AACA,6CAAyC,gCAAgC;;;AAGzE;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAsB,eAAe;;AAErC;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;;;;;ACnHA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACpDA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAAyC,wBAAwB;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACtGA;;AAEA;AACA;;AAEA;;;;;;;ACLA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,iCAAgC;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;AACH;;AAEA;;;;;;;ACtTA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC3GA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAgB;AAChB,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChOA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA,QAAO,YAAY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;ACnFA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;;;;;;;;AChFA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAiB,SAAS;AAC1B,6BAA4B;AAC5B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACtMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,cAAc;AACzB,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpJA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvoCA;;AAEA;AACA;AACA,6CAAyC,0BAA0B;AACnE;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,mCAAmC;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,mCAAmC;AAClD;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,IAAG,OAAO;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB;AACA,cAAa,KAAK;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAkB,aAAa;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,SAAS;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC9WA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO,SAAS;AAC3B;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA,gBAAe,KAAK;AACpB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA,gBAAe,KAAK;AACpB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA0B;;AAE1B;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,gBAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChMA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAsC;AACtC,wCAAuC;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;;;;;;ACxKA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,YAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,KAAK;AACzB,mBAAkB,KAAK,SAAS;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA,aAAY,MAAM;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,aAAY,WAAW;AACvB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;;AAEA;;;;;;;ACnSA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrHA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9EA;;AAEA;AACA;AACA;AACA,6CAAyC,+BAA+B;AACxE;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa,OAAO;AACpB;AACA,eAAc,KAAK;AACnB,eAAc,KAAK;AACnB,eAAc,OAAO;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAoB,4BAA4B;AAChD;AACA;AACA;;AAEA;AACA,qBAAoB,WAAW;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrPA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,YAAW,EAAE;AACb;AACA,aAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,YAAW,EAAE;AACb;AACA,aAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,YAAW,EAAE;AACb;AACA,aAAY,OAAO;AACnB;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,YAAW,EAAE;AACb;AACA,aAAY,OAAO;AACnB;AACA;AACA,+BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjFA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA,oBAAmB,cAAc;;AAEjC;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa;;AAEb,aAAY;AACZ,8BAA6B,QAAQ;;AAErC;AACA,8BAA6B,QAAQ;AACrC;AACA;AACA;;AAEA,YAAW;;AAEX;AACA;;AAEA;AACA;AACA;;;;;;;;ACjHA;;AAEA,6CAA4C,6BAA6B;;;AAGzE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,uBAAuB;AACxC;AACA,YAAW,OAAO;AAClB;AACA,aAAY,KAAK;AACjB;AACA;AACA;;AAEA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnMA;;AAEA,6CAA4C,mCAAmC;;AAE/E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,aAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA,kBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,kBAAkB;AACrC;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAmC,OAAO;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA8B,OAAO;AACrC;AACA;;AAEA;AACA;;;;;;;AChHA;;AAEA,6CAAyC,oBAAoB;;;AAG7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,2CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,2CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA,WAAU;AACV;;AAEA;;;;;;;ACnFA;;AAEA,6CAA4C,8BAA8B;;AAE1E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAqD,SAAS;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzPA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B,+BAA+B;AAC1D;AACA;;AAEA;AACA;;;;;;;ACpFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvBA;;AAEA,6CAAyC,0BAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,qCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qCAAoC,SAAS;AAC7C;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3NA;;AAEA;;AAEA;AACA;AACA;AACA,yCAAwC,QAAQ;AAChD;AACA;AACA,eAAc,iBAAiB,GAAG,EAAE;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC9EA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;;;;;;;;ACrDA;;AAEA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,aAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB;AACA,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB;AACA,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;;;AAGf;AACA;AACA,wCAAuC;AACvC,6CAA4C;AAC5C,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;ACxaA;;AAEA;AACA,6CAA4C,oBAAoB;;AAEhE;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,gDAAgD;AACxE;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAG;AACH;;;;;;;;ACpcA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAAyC,yBAAyB;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC,YAAY;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,UAAU,2CAA2C;AAC5D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA,iBAAgB;AAChB,gCAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAgB,mDAAmD;AACnE;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,OAAO;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;;AAEA;;;;;;;;ACnfA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC/NA;;AAEA,6CAA4C,qBAAqB;AACjE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,cAAc;AACzB;AACA;AACA,YAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,mBAAmB;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1XA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA,aAAY,MAAM;AAClB;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA,oCAAmC,OAAO;AAC1C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACnDA;;AAEA,6CAA4C,wBAAwB;AACpE;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,oDAAmD,GAAG;AACtD;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtHA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,uCAAsC,iCAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA,0BAAyB,cAAc;AACvC,+BAA8B;AAC9B;AACA;;;;;;;;ACnjBA;;AAEA,6CAAyC,uBAAuB;AAChE;AACA;AACA;;;AAGA;AACA,0EAAyE;AACzE,uDAAsD;AACtD,6EAA4E;AAC5E,+DAA8D;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA,yCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC7CA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACtBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpEA;;AAEA;;AAEA;AACA;AACA;AACA,gEAA+D;AAC/D;AACA;;;;;;;ACTA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACzBA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA,eAAc,qBAAqB;AACnC;AACA;AACA;AACA,eAAc,qBAAqB;AACnC;AACA;AACA;AACA,eAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,YAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,cAAa,MAAM;AACnB,eAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA,cAAa,aAAa;AAC1B;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA,cAAa,KAAK;AAClB;AACA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,aAAa;AACxB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,kBAAiB,SAAS;AAC1B;AACA;;;;;;;ACtfA;;AAEA;AACA;AACA,6CAAwC,qBAAqB;AAC7D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA,cAAa,OAAO;AACpB;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA,cAAa,OAAO;AACpB;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtTA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxEA;;AAEA;AACA,6CAAyC,qBAAqB;;;AAG9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB,6CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAgE;AAChE;AACA;AACA;;;;;;;AClNA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;ACdA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AChBA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;AC3BA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACnCA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACrFA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;;;;;;ACbA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;;AAEA;AACA,6CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,oCAAoC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,8CAA8C;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA,QAAO;AACP;AACA,kCAAiC;AACjC,0CAAyC;AACzC;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAoD;AACpD;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACrrBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC5CA;;AAEA;AACA;AACA,6CAAyC,iBAAiB;;AAE1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC1DA;;AAEA;AACA;AACA;AACA;AACA,6CAA+C,sBAAsB;;AAErE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,oBAAmB,8BAA8B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7IA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAmD,KAAK,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD,uCAAsC;AACtC,qCAAoC;AACpC,uCAAsC;AACtC,qCAAoC;AACpC,uCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AClrCA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACtFA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;;;;;;;AC3DA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;AClCA;;AAEA;AACA,6CAA4C,sBAAsB;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,Y;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,U;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AChHA;;AAEA;AACA;AACA,6CAA4C,qBAAqB;AACjE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA,kBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;;AAEA;AACA,UAAS;AACT;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,gBAAe;AACf;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D;AAC/D;AACA;AACA;;;;;;;ACt1BA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACdA;;AAEA,6CAA+C,qBAAqB;AACpE;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mCAAkC,aAAa;;AAE/C;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtDA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA,IAAG;AACH;;;;;;;ACxCA;;AAEA;AACA;AACA,6CAA4C,kBAAkB;AAC9D;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA,mCAAkC,iBAAiB;;AAEnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA,eAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA4D;AAC5D;AACA,IAAG,qDAAqD;AACxD;AACA;AACA;AACA,IAAG,oEAAoE;AACvE;AACA,IAAG,OAAO;AACV,oDAAmD;AACnD;AACA;;;;;;;ACtUA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS,uCAAuC;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;;;;;;AC/CA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;;AC5CA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC1FA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;;AC5CA;;AAEA;AACA;AACA,6CAAyC,qBAAqB;AAC9D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,6BAA6B;AAChD;AACA;AACA;;AAEA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA,wCAAuC;AACvC;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA,wCAAuC;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACjbA;;AAEA,6CAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB,yBAAyB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;AC3UA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO,OAAO;AACd;AACA;;AAEA;AACA;AACA,IAAG;AACH;;;;;;;ACnDA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACvCA;;AAEA,6CAAyC,oBAAoB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChIA;;AAEA;AACA,6CAAyC,gBAAgB;AACzD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACzSA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvBA;;AAEA,6CAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS,uCAAuC;AAChD;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK,OAAO;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAS,uCAAuC;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrHA;;AAEA;AACA,6CAA4C,qBAAqB;AACjE;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,kCAAiC,aAAa;;AAE9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACjFA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChCA;;AAEA;AACA,6CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,uEAAsE,EAAE;AACxE,kCAAiC;;AAEjC;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,+BAA+B;AACnE;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB;;AAEhB,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA;AACA,YAAW,OAAO;AAClB;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACp6BA;;AAEA;AACA;;;AAGA;AACA;AACA,8BAA6B,gCAAgC;AAC7D,wFAAuF;AACvF,kBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,gBAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0bc1273c071303230340","require('newrelic');\nimport Animations from './animations';\nimport Start from './start';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvas = document.getElementById('canvas');\n  const ctx = canvas.getContext('2d');\n  ctx.canvas.width = window.innerWidth;\n  ctx.canvas.height = window.innerHeight;\n\n  Start(ctx, canvas);\n  Animations(ctx, canvas);\n\n  const modal = document.getElementById('myModal');\n\n  document.addEventListener('keydown', (e) => {\n    e.preventDefault();\n    $('#myModal').addClass('fadeOut');\n\n    const footer = document.getElementById('footer');\n    footer.style.zIndex = '1';\n  });\n\n  window.onclick = (e) => {\n    e.preventDefault();\n    if (e.target === modal)  {\n      $('#myModal').addClass('fadeOut');\n      const footer = document.getElementById('footer');\n      footer.style.zIndex = '1';\n    }\n  };\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./frontend/dropit.js","import anime from 'animejs';\nimport { soundSet1 } from './sounds/sound_set_1';\nimport { soundSet2 } from './sounds/sound_set_2';\nimport { soundSet3 } from './sounds/sound_set_3';\nimport { soundSet4 } from './sounds/sound_set_4';\nimport Howler from './howler.min.js';\n\nconst Animations = (ctx, canvas) => {\n\n  //Set default state;\n  let numOfCircles = 25;\n  let distance = 300;\n  let actions = [];\n  let sound;\n\n  let colorSets = [\n    //colorset1\n    [\"#f8ffe5\", \"#06D6A0\", \"#1B9AAA\", \"#EF476F\", \"#FFC43D\"],\n    //colorset2\n    [\"#5b507a\", \"#5B618A\", \"#9EADC8\", \"#B9E28C\", \"#D6D84F\"],\n    //colorset3\n    [\"#5bc0eb\", \"#f9c80e\", \"#41ead4\", \"#fdfffc\", \"#b91372\"],\n    //colorset4\n    [\"#f6e8ea\", \"#ef626c\", \"#de1a1a\", \"#acbed8\", \"#84dccf\"]\n  ];\n\n  let fillSets = [\n    \"#312f2f\",\n    \"#181819\",\n    \"#0b111c\",\n    \"#010e23\"\n  ];\n\n  let soundSets = [\n    soundSet1,\n    soundSet2,\n    soundSet3,\n    soundSet4\n  ];\n\n  let fontSize = () => {\n    return parseFloat(getComputedStyle(document.documentElement).fontSize);\n  };\n\n  const resizeCanvas = () => {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n  };\n\n  const removeAction = (action) => {\n    let idx = actions.indexOf(action);\n    if (idx > -1) actions.splice(idx, 1);\n  };\n\n  const changeColorSet = () => {\n    let temp = colorSets.shift();\n    colorSets.push(temp);\n  };\n\n  const changeSoundSet = () => {\n    let temp = soundSets.shift();\n    soundSets.push(temp);\n  };\n\n  const drawRipple = (x, y) => {\n    //Choose a random colorset\n    let colorSet = colorSets[0];\n    let ripple = {};\n\n    ripple.x = x;\n    ripple.y = y;\n    ripple.color = colorSet[anime.random(0, colorSet.length - 1)];\n    ripple.radius = 0;\n    ripple.alpha = 1;\n    ripple.lineWidth = 5;\n\n    ripple.draw = function() {\n      ctx.globalAlpha = ripple.alpha;\n      ctx.beginPath();\n      ctx.arc(ripple.x, ripple.y, ripple.radius, 2 * Math.PI, false);\n      ctx.lineWidth = ripple.lineWidth;\n      ctx.strokeStyle = ripple.color;\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    };\n\n    return ripple;\n  };\n\n  const drawCircle = (x, y) => {\n    //Choose a random colorset\n    let colorSet = colorSets[0];\n    let circle = {};\n    circle.x = x;\n    circle.y = y;\n    circle.color = colorSet[anime.random(0, colorSet.length - 1)];\n    circle.radius = anime.random(fontSize(), fontSize() * 2);\n\n    circle.draw = function() {\n      ctx.beginPath();\n      ctx.arc(circle.x, circle.y, circle.radius, 2 * Math.PI, false);\n      ctx.fillStyle = circle.color;\n      ctx.fill();\n    };\n\n    return circle;\n  };\n\n  const drawCircles = (x, y) => {\n    let circles = [];\n    for (let i = 0; i < numOfCircles; i++) {\n      let circle = drawCircle(x, y);\n      circles.push(circle);\n    }\n    return circles;\n  };\n\n  const animateRipple = (ripple, size) => {\n    return anime({\n      targets: ripple,\n      radius: () => {\n        return anime.random(fontSize() * size, fontSize() * (size + 2));\n      },\n      lineWidth: 0,\n      alpha: {\n        value: 0,\n        easing: 'linear',\n        duration: () => {\n          return anime.random(300, 500);\n        }\n      },\n      duration: () => {\n        return anime.random(1000, 1300);\n      },\n      easing: 'easeOutExpo',\n      complete: removeAction\n    });\n  };\n\n  const animateCircles = (x, y) => {\n    resizeCanvas();\n\n    //Draw shapes\n    let circles = drawCircles(x, y);\n    let ripple1 = drawRipple(x, y);\n    let ripple2 = drawRipple(x, y);\n    let ripple3 = drawRipple(x, y);\n\n    //Animate shapes\n    let circleAnimation = anime({\n      targets: circles,\n      x: (circle) => {\n        return circle.x + anime.random(-distance, distance);\n      },\n      y: (circle) => {\n        return circle.y + anime.random(-distance, distance);\n      },\n      radius: 0,\n      duration: () => {\n        return anime.random(1000, 1300);\n      },\n      easing: 'easeOutExpo',\n      complete: removeAction\n    });\n\n    //Animate ripples\n    let ripple1Animation = animateRipple(ripple1, 5);\n    let ripple2Animation = animateRipple(ripple2, 7);\n    let ripple3Animation = animateRipple(ripple3, 9);\n\n    actions.push(circleAnimation);\n    actions.push(ripple1Animation);\n    actions.push(ripple2Animation);\n    actions.push(ripple3Animation);\n  };\n\n  const animate = anime({\n    duration: Infinity,\n    update: () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      actions.forEach((action) => {\n        action.animatables.forEach((animatable) => {\n          animatable.target.draw();\n        });\n      });\n    }\n  });\n\n  //Update coordinates after animation\n  let x, y;\n\n  const updateCoords = () => {\n    x = Math.random() * (canvas.width);\n    y = Math.random() * (canvas.height);\n  };\n\n  const removeContainer = () => {\n    $('#title').removeClass('pulse');\n    $('#description').removeClass('pulse');\n  };\n\n  const pulseContainer = () => {\n    $('#title').addClass('pulse');\n    $('#description').addClass('pulse');\n    setTimeout(\n      removeContainer\n      , 300);\n  };\n\n  const removeLogo = () => {\n    $('#logo').removeClass('pulse');\n  };\n\n  const pulseLogo = () => {\n    $('#logo').addClass('pulse');\n    setTimeout(\n      removeLogo\n      , 300);\n  };\n\n  document.addEventListener('keydown', (e) => {\n    e.preventDefault();\n\n    //Spacebar to change colorset and soundset\n    if (e.keyCode === 32) {\n      changeColorSet();\n      changeSoundSet();\n\n      let el = $('#logo');\n      let offset = el.offset();\n      animateCircles(offset.left + 25, offset.top + 25);\n      pulseLogo();\n\n      sound = new Howl({\n        src: soundSets[0][e.keyCode]\n      });\n      sound.play();\n\n    }\n\n    //Number and letter key to play sound\n    if (e.keyCode >= 65 && e.keyCode <= 90) {\n      updateCoords();\n      animateCircles(x, y);\n      pulseContainer();\n\n      sound = new Howl({\n        src: soundSets[0][e.keyCode]\n      });\n      sound.play();\n    }\n\n  });\n\n  window.addEventListener('resize', resizeCanvas);\n\n};\n\nexport default Animations;\n\n\n\n// WEBPACK FOOTER //\n// ./frontend/animations.js","/*\n * Anime v1.1.3\n * http://anime-js.com\n * JavaScript animation engine\n * Copyright (c) 2016 Julian Garnier\n * http://juliangarnier.com\n * Released under the MIT license\n */\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.anime = factory();\n  }\n}(this, function () {\n\n  var version = '1.1.3';\n\n  // Defaults\n\n  var defaultSettings = {\n    duration: 1000,\n    delay: 0,\n    loop: false,\n    autoplay: true,\n    direction: 'normal',\n    easing: 'easeOutElastic',\n    elasticity: 400,\n    round: false,\n    begin: undefined,\n    update: undefined,\n    complete: undefined\n  }\n\n  // Transforms\n\n  var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY'];\n  var transform, transformStr = 'transform';\n\n  // Utils\n\n  var is = {\n    arr: function(a) { return Array.isArray(a) },\n    obj: function(a) { return Object.prototype.toString.call(a).indexOf('Object') > -1 },\n    svg: function(a) { return a instanceof SVGElement },\n    dom: function(a) { return a.nodeType || is.svg(a) },\n    num: function(a) { return !isNaN(parseInt(a)) },\n    str: function(a) { return typeof a === 'string' },\n    fnc: function(a) { return typeof a === 'function' },\n    und: function(a) { return typeof a === 'undefined' },\n    nul: function(a) { return typeof a === 'null' },\n    hex: function(a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a) },\n    rgb: function(a) { return /^rgb/.test(a) },\n    hsl: function(a) { return /^hsl/.test(a) },\n    col: function(a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)) }\n  }\n\n  // Easings functions adapted from http://jqueryui.com/\n\n  var easings = (function() {\n    var eases = {};\n    var names = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];\n    var functions = {\n      Sine: function(t) { return 1 + Math.sin(Math.PI / 2 * t - Math.PI / 2); },\n      Circ: function(t) { return 1 - Math.sqrt( 1 - t * t ); },\n      Elastic: function(t, m) {\n        if( t === 0 || t === 1 ) return t;\n        var p = (1 - Math.min(m, 998) / 1000), st = t / 1, st1 = st - 1, s = p / ( 2 * Math.PI ) * Math.asin( 1 );\n        return -( Math.pow( 2, 10 * st1 ) * Math.sin( ( st1 - s ) * ( 2 * Math.PI ) / p ) );\n      },\n      Back: function(t) { return t * t * ( 3 * t - 2 ); },\n      Bounce: function(t) {\n        var pow2, bounce = 4;\n        while ( t < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}\n        return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - t, 2 );\n      }\n    }\n    names.forEach(function(name, i) {\n      functions[name] = function(t) {\n        return Math.pow( t, i + 2 );\n      }\n    });\n    Object.keys(functions).forEach(function(name) {\n      var easeIn = functions[name];\n      eases['easeIn' + name] = easeIn;\n      eases['easeOut' + name] = function(t, m) { return 1 - easeIn(1 - t, m); };\n      eases['easeInOut' + name] = function(t, m) { return t < 0.5 ? easeIn(t * 2, m) / 2 : 1 - easeIn(t * -2 + 2, m) / 2; };\n      eases['easeOutIn' + name] = function(t, m) { return t < 0.5 ? (1 - easeIn(1 - 2 * t, m)) / 2 : (easeIn(t * 2 - 1, m) + 1) / 2; };\n    });\n    eases.linear = function(t) { return t; };\n    return eases;\n  })();\n\n  // Strings\n\n  var numberToString = function(val) {\n    return (is.str(val)) ? val : val + '';\n  }\n\n  var stringToHyphens = function(str) {\n    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n  }\n\n  var selectString = function(str) {\n    if (is.col(str)) return false;\n    try {\n      var nodes = document.querySelectorAll(str);\n      return nodes;\n    } catch(e) {\n      return false;\n    }\n  }\n\n  // Numbers\n\n  var random = function(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  // Arrays\n\n  var flattenArray = function(arr) {\n    return arr.reduce(function(a, b) {\n      return a.concat(is.arr(b) ? flattenArray(b) : b);\n    }, []);\n  }\n\n  var toArray = function(o) {\n    if (is.arr(o)) return o;\n    if (is.str(o)) o = selectString(o) || o;\n    if (o instanceof NodeList || o instanceof HTMLCollection) return [].slice.call(o);\n    return [o];\n  }\n\n  var arrayContains = function(arr, val) {\n    return arr.some(function(a) { return a === val; });\n  }\n\n  var groupArrayByProps = function(arr, propsArr) {\n    var groups = {};\n    arr.forEach(function(o) {\n      var group = JSON.stringify(propsArr.map(function(p) { return o[p]; }));\n      groups[group] = groups[group] || [];\n      groups[group].push(o);\n    });\n    return Object.keys(groups).map(function(group) {\n      return groups[group];\n    });\n  }\n\n  var removeArrayDuplicates = function(arr) {\n    return arr.filter(function(item, pos, self) {\n      return self.indexOf(item) === pos;\n    });\n  }\n\n  // Objects\n\n  var cloneObject = function(o) {\n    var newObject = {};\n    for (var p in o) newObject[p] = o[p];\n    return newObject;\n  }\n\n  var mergeObjects = function(o1, o2) {\n    for (var p in o2) o1[p] = !is.und(o1[p]) ? o1[p] : o2[p];\n    return o1;\n  }\n\n  // Colors\n\n  var hexToRgb = function(hex) {\n    var rgx = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    var hex = hex.replace(rgx, function(m, r, g, b) { return r + r + g + g + b + b; });\n    var rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    var r = parseInt(rgb[1], 16);\n    var g = parseInt(rgb[2], 16);\n    var b = parseInt(rgb[3], 16);\n    return 'rgb(' + r + ',' + g + ',' + b + ')';\n  }\n\n  var hslToRgb = function(hsl) {\n    var hsl = /hsl\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%\\)/g.exec(hsl);\n    var h = parseInt(hsl[1]) / 360;\n    var s = parseInt(hsl[2]) / 100;\n    var l = parseInt(hsl[3]) / 100;\n    var hue2rgb = function(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1/6) return p + (q - p) * 6 * t;\n      if (t < 1/2) return q;\n      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n      return p;\n    }\n    var r, g, b;\n    if (s == 0) {\n      r = g = b = l;\n    } else {\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var p = 2 * l - q;\n      r = hue2rgb(p, q, h + 1/3);\n      g = hue2rgb(p, q, h);\n      b = hue2rgb(p, q, h - 1/3);\n    }\n    return 'rgb(' + r * 255 + ',' + g * 255 + ',' + b * 255 + ')';\n  }\n\n  var colorToRgb = function(val) {\n    if (is.rgb(val)) return val;\n    if (is.hex(val)) return hexToRgb(val);\n    if (is.hsl(val)) return hslToRgb(val);\n  }\n\n  // Units\n\n  var getUnit = function(val) {\n    return /([\\+\\-]?[0-9|auto\\.]+)(%|px|pt|em|rem|in|cm|mm|ex|pc|vw|vh|deg)?/.exec(val)[2];\n  }\n\n  var addDefaultTransformUnit = function(prop, val, intialVal) {\n    if (getUnit(val)) return val;\n    if (prop.indexOf('translate') > -1) return getUnit(intialVal) ? val + getUnit(intialVal) : val + 'px';\n    if (prop.indexOf('rotate') > -1 || prop.indexOf('skew') > -1) return val + 'deg';\n    return val;\n  }\n\n  // Values\n\n  var getCSSValue = function(el, prop) {\n    // First check if prop is a valid CSS property\n    if (prop in el.style) {\n      // Then return the property value or fallback to '0' when getPropertyValue fails\n      return getComputedStyle(el).getPropertyValue(stringToHyphens(prop)) || '0';\n    }\n  }\n\n  var getTransformValue = function(el, prop) {\n    var defaultVal = prop.indexOf('scale') > -1 ? 1 : 0;\n    var str = el.style.transform;\n    if (!str) return defaultVal;\n    var rgx = /(\\w+)\\((.+?)\\)/g;\n    var match = [];\n    var props = [];\n    var values = [];\n    while (match = rgx.exec(str)) {\n      props.push(match[1]);\n      values.push(match[2]);\n    }\n    var val = values.filter(function(f, i) { return props[i] === prop; });\n    return val.length ? val[0] : defaultVal;\n  }\n\n  var getAnimationType = function(el, prop) {\n    if ( is.dom(el) && arrayContains(validTransforms, prop)) return 'transform';\n    if ( is.dom(el) && (el.getAttribute(prop) || (is.svg(el) && el[prop]))) return 'attribute';\n    if ( is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) return 'css';\n    if (!is.nul(el[prop]) && !is.und(el[prop])) return 'object';\n  }\n\n  var getInitialTargetValue = function(target, prop) {\n    switch (getAnimationType(target, prop)) {\n      case 'transform': return getTransformValue(target, prop);\n      case 'css': return getCSSValue(target, prop);\n      case 'attribute': return target.getAttribute(prop);\n    }\n    return target[prop] || 0;\n  }\n\n  var getValidValue = function(values, val, originalCSS) {\n    if (is.col(val)) return colorToRgb(val);\n    if (getUnit(val)) return val;\n    var unit = getUnit(values.to) ? getUnit(values.to) : getUnit(values.from);\n    if (!unit && originalCSS) unit = getUnit(originalCSS);\n    return unit ? val + unit : val;\n  }\n\n  var decomposeValue = function(val) {\n    var rgx = /-?\\d*\\.?\\d+/g;\n    return {\n      original: val,\n      numbers: numberToString(val).match(rgx) ? numberToString(val).match(rgx).map(Number) : [0],\n      strings: numberToString(val).split(rgx)\n    }\n  }\n\n  var recomposeValue = function(numbers, strings, initialStrings) {\n    return strings.reduce(function(a, b, i) {\n      var b = (b ? b : initialStrings[i - 1]);\n      return a + numbers[i - 1] + b;\n    });\n  }\n\n  // Animatables\n\n  var getAnimatables = function(targets) {\n    var targets = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];\n    return targets.map(function(t, i) {\n      return { target: t, id: i };\n    });\n  }\n\n  // Properties\n\n  var getProperties = function(params, settings) {\n    var props = [];\n    for (var p in params) {\n      if (!defaultSettings.hasOwnProperty(p) && p !== 'targets') {\n        var prop = is.obj(params[p]) ? cloneObject(params[p]) : {value: params[p]};\n        prop.name = p;\n        props.push(mergeObjects(prop, settings));\n      }\n    }\n    return props;\n  }\n\n  var getPropertiesValues = function(target, prop, value, i) {\n    var values = toArray( is.fnc(value) ? value(target, i) : value);\n    return {\n      from: (values.length > 1) ? values[0] : getInitialTargetValue(target, prop),\n      to: (values.length > 1) ? values[1] : values[0]\n    }\n  }\n\n  // Tweens\n\n  var getTweenValues = function(prop, values, type, target) {\n    var valid = {};\n    if (type === 'transform') {\n      valid.from = prop + '(' + addDefaultTransformUnit(prop, values.from, values.to) + ')';\n      valid.to = prop + '(' + addDefaultTransformUnit(prop, values.to) + ')';\n    } else {\n      var originalCSS = (type === 'css') ? getCSSValue(target, prop) : undefined;\n      valid.from = getValidValue(values, values.from, originalCSS);\n      valid.to = getValidValue(values, values.to, originalCSS);\n    }\n    return { from: decomposeValue(valid.from), to: decomposeValue(valid.to) };\n  }\n\n  var getTweensProps = function(animatables, props) {\n    var tweensProps = [];\n    animatables.forEach(function(animatable, i) {\n      var target = animatable.target;\n      return props.forEach(function(prop) {\n        var animType = getAnimationType(target, prop.name);\n        if (animType) {\n          var values = getPropertiesValues(target, prop.name, prop.value, i);\n          var tween = cloneObject(prop);\n          tween.animatables = animatable;\n          tween.type = animType;\n          tween.from = getTweenValues(prop.name, values, tween.type, target).from;\n          tween.to = getTweenValues(prop.name, values, tween.type, target).to;\n          tween.round = (is.col(values.from) || tween.round) ? 1 : 0;\n          tween.delay = (is.fnc(tween.delay) ? tween.delay(target, i, animatables.length) : tween.delay) / animation.speed;\n          tween.duration = (is.fnc(tween.duration) ? tween.duration(target, i, animatables.length) : tween.duration) / animation.speed;\n          tweensProps.push(tween);\n        }\n      });\n    });\n    return tweensProps;\n  }\n\n  var getTweens = function(animatables, props) {\n    var tweensProps = getTweensProps(animatables, props);\n    var splittedProps = groupArrayByProps(tweensProps, ['name', 'from', 'to', 'delay', 'duration']);\n    return splittedProps.map(function(tweenProps) {\n      var tween = cloneObject(tweenProps[0]);\n      tween.animatables = tweenProps.map(function(p) { return p.animatables });\n      tween.totalDuration = tween.delay + tween.duration;\n      return tween;\n    });\n  }\n\n  var reverseTweens = function(anim, delays) {\n    anim.tweens.forEach(function(tween) {\n      var toVal = tween.to;\n      var fromVal = tween.from;\n      var delayVal = anim.duration - (tween.delay + tween.duration);\n      tween.from = toVal;\n      tween.to = fromVal;\n      if (delays) tween.delay = delayVal;\n    });\n    anim.reversed = anim.reversed ? false : true;\n  }\n\n  var getTweensDuration = function(tweens) {\n    return Math.max.apply(Math, tweens.map(function(tween){ return tween.totalDuration; }));\n  }\n\n  var getTweensDelay = function(tweens) {\n    return Math.min.apply(Math, tweens.map(function(tween){ return tween.delay; }));\n  }\n\n  // will-change\n\n  var getWillChange = function(anim) {\n    var props = [];\n    var els = [];\n    anim.tweens.forEach(function(tween) {\n      if (tween.type === 'css' || tween.type === 'transform' ) {\n        props.push(tween.type === 'css' ? stringToHyphens(tween.name) : 'transform');\n        tween.animatables.forEach(function(animatable) { els.push(animatable.target); });\n      }\n    });\n    return {\n      properties: removeArrayDuplicates(props).join(', '),\n      elements: removeArrayDuplicates(els)\n    }\n  }\n\n  var setWillChange = function(anim) {\n    var willChange = getWillChange(anim);\n    willChange.elements.forEach(function(element) {\n      element.style.willChange = willChange.properties;\n    });\n  }\n\n  var removeWillChange = function(anim) {\n    var willChange = getWillChange(anim);\n    willChange.elements.forEach(function(element) {\n      element.style.removeProperty('will-change');\n    });\n  }\n\n  /* Svg path */\n\n  var getPathProps = function(path) {\n    var el = is.str(path) ? selectString(path)[0] : path;\n    return {\n      path: el,\n      value: el.getTotalLength()\n    }\n  }\n\n  var snapProgressToPath = function(tween, progress) {\n    var pathEl = tween.path;\n    var pathProgress = tween.value * progress;\n    var point = function(offset) {\n      var o = offset || 0;\n      var p = progress > 1 ? tween.value + o : pathProgress + o;\n      return pathEl.getPointAtLength(p);\n    }\n    var p = point();\n    var p0 = point(-1);\n    var p1 = point(+1);\n    switch (tween.name) {\n      case 'translateX': return p.x;\n      case 'translateY': return p.y;\n      case 'rotate': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;\n    }\n  }\n\n  // Progress\n\n  var getTweenProgress = function(tween, time) {\n    var elapsed = Math.min(Math.max(time - tween.delay, 0), tween.duration);\n    var percent = elapsed / tween.duration;\n    var progress = tween.to.numbers.map(function(number, p) {\n      var start = tween.from.numbers[p];\n      var eased = easings[tween.easing](percent, tween.elasticity);\n      var val = tween.path ? snapProgressToPath(tween, eased) : start + eased * (number - start);\n      val = tween.round ? Math.round(val * tween.round) / tween.round : val;\n      return val;\n    });\n    return recomposeValue(progress, tween.to.strings, tween.from.strings);\n  }\n\n  var setAnimationProgress = function(anim, time) {\n    var transforms;\n    anim.currentTime = time;\n    anim.progress = (time / anim.duration) * 100;\n    for (var t = 0; t < anim.tweens.length; t++) {\n      var tween = anim.tweens[t];\n      tween.currentValue = getTweenProgress(tween, time);\n      var progress = tween.currentValue;\n      for (var a = 0; a < tween.animatables.length; a++) {\n        var animatable = tween.animatables[a];\n        var id = animatable.id;\n        var target = animatable.target;\n        var name = tween.name;\n        switch (tween.type) {\n          case 'css': target.style[name] = progress; break;\n          case 'attribute': target.setAttribute(name, progress); break;\n          case 'object': target[name] = progress; break;\n          case 'transform':\n          if (!transforms) transforms = {};\n          if (!transforms[id]) transforms[id] = [];\n          transforms[id].push(progress);\n          break;\n        }\n      }\n    }\n    if (transforms) {\n      if (!transform) transform = (getCSSValue(document.body, transformStr) ? '' : '-webkit-') + transformStr;\n      for (var t in transforms) {\n        anim.animatables[t].target.style[transform] = transforms[t].join(' ');\n      }\n    }\n  }\n\n  // Animation\n\n  var createAnimation = function(params) {\n    var anim = {};\n    anim.animatables = getAnimatables(params.targets);\n    anim.settings = mergeObjects(params, defaultSettings);\n    anim.properties = getProperties(params, anim.settings);\n    anim.tweens = getTweens(anim.animatables, anim.properties);\n    anim.duration = anim.tweens.length ? getTweensDuration(anim.tweens) : params.duration;\n    anim.delay = anim.tweens.length ? getTweensDelay(anim.tweens) : params.delay;\n    anim.currentTime = 0;\n    anim.progress = 0;\n    anim.ended = false;\n    return anim;\n  }\n\n  // Public\n\n  var animations = [];\n  var raf = 0;\n\n  var engine = (function() {\n    var play = function() { raf = requestAnimationFrame(step); };\n    var step = function(t) {\n      if (animations.length) {\n        for (var i = 0; i < animations.length; i++) animations[i].tick(t);\n        play();\n      } else {\n        cancelAnimationFrame(raf);\n        raf = 0;\n      }\n    }\n    return play;\n  })();\n\n  var animation = function(params) {\n\n    var anim = createAnimation(params);\n    var time = {};\n\n    anim.tick = function(now) {\n      anim.ended = false;\n      if (!time.start) time.start = now;\n      time.current = Math.min(Math.max(time.last + now - time.start, 0), anim.duration);\n      setAnimationProgress(anim, time.current);\n      var s = anim.settings;\n      if (time.current >= anim.delay) {\n        if (s.begin) s.begin(anim); s.begin = undefined;\n        if (s.update) s.update(anim);\n      }\n      if (time.current >= anim.duration) {\n        if (s.loop) {\n          time.start = now;\n          if (s.direction === 'alternate') reverseTweens(anim, true);\n          if (is.num(s.loop)) s.loop--;\n        } else {\n          anim.ended = true;\n          anim.pause();\n          if (s.complete) s.complete(anim);\n        }\n        time.last = 0;\n      }\n    }\n\n    anim.seek = function(progress) {\n      setAnimationProgress(anim, (progress / 100) * anim.duration);\n    }\n\n    anim.pause = function() {\n      removeWillChange(anim);\n      var i = animations.indexOf(anim);\n      if (i > -1) animations.splice(i, 1);\n    }\n\n    anim.play = function(params) {\n      anim.pause();\n      if (params) anim = mergeObjects(createAnimation(mergeObjects(params, anim.settings)), anim);\n      time.start = 0;\n      time.last = anim.ended ? 0 : anim.currentTime;\n      var s = anim.settings;\n      if (s.direction === 'reverse') reverseTweens(anim);\n      if (s.direction === 'alternate' && !s.loop) s.loop = 1;\n      setWillChange(anim);\n      animations.push(anim);\n      if (!raf) engine();\n    }\n\n    anim.restart = function() {\n      if (anim.reversed) reverseTweens(anim);\n      anim.pause();\n      anim.seek(0);\n      anim.play();\n    }\n\n    if (anim.settings.autoplay) anim.play();\n\n    return anim;\n\n  }\n\n  // Remove one or multiple targets from all active animations.\n\n  var remove = function(elements) {\n    var targets = flattenArray(is.arr(elements) ? elements.map(toArray) : toArray(elements));\n    for (var i = animations.length-1; i >= 0; i--) {\n      var animation = animations[i];\n      var tweens = animation.tweens;\n      for (var t = tweens.length-1; t >= 0; t--) {\n        var animatables = tweens[t].animatables;\n        for (var a = animatables.length-1; a >= 0; a--) {\n          if (arrayContains(targets, animatables[a].target)) {\n            animatables.splice(a, 1);\n            if (!animatables.length) tweens.splice(t, 1);\n            if (!tweens.length) animation.pause();\n          }\n        }\n      }\n    }\n  }\n\n  animation.version = version;\n  animation.speed = 1;\n  animation.list = animations;\n  animation.remove = remove;\n  animation.easings = easings;\n  animation.getValue = getInitialTargetValue;\n  animation.path = getPathProps;\n  animation.random = random;\n\n  return animation;\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/animejs/anime.js\n// module id = 2\n// module chunks = 0","export const soundSet1 = {\n  32: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485317545/clap_ussscf.wav'],\n  65: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304441/1_xctwu8.mp3'],\n  66: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304445/2_ew0ciq.mp3'],\n  67: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304447/3_fvupmh.mp3'],\n  68: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304439/4_vmc6iv.mp3'],\n  69: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304451/5_dicr5q.mp3'],\n  70: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304444/6_w6kndp.mp3'],\n  71: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304442/7_fdvwdy.mp3'],\n  72: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304447/8_f5szkh.mp3'],\n  73: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304447/9_ddy3fb.mp3'],\n  74: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304450/10_zjbmnr.mp3'],\n  75: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304458/11_l0kj2j.mp3'],\n  76: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304449/12_hekw7o.mp3'],\n  77: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304452/13_ac0yri.mp3'],\n  78: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304448/14_mm6pxe.mp3'],\n  79: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304451/15_r8tapy.mp3'],\n  80: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304457/16_z3jqm7.mp3'],\n  81: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304463/17_zxtm4k.mp3'],\n  82: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304454/18_eaveqc.mp3'],\n  83: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304459/19_fuw8dd.mp3'],\n  84: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304457/20_bs9a8d.mp3'],\n  85: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304472/21_rqp5qt.mp3'],\n  86: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304471/22_j4kmta.mp3'],\n  87: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304470/23_yagbun.mp3'],\n  88: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304462/24_ze4ghc.mp3'],\n  89: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304468/25_tx4b4v.mp3'],\n  90: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485304470/26_lnxzlb.mp3']\n};\n\n\n\n// WEBPACK FOOTER //\n// ./frontend/sounds/sound_set_1.js","export const soundSet2 = {\n  32: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485317545/clap_ussscf.wav'],\n  65: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305281/27_hyqs6f.mp3'],\n  66: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305284/28_a1xtxt.mp3'],\n  67: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305280/29_mhwpyu.mp3'],\n  68: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305288/30_iadkv9.mp3'],\n  69: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305286/31_udsesn.mp3'],\n  70: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305289/32_kovkgj.mp3'],\n  71: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305287/33_skjuep.mp3'],\n  72: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305283/34_lfodfp.mp3'],\n  73: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305286/35_nrcg0v.mp3'],\n  74: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305290/36_cey42w.mp3'],\n  75: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305288/37_lbptfv.mp3'],\n  76: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305290/38_o8gkzb.mp3'],\n  77: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305290/39_fr4ynq.mp3'],\n  78: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305295/40_uq5ksg.mp3'],\n  79: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305293/41_qberkg.mp3'],\n  80: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305293/42_apphhd.mp3'],\n  81: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305298/43_j8e8j8.mp3'],\n  82: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305298/44_aiakw0.mp3'],\n  83: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305299/45_msqxca.mp3'],\n  84: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305295/46_bkwvxn.mp3'],\n  85: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305296/47_d3rqhn.mp3'],\n  86: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305300/48_ft4tsc.mp3'],\n  87: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305300/49_dj3yeb.mp3'],\n  88: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305300/50_jkg6xg.mp3'],\n  89: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305301/51_yassg5.mp3'],\n  90: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485305301/52_evxhyz.mp3']\n};\n\n\n\n// WEBPACK FOOTER //\n// ./frontend/sounds/sound_set_2.js","export const soundSet3 = {\n  32: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485317545/clap_ussscf.wav'],\n  65: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306205/53_aweced.mp3'],\n  66: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306203/54_ybc8rq.mp3'],\n  67: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306203/55_fjox4o.mp3'],\n  68: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306209/56_bcecx7.mp3'],\n  69: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306212/57_iqzppi.mp3'],\n  70: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306205/58_edqghd.mp3'],\n  71: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306204/59_y19nub.mp3'],\n  72: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306207/60_fgtoai.mp3'],\n  73: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306208/61_tumyui.mp3'],\n  74: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306207/62_o5as3j.mp3'],\n  75: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306210/63_tzfy4v.mp3'],\n  76: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306208/64_p1lnfg.mp3'],\n  77: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306208/65_cemr0u.mp3'],\n  78: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306211/66_glvnjx.mp3'],\n  79: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306213/67_n1whl0.mp3'],\n  80: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306213/68_otaywp.mp3'],\n  81: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306212/69_pjnkdj.mp3'],\n  82: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306212/70_wrj9zu.mp3'],\n  83: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306216/71_alqewv.mp3'],\n  84: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306216/72_fc7au3.mp3'],\n  85: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306217/73_nf1wme.mp3'],\n  86: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306217/74_rislgn.mp3'],\n  87: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306219/75_papkff.mp3'],\n  88: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306217/76_xt1d0b.mp3'],\n  89: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306216/77_gskhyv.mp3'],\n  90: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306218/78_xrm1de.mp3']\n};\n\n\n\n// WEBPACK FOOTER //\n// ./frontend/sounds/sound_set_3.js","export const soundSet4 = {\n  32: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485317545/clap_ussscf.wav'],\n  65: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306306/79_qrx0gf.mp3'],\n  66: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306303/80_rneo7i.mp3'],\n  67: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306307/81_ueyfqz.mp3'],\n  68: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306306/82_nlepoo.mp3'],\n  69: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306314/83_l43vul.mp3'],\n  70: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306305/84_kanfri.mp3'],\n  71: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306305/85_hd93dy.mp3'],\n  72: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306306/86_v8ojzj.mp3'],\n  73: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306306/87_ciwyuf.mp3'],\n  74: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306307/88_s55fss.mp3'],\n  75: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306310/89_u34pa7.mp3'],\n  76: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306308/90_ewmsft.mp3'],\n  77: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306308/91_nslkjq.mp3'],\n  78: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306309/92_vvnwjn.mp3'],\n  79: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306312/93_lqj18n.mp3'],\n  80: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306310/94_dgalal.mp3'],\n  81: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306312/95_dpuxdg.mp3'],\n  82: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306315/96_a3rsno.mp3'],\n  83: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306315/97_meiv5c.mp3'],\n  84: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306312/98_zcijsy.mp3'],\n  85: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306315/99_gs8d3u.mp3'],\n  86: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306316/100_xmevws.mp3'],\n  87: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306316/101_cgeizj.mp3'],\n  88: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306318/102_cfkuny.mp3'],\n  89: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306319/103_hlrafb.mp3'],\n  90: ['https://res.cloudinary.com/dxfu1kzhk/video/upload/v1485306318/104_s18lw0.mp3']\n};\n\n\n\n// WEBPACK FOOTER //\n// ./frontend/sounds/sound_set_4.js","/*! howler.js v2.0.2 | (c) 2013-2016, James Simpson of GoldFire Studios | MIT License | howlerjs.com */\n!function(){\"use strict\";var e=function(){this.init()};e.prototype={init:function(){var e=this||n;return e._codecs={},e._howls=[],e._muted=!1,e._volume=1,e._canPlayEvent=\"canplaythrough\",e._navigator=\"undefined\"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.mobileAutoEnable=!0,e._setup(),e},volume:function(e){var t=this||n;if(e=parseFloat(e),t.ctx||_(),\"undefined\"!=typeof e&&e>=0&&e<=1){if(t._volume=e,t._muted)return t;t.usingWebAudio&&(t.masterGain.gain.value=e);for(var o=0;o<t._howls.length;o++)if(!t._howls[o]._webAudio)for(var r=t._howls[o]._getSoundIds(),u=0;u<r.length;u++){var a=t._howls[o]._soundById(r[u]);a&&a._node&&(a._node.volume=a._volume*e)}return t}return t._volume},mute:function(e){var t=this||n;t.ctx||_(),t._muted=e,t.usingWebAudio&&(t.masterGain.gain.value=e?0:t._volume);for(var o=0;o<t._howls.length;o++)if(!t._howls[o]._webAudio)for(var r=t._howls[o]._getSoundIds(),u=0;u<r.length;u++){var a=t._howls[o]._soundById(r[u]);a&&a._node&&(a._node.muted=!!e||a._muted)}return t},unload:function(){for(var e=this||n,t=e._howls.length-1;t>=0;t--)e._howls[t].unload();return e.usingWebAudio&&e.ctx&&\"undefined\"!=typeof e.ctx.close&&(e.ctx.close(),e.ctx=null,_()),e},codecs:function(e){return(this||n)._codecs[e.replace(/^x-/,\"\")]},_setup:function(){var e=this||n;if(e.state=e.ctx?e.ctx.state||\"running\":\"running\",e._autoSuspend(),!e.usingWebAudio)if(\"undefined\"!=typeof Audio)try{var t=new Audio;\"undefined\"==typeof t.oncanplaythrough&&(e._canPlayEvent=\"canplay\")}catch(n){e.noAudio=!0}else e.noAudio=!0;try{var t=new Audio;t.muted&&(e.noAudio=!0)}catch(e){}return e.noAudio||e._setupCodecs(),e},_setupCodecs:function(){var e=this||n,t=null;try{t=\"undefined\"!=typeof Audio?new Audio:null}catch(n){return e}if(!t||\"function\"!=typeof t.canPlayType)return e;var o=t.canPlayType(\"audio/mpeg;\").replace(/^no$/,\"\"),r=e._navigator&&e._navigator.userAgent.match(/OPR\\/([0-6].)/g),u=r&&parseInt(r[0].split(\"/\")[1],10)<33;return e._codecs={mp3:!(u||!o&&!t.canPlayType(\"audio/mp3;\").replace(/^no$/,\"\")),mpeg:!!o,opus:!!t.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/,\"\"),ogg:!!t.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/,\"\"),oga:!!t.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/,\"\"),wav:!!t.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/,\"\"),aac:!!t.canPlayType(\"audio/aac;\").replace(/^no$/,\"\"),caf:!!t.canPlayType(\"audio/x-caf;\").replace(/^no$/,\"\"),m4a:!!(t.canPlayType(\"audio/x-m4a;\")||t.canPlayType(\"audio/m4a;\")||t.canPlayType(\"audio/aac;\")).replace(/^no$/,\"\"),mp4:!!(t.canPlayType(\"audio/x-mp4;\")||t.canPlayType(\"audio/mp4;\")||t.canPlayType(\"audio/aac;\")).replace(/^no$/,\"\"),weba:!!t.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/,\"\"),webm:!!t.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/,\"\"),dolby:!!t.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/,\"\"),flac:!!(t.canPlayType(\"audio/x-flac;\")||t.canPlayType(\"audio/flac;\")).replace(/^no$/,\"\")},e},_enableMobileAudio:function(){var e=this||n,t=/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(e._navigator&&e._navigator.userAgent),o=!!(\"ontouchend\"in window||e._navigator&&e._navigator.maxTouchPoints>0||e._navigator&&e._navigator.msMaxTouchPoints>0);if(!e._mobileEnabled&&e.ctx&&(t||o)){e._mobileEnabled=!1,e._mobileUnloaded||44100===e.ctx.sampleRate||(e._mobileUnloaded=!0,e.unload()),e._scratchBuffer=e.ctx.createBuffer(1,1,22050);var r=function(){var n=e.ctx.createBufferSource();n.buffer=e._scratchBuffer,n.connect(e.ctx.destination),\"undefined\"==typeof n.start?n.noteOn(0):n.start(0),n.onended=function(){n.disconnect(0),e._mobileEnabled=!0,e.mobileAutoEnable=!1,document.removeEventListener(\"touchend\",r,!0)}};return document.addEventListener(\"touchend\",r,!0),e}},_autoSuspend:function(){var e=this;if(e.autoSuspend&&e.ctx&&\"undefined\"!=typeof e.ctx.suspend&&n.usingWebAudio){for(var t=0;t<e._howls.length;t++)if(e._howls[t]._webAudio)for(var o=0;o<e._howls[t]._sounds.length;o++)if(!e._howls[t]._sounds[o]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout(function(){e.autoSuspend&&(e._suspendTimer=null,e.state=\"suspending\",e.ctx.suspend().then(function(){e.state=\"suspended\",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())}))},3e4),e}},_autoResume:function(){var e=this;if(e.ctx&&\"undefined\"!=typeof e.ctx.resume&&n.usingWebAudio)return\"running\"===e.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):\"suspended\"===e.state?(e.state=\"resuming\",e.ctx.resume().then(function(){e.state=\"running\";for(var n=0;n<e._howls.length;n++)e._howls[n]._emit(\"resume\")}),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):\"suspending\"===e.state&&(e._resumeAfterSuspend=!0),e}};var n=new e,t=function(e){var n=this;return e.src&&0!==e.src.length?void n.init(e):void console.error(\"An array of source files must be passed with any new Howl.\")};t.prototype={init:function(e){var t=this;return n.ctx||_(),t._autoplay=e.autoplay||!1,t._format=\"string\"!=typeof e.format?e.format:[e.format],t._html5=e.html5||!1,t._muted=e.mute||!1,t._loop=e.loop||!1,t._pool=e.pool||5,t._preload=\"boolean\"!=typeof e.preload||e.preload,t._rate=e.rate||1,t._sprite=e.sprite||{},t._src=\"string\"!=typeof e.src?e.src:[e.src],t._volume=void 0!==e.volume?e.volume:1,t._duration=0,t._state=\"unloaded\",t._sounds=[],t._endTimers={},t._queue=[],t._onend=e.onend?[{fn:e.onend}]:[],t._onfade=e.onfade?[{fn:e.onfade}]:[],t._onload=e.onload?[{fn:e.onload}]:[],t._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],t._onpause=e.onpause?[{fn:e.onpause}]:[],t._onplay=e.onplay?[{fn:e.onplay}]:[],t._onstop=e.onstop?[{fn:e.onstop}]:[],t._onmute=e.onmute?[{fn:e.onmute}]:[],t._onvolume=e.onvolume?[{fn:e.onvolume}]:[],t._onrate=e.onrate?[{fn:e.onrate}]:[],t._onseek=e.onseek?[{fn:e.onseek}]:[],t._onresume=[],t._webAudio=n.usingWebAudio&&!t._html5,\"undefined\"!=typeof n.ctx&&n.ctx&&n.mobileAutoEnable&&n._enableMobileAudio(),n._howls.push(t),t._autoplay&&t._queue.push({event:\"play\",action:function(){t.play()}}),t._preload&&t.load(),t},load:function(){var e=this,t=null;if(n.noAudio)return void e._emit(\"loaderror\",null,\"No audio support.\");\"string\"==typeof e._src&&(e._src=[e._src]);for(var r=0;r<e._src.length;r++){var a,d;if(e._format&&e._format[r])a=e._format[r];else{if(d=e._src[r],\"string\"!=typeof d){e._emit(\"loaderror\",null,\"Non-string found in selected audio sources - ignoring.\");continue}a=/^data:audio\\/([^;,]+);/i.exec(d),a||(a=/\\.([^.]+)$/.exec(d.split(\"?\",1)[0])),a&&(a=a[1].toLowerCase())}if(n.codecs(a)){t=e._src[r];break}}return t?(e._src=t,e._state=\"loading\",\"https:\"===window.location.protocol&&\"http:\"===t.slice(0,5)&&(e._html5=!0,e._webAudio=!1),new o(e),e._webAudio&&u(e),e):void e._emit(\"loaderror\",null,\"No codec support for selected audio sources.\")},play:function(e,t){var o=this,r=null;if(\"number\"==typeof e)r=e,e=null;else{if(\"string\"==typeof e&&\"loaded\"===o._state&&!o._sprite[e])return null;if(\"undefined\"==typeof e){e=\"__default\";for(var u=0,a=0;a<o._sounds.length;a++)o._sounds[a]._paused&&!o._sounds[a]._ended&&(u++,r=o._sounds[a]._id);1===u?e=null:r=null}}var d=r?o._soundById(r):o._inactiveSound();if(!d)return null;if(r&&!e&&(e=d._sprite||\"__default\"),\"loaded\"!==o._state&&!o._sprite[e])return o._queue.push({event:\"play\",action:function(){o.play(o._soundById(d._id)?d._id:void 0)}}),d._id;if(r&&!d._paused)return t||setTimeout(function(){o._emit(\"play\",d._id)},0),d._id;o._webAudio&&n._autoResume();var i=Math.max(0,d._seek>0?d._seek:o._sprite[e][0]/1e3),_=Math.max(0,(o._sprite[e][0]+o._sprite[e][1])/1e3-i),s=1e3*_/Math.abs(d._rate);d._paused=!1,d._ended=!1,d._sprite=e,d._seek=i,d._start=o._sprite[e][0]/1e3,d._stop=(o._sprite[e][0]+o._sprite[e][1])/1e3,d._loop=!(!d._loop&&!o._sprite[e][2]);var l=d._node;if(o._webAudio){var f=function(){o._refreshBuffer(d);var e=d._muted||o._muted?0:d._volume;l.gain.setValueAtTime(e,n.ctx.currentTime),d._playStart=n.ctx.currentTime,\"undefined\"==typeof l.bufferSource.start?d._loop?l.bufferSource.noteGrainOn(0,i,86400):l.bufferSource.noteGrainOn(0,i,_):d._loop?l.bufferSource.start(0,i,86400):l.bufferSource.start(0,i,_),s!==1/0&&(o._endTimers[d._id]=setTimeout(o._ended.bind(o,d),s)),t||setTimeout(function(){o._emit(\"play\",d._id)},0)},c=\"running\"===n.state;\"loaded\"===o._state&&c?f():(o.once(c?\"load\":\"resume\",f,c?d._id:null),o._clearTimer(d._id))}else{var p=function(){l.currentTime=i,l.muted=d._muted||o._muted||n._muted||l.muted,l.volume=d._volume*n.volume(),l.playbackRate=d._rate,setTimeout(function(){l.play(),s!==1/0&&(o._endTimers[d._id]=setTimeout(o._ended.bind(o,d),s)),t||o._emit(\"play\",d._id)},0)},m=\"loaded\"===o._state&&(window&&window.ejecta||!l.readyState&&n._navigator.isCocoonJS);if(4===l.readyState||m)p();else{var v=function(){p(),l.removeEventListener(n._canPlayEvent,v,!1)};l.addEventListener(n._canPlayEvent,v,!1),o._clearTimer(d._id)}}return d._id},pause:function(e){var n=this;if(\"loaded\"!==n._state)return n._queue.push({event:\"pause\",action:function(){n.pause(e)}}),n;for(var t=n._getSoundIds(e),o=0;o<t.length;o++){n._clearTimer(t[o]);var r=n._soundById(t[o]);if(r&&!r._paused&&(r._seek=n.seek(t[o]),r._rateSeek=0,r._paused=!0,n._stopFade(t[o]),r._node))if(n._webAudio){if(!r._node.bufferSource)return n;\"undefined\"==typeof r._node.bufferSource.stop?r._node.bufferSource.noteOff(0):r._node.bufferSource.stop(0),n._cleanBuffer(r._node)}else isNaN(r._node.duration)&&r._node.duration!==1/0||r._node.pause();arguments[1]||n._emit(\"pause\",r?r._id:null)}return n},stop:function(e,n){var t=this;if(\"loaded\"!==t._state)return t._queue.push({event:\"stop\",action:function(){t.stop(e)}}),t;for(var o=t._getSoundIds(e),r=0;r<o.length;r++){t._clearTimer(o[r]);var u=t._soundById(o[r]);if(u&&(u._seek=u._start||0,u._rateSeek=0,u._paused=!0,u._ended=!0,t._stopFade(o[r]),u._node))if(t._webAudio){if(!u._node.bufferSource)return n||t._emit(\"stop\",u._id),t;\"undefined\"==typeof u._node.bufferSource.stop?u._node.bufferSource.noteOff(0):u._node.bufferSource.stop(0),t._cleanBuffer(u._node)}else isNaN(u._node.duration)&&u._node.duration!==1/0||(u._node.currentTime=u._start||0,u._node.pause());u&&!n&&t._emit(\"stop\",u._id)}return t},mute:function(e,t){var o=this;if(\"loaded\"!==o._state)return o._queue.push({event:\"mute\",action:function(){o.mute(e,t)}}),o;if(\"undefined\"==typeof t){if(\"boolean\"!=typeof e)return o._muted;o._muted=e}for(var r=o._getSoundIds(t),u=0;u<r.length;u++){var a=o._soundById(r[u]);a&&(a._muted=e,o._webAudio&&a._node?a._node.gain.setValueAtTime(e?0:a._volume,n.ctx.currentTime):a._node&&(a._node.muted=!!n._muted||e),o._emit(\"mute\",a._id))}return o},volume:function(){var e,t,o=this,r=arguments;if(0===r.length)return o._volume;if(1===r.length||2===r.length&&\"undefined\"==typeof r[1]){var u=o._getSoundIds(),a=u.indexOf(r[0]);a>=0?t=parseInt(r[0],10):e=parseFloat(r[0])}else r.length>=2&&(e=parseFloat(r[0]),t=parseInt(r[1],10));var d;if(!(\"undefined\"!=typeof e&&e>=0&&e<=1))return d=t?o._soundById(t):o._sounds[0],d?d._volume:0;if(\"loaded\"!==o._state)return o._queue.push({event:\"volume\",action:function(){o.volume.apply(o,r)}}),o;\"undefined\"==typeof t&&(o._volume=e),t=o._getSoundIds(t);for(var i=0;i<t.length;i++)d=o._soundById(t[i]),d&&(d._volume=e,r[2]||o._stopFade(t[i]),o._webAudio&&d._node&&!d._muted?d._node.gain.setValueAtTime(e,n.ctx.currentTime):d._node&&!d._muted&&(d._node.volume=e*n.volume()),o._emit(\"volume\",d._id));return o},fade:function(e,t,o,r){var u=this,a=Math.abs(e-t),d=e>t?\"out\":\"in\",i=a/.01,_=i>0?o/i:o;if(_<4&&(i=Math.ceil(i/(4/_)),_=4),\"loaded\"!==u._state)return u._queue.push({event:\"fade\",action:function(){u.fade(e,t,o,r)}}),u;u.volume(e,r);for(var s=u._getSoundIds(r),l=0;l<s.length;l++){var f=u._soundById(s[l]);if(f){if(r||u._stopFade(s[l]),u._webAudio&&!f._muted){var c=n.ctx.currentTime,p=c+o/1e3;f._volume=e,f._node.gain.setValueAtTime(e,c),f._node.gain.linearRampToValueAtTime(t,p)}var m=e;f._interval=setInterval(function(e,n){i>0&&(m+=\"in\"===d?.01:-.01),m=Math.max(0,m),m=Math.min(1,m),m=Math.round(100*m)/100,u._webAudio?(\"undefined\"==typeof r&&(u._volume=m),n._volume=m):u.volume(m,e,!0),m===t&&(clearInterval(n._interval),n._interval=null,u.volume(m,e),u._emit(\"fade\",e))}.bind(u,s[l],f),_)}}return u},_stopFade:function(e){var t=this,o=t._soundById(e);return o&&o._interval&&(t._webAudio&&o._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(o._interval),o._interval=null,t._emit(\"fade\",e)),t},loop:function(){var e,n,t,o=this,r=arguments;if(0===r.length)return o._loop;if(1===r.length){if(\"boolean\"!=typeof r[0])return t=o._soundById(parseInt(r[0],10)),!!t&&t._loop;e=r[0],o._loop=e}else 2===r.length&&(e=r[0],n=parseInt(r[1],10));for(var u=o._getSoundIds(n),a=0;a<u.length;a++)t=o._soundById(u[a]),t&&(t._loop=e,o._webAudio&&t._node&&t._node.bufferSource&&(t._node.bufferSource.loop=e,e&&(t._node.bufferSource.loopStart=t._start||0,t._node.bufferSource.loopEnd=t._stop)));return o},rate:function(){var e,t,o=this,r=arguments;if(0===r.length)t=o._sounds[0]._id;else if(1===r.length){var u=o._getSoundIds(),a=u.indexOf(r[0]);a>=0?t=parseInt(r[0],10):e=parseFloat(r[0])}else 2===r.length&&(e=parseFloat(r[0]),t=parseInt(r[1],10));var d;if(\"number\"!=typeof e)return d=o._soundById(t),d?d._rate:o._rate;if(\"loaded\"!==o._state)return o._queue.push({event:\"rate\",action:function(){o.rate.apply(o,r)}}),o;\"undefined\"==typeof t&&(o._rate=e),t=o._getSoundIds(t);for(var i=0;i<t.length;i++)if(d=o._soundById(t[i])){d._rateSeek=o.seek(t[i]),d._playStart=o._webAudio?n.ctx.currentTime:d._playStart,d._rate=e,o._webAudio&&d._node&&d._node.bufferSource?d._node.bufferSource.playbackRate.value=e:d._node&&(d._node.playbackRate=e);var _=o.seek(t[i]),s=(o._sprite[d._sprite][0]+o._sprite[d._sprite][1])/1e3-_,l=1e3*s/Math.abs(d._rate);!o._endTimers[t[i]]&&d._paused||(o._clearTimer(t[i]),o._endTimers[t[i]]=setTimeout(o._ended.bind(o,d),l)),o._emit(\"rate\",d._id)}return o},seek:function(){var e,t,o=this,r=arguments;if(0===r.length)t=o._sounds[0]._id;else if(1===r.length){var u=o._getSoundIds(),a=u.indexOf(r[0]);a>=0?t=parseInt(r[0],10):(t=o._sounds[0]._id,e=parseFloat(r[0]))}else 2===r.length&&(e=parseFloat(r[0]),t=parseInt(r[1],10));if(\"undefined\"==typeof t)return o;if(\"loaded\"!==o._state)return o._queue.push({event:\"seek\",action:function(){o.seek.apply(o,r)}}),o;var d=o._soundById(t);if(d){if(!(\"number\"==typeof e&&e>=0)){if(o._webAudio){var i=o.playing(t)?n.ctx.currentTime-d._playStart:0,_=d._rateSeek?d._rateSeek-d._seek:0;return d._seek+(_+i*Math.abs(d._rate))}return d._node.currentTime}var s=o.playing(t);s&&o.pause(t,!0),d._seek=e,d._ended=!1,o._clearTimer(t),s&&o.play(t,!0),!o._webAudio&&d._node&&(d._node.currentTime=e),o._emit(\"seek\",t)}return o},playing:function(e){var n=this;if(\"number\"==typeof e){var t=n._soundById(e);return!!t&&!t._paused}for(var o=0;o<n._sounds.length;o++)if(!n._sounds[o]._paused)return!0;return!1},duration:function(e){var n=this,t=n._duration,o=n._soundById(e);return o&&(t=n._sprite[o._sprite][1]/1e3),t},state:function(){return this._state},unload:function(){for(var e=this,t=e._sounds,o=0;o<t.length;o++){t[o]._paused||(e.stop(t[o]._id),e._emit(\"end\",t[o]._id)),e._webAudio||(t[o]._node.src=\"data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=\",t[o]._node.removeEventListener(\"error\",t[o]._errorFn,!1),t[o]._node.removeEventListener(n._canPlayEvent,t[o]._loadFn,!1)),delete t[o]._node,e._clearTimer(t[o]._id);var u=n._howls.indexOf(e);u>=0&&n._howls.splice(u,1)}var a=!0;for(o=0;o<n._howls.length;o++)if(n._howls[o]._src===e._src){a=!1;break}return r&&a&&delete r[e._src],n.noAudio=!1,e._state=\"unloaded\",e._sounds=[],e=null,null},on:function(e,n,t,o){var r=this,u=r[\"_on\"+e];return\"function\"==typeof n&&u.push(o?{id:t,fn:n,once:o}:{id:t,fn:n}),r},off:function(e,n,t){var o=this,r=o[\"_on\"+e],u=0;if(n){for(u=0;u<r.length;u++)if(n===r[u].fn&&t===r[u].id){r.splice(u,1);break}}else if(e)o[\"_on\"+e]=[];else{var a=Object.keys(o);for(u=0;u<a.length;u++)0===a[u].indexOf(\"_on\")&&Array.isArray(o[a[u]])&&(o[a[u]]=[])}return o},once:function(e,n,t){var o=this;return o.on(e,n,t,1),o},_emit:function(e,n,t){for(var o=this,r=o[\"_on\"+e],u=r.length-1;u>=0;u--)r[u].id&&r[u].id!==n&&\"load\"!==e||(setTimeout(function(e){e.call(this,n,t)}.bind(o,r[u].fn),0),r[u].once&&o.off(e,r[u].fn,r[u].id));return o},_loadQueue:function(){var e=this;if(e._queue.length>0){var n=e._queue[0];e.once(n.event,function(){e._queue.shift(),e._loadQueue()}),n.action()}return e},_ended:function(e){var t=this,o=e._sprite,r=!(!e._loop&&!t._sprite[o][2]);if(t._emit(\"end\",e._id),!t._webAudio&&r&&t.stop(e._id,!0).play(e._id),t._webAudio&&r){t._emit(\"play\",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=n.ctx.currentTime;var u=1e3*(e._stop-e._start)/Math.abs(e._rate);t._endTimers[e._id]=setTimeout(t._ended.bind(t,e),u)}return t._webAudio&&!r&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,t._clearTimer(e._id),t._cleanBuffer(e._node),n._autoSuspend()),t._webAudio||r||t.stop(e._id),t},_clearTimer:function(e){var n=this;return n._endTimers[e]&&(clearTimeout(n._endTimers[e]),delete n._endTimers[e]),n},_soundById:function(e){for(var n=this,t=0;t<n._sounds.length;t++)if(e===n._sounds[t]._id)return n._sounds[t];return null},_inactiveSound:function(){var e=this;e._drain();for(var n=0;n<e._sounds.length;n++)if(e._sounds[n]._ended)return e._sounds[n].reset();return new o(e)},_drain:function(){var e=this,n=e._pool,t=0,o=0;if(!(e._sounds.length<n)){for(o=0;o<e._sounds.length;o++)e._sounds[o]._ended&&t++;for(o=e._sounds.length-1;o>=0;o--){if(t<=n)return;e._sounds[o]._ended&&(e._webAudio&&e._sounds[o]._node&&e._sounds[o]._node.disconnect(0),e._sounds.splice(o,1),t--)}}},_getSoundIds:function(e){var n=this;if(\"undefined\"==typeof e){for(var t=[],o=0;o<n._sounds.length;o++)t.push(n._sounds[o]._id);return t}return[e]},_refreshBuffer:function(e){var t=this;return e._node.bufferSource=n.ctx.createBufferSource(),e._node.bufferSource.buffer=r[t._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop),e._node.bufferSource.playbackRate.value=e._rate,t},_cleanBuffer:function(e){var n=this;if(n._scratchBuffer){e.bufferSource.onended=null,e.bufferSource.disconnect(0);try{e.bufferSource.buffer=n._scratchBuffer}catch(e){}}return e.bufferSource=null,n}};var o=function(e){this._parent=e,this.init()};o.prototype={init:function(){var e=this,n=e._parent;return e._muted=n._muted,e._loop=n._loop,e._volume=n._volume,e._muted=n._muted,e._rate=n._rate,e._seek=0,e._paused=!0,e._ended=!0,e._sprite=\"__default\",e._id=Math.round(Date.now()*Math.random()),n._sounds.push(e),e.create(),e},create:function(){var e=this,t=e._parent,o=n._muted||e._muted||e._parent._muted?0:e._volume;return t._webAudio?(e._node=\"undefined\"==typeof n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),e._node.gain.setValueAtTime(o,n.ctx.currentTime),e._node.paused=!0,e._node.connect(n.masterGain)):(e._node=new Audio,e._errorFn=e._errorListener.bind(e),e._node.addEventListener(\"error\",e._errorFn,!1),e._loadFn=e._loadListener.bind(e),e._node.addEventListener(n._canPlayEvent,e._loadFn,!1),e._node.src=t._src,e._node.preload=\"auto\",e._node.volume=o*n.volume(),e._node.load()),e},reset:function(){var e=this,n=e._parent;return e._muted=n._muted,e._loop=n._loop,e._volume=n._volume,e._muted=n._muted,e._rate=n._rate,e._seek=0,e._rateSeek=0,e._paused=!0,e._ended=!0,e._sprite=\"__default\",e._id=Math.round(Date.now()*Math.random()),e},_errorListener:function(){var e=this;e._parent._emit(\"loaderror\",e._id,e._node.error?e._node.error.code:0),e._node.removeEventListener(\"error\",e._errorListener,!1)},_loadListener:function(){var e=this,t=e._parent;t._duration=Math.ceil(10*e._node.duration)/10,0===Object.keys(t._sprite).length&&(t._sprite={__default:[0,1e3*t._duration]}),\"loaded\"!==t._state&&(t._state=\"loaded\",t._emit(\"load\"),t._loadQueue()),e._node.removeEventListener(n._canPlayEvent,e._loadFn,!1)}};var r={},u=function(e){var n=e._src;if(r[n])return e._duration=r[n].duration,void i(e);if(/^data:[^;]+;base64,/.test(n)){for(var t=atob(n.split(\",\")[1]),o=new Uint8Array(t.length),u=0;u<t.length;++u)o[u]=t.charCodeAt(u);d(o.buffer,e)}else{var _=new XMLHttpRequest;_.open(\"GET\",n,!0),_.responseType=\"arraybuffer\",_.onload=function(){var n=(_.status+\"\")[0];return\"0\"!==n&&\"2\"!==n&&\"3\"!==n?void e._emit(\"loaderror\",null,\"Failed loading audio file with status: \"+_.status+\".\"):void d(_.response,e)},_.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete r[n],e.load())},a(_)}},a=function(e){try{e.send()}catch(n){e.onerror()}},d=function(e,t){n.ctx.decodeAudioData(e,function(e){e&&t._sounds.length>0&&(r[t._src]=e,i(t,e))},function(){t._emit(\"loaderror\",null,\"Decoding audio data failed.\")})},i=function(e,n){n&&!e._duration&&(e._duration=n.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),\"loaded\"!==e._state&&(e._state=\"loaded\",e._emit(\"load\"),e._loadQueue())},_=function(){try{\"undefined\"!=typeof AudioContext?n.ctx=new AudioContext:\"undefined\"!=typeof webkitAudioContext?n.ctx=new webkitAudioContext:n.usingWebAudio=!1}catch(e){n.usingWebAudio=!1}var e=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),t=n._navigator&&n._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/),o=t?parseInt(t[1],10):null;if(e&&o&&o<9){var r=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());(n._navigator&&n._navigator.standalone&&!r||n._navigator&&!n._navigator.standalone&&!r)&&(n.usingWebAudio=!1)}n.usingWebAudio&&(n.masterGain=\"undefined\"==typeof n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.value=1,n.masterGain.connect(n.ctx.destination)),n._setup()};\"function\"==typeof define&&define.amd&&define([],function(){return{Howler:n,Howl:t}}),\"undefined\"!=typeof exports&&(exports.Howler=n,exports.Howl=t),\"undefined\"!=typeof window?(window.HowlerGlobal=e,window.Howler=n,window.Howl=t,window.Sound=o):\"undefined\"!=typeof global&&(global.HowlerGlobal=e,global.Howler=n,global.Howl=t,global.Sound=o)}();\n/*! Spatial Plugin */\n!function(){\"use strict\";HowlerGlobal.prototype._pos=[0,0,0],HowlerGlobal.prototype._orientation=[0,0,-1,0,1,0],HowlerGlobal.prototype.stereo=function(e){var n=this;if(!n.ctx||!n.ctx.listener)return n;for(var t=n._howls.length-1;t>=0;t--)n._howls[t].stereo(e);return n},HowlerGlobal.prototype.pos=function(e,n,t){var o=this;return o.ctx&&o.ctx.listener?(n=\"number\"!=typeof n?o._pos[1]:n,t=\"number\"!=typeof t?o._pos[2]:t,\"number\"!=typeof e?o._pos:(o._pos=[e,n,t],o.ctx.listener.setPosition(o._pos[0],o._pos[1],o._pos[2]),o)):o},HowlerGlobal.prototype.orientation=function(e,n,t,o,r,i){var a=this;if(!a.ctx||!a.ctx.listener)return a;var p=a._orientation;return n=\"number\"!=typeof n?p[1]:n,t=\"number\"!=typeof t?p[2]:t,o=\"number\"!=typeof o?p[3]:o,r=\"number\"!=typeof r?p[4]:r,i=\"number\"!=typeof i?p[5]:i,\"number\"!=typeof e?p:(a._orientation=[e,n,t,o,r,i],a.ctx.listener.setOrientation(e,n,t,o,r,i),a)},Howl.prototype.init=function(e){return function(n){var t=this;return t._orientation=n.orientation||[1,0,0],t._stereo=n.stereo||null,t._pos=n.pos||null,t._pannerAttr={coneInnerAngle:\"undefined\"!=typeof n.coneInnerAngle?n.coneInnerAngle:360,coneOuterAngle:\"undefined\"!=typeof n.coneOuterAngle?n.coneOuterAngle:360,coneOuterGain:\"undefined\"!=typeof n.coneOuterGain?n.coneOuterGain:0,distanceModel:\"undefined\"!=typeof n.distanceModel?n.distanceModel:\"inverse\",maxDistance:\"undefined\"!=typeof n.maxDistance?n.maxDistance:1e4,panningModel:\"undefined\"!=typeof n.panningModel?n.panningModel:\"HRTF\",refDistance:\"undefined\"!=typeof n.refDistance?n.refDistance:1,rolloffFactor:\"undefined\"!=typeof n.rolloffFactor?n.rolloffFactor:1},t._onstereo=n.onstereo?[{fn:n.onstereo}]:[],t._onpos=n.onpos?[{fn:n.onpos}]:[],t._onorientation=n.onorientation?[{fn:n.onorientation}]:[],e.call(this,n)}}(Howl.prototype.init),Howl.prototype.stereo=function(n,t){var o=this;if(!o._webAudio)return o;if(\"loaded\"!==o._state)return o._queue.push({event:\"stereo\",action:function(){o.stereo(n,t)}}),o;var r=\"undefined\"==typeof Howler.ctx.createStereoPanner?\"spatial\":\"stereo\";if(\"undefined\"==typeof t){if(\"number\"!=typeof n)return o._stereo;o._stereo=n,o._pos=[n,0,0]}for(var i=o._getSoundIds(t),a=0;a<i.length;a++){var p=o._soundById(i[a]);if(p){if(\"number\"!=typeof n)return p._stereo;p._stereo=n,p._pos=[n,0,0],p._node&&(p._pannerAttr.panningModel=\"equalpower\",p._panner&&p._panner.pan||e(p,r),\"spatial\"===r?p._panner.setPosition(n,0,0):p._panner.pan.value=n),o._emit(\"stereo\",p._id)}}return o},Howl.prototype.pos=function(n,t,o,r){var i=this;if(!i._webAudio)return i;if(\"loaded\"!==i._state)return i._queue.push({event:\"pos\",action:function(){i.pos(n,t,o,r)}}),i;if(t=\"number\"!=typeof t?0:t,o=\"number\"!=typeof o?-.5:o,\"undefined\"==typeof r){if(\"number\"!=typeof n)return i._pos;i._pos=[n,t,o]}for(var a=i._getSoundIds(r),p=0;p<a.length;p++){var f=i._soundById(a[p]);if(f){if(\"number\"!=typeof n)return f._pos;f._pos=[n,t,o],f._node&&(f._panner&&!f._panner.pan||e(f,\"spatial\"),f._panner.setPosition(n,t,o)),i._emit(\"pos\",f._id)}}return i},Howl.prototype.orientation=function(n,t,o,r){var i=this;if(!i._webAudio)return i;if(\"loaded\"!==i._state)return i._queue.push({event:\"orientation\",action:function(){i.orientation(n,t,o,r)}}),i;if(t=\"number\"!=typeof t?i._orientation[1]:t,o=\"number\"!=typeof o?i._orientation[2]:o,\"undefined\"==typeof r){if(\"number\"!=typeof n)return i._orientation;i._orientation=[n,t,o]}for(var a=i._getSoundIds(r),p=0;p<a.length;p++){var f=i._soundById(a[p]);if(f){if(\"number\"!=typeof n)return f._orientation;f._orientation=[n,t,o],f._node&&(f._panner||(f._pos||(f._pos=i._pos||[0,0,-.5]),e(f,\"spatial\")),f._panner.setOrientation(n,t,o)),i._emit(\"orientation\",f._id)}}return i},Howl.prototype.pannerAttr=function(){var n,t,o,r=this,i=arguments;if(!r._webAudio)return r;if(0===i.length)return r._pannerAttr;if(1===i.length){if(\"object\"!=typeof i[0])return o=r._soundById(parseInt(i[0],10)),o?o._pannerAttr:r._pannerAttr;n=i[0],\"undefined\"==typeof t&&(r._pannerAttr={coneInnerAngle:\"undefined\"!=typeof n.coneInnerAngle?n.coneInnerAngle:r._coneInnerAngle,coneOuterAngle:\"undefined\"!=typeof n.coneOuterAngle?n.coneOuterAngle:r._coneOuterAngle,coneOuterGain:\"undefined\"!=typeof n.coneOuterGain?n.coneOuterGain:r._coneOuterGain,distanceModel:\"undefined\"!=typeof n.distanceModel?n.distanceModel:r._distanceModel,maxDistance:\"undefined\"!=typeof n.maxDistance?n.maxDistance:r._maxDistance,panningModel:\"undefined\"!=typeof n.panningModel?n.panningModel:r._panningModel,refDistance:\"undefined\"!=typeof n.refDistance?n.refDistance:r._refDistance,rolloffFactor:\"undefined\"!=typeof n.rolloffFactor?n.rolloffFactor:r._rolloffFactor})}else 2===i.length&&(n=i[0],t=parseInt(i[1],10));for(var a=r._getSoundIds(t),p=0;p<a.length;p++)if(o=r._soundById(a[p])){var f=o._pannerAttr;f={coneInnerAngle:\"undefined\"!=typeof n.coneInnerAngle?n.coneInnerAngle:f.coneInnerAngle,coneOuterAngle:\"undefined\"!=typeof n.coneOuterAngle?n.coneOuterAngle:f.coneOuterAngle,coneOuterGain:\"undefined\"!=typeof n.coneOuterGain?n.coneOuterGain:f.coneOuterGain,distanceModel:\"undefined\"!=typeof n.distanceModel?n.distanceModel:f.distanceModel,maxDistance:\"undefined\"!=typeof n.maxDistance?n.maxDistance:f.maxDistance,panningModel:\"undefined\"!=typeof n.panningModel?n.panningModel:f.panningModel,refDistance:\"undefined\"!=typeof n.refDistance?n.refDistance:f.refDistance,rolloffFactor:\"undefined\"!=typeof n.rolloffFactor?n.rolloffFactor:f.rolloffFactor};var s=o._panner;s?(s.coneInnerAngle=f.coneInnerAngle,s.coneOuterAngle=f.coneOuterAngle,s.coneOuterGain=f.coneOuterGain,s.distanceModel=f.distanceModel,s.maxDistance=f.maxDistance,s.panningModel=f.panningModel,s.refDistance=f.refDistance,s.rolloffFactor=f.rolloffFactor):(o._pos||(o._pos=r._pos||[0,0,-.5]),e(o,\"spatial\"))}return r},Sound.prototype.init=function(e){return function(){var n=this,t=n._parent;n._orientation=t._orientation,n._stereo=t._stereo,n._pos=t._pos,n._pannerAttr=t._pannerAttr,e.call(this),n._stereo?t.stereo(n._stereo):n._pos&&t.pos(n._pos[0],n._pos[1],n._pos[2],n._id)}}(Sound.prototype.init),Sound.prototype.reset=function(e){return function(){var n=this,t=n._parent;return n._orientation=t._orientation,n._pos=t._pos,n._pannerAttr=t._pannerAttr,e.call(this)}}(Sound.prototype.reset);var e=function(e,n){n=n||\"spatial\",\"spatial\"===n?(e._panner=Howler.ctx.createPanner(),e._panner.coneInnerAngle=e._pannerAttr.coneInnerAngle,e._panner.coneOuterAngle=e._pannerAttr.coneOuterAngle,e._panner.coneOuterGain=e._pannerAttr.coneOuterGain,e._panner.distanceModel=e._pannerAttr.distanceModel,e._panner.maxDistance=e._pannerAttr.maxDistance,e._panner.panningModel=e._pannerAttr.panningModel,e._panner.refDistance=e._pannerAttr.refDistance,e._panner.rolloffFactor=e._pannerAttr.rolloffFactor,e._panner.setPosition(e._pos[0],e._pos[1],e._pos[2]),e._panner.setOrientation(e._orientation[0],e._orientation[1],e._orientation[2])):(e._panner=Howler.ctx.createStereoPanner(),e._panner.pan.value=e._stereo),e._panner.connect(e._node),e._paused||e._parent.pause(e._id,!0).play(e._id)}}();\n\n\n// WEBPACK FOOTER //\n// ./frontend/howler.min.js","module.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = 8\n// module chunks = 0","import anime from 'animejs';\nimport { soundSet1 } from './sounds/sound_set_1';\nimport Howler from './howler.min.js';\n\nconst Start = (ctx, canvas) => {\n\n  let numOfCircles = 25;\n  let distance = 300;\n  let actions = [];\n  let sound;\n\n  let fontSize = () => {\n    return parseFloat(getComputedStyle(document.documentElement).fontSize);\n  };\n\n  const resizeCanvas = () => {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n  };\n\n  const removeAction = (action) => {\n    let idx = actions.indexOf(action);\n    if (idx > -1) actions.splice(idx, 1);\n  };\n\n  const drawRipple = (x, y) => {\n    //Choose a random colorset\n    let colorSet = [\"#f8ffe5\", \"#06D6A0\", \"#1B9AAA\", \"#EF476F\", \"#FFC43D\"];\n    let ripple = {};\n\n    ripple.x = x;\n    ripple.y = y;\n    ripple.color = colorSet[anime.random(0, colorSet.length - 1)];\n    ripple.radius = 0;\n    ripple.alpha = 1;\n    ripple.lineWidth = 5;\n\n    ripple.draw = function() {\n      ctx.globalAlpha = ripple.alpha;\n      ctx.beginPath();\n      ctx.arc(ripple.x, ripple.y, ripple.radius, 2 * Math.PI, false);\n      ctx.lineWidth = ripple.lineWidth;\n      ctx.strokeStyle = ripple.color;\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    };\n\n    return ripple;\n  };\n\n  const drawCircle = (x, y) => {\n    let colorSet = [\"#f8ffe5\", \"#06D6A0\", \"#1B9AAA\", \"#EF476F\", \"#FFC43D\"];\n    let circle = {};\n    circle.x = x;\n    circle.y = y;\n    circle.color = colorSet[anime.random(0, colorSet.length - 1)];\n    circle.radius = anime.random(fontSize(), fontSize() * 2);\n\n    circle.draw = function() {\n      ctx.beginPath();\n      ctx.arc(circle.x, circle.y, circle.radius, 2 * Math.PI, false);\n      ctx.fillStyle = circle.color;\n      ctx.fill();\n    };\n\n    return circle;\n  };\n\n  const drawCircles = (x, y) => {\n    let circles = [];\n    for (let i = 0; i < numOfCircles; i++) {\n      let circle = drawCircle(x, y);\n      circles.push(circle);\n    }\n    return circles;\n  };\n\n  const animateRipple = (ripple, size) => {\n    return anime({\n      targets: ripple,\n      radius: () => {\n        return anime.random(fontSize() * size, fontSize() * (size + 2));\n      },\n      lineWidth: 0,\n      alpha: {\n        value: 0,\n        easing: 'linear',\n        duration: () => {\n          return anime.random(300, 500);\n        }\n      },\n      duration: () => {\n        return anime.random(1000, 1300);\n      },\n      easing: 'easeOutExpo',\n      complete: removeAction\n    });\n  };\n\n  const animateCircles = (x, y) => {\n    resizeCanvas();\n\n    //Draw shapes\n    let circles = drawCircles(x, y);\n    let ripple1 = drawRipple(x, y);\n    let ripple2 = drawRipple(x, y);\n    let ripple3 = drawRipple(x, y);\n\n    //Animate shapes\n    let circleAnimation = anime({\n      targets: circles,\n      x: (circle) => {\n        return circle.x + anime.random(-distance, distance);\n      },\n      y: (circle) => {\n        return circle.y + anime.random(-distance, distance);\n      },\n      radius: 0,\n      duration: () => {\n        return anime.random(1000, 1300);\n      },\n      easing: 'easeOutExpo',\n      complete: removeAction\n    });\n\n    //Animate ripples\n    let ripple1Animation = animateRipple(ripple1, 5);\n    let ripple2Animation = animateRipple(ripple2, 7);\n    let ripple3Animation = animateRipple(ripple3, 9);\n\n    actions.push(circleAnimation);\n    actions.push(ripple1Animation);\n    actions.push(ripple2Animation);\n    actions.push(ripple3Animation);\n  };\n\n  const removeContainer = () => {\n    $('#title').removeClass('bounceIn');\n    $('#description').removeClass('bounceIn');\n  };\n\n  const pulseContainer = () => {\n    $('#title').addClass('bounceIn');\n    $('#description').addClass('bounceIn');\n    setTimeout(\n      removeContainer\n      , 300);\n  };\n\n  const removeLogo = () => {\n    $('#logo').removeClass('bounceIn');\n  };\n\n  const pulseLogo = () => {\n    $('#logo').addClass('bounceIn');\n\n    let el = $('#logo');\n    let offset = el.offset();\n\n    animateCircles(offset.left, offset.top);\n    const animate = anime({\n      duration: 1000,\n      update: () => {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        actions.forEach((action) => {\n          action.animatables.forEach((animatable) => {\n            animatable.target.draw();\n          });\n        });\n      }\n    });\n\n    sound = new Howl({\n      src: soundSet1[65]\n    });\n    sound.play();\n\n    setTimeout(\n      removeLogo\n      , 300);\n  };\n\n  const showModal = () => {\n    const modal = document.getElementById('myModal');\n    modal.style.display = 'block';\n    $('#myModal').addClass('fadeIn');\n  };\n\n  setTimeout(pulseContainer, 500);\n  setTimeout(pulseLogo, 800);\n  setTimeout(showModal, 1000);\n\n};\n\nexport default Start;\n\n\n\n// WEBPACK FOOTER //\n// ./frontend/start.js","'use strict'\n\nvar logger = require('./lib/logger.js')\nvar semver = require('semver')\n\nvar message\nvar agent\n\nvar agentVersion = require('./package.json').version\nlogger.info(\n  \"Using New Relic for Node.js. Agent version: %s; Node version: %s.\",\n  agentVersion, process.version\n)\n\nif (require.cache.__NR_cache) {\n  logger.warn(\n    'Attempting to load a second copy of newrelic from %s, using cache instead',\n    __dirname\n  )\n  module.exports = require.cache.__NR_cache\n} else {\n  initialize()\n}\n\nfunction initialize() {\n  logger.debug(\n    'Loading agent from %s',\n    __dirname\n  )\n\n  try {\n    logger.debug(\"Process was running %s seconds before agent was loaded.\",\n                 process.uptime())\n    // Technically we run on 0.6, until we verify there are 0 users on 0.6, we\n    // should leave this code doing a check against 0.6, but then advise that\n    // people upgrade to one of our officially supported version (0.8 and higher)\n    if (semver.satisfies(process.version, '<0.6.0')) {\n      message = \"New Relic for Node.js requires a version of Node equal to or\\n\" +\n                \"greater than 0.8.0. Not starting!\"\n\n      logger.error(message)\n      throw new Error(message)\n    }\n\n    logger.debug(\"Current working directory at module load is %s.\", process.cwd())\n    logger.debug(\"Process title is %s.\", process.title)\n    logger.debug(\"Application was invoked as %s.\", process.argv.join(' '))\n\n    /* Loading the configuration can throw if a configuration file isn't found and\n     * the environment variable NEW_RELIC_NO_CONFIG_FILE isn't set.\n     */\n    var config = require('./lib/config.js').initialize()\n    if (!config.agent_enabled) {\n      logger.info(\"Module not enabled in configuration; not starting.\")\n    } else {\n      /* Only load the rest of the module if configuration is available and the\n       * configurator didn't throw.\n       *\n       * The agent must be a singleton, or else module loading will be patched\n       * multiple times, with undefined results. New Relic's instrumentation\n       * can't be enabled or disabled without an application restart.\n       */\n      var Agent = require('./lib/agent.js')\n      agent = new Agent(config)\n      var appNames = agent.config.applications()\n\n      if (config.logging.diagnostics) {\n        logger.warn(\n          'Diagnostics logging is enabled, this may cause significant overhead.'\n        )\n      }\n\n      if (appNames.length < 1) {\n        message = \"New Relic requires that you name this application!\\n\" +\n                  \"Set app_name in your newrelic.js file or set environment variable\\n\" +\n                  \"NEW_RELIC_APP_NAME. Not starting!\"\n        logger.error(message)\n        throw new Error(message)\n      }\n\n      var shimmer = require('./lib/shimmer.js')\n      shimmer.patchModule(agent)\n      shimmer.bootstrapInstrumentation(agent)\n\n      agent.start(function cb_start(error) {\n        if (!error) {\n          return logger.debug(\"New Relic for Node.js is connected to New Relic.\")\n        }\n\n        var errorMessage = \"New Relic for Node.js halted startup due to an error:\"\n        logger.error(error, errorMessage)\n\n        console.error(errorMessage)\n        console.error(error.stack)\n      })\n    }\n  } catch (error) {\n    message = \"New Relic for Node.js was unable to bootstrap itself due to an error:\"\n    logger.error(error, message)\n\n    console.error(message)\n    console.error(error.stack)\n  }\n\n  var API\n  if (agent) {\n    API = require('./api.js')\n  } else {\n    API = require('./stub_api.js')\n  }\n\n  require.cache.__NR_cache = module.exports = new API(agent)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/index.js\n// module id = 10\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 11\n// module chunks = 0","'use strict'\n\nvar Logger = require('./util/logger')\nvar fs = require('fs')\n\n// create bootstrapping logger\nmodule.exports = new Logger({\n  name: 'newrelic_bootstrap',\n  stream: process.stdout,\n  level: 'info'\n})\n\n/**\n * Don't load config.js until this point, because it requires this\n * module, and if it gets loaded too early, module.exports will have no\n * value.\n */\nvar config = require('./config.js').initialize()\n\nvar options = {\n  name: 'newrelic',\n  level: config.logging.level,\n  enabled: config.logging.enabled\n}\n\n// create the \"real\" logger\nmodule.exports = new Logger(options)\n\nif (config.logging.enabled) {\n  var stream\n  switch (config.logging.filepath) {\n    case 'stdout':\n      stream = process.stdout\n      break\n\n    case 'stderr':\n      stream = process.stderr\n      break\n\n    default:\n      stream = fs.createWriteStream(config.logging.filepath, {flags: 'a+'})\n      stream.on('error', function logStreamOnError(err) {\n        /* eslint-disable no-console */\n        // Since our normal logging didn't work, dump this to stderr.\n        console.error('New Relic failed to open log file ' + config.logging.filepath)\n        console.error(err)\n        /* eslint-enable no-console */\n      })\n  }\n  module.exports.pipe(stream)\n}\n\n// now tell the config module to switch to the real logger\nconfig.setLogger(module.exports)\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/logger.js\n// module id = 12\n// module chunks = 0","'use strict'\n\nvar stringifySync = require('./safe-json').stringifySync\nvar util = require('util')\nvar Readable = require('readable-stream')\nvar os = require('os')\n\nmodule.exports = Logger\n\nvar LEVELS = {\n  'trace': 10,\n  'debug': 20,\n  'info': 30,\n  'warn': 40,\n  'error': 50,\n  'fatal': 60\n}\n\nutil.inherits(Logger, Readable)\n\nfunction Logger(options, extra) {\n  if (!(this instanceof Logger)) {\n    return new Logger(options, extra)\n  }\n\n  Readable.call(this)\n  var passedInLevel = this.coerce(options.level)\n  this.options = {\n    _level: passedInLevel,\n    enabled: options.enabled === undefined ? true : options.enabled\n  }\n  this.name = options.name\n  this.hostname = options.hostname || os.hostname()\n  this.extra = extra || {}\n  this.buffer = ''\n  this.reading = false\n  if (options.stream) {\n    this.pipe(options.stream)\n  }\n}\n\nvar loggingFunctions = {}\n\nObject.keys(LEVELS).forEach(function buildLevel(_level) {\n  function log(extra) {\n    var level = Logger.prototype.coerce(LEVELS[_level])\n    if (!this.options.enabled) return false\n    if (level < this.options._level) return false\n\n    var has_extra = typeof extra === 'object'\n    var args = Array.prototype.slice.call(arguments, has_extra ? 1 : 0)\n    return this.write(level, args, has_extra ? extra : null)\n  }\n\n  loggingFunctions[_level] = function checkLevel() {\n    log.apply(this, arguments)\n  }\n\n  var seenMessages = {}\n  loggingFunctions[_level + 'Once'] = function logOnce(key) {\n    if (typeof key !== 'string') {\n      this.debug('Attempted to key on a non-string in ' + _level + 'Once: ' + key)\n      return\n    }\n\n    var level = Logger.prototype.coerce(LEVELS[_level])\n    if (!this.options.enabled) return false\n    if (level < this.options._level) return false\n\n    if (seenMessages[key] !== true) {\n      var args = Array.prototype.slice.call(arguments, 1)\n      var writeSuccessful = log.apply(this, args)\n\n      if (writeSuccessful) {\n        seenMessages[key] = true\n      }\n    }\n  }\n\n  var seenPerInterval = {}\n  loggingFunctions[_level + 'OncePer'] = function logOncePer(key, interval) {\n    if (typeof key !== 'string') {\n      this.debug('Attempted to key on a non-string in ' + _level + 'Once: ' + key)\n      return\n    }\n\n    var level = Logger.prototype.coerce(LEVELS[_level])\n    if (!this.options.enabled) return false\n    if (level < this.options._level) return false\n\n    if (seenPerInterval[key] !== true) {\n      var args = Array.prototype.slice.call(arguments, 2)\n      var writeSuccessful = log.apply(this, args)\n\n      if (writeSuccessful) {\n        seenPerInterval[key] = true\n\n        var clearSeen = setTimeout(function clearKey() {\n          delete seenPerInterval[key]\n        }, interval)\n\n        if (clearSeen.unref !== undefined) {\n          clearSeen.unref()\n        }\n      }\n    }\n  }\n})\n\nutil._extend(Logger.prototype, loggingFunctions)\n\nLogger.prototype.coerce = function coerce(value) {\n  if (!isNaN(parseInt(value, 10)) && isFinite(value)) {\n    // value is numeric\n    if (value < 10) value = 10\n    if (value > 60) value = 60\n\n    return value\n  }\n  return LEVELS[value] || 50\n}\n\nLogger.prototype.child = function child(extra) {\n  var childLogger = Object.create(loggingFunctions)\n\n  childLogger.extra = util._extend({}, this.extra)\n  util._extend(childLogger.extra, extra)\n\n  var parent = this\n  childLogger.options = parent.options\n\n  childLogger.write = function write(level, args, extra) {\n    extra = getPropertiesToLog(extra)\n    var selfExtra = util._extend({}, this.extra)\n\n    extra = util._extend(selfExtra, extra)\n    return parent.write(level, args, extra)\n  }\n\n  childLogger.setEnabled = Logger.prototype.setEnabled\n  childLogger.child = Logger.prototype.child\n\n  return childLogger\n}\n\nLogger.prototype.level = function level(lvl) {\n  this.options._level = this.coerce(lvl)\n}\n\nLogger.prototype.setEnabled = function setEnabled(enabled) {\n  if (typeof enabled === 'boolean') {\n    this.options.enabled = enabled\n  }\n}\n\nLogger.prototype._read = function _read() {\n  if (this.buffer.length !== 0) {\n    this.reading = this.push(this.buffer)\n    this.buffer = ''\n  } else {\n    this.reading = true\n  }\n}\n\n/**\n * For performance reasons we do not support %j because we will have\n * already converted the objects to strings.\n * Returns a boolean representing the status of the write\n * (success/failure)\n */\nLogger.prototype.write = function write(level, args, extra) {\n  for (var i = 0, l = args.length; i < l; ++i) {\n    if (typeof args[i] === 'function') {\n      args[i] = args[i].valueOf()\n    } else if (typeof args[i] === 'object') {\n      args[i] = stringifySync(args[i])\n    }\n  }\n\n  var entry = new Entry(this, level, util.format.apply(util, args))\n\n  util._extend(entry, this.extra)\n  util._extend(entry, getPropertiesToLog(extra))\n\n  if (this.reading) {\n    this.reading = this.push(stringifySync(entry) + '\\n')\n  } else {\n    this.buffer += stringifySync(entry) + '\\n'\n  }\n  return true\n}\n\nfunction Entry(logger, level, msg) {\n  this.v = 0\n  this.level = level\n  this.name = logger.name\n  this.hostname = logger.hostname\n  this.pid = process.pid\n  this.time = new Date().toISOString()\n  this.msg = msg\n}\n\nfunction getPropertiesToLog(extra) {\n  var obj = util._extend({}, extra)\n  // Error properties (message, stack) are not enumerable, so getting them directly\n  if (extra instanceof Error) {\n    var names = Object.getOwnPropertyNames(extra)\n    if (names) {\n      for (var i = 0; i < names.length; i++) {\n        obj[names[i]] = extra[names[i]]\n      }\n    }\n  }\n  return obj\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/logger.js\n// module id = 13\n// module chunks = 0","'use strict'\n\nvar stringifySafe = require('json-stringify-safe')\n\nmodule.exports = {\n  parse: function parseAsync(str, cb) {\n    try {\n      cb(null, JSON.parse(str))\n    } catch (err) {\n      cb(err, null)\n    }\n  },\n\n  stringify: function stringifyAsync(obj, cb) {\n    try {\n      cb(null, stringifySafe(obj))\n    } catch (err) {\n      cb(err, '[UNPARSABLE OBJECT]')\n    }\n  },\n\n  stringifySync: function stringifySync(obj, returnVal) {\n    try {\n      return stringifySafe(obj)\n    } catch (err) {\n      return returnVal || '[UNPARSABLE OBJECT]'\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/safe-json.js\n// module id = 14\n// module chunks = 0","exports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/json-stringify-safe/stringify.js\n// module id = 15\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/util.js\n// module id = 16\n// module chunks = 0","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/support/isBufferBrowser.js\n// module id = 17\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util/~/inherits/inherits_browser.js\n// module id = 18\n// module chunks = 0","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nif (!process.browser && process.env.READABLE_STREAM === 'disable') {\n  module.exports = require('stream');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/readable.js\n// module id = 19\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/lib/_stream_readable.js\n// module id = 20\n// module chunks = 0","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/~/isarray/index.js\n// module id = 21\n// module chunks = 0","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 22\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 23\n// module chunks = 0","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 24\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 25\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 26\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/index.js\n// module id = 27\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inherits/inherits_browser.js\n// module id = 28\n// module chunks = 0","var Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\nif (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/readable.js\n// module id = 29\n// module chunks = 0","'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n/*<replacement>*/\nvar bufferShim = require('buffer-shims');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = bufferShim.from(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var _e = new Error('stream.unshift() after end event');\n      stream.emit('error', _e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function (ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = bufferShim.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/lib/_stream_readable.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process-nextick-args/index.js\n// module id = 31\n// module chunks = 0","'use strict';\n\nvar buffer = require('buffer');\nvar Buffer = buffer.Buffer;\nvar SlowBuffer = buffer.SlowBuffer;\nvar MAX_LEN = buffer.kMaxLength || 2147483647;\nexports.alloc = function alloc(size, fill, encoding) {\n  if (typeof Buffer.alloc === 'function') {\n    return Buffer.alloc(size, fill, encoding);\n  }\n  if (typeof encoding === 'number') {\n    throw new TypeError('encoding must not be number');\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size > MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  var enc = encoding;\n  var _fill = fill;\n  if (_fill === undefined) {\n    enc = undefined;\n    _fill = 0;\n  }\n  var buf = new Buffer(size);\n  if (typeof _fill === 'string') {\n    var fillBuf = new Buffer(_fill, enc);\n    var flen = fillBuf.length;\n    var i = -1;\n    while (++i < size) {\n      buf[i] = fillBuf[i % flen];\n    }\n  } else {\n    buf.fill(_fill);\n  }\n  return buf;\n}\nexports.allocUnsafe = function allocUnsafe(size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    return Buffer.allocUnsafe(size);\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size > MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  return new Buffer(size);\n}\nexports.from = function from(value, encodingOrOffset, length) {\n  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {\n    return Buffer.from(value, encodingOrOffset, length);\n  }\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n  if (typeof value === 'string') {\n    return new Buffer(value, encodingOrOffset);\n  }\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    var offset = encodingOrOffset;\n    if (arguments.length === 1) {\n      return new Buffer(value);\n    }\n    if (typeof offset === 'undefined') {\n      offset = 0;\n    }\n    var len = length;\n    if (typeof len === 'undefined') {\n      len = value.byteLength - offset;\n    }\n    if (offset >= value.byteLength) {\n      throw new RangeError('\\'offset\\' is out of bounds');\n    }\n    if (len > value.byteLength - offset) {\n      throw new RangeError('\\'length\\' is out of bounds');\n    }\n    return new Buffer(value.slice(offset, offset + len));\n  }\n  if (Buffer.isBuffer(value)) {\n    var out = new Buffer(value.length);\n    value.copy(out, 0, 0, value.length);\n    return out;\n  }\n  if (value) {\n    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {\n      return new Buffer(value);\n    }\n    if (value.type === 'Buffer' && Array.isArray(value.data)) {\n      return new Buffer(value.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');\n}\nexports.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  if (typeof Buffer.allocUnsafeSlow === 'function') {\n    return Buffer.allocUnsafeSlow(size);\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size >= MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  return new SlowBuffer(size);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer-shims/index.js\n// module id = 32\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-util-is/lib/util.js\n// module id = 33\n// module chunks = 0","/* (ignored) */\n\n\n//////////////////\n// WEBPACK FOOTER\n// util (ignored)\n// module id = 34\n// module chunks = 0","'use strict';\n\nvar Buffer = require('buffer').Buffer;\n/*<replacement>*/\nvar bufferShim = require('buffer-shims');\n/*</replacement>*/\n\nmodule.exports = BufferList;\n\nfunction BufferList() {\n  this.head = null;\n  this.tail = null;\n  this.length = 0;\n}\n\nBufferList.prototype.push = function (v) {\n  var entry = { data: v, next: null };\n  if (this.length > 0) this.tail.next = entry;else this.head = entry;\n  this.tail = entry;\n  ++this.length;\n};\n\nBufferList.prototype.unshift = function (v) {\n  var entry = { data: v, next: this.head };\n  if (this.length === 0) this.tail = entry;\n  this.head = entry;\n  ++this.length;\n};\n\nBufferList.prototype.shift = function () {\n  if (this.length === 0) return;\n  var ret = this.head.data;\n  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n  --this.length;\n  return ret;\n};\n\nBufferList.prototype.clear = function () {\n  this.head = this.tail = null;\n  this.length = 0;\n};\n\nBufferList.prototype.join = function (s) {\n  if (this.length === 0) return '';\n  var p = this.head;\n  var ret = '' + p.data;\n  while (p = p.next) {\n    ret += s + p.data;\n  }return ret;\n};\n\nBufferList.prototype.concat = function (n) {\n  if (this.length === 0) return bufferShim.alloc(0);\n  if (this.length === 1) return this.head.data;\n  var ret = bufferShim.allocUnsafe(n >>> 0);\n  var p = this.head;\n  var i = 0;\n  while (p) {\n    p.data.copy(ret, i);\n    i += p.data.length;\n    p = p.next;\n  }\n  return ret;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/lib/internal/streams/BufferList.js\n// module id = 35\n// module chunks = 0","// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/lib/_stream_duplex.js\n// module id = 36\n// module chunks = 0","// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n/*<replacement>*/\nvar bufferShim = require('buffer-shims');\n/*</replacement>*/\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n  // Always throw error if a null is written\n  // if we are not in object mode then throw\n  // if it is not a buffer, string, or undefined.\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = bufferShim.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/lib/_stream_writable.js\n// module id = 37\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 38\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 39\n// module chunks = 0","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/util-deprecate/browser.js\n// module id = 40\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/string_decoder/index.js\n// module id = 41\n// module chunks = 0","// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/lib/_stream_transform.js\n// module id = 42\n// module chunks = 0","// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/lib/_stream_passthrough.js\n// module id = 43\n// module chunks = 0","module.exports = require(\"./lib/_stream_writable.js\")\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/writable.js\n// module id = 44\n// module chunks = 0","module.exports = require(\"./lib/_stream_duplex.js\")\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/duplex.js\n// module id = 45\n// module chunks = 0","module.exports = require(\"./lib/_stream_transform.js\")\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/transform.js\n// module id = 46\n// module chunks = 0","module.exports = require(\"./lib/_stream_passthrough.js\")\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/readable-stream/passthrough.js\n// module id = 47\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/~/core-util-is/lib/util.js\n// module id = 48\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/~/inherits/inherits_browser.js\n// module id = 49\n// module chunks = 0","/* (ignored) */\n\n\n//////////////////\n// WEBPACK FOOTER\n// util (ignored)\n// module id = 50\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/lib/_stream_duplex.js\n// module id = 51\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/lib/_stream_writable.js\n// module id = 52\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/~/string_decoder/index.js\n// module id = 53\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/lib/_stream_transform.js\n// module id = 54\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/readable-stream/lib/_stream_passthrough.js\n// module id = 55\n// module chunks = 0","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/os-browserify/browser.js\n// module id = 56\n// module chunks = 0","'use strict'\n\nvar util = require('util')\nvar path = require('path')\nvar fs = require('fs')\nvar EventEmitter = require('events').EventEmitter\nvar NAMES = require('./metrics/names.js')\nvar feature_flag = require('./feature_flags.js')\nvar flatten = require('./util/flatten')\nvar hashes = require('./util/hashes')\nvar exists = fs.existsSync || path.existsSync\nvar safeJSON = require('./util/safe-json')\nvar stringifySync = safeJSON.stringifySync\nvar parse = safeJSON.parse\nvar os = require('os')\nvar logger\n\n/**\n * CONSTANTS -- we gotta lotta 'em\n */\nvar DEFAULT_CONFIG_PATH = path.join(__dirname, 'config.default.js')\nvar DEFAULT_CONFIG = require(DEFAULT_CONFIG_PATH).config\nvar DEFAULT_FILENAME = 'newrelic.js'\nvar AZURE_APP_NAME = 'APP_POOL_ID'\nvar CONFIG_FILE_LOCATIONS = [\n  process.env.NEW_RELIC_HOME,\n  process.cwd(),\n  process.env.HOME,\n  path.join(__dirname, '../../..') // above node_modules\n]\n\n// the REPL has no main module\nif (process.mainModule && process.mainModule.filename) {\n  CONFIG_FILE_LOCATIONS.splice(2, 0, path.dirname(process.mainModule.filename))\n}\n\n/*\n * ENV_MAPPING, LIST_VARS, and BOOLEAN_VARS could probably be unified and\n * objectified, but this is simple and works.\n */\nvar ENV_MAPPING = {\n  newrelic_home: \"NEW_RELIC_HOME\",\n  app_name: \"NEW_RELIC_APP_NAME\",\n  license_key: \"NEW_RELIC_LICENSE_KEY\",\n  ssl: \"NEW_RELIC_USE_SSL\",\n  host: \"NEW_RELIC_HOST\",\n  port: \"NEW_RELIC_PORT\",\n  proxy: \"NEW_RELIC_PROXY_URL\",\n  proxy_host: \"NEW_RELIC_PROXY_HOST\",\n  proxy_port: \"NEW_RELIC_PROXY_PORT\",\n  proxy_user: \"NEW_RELIC_PROXY_USER\",\n  proxy_pass: \"NEW_RELIC_PROXY_PASS\",\n  ignore_server_configuration: \"NEW_RELIC_IGNORE_SERVER_CONFIGURATION\",\n  agent_enabled: \"NEW_RELIC_ENABLED\",\n  apdex_t: \"NEW_RELIC_APDEX\",\n  capture_params: \"NEW_RELIC_CAPTURE_PARAMS\",\n  ignored_params: \"NEW_RELIC_IGNORED_PARAMS\",\n  logging: {\n    level: \"NEW_RELIC_LOG_LEVEL\",\n    filepath: \"NEW_RELIC_LOG\",\n    enabled: \"NEW_RELIC_LOG_ENABLED\"\n  },\n  audit_log: {\n    enabled: \"NEW_RELIC_AUDIT_LOG_ENABLED\",\n    endpoints: \"NEW_RELIC_AUDIT_LOG_ENDPOINTS\"\n  },\n  error_collector: {\n    enabled: \"NEW_RELIC_ERROR_COLLECTOR_ENABLED\",\n    ignore_status_codes: \"NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES\"\n  },\n  transaction_tracer: {\n    enabled: \"NEW_RELIC_TRACER_ENABLED\",\n    transaction_threshold: \"NEW_RELIC_TRACER_THRESHOLD\",\n    top_n: \"NEW_RELIC_TRACER_TOP_N\",\n    record_sql: \"NEW_RELIC_RECORD_SQL\",\n    explain_threshold: \"NEW_RELIC_EXPLAIN_THRESHOLD\"\n  },\n  utilization: {\n    detect_aws: \"NEW_RELIC_UTILIZATION_DETECT_AWS\",\n    detect_docker: \"NEW_RELIC_UTILIZATION_DETECT_DOCKER\",\n    logical_processors: \"NEW_RELIC_UTILIZATION_LOGICAL_PROCESSORS\",\n    total_ram_mib: \"NEW_RELIC_UTILIZATION_TOTAL_RAM_MIB\",\n    billing_hostname: \"NEW_RELIC_UTILIZATION_BILLING_HOSTNAME\"\n  },\n  debug: {\n    internal_metrics: \"NEW_RELIC_DEBUG_METRICS\",\n    tracer_tracing: \"NEW_RELIC_DEBUG_TRACER\"\n  },\n  rules: {\n    name: \"NEW_RELIC_NAMING_RULES\",\n    ignore: \"NEW_RELIC_IGNORING_RULES\"\n  },\n  enforce_backstop: \"NEW_RELIC_ENFORCE_BACKSTOP\",\n  browser_monitoring: {\n    enable: \"NEW_RELIC_BROWSER_MONITOR_ENABLE\",\n    debug: \"NEW_RELIC_BROWSER_MONITOR_DEBUG\"\n  },\n  high_security: \"NEW_RELIC_HIGH_SECURITY\",\n  labels: \"NEW_RELIC_LABELS\",\n  slow_sql: {\n    enabled: \"NEW_RELIC_SLOW_SQL_ENABLED\",\n    max_samples: \"NEW_RELIC_MAX_SQL_SAMPLES\"\n  },\n  process_host: {\n    display_name: \"NEW_RELIC_PROCESS_HOST_DISPLAY_NAME\",\n    ipv_preference: \"NEW_RELIC_IPV_PREFERENCE\"\n  },\n  datastore_tracer: {\n    instance_reporting: {\n      enabled: \"NEW_RELIC_DATASTORE_INSTANCE_REPORTING_ENABLED\"\n    },\n    database_name_reporting:{\n      enabled: \"NEW_RELIC_DATASTORE_DATABASE_NAME_REPORTING_ENABLED\"\n    }\n  }\n}\n\n// values in list variables are comma-delimited lists\nvar LIST_VARS = [\n  \"NEW_RELIC_APP_NAME\",\n  \"NEW_RELIC_IGNORED_PARAMS\",\n  \"NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES\",\n  \"NEW_RELIC_IGNORING_RULES\",\n  \"NEW_RELIC_AUDIT_LOG_ENDPOINTS\"\n]\n\n// values in object lists are comma-delimited object literals\nvar OBJECT_LIST_VARS = [\n  \"NEW_RELIC_NAMING_RULES\"\n]\n\nvar HAS_ARBITRARY_KEYS = [\n  'labels'\n]\n\n/*\n * Values in boolean variables. Is pretty tolerant about values, but\n * don't get fancy and just use 'true' and 'false', everybody.\n */\nvar BOOLEAN_VARS = [\n  \"NEW_RELIC_IGNORE_SERVER_CONFIGURATION\",\n  \"NEW_RELIC_ENABLED\",\n  \"NEW_RELIC_CAPTURE_PARAMS\",\n  \"NEW_RELIC_ERROR_COLLECTOR_ENABLED\",\n  \"NEW_RELIC_TRACER_ENABLED\",\n  \"NEW_RELIC_DEBUG_METRICS\",\n  \"NEW_RELIC_DEBUG_TRACER\",\n  \"NEW_RELIC_ENFORCE_BACKSTOP\",\n  \"NEW_RELIC_USE_SSL\",\n  \"NEW_RELIC_BROWSER_MONITOR_ENABLE\",\n  \"NEW_RELIC_BROWSER_MONITOR_DEBUG\",\n  \"NEW_RELIC_HIGH_SECURITY\",\n  \"NEW_RELIC_SLOW_SQL_ENABLED\",\n  \"NEW_RELIC_LOG_ENABLED\",\n  \"NEW_RELIC_AUDIT_LOG_ENABLED\",\n  \"NEW_RELIC_DATASTORE_DATABASE_NAME_REPORTING_ENABLED\",\n  \"NEW_RELIC_DATASTORE_INSTANCE_REPORTING_ENABLED\"\n]\n\nvar FLOAT_VARS = [\n  'NEW_RELIC_APDEX'\n]\n\nvar INT_VARS = [\n  'NEW_RELIC_EXPLAIN_THRESHOLD',\n  'NEW_RELIC_MAX_SQL_SAMPLES'\n]\n\n// Config keys that can't be set by the server if high_security === true\nvar HIGH_SECURITY_SETTINGS = {\n  ssl: true,\n  capture_params: false,\n  transaction_tracer: {\n    record_sql: 'off'\n  },\n  slow_sql: {\n    enabled: false\n  }\n}\n\nvar HIGH_SECURITY_KEYS = Object.keys(flatten({}, '', HIGH_SECURITY_SETTINGS))\n\n// blank out these config values before sending to the collector\nvar REDACT_BEFORE_SEND = ['proxy_pass', 'proxy_user', 'proxy']\n\n// process.domain needs to be stripped befeore sending\nvar REMOVE_BEFORE_SEND = ['domain']\n\nfunction isTruthular(setting) {\n  if (setting === undefined || setting === null) return false\n\n  var normalized = setting.toString().toLowerCase()\n  switch (normalized) {\n    case 'false':\n    case 'f':\n    case 'no':\n    case 'n':\n    case 'disabled':\n    case '0':\n      return false\n\n    default:\n      return true\n  }\n}\n\nfunction fromObjectList(setting) {\n  try {\n    return JSON.parse('[' + setting + ']')\n  } catch (error) {\n    logger.error(\"New Relic configurator could not deserialize object list:\")\n    logger.error(error.stack)\n  }\n}\n\nfunction _findConfigFile() {\n  var candidate\n  var filepath\n\n\n  for (var i = 0; i < CONFIG_FILE_LOCATIONS.length; i++) {\n    candidate = CONFIG_FILE_LOCATIONS[i]\n    if (!candidate) continue\n\n    filepath = path.join(path.resolve(candidate), DEFAULT_FILENAME)\n    if (!exists(filepath)) continue\n\n    return fs.realpathSync(filepath)\n  }\n}\n\nfunction _failHard() {\n  var mainpath = path.resolve(path.join(process.cwd(), DEFAULT_FILENAME))\n  var altpath = path.resolve(\n    path.dirname(process.mainModule.filename),\n    DEFAULT_FILENAME\n  )\n\n\n  var locations\n  if (mainpath !== altpath) {\n    locations = mainpath + \" or\\n\" + altpath\n  } else {\n    locations = mainpath\n  }\n\n  throw new Error(\n    \"Unable to find New Relic module configuration. A default\\n\" +\n    \"configuration file can be copied from \" + DEFAULT_CONFIG_PATH + \"\\n\" +\n    \"and put at \" + locations + \".\"\n  )\n}\n\nfunction Config(config) {\n  EventEmitter.call(this)\n\n  // 1. start by cloning the defaults\n  try {\n    var basis = JSON.parse(stringifySync(DEFAULT_CONFIG))\n    Object.keys(basis).forEach(function cb_forEach(key) {\n      this[key] = basis[key]\n    }, this)\n  } catch (err) {\n    logger.warn('Unable to clone the default config, %s: %s', DEFAULT_CONFIG_PATH, err)\n  }\n\n  if (config &&\n      (process.env[ENV_MAPPING.ssl] === 'false' || config.ssl === false) &&\n      process.env[ENV_MAPPING.port] === undefined && config.port === undefined ) {\n    config.port = 80\n  }\n\n  // 2. initialize undocumented, internal-only default values\n\n  // feature flags are mostly private settings for gating unreleased features\n  // flags are set in the feature_flags.js file\n  this.feature_flag = feature_flag.prerelease\n\n  // set by environment\n  this.newrelic_home = null\n  // set by configuration file loader\n  this.config_file_path = null\n  // set by collector on handshake\n  this.run_id = null\n  this.application_id = null\n  this.web_transactions_apdex = {}\n  this.cross_process_id = null\n  this.encoding_key = null\n  this.obfuscatedId = null\n  this.trusted_account_ids = null\n\n  // how frequently harvester runs\n  this.data_report_period = 60\n\n  // based on max call stack depth\n  this.max_trace_segments = 900\n\n  // feature level of this account\n  this.product_level = 0\n  // product-level related\n  this.collect_traces = true\n  this.collect_errors = true\n\n  // override options for utilization stats\n  this.utilization.logical_processors = null\n  this.utilization.total_ram_mib = null\n  this.utilization.billing_hostname = null\n\n  this.browser_monitoring.loader = 'rum'\n  this.browser_monitoring.loader_version = ''\n\n  // Settings to play nice with DLPs (see NODE-1044).\n  this.compressed_content_encoding = \"deflate\"  // Deflate or gzip\n  this.simple_compression = false               // Disables subcomponent compression\n  this.put_for_data_send = false                // Changes http verb for harvest\n\n\n  // 3. override defaults with values from the loaded / passed configuration\n  this._fromPassed(config)\n\n  // 3.5. special values (only Azure environment APP_POOL_ID for now)\n  this._fromSpecial()\n\n  // 4. override config with environment variables\n  this._fromEnvironment()\n\n  // 5. clean up anything that requires postprocessing\n  this._canonicalize()\n\n  // 6. put the version in the config\n  this.version = require('../package.json').version\n\n  // 7. apply high security overrides\n  if (this.high_security === true) {\n    this._applyHighSecurity()\n  }\n}\nutil.inherits(Config, EventEmitter)\n\n/**\n * Because this module and logger depend on each other, the logger needs\n * a way to inject the actual logger instance once it's constructed.\n * It's kind of a Rube Goldberg device, but it works.\n *\n * @param {Logger} bootstrapped The actual, configured logger.\n */\nConfig.prototype.setLogger = function setLogger(bootstrapped) {\n  logger = bootstrapped\n}\n\n/**\n * Accept any configuration passed back from the server. Will log all\n * recognized, unsupported, and unknown parameters. Some may not be set,\n * depending on the setting of ignore_server_configuration.\n *\n * @param {object} json The config blob sent by New Relic.\n */\nConfig.prototype.onConnect = function onConnect(json, recursion) {\n  json = json || {}\n  if (this.high_security === true && recursion !== true && json.high_security !== true) {\n    this.agent_enabled = false\n    this.emit('agent_enabled', false)\n    return\n  }\n  if (Object.keys(json).length === 0) return\n\n  Object.keys(json).forEach(function cb_forEach(key) {\n    this._fromServer(json, key)\n  }, this)\n\n  this.emit('change', this)\n}\n\n/**\n * The guts of the logic about how to deal with server-side configuration.\n *\n * @param {object} params A configuration dictionary.\n * @param {string} key    The particular configuration parameter to set.\n */\nConfig.prototype._fromServer = function _fromServer(params, key) {\n  switch (key) {\n    // handled by the connection\n    case 'messages':\n      break\n\n    // *sigh* Xzibit, etc.\n    case 'agent_config':\n      this.onConnect(params[key], true)\n      break\n\n    // if it's undefined or null, so be it\n    case 'agent_run_id':\n      this.run_id = params.agent_run_id\n      break\n\n    // handled by config.onConnect\n    case 'high_security':\n      break\n\n    // always accept these settings\n    case 'cross_process_id':\n    case 'encoding_key':\n      this._alwaysUpdateIfChanged(params, key)\n      if (this.cross_process_id && this.encoding_key) {\n        this.obfuscatedId = hashes.obfuscateNameUsingKey(this.cross_process_id,\n                                                         this.encoding_key)\n      }\n      break\n\n    // always accept these settings\n    case 'collect_traces':\n    case 'collect_errors':\n    case 'product_level':\n    case 'application_id':\n    case 'trusted_account_ids':\n      this._alwaysUpdateIfChanged(params, key)\n      break\n\n    case 'collect_error_events':\n      if (params.collect_error_events === false) {\n        this._updateNestedIfChanged(\n          params,\n          this.error_collector,\n          key,\n          'capture_events'\n        )\n      }\n      break\n\n    // also accept these settings\n    case 'url_rules':\n    case 'metric_name_rules':\n    case 'transaction_name_rules':\n    case 'transaction_segment_terms':\n      this._emitIfSet(params, key)\n      break\n\n    // setting these can be disabled by ignore_server_configuration\n    case 'ssl':\n    case 'apdex_t':\n    case 'web_transactions_apdex':\n    case 'data_report_period':\n    case 'ignored_params':\n      this._updateIfChanged(params, key)\n      break\n    case 'transaction_tracer.enabled':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_tracer,\n        'transaction_tracer.enabled',\n        'enabled'\n      )\n      break\n    case 'transaction_tracer.transaction_threshold':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_tracer,\n        'transaction_tracer.transaction_threshold',\n        'transaction_threshold'\n      )\n      break\n    case 'error_collector.enabled':\n      this._updateNestedIfChanged(\n        params,\n        this.error_collector,\n        'error_collector.enabled',\n        'enabled'\n      )\n      break\n    case 'error_collector.ignore_status_codes':\n      this._updateNestedIfChanged(\n        params,\n        this.error_collector,\n        'error_collector.ignore_status_codes',\n        'ignore_status_codes'\n      )\n      this._canonicalize()\n      break\n\n    case 'error_collector.capture_events':\n      this._updateNestedIfChanged(\n        params,\n        this.error_collector,\n        'error_collector.capture_events',\n        'capture_events'\n      )\n      break\n\n    case 'error_collector.max_event_samples_stored':\n      this._updateNestedIfChanged(\n        params,\n        this.error_collector,\n        'error_collector.max_event_samples_stored',\n        'max_event_samples_stored'\n      )\n      break\n\n    case 'collect_analytics_events':\n      // never enable from server-side\n      // but we allow the server to disable\n      if (params.collect_analytics_events === false)\n        this.transaction_events.enabled = false\n      break\n\n    case 'collect_custom_events':\n      // never enable from server-side\n      // but we allow the server to disable\n      if (params.collect_custom_events === false)\n        this.custom_insights_events.enabled = false\n      break\n\n    case 'transaction_events.max_samples_stored':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_events,\n        key,\n        'max_samples_stored'\n      )\n      break\n\n    case 'transaction_events.max_samples_per_minute':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_events,\n        key,\n        'max_samples_per_minute'\n      )\n      break\n\n    case 'transaction_events.enabled':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_events,\n        key,\n        'enabled'\n      )\n      break\n\n    // these are used by browser_monitoring\n    // and the api.getRUMHeader() method\n    case 'js_agent_file':\n    case 'js_agent_loader_file':\n    case 'beacon':\n    case 'error_beacon':\n    case 'browser_key':\n    case 'js_agent_loader':\n      this._updateNestedIfChangedRaw(\n        params,\n        this.browser_monitoring,\n        key,\n        key\n      )\n      break\n\n    case 'browser_monitoring.loader':\n      this._updateNestedIfChangedRaw(\n        params,\n        this.browser_monitoring,\n        key,\n        'loader'\n      )\n      break\n\n    // After 2015-02, the collector no longer supports the capture_params setting.\n    case 'capture_params':\n      break\n    // these settings aren't supported by the agent (yet)\n    case 'sampling_rate':\n    case 'episodes_file':\n    case 'episodes_url':\n    case 'cross_application_tracing':\n    case 'transaction_tracer.record_sql':\n    case 'slow_sql.enabled':\n    case 'rum.load_episodes_file':\n      this.logUnsupported(params, key)\n      break\n\n    default:\n      this.logUnknown(params, key)\n  }\n}\n\n/**\n * Change a value sent by the collector if and only if it's different from the\n * value we already have. Emit an event with the key name and the new value,\n * and log that the value has changed.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._alwaysUpdateIfChanged = function _alwaysUpdateIfChanged(json, key) {\n  var value = json[key]\n  if (value !== null && value !== undefined && this[key] !== value) {\n    if (Array.isArray(value) && Array.isArray(this[key])) {\n      value.forEach(function cb_forEach(element) {\n        if (this[key].indexOf(element) === -1) this[key].push(element)\n      }, this)\n    } else {\n      this[key] = value\n    }\n    this.emit(key, value)\n    logger.debug(\"Configuration of %s was changed to %s by New Relic.\", key, value)\n  }\n}\n\n/**\n * Change a value sent by the collector if and only if it's different from the\n * value we already have. Emit an event with the key name and the new value,\n * and log that the value has changed. Parameter will be ignored if\n * ignore_server_configuration is set.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._updateIfChanged = function _updateIfChanged(json, key) {\n  this._updateNestedIfChanged(json, this, key, key)\n}\n\n/**\n * Some parameter values are nested, need a simple way to change them as well.\n * Will merge local and remote if and only if both are arrays. Parameter will\n * be ignored if ignore_server_configuration is set.\n *\n * @param {object} remote    JSON sent from New Relic.\n * @param {object} local     A portion of this configuration object.\n * @param {string} remoteKey The name sent by New Relic.\n * @param {string} localKey  The local name.\n */\nConfig.prototype._updateNestedIfChanged = _updateNestedIfChanged\n\nfunction _updateNestedIfChanged(remote, local, remoteKey, localKey) {\n  if (this.ignore_server_configuration) return this.logDisabled(remote, remoteKey)\n  // if high-sec mode is enabled, we do not accept server changes to high-sec\n  if (this.high_security && HIGH_SECURITY_KEYS.indexOf(localKey) !== -1) {\n    return this.logDisabled(remote, remoteKey)\n  }\n  return this._updateNestedIfChangedRaw(remote, local, remoteKey, localKey)\n}\n\nConfig.prototype._updateNestedIfChangedRaw = function _updateNestedIfChangedRaw(\n    remote, local, remoteKey, localKey) {\n  var value = remote[remoteKey]\n  if (value !== null && value !== undefined && local[localKey] !== value) {\n    if (Array.isArray(value) && Array.isArray(local[localKey])) {\n      value.forEach(function cb_forEach(element) {\n        if (local[localKey].indexOf(element) === -1) local[localKey].push(element)\n      })\n    } else {\n      local[localKey] = value\n    }\n    this.emit(remoteKey, value)\n    logger.debug(\"Configuration of %s was changed to %s by New Relic.\", remoteKey, value)\n  }\n}\n\n/**\n * Some parameter values are just to be passed on.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._emitIfSet = function _emitIfSet(json, key) {\n  var value = json[key]\n  if (value !== null && value !== undefined) this.emit(key, value)\n}\n\n/**\n * The agent would normally do something with this parameter, but server-side\n * configuration is disabled via ignore_server_configuration.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent won't set.\n */\nConfig.prototype.logDisabled = function logDisabled(json, key) {\n  var value = json[key]\n  if (value !== null && value !== undefined) {\n    logger.debug(\n      \"Server-side configuration of %s is currently disabled by local configuration. \" +\n      \"(Server sent value of %s.)\",\n      key,\n      value\n    )\n  }\n}\n\n/**\n * Help support out by putting in the logs the fact that we don't currently\n * support the provided configuration key, and including the sent value.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent doesn't set.\n */\nConfig.prototype.logUnsupported = function logUnsupported(json, key) {\n  var flavor\n  if (this.ignore_server_configuration) {\n    flavor = \"ignored\"\n  } else {\n    flavor = \"not supported by the Node.js agent\"\n  }\n\n  var value = json[key]\n  if (value !== null && value !== undefined) {\n    logger.debug(\n      \"Server-side configuration of %s is currently %s. (Server sent value of %s.)\",\n      key,\n      flavor,\n      value\n    )\n    this.emit(key, value)\n  }\n}\n\n/**\n * The agent knows nothing about this parameter.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent knows nothing about.\n */\nConfig.prototype.logUnknown = function logUnknown(json, key) {\n  var value = json[key]\n  logger.debug(\n    \"New Relic sent unknown configuration parameter %s with value %s.\",\n    key,\n    value\n  )\n}\n\n/**\n * Gets the user set host display name. If not provided, it returns the default value.\n *\n * This function is written is this strange way becauase of the use of caching variables.\n * I wanted to cache the DisplayHost, but if I attached the variable to the config object,\n * it sends the extra variable to New Relic, which is not desired.\n *\n * @return {string} display host name\n */\nConfig.prototype.getDisplayHost = getDisplayHost\n\nConfig.prototype.clearDisplayHostCache = function clearDisplayHostCache() {\n  this.getDisplayHost = getDisplayHost\n}\n\nfunction getDisplayHost() {\n  var _displayHost\n  this.getDisplayHost = function getCachedDisplayHost() {\n    return _displayHost\n  }\n  if (this.process_host.display_name === '') {\n    _displayHost = this.getHostnameSafe()\n    return _displayHost\n  }\n  var stringBuffer = new Buffer(this.process_host.display_name, 'utf8')\n  var numBytes = stringBuffer.length\n\n  if (numBytes > 255) {\n    logger.warn('Custom host display name must be less than 255 bytes')\n    _displayHost = this.getHostnameSafe()\n    return _displayHost\n  }\n\n  _displayHost = this.process_host.display_name\n  return _displayHost\n}\n\n/**\n * Gets the system's host name. If that fails, it just returns ipv4/6 based on the user's\n * process_host.ipv_preferenece setting.\n *\n * This function is written is this strange way becauase of the use of caching variables.\n * I wanted to cache the Hostname, but if I attached the variable to the config object,\n * it sends the extra variable to New Relic, which is not desired.\n *\n * @return {string} host name\n */\nConfig.prototype.getHostnameSafe = getHostnameSafe\n\nConfig.prototype.clearHostnameCache = function clearHostnameCache() {\n  this.getHostnameSafe = getHostnameSafe\n}\n\nConfig.prototype.getIPAddresses = function getIPAddresses() {\n  var addresses = {}\n  var interfaces = os.networkInterfaces()\n\n  for (var interfaceKey in interfaces) {\n    if (interfaceKey.match(/^lo/)) continue\n\n    var interfaceDescriptions = interfaces[interfaceKey]\n    for (var i = 0; i < interfaceDescriptions.length; i++) {\n      var description = interfaceDescriptions[i]\n      var family = description.family.toLowerCase()\n      addresses[family] = description.address\n    }\n  }\n  return addresses\n}\n\nfunction getHostnameSafe() {\n  var _hostname\n  this.getHostnameSafe = function getCachedHostname() {\n    return _hostname\n  }\n  try {\n    _hostname = os.hostname()\n    return _hostname\n  } catch (e) {\n    var addresses = this.getIPAddresses()\n\n    if (this.process_host.ipv_preference === '6' && addresses.ipv6) {\n      _hostname = addresses.ipv6\n    } else if (addresses.ipv4) {\n      logger.info('Defaulting to ipv4 address for host name')\n      _hostname = addresses.ipv4\n    } else if (addresses.ipv6) {\n      logger.info('Defaulting to ipv6 address for host name')\n      _hostname = addresses.ipv6\n    } else {\n      logger.info('No hostname, ipv4, or ipv6 address found for machine')\n      _hostname = 'UNKNOWN_BOX'\n    }\n\n    return _hostname\n  }\n}\n\n/**\n * Ensure that the apps names are always returned as a list.\n */\nConfig.prototype.applications = function applications() {\n  var apps = this.app_name\n\n  if (Array.isArray(apps) && apps.length > 0) {\n    return apps\n  }\n\n  if (apps && typeof apps === 'string') {\n    return [apps]\n  }\n\n  return []\n}\n\n/**\n * Safely overwrite defaults with values passed to constructor.\n *\n * @param object external The configuration being loaded.\n * @param object internal Whichever chunk of the config being overridden.\n */\nConfig.prototype._fromPassed = function _fromPassed(external, internal, arbitrary) {\n  if (!external) return\n  if (!internal) internal = this\n\n  Object.keys(external).forEach(function cb_forEach(key) {\n    // if it's not in the defaults, it doesn't exist\n    if (!arbitrary && internal[key] === undefined) return\n\n    try {\n      var node = external[key]\n    } catch (err) {\n      logger.warn('Error thrown on access of user config for key: %s', key)\n      return\n    }\n\n    if (Array.isArray(node)) {\n      internal[key] = node\n    } else if (typeof node === 'object') {\n      // is top level and can have arbitrary keys\n      if (internal === this && HAS_ARBITRARY_KEYS.indexOf(key) !== -1) {\n        this._fromPassed(node, internal[key], true)\n      } else {\n        this._fromPassed(node, internal[key], false)\n      }\n    } else {\n      internal[key] = node\n    }\n  }, this)\n}\n\n/**\n * Some values should be picked up only if they're not otherwise set, like\n * the Windows / Azure application name. Don't set it if there's already\n * a non-empty value set via the configuration file, and allow these\n * values to be overwritten by environment variables. Just saves a step for\n * PaaS users who don't want to have multiple settings for a single piece\n * of configuration.\n */\nConfig.prototype._fromSpecial = function _fromSpecial() {\n  var name = this.app_name\n  if (name === null || name === undefined || name === '' ||\n      (Array.isArray(name) && name.length === 0)) {\n    var azureName = process.env[AZURE_APP_NAME]\n    if (azureName) this.app_name = azureName.split(',')\n  }\n}\n\n/**\n * Recursively visit the nodes of the constant containing the mapping between\n * environment variable names, overriding any configuration values that are\n * found in the environment. Operates purely via side effects.\n *\n * @param object metadata The current level of the mapping object. Should never\n *                        need to set this yourself.\n * @param object data     The current level of the configuration object. Should\n *                        never need to set this yourself.\n */\nConfig.prototype._fromEnvironment = function _fromEnvironment(metadata, data) {\n  if (!metadata) metadata = ENV_MAPPING\n  if (!data) data = this\n\n  Object.keys(metadata).forEach(function cb_forEach(value) {\n    // if it's not in the config, it doesn't exist\n    if (data[value] === undefined) return\n\n    var node = metadata[value]\n    if (typeof node === 'string') {\n      var setting = process.env[node]\n      if (setting) {\n        if (LIST_VARS.indexOf(node) > -1) {\n          data[value] = setting.split(',').map(function cb_map(k) {\n            return k.trim()\n          })\n        } else if (OBJECT_LIST_VARS.indexOf(node) > -1) {\n          data[value] = fromObjectList(setting)\n        } else if (BOOLEAN_VARS.indexOf(node) > -1) {\n          data[value] = isTruthular(setting)\n        } else if (FLOAT_VARS.indexOf(node) > -1) {\n          data[value] = parseFloat(setting, 10)\n        } else if (INT_VARS.indexOf(node) > -1) {\n          data[value] = parseInt(setting, 10)\n        } else {\n          data[value] = setting\n        }\n      }\n    } else {\n      // don't crash if the mapping has config keys the current config doesn't.\n      if (!data[value]) data[value] = {}\n      this._fromEnvironment(node, data[value])\n    }\n  }, this)\n}\n\n/**\n * Depending on how the status codes are set, they could be strings, which\n * makes strict equality testing / indexOf fail. To keep things cheap, parse\n * them once, after configuration has finished loading. Other one-off shims\n * based on special properties of configuration values should go here as well.\n */\nConfig.prototype._canonicalize = function _canonicalize() {\n  var codes = this.error_collector && this.error_collector.ignore_status_codes\n  if (codes) {\n    this.error_collector.ignore_status_codes = codes.map(function cb_map(code) {\n      return parseInt(code, 10)\n    })\n  }\n\n  var logAliases = {\n    'verbose': 'trace',\n    'debugging': 'debug',\n    'warning': 'warn',\n    'err': 'error'\n  }\n  var level = this.logging.level\n  this.logging.level = logAliases[level] || level\n}\n\n/**\n * This goes through the settings that high security mode needs and coerces\n * them to be correct.\n */\nConfig.prototype._applyHighSecurity = function _applyHighSecurity() {\n  var config = this\n  checkNode('', this, HIGH_SECURITY_SETTINGS)\n\n  function checkNode(base, config, settings) {\n    Object.keys(settings).forEach(checkKey.bind(null, base, config, settings))\n  }\n\n  function checkKey(base, target, settings, key) {\n    var hsValue = settings[key]\n\n\n    if (hsValue && typeof hsValue === 'object') {\n      if (typeof target[key] !== 'object') {\n        logger.warn(\n          'High Security Mode: %s should be an object, found %s',\n          key,\n          target[key]\n        )\n        target[key] = {}\n      }\n\n      return checkNode(base + key + '.', target[key], hsValue)\n    }\n\n    if (target[key] !== hsValue) {\n      logger.warn('High Security Mode: %s was set to %s, coercing to %s',\n                  key, target[key], hsValue)\n      target[key] = hsValue\n      config.emit(base + key, hsValue)\n    }\n  }\n}\n\n/**\n * The agent will use the supportability metrics object if it's\n * available.\n *\n * @param string suffix Supportability metric name.\n * @param number duration Milliseconds that the measured operation took.\n */\nConfig.prototype.measureInternal = function measureInternal(suffix, duration) {\n  if (this.debug.supportability) {\n    var internal = this.debug.supportability\n    internal.measureMilliseconds(NAMES.SUPPORTABILITY.PREFIX + suffix, null, duration)\n  }\n}\n\nConfig.prototype.validateFlags = function validateFlags() {\n  Object.keys(this.feature_flag).forEach(function cb_forEach(key) {\n    if (feature_flag.released.indexOf(key) > -1) {\n      logger.warn('Feature flag ' + key + ' has been released')\n    }\n    if (feature_flag.unreleased.indexOf(key) > -1) {\n      logger.warn('Feature flag ' + key + ' has been deprecated')\n    }\n  })\n}\n\n/**\n * Get a JSONifiable object containing all settings we want to report to the\n * collector and store in the environment_values table.\n *\n * @return Object containing simple key-value pairs of settings\n */\nConfig.prototype.publicSettings = function publicSettings() {\n  var settings = {}\n\n  for (var key in this) {\n    if (this.hasOwnProperty(key)) {\n      var item = this[key]\n\n      if (REDACT_BEFORE_SEND.indexOf(key) > -1) {\n        item = '****'\n      }\n\n      if (REMOVE_BEFORE_SEND.indexOf(key) === -1) {\n        settings[key] = item\n      }\n    }\n  }\n\n  // Agent-side setting is 'enable', but collector-side setting is\n  // 'auto_instrument'. Send both values up.\n  settings.browser_monitoring.auto_instrument = settings.browser_monitoring.enable\n\n  // Remove simple circular references\n  parse(stringifySync(settings), function cb_parse(err, settingsCopy) {\n    if (err === null) {\n      settings = flatten({}, '', settingsCopy)\n    } else {\n      logger.warn('Error while creating deep copy: %s', err)\n    }\n  })\n\n  return settings\n}\n\n/**\n * Create a configuration, either from a configuration file or the node\n * process's environment.\n *\n * For configuration via file, check these directories, in order, for a\n * file named 'newrelic.js':\n *\n *   1. The process's current working directory at startup.\n *   2. The same directory as the process's main module (i.e. the filename\n *      passed to node on the command line).\n *   3. The directory pointed to by the environment variable NEW_RELIC_HOME.\n *   4. The current process's HOME directory.\n *   5. If this module is installed as a dependency, the directory above the\n *      node_modules folder in which newrelic is installed.\n *\n * For configration via environment (useful on Joyent, Azure, Heroku, or\n * other PaaS offerings), set NEW_RELIC_NO_CONFIG_FILE to something truthy\n * and read README.md for details on what configuration variables are\n * necessary, as well as a complete enumeration of the other available\n * variables.\n *\n * @param {object} config Optional configuration to be used in place of a\n *                        config file.\n */\nfunction initialize(config) {\n  /* When the logger is required here, it bootstraps itself and then\n   * injects itself into this module's closure via setLogger on the\n   * instance of the logger it creates.\n   */\n  logger = require('./logger.js')\n\n  if (config) return new Config(config)\n\n  if (isTruthular(process.env.NEW_RELIC_NO_CONFIG_FILE)) {\n    config = new Config({})\n    if (config.newrelic_home) delete config.newrelic_home\n    return config\n  }\n\n  var filepath = _findConfigFile()\n  if (!filepath) return _failHard()\n\n  try {\n    config = new Config(require(filepath).config)\n    config.config_file_path = filepath\n    logger.debug(\"Using configuration file %s.\", filepath)\n\n    config.validateFlags()\n\n    return config\n  } catch (error) {\n    logger.error(error)\n\n    throw new Error(\n      \"Unable to read configuration file \" + filepath + \". A default\\n\" +\n      \"configuration file can be copied from \" + DEFAULT_CONFIG_PATH + \"\\n\" +\n      \"and renamed to 'newrelic.js' in the directory from which you'll be starting\\n\" +\n      \"your application.\"\n    )\n  }\n}\n\n/**\n * Preserve the legacy initializer, but also allow consumers to manage their\n * own configuration if they choose.\n */\nConfig.initialize = initialize\n\nmodule.exports = Config\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/config.js\n// module id = 57\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/path-browserify/index.js\n// module id = 58\n// module chunks = 0","'use strict'\n\nvar NODEJS = {\n  PREFIX: 'Nodejs/'\n}\n\nvar ALL = 'all'\n\nvar ERRORS = {\n  PREFIX: 'Errors/',\n  ALL: 'Errors/' + ALL,\n  WEB: 'Errors/allWeb',\n  OTHER: 'Errors/allOther'\n}\n\nvar EVENTS = {\n  WAIT: 'Events/wait'\n}\n\nvar MEMORY = {\n  PHYSICAL: 'Memory/Physical',\n  FREE_HEAP: 'Memory/Heap/Free',\n  USED_HEAP: 'Memory/Heap/Used',\n  MAX_HEAP: 'Memory/Heap/Max',\n  USED_NONHEAP: 'Memory/NonHeap/Used'\n}\n\nvar CPU = {\n  SYSTEM_TIME: 'CPU/System Time',\n  SYSTEM_UTILIZATION: 'CPU/System/Utilization',\n  USER_TIME: 'CPU/User Time',\n  USER_UTILIZATION: 'CPU/User/Utilization'\n}\n\nvar GC = {\n  PREFIX: 'GC/',\n  PAUSE_TIME: 'GC/System/Pauses'\n}\n\nvar VIEW = {\n  PREFIX: 'View/',\n  RENDER: '/Rendering'\n}\n\nvar DB = {\n  PREFIX: 'Datastore/',\n  STATEMENT: 'Datastore/statement',\n  OPERATION: 'Datastore/operation',\n  INSTANCE: 'Datastore/instance',\n  ALL: 'Datastore/' + ALL,\n  WEB: 'allWeb',\n  OTHER: 'allOther'\n}\n\nvar EXTERNAL = {\n  PREFIX: 'External/',\n  ALL: 'External/' + ALL,\n  WEB: 'External/allWeb',\n  OTHER: 'External/allOther',\n  APP: 'ExternalApp/',\n  TRANSACTION: 'ExternalTransaction/'\n}\n\nvar FUNCTION = {\n  PREFIX: 'Function/'\n}\n\nvar MIDDLEWARE = {\n  PREFIX: NODEJS.PREFIX + 'Middleware/'\n}\n\nvar FS = {\n  PREFIX: 'Filesystem/'\n}\n\nvar MEMCACHE = {\n  PREFIX: 'Memcache',\n  OPERATION: DB.OPERATION + '/Memcache/',\n  INSTANCE: DB.INSTANCE + '/Memcache/',\n  ALL: DB.PREFIX + 'Memcache/' + ALL\n}\n\nvar MONGODB = {\n  PREFIX: 'MongoDB',\n  STATEMENT: DB.STATEMENT + '/MongoDB/',\n  OPERATION: DB.OPERATION + '/MongoDB/',\n  INSTANCE: DB.INSTANCE + '/MongoDB/'\n}\n\nvar MYSQL = {\n  PREFIX: 'MySQL',\n  STATEMENT: DB.STATEMENT + '/MySQL/',\n  OPERATION: DB.OPERATION + '/MySQL/',\n  INSTANCE: DB.INSTANCE + '/MySQL/'\n}\n\nvar REDIS = {\n  PREFIX: 'Redis',\n  OPERATION: DB.OPERATION + '/Redis/',\n  INSTANCE: DB.INSTANCE + '/Redis/',\n  ALL: DB.PREFIX + 'Redis/' + ALL\n}\n\nvar POSTGRES = {\n  PREFIX: 'Postgres',\n  STATEMENT: DB.STATEMENT + '/Postgres/',\n  OPERATION: DB.OPERATION + '/Postgres/',\n  INSTANCE: DB.INSTANCE + '/Postgres/'\n}\n\nvar CASSANDRA = {\n  PREFIX: 'Cassandra',\n  OPERATION: DB.OPERATION + '/Cassandra/',\n  STATEMENT: DB.STATEMENT + '/Cassandra/',\n  INSTANCE: DB.INSTANCE + '/Cassandra/',\n  ALL: DB.PREFIX + 'Cassandra/' + ALL\n\n}\n\nvar ORACLE = {\n  PREFIX: 'Oracle',\n  STATEMENT: DB.STATEMENT + '/Oracle/',\n  OPERATION: DB.OPERATION + '/Oracle/',\n  INSTANCE: DB.INSTANCE + '/Oracle/'\n}\n\nvar EXPRESS = {\n  PREFIX: 'Expressjs/',\n  MIDDLEWARE: MIDDLEWARE.PREFIX + 'Expressjs/',\n  ERROR_HANDLER: MIDDLEWARE.PREFIX + 'Expressjs/'\n}\n\nvar RESTIFY = {\n  PREFIX: 'Restify/'\n}\n\nvar HAPI = {\n  PREFIX: 'Hapi/'\n}\n\nvar SUPPORTABILITY = {\n  PREFIX: 'Supportability/',\n  UNINSTRUMENTED: 'Supportability/Uninstrumented',\n  EVENTS: 'Supportability/Events',\n  API: 'Supportability/API',\n  UTILIZATION: 'Supportability/utilization',\n  DEPENDENCIES: 'Supportability/InstalledDependencies'\n}\n\nvar UTILIZATION = {\n  AWS_ERROR: SUPPORTABILITY.UTILIZATION + '/aws/error',\n  DOCKER_ERROR: SUPPORTABILITY.UTILIZATION + '/docker/error'\n}\n\n\nvar CUSTOM_EVENTS = {\n  PREFIX: SUPPORTABILITY.EVENTS + '/Customer/',\n  DROPPED: SUPPORTABILITY.EVENTS + '/Customer/Dropped',\n  SEEN: SUPPORTABILITY.EVENTS + '/Customer/Seen',\n  SENT: SUPPORTABILITY.EVENTS + '/Customer/Sent',\n  TOO_LARGE: SUPPORTABILITY.EVENTS + '/Customer/TooLarge',\n  FAILED: SUPPORTABILITY.EVENTS + '/Customer/FailedToSend'\n}\n\nvar TRANSACTION_ERROR = {\n  SEEN: SUPPORTABILITY.EVENTS + '/TransactionError/Seen',\n  SENT: SUPPORTABILITY.EVENTS + '/TransactionError/Sent'\n}\n\nvar WEB = {\n  RESPONSE_TIME: 'WebTransaction',\n  TOTAL_TIME: 'WebTransactionTotalTime'\n}\n\nvar BACKGROUND = {\n  RESPONSE_TIME: 'OtherTransaction',\n  TOTAL_TIME: 'OtherTransactionTotalTime'\n}\n\nvar TRUNCATED = {\n  PREFIX: 'Truncated/'\n}\n\nmodule.exports = {\n  ACTION_DELIMITER: '/',\n  ALL: ALL,\n  APDEX: 'Apdex',\n  BACKGROUND: BACKGROUND,\n  CASSANDRA: CASSANDRA,\n  CLIENT_APPLICATION: 'ClientApplication',\n  CONTROLLER: 'Controller',\n  CPU: CPU,\n  GC: GC,\n  CUSTOM: 'Custom',\n  CUSTOM_EVENTS: CUSTOM_EVENTS,\n  DB: DB,\n  ERRORS: ERRORS,\n  EVENTS: EVENTS,\n  EXPRESS: EXPRESS,\n  EXTERNAL: EXTERNAL,\n  FS: FS,\n  FUNCTION: FUNCTION,\n  HAPI: HAPI,\n  HTTP: 'HttpDispatcher',\n  MEMCACHE: MEMCACHE,\n  MEMORY: MEMORY,\n  MONGODB: MONGODB,\n  MYSQL: MYSQL,\n  NORMALIZED: 'NormalizedUri',\n  NODEJS: NODEJS,\n  ORACLE: ORACLE,\n  POSTGRES: POSTGRES,\n  QUEUETIME: 'WebFrontend/QueueTime',\n  REDIS: REDIS,\n  RESTIFY: RESTIFY,\n  SUPPORTABILITY: SUPPORTABILITY,\n  TRANSACTION_ERROR: TRANSACTION_ERROR,\n  TRUNCATED: TRUNCATED,\n  URI: 'Uri',\n  UTILIZATION: UTILIZATION,\n  VIEW: VIEW,\n  WEB: WEB\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/names.js\n// module id = 59\n// module chunks = 0","'use strict'\n\n// unreleased flags gating an active feature\nexports.prerelease = {\n  cat: true,\n  custom_instrumentation: true,\n  custom_metrics: true,\n  express5: false,\n  synthetics: true,\n  express_segments: true,\n  native_metrics: true,\n  promise_segments: false,\n  reverse_naming_rules: true,\n  send_request_uri_attribute: false\n}\n\n// flags that are no longer used for released features\nexports.released = [\n  'released',\n  'express4',\n  'insights',\n  'postgres',\n  'mysql_pool',\n  'proxy',\n  'custom_events'\n]\n\n// flags that are no longer used for unreleased features\nexports.unreleased = [\n  'unreleased'\n]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/feature_flags.js\n// module id = 60\n// module chunks = 0","'use strict'\n\n/**\n * Flatten nested maps of JSONifiable data.\n *\n * Ex: {a: 5, b: {c: true, d: 7}} -> {a: 5, 'b.c': true, 'b.d': 7}\n *\n * @param result Object to place key-value pairs into, normally called with {}\n * @param prefix Prefix for keys, normally called with ''\n * @param obj    Object to be flattened\n *\n * @return Object with flattened key-value pairs\n */\nmodule.exports = function flatten(result, prefix, obj, seen) {\n  seen = seen || []\n  seen.push(obj)\n\n  for (var key in obj) {\n    if (seen.indexOf(obj[key]) > -1) {\n      continue\n    }\n\n    if (obj[key] instanceof Object) flatten(result, prefix + key + '.', obj[key], seen)\n    else result[prefix + key] = obj[key]\n  }\n\n  return result\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/flatten.js\n// module id = 61\n// module chunks = 0","'use strict'\n\nvar crypto = require('crypto')\n\nfunction encode(bytes, keyBytes) {\n  for (var i = 0; i < bytes.length; i++) {\n    // This is really dense but happens commonly so I'm in-lining some of what\n    // could be tossed into variables. It takes the current byte of bytes, then\n    // XORs it with the current byte of the key (which uses modulo to make sure\n    // to not overrun the end.)\n    bytes.writeUInt8(bytes.readUInt8(i) ^ keyBytes.readUInt8(i % keyBytes.length), i)\n  }\n  return bytes\n}\n\nfunction obfuscateNameUsingKey(name, key) {\n  var encodedBytes = new Buffer(name, 'utf-8')\n  var keyBytes = new Buffer(key)\n  return encode(encodedBytes, keyBytes).toString('base64')\n}\n\nfunction deobfuscateNameUsingKey(name, key) {\n  var bytes = new Buffer(name, 'base64')\n  var keyBytes = new Buffer(key)\n\n  return encode(bytes, keyBytes).toString(\"utf-8\")\n}\n\nfunction calculatePathHash(appName, pathName, referingPathHash) {\n  if (typeof referingPathHash === 'string') {\n    referingPathHash = parseInt(referingPathHash, 16)\n  }\n  var rotated = ((referingPathHash << 1) | (referingPathHash >>> 31)) >>> 0\n  var hash = getHash(appName, pathName)\n\n  var result = (rotated ^ hash) >>> 0\n\n  // This is a trick to pad it out to 8 chars regardless of length.\n  var retval = ('00000000' + result.toString(16)).substr(-8)\n\n  return retval\n}\n\nfunction getHash(appName, txName) {\n  var md5sum = crypto.createHash('md5')\n  md5sum.update(new Buffer(appName + ';' + txName), 'utf8')\n  var buf = new Buffer(md5sum.digest('base64'), 'base64')\n  // pull the low 4 bytes in network byte order\n  return buf.slice(buf.length - 4, buf.length).readUInt32BE(0)\n}\n\nexports.obfuscateNameUsingKey = obfuscateNameUsingKey\nexports.deobfuscateNameUsingKey = deobfuscateNameUsingKey\nexports.calculatePathHash = calculatePathHash\nexports.getHash = getHash\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/hashes.js\n// module id = 62\n// module chunks = 0","var rng = require('./rng')\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = require('./create-hash')\n\nexports.createHmac = require('./create-hmac')\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, new Buffer(rng(size)))\n    } catch (err) { callback(err) }\n  } else {\n    return new Buffer(rng(size))\n  }\n}\n\nfunction each(a, f) {\n  for(var i in a)\n    f(a[i], i)\n}\n\nexports.getHashes = function () {\n  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']\n}\n\nvar p = require('./pbkdf2')(exports)\nexports.pbkdf2 = p.pbkdf2\nexports.pbkdf2Sync = p.pbkdf2Sync\nrequire('browserify-aes/inject')(exports, module.exports);\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\neach(['createCredentials'\n, 'createSign'\n, 'createVerify'\n, 'createDiffieHellman'\n], function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/crypto-browserify/index.js\n// module id = 63\n// module chunks = 0","(function() {\n  var g = ('undefined' === typeof window ? global : window) || {}\n  _crypto = (\n    g.crypto || g.msCrypto || require('crypto')\n  )\n  module.exports = function(size) {\n    // Modern Browsers\n    if(_crypto.getRandomValues) {\n      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array\n      /* This will not work in older browsers.\n       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n       */\n    \n      _crypto.getRandomValues(bytes);\n      return bytes;\n    }\n    else if (_crypto.randomBytes) {\n      return _crypto.randomBytes(size)\n    }\n    else\n      throw new Error(\n        'secure random number generation not supported by this browser\\n'+\n        'use chrome, FireFox or Internet Explorer 11'\n      )\n  }\n}())\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/crypto-browserify/rng.js\n// module id = 64\n// module chunks = 0","/* (ignored) */\n\n\n//////////////////\n// WEBPACK FOOTER\n// crypto (ignored)\n// module id = 65\n// module chunks = 0","var createHash = require('sha.js')\n\nvar md5 = toConstructor(require('./md5'))\nvar rmd160 = toConstructor(require('ripemd160'))\n\nfunction toConstructor (fn) {\n  return function () {\n    var buffers = []\n    var m= {\n      update: function (data, enc) {\n        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)\n        buffers.push(data)\n        return this\n      },\n      digest: function (enc) {\n        var buf = Buffer.concat(buffers)\n        var r = fn(buf)\n        buffers = null\n        return enc ? r.toString(enc) : r\n      }\n    }\n    return m\n  }\n}\n\nmodule.exports = function (alg) {\n  if('md5' === alg) return new md5()\n  if('rmd160' === alg) return new rmd160()\n  return createHash(alg)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/crypto-browserify/create-hash.js\n// module id = 66\n// module chunks = 0","var exports = module.exports = function (alg) {\n  var Alg = exports[alg]\n  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')\n  return new Alg()\n}\n\nvar Buffer = require('buffer').Buffer\nvar Hash   = require('./hash')(Buffer)\n\nexports.sha1 = require('./sha1')(Buffer, Hash)\nexports.sha256 = require('./sha256')(Buffer, Hash)\nexports.sha512 = require('./sha512')(Buffer, Hash)\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sha.js/index.js\n// module id = 67\n// module chunks = 0","module.exports = function (Buffer) {\n\n  //prototype class for hash functions\n  function Hash (blockSize, finalSize) {\n    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)\n    this._finalSize = finalSize\n    this._blockSize = blockSize\n    this._len = 0\n    this._s = 0\n  }\n\n  Hash.prototype.init = function () {\n    this._s = 0\n    this._len = 0\n  }\n\n  Hash.prototype.update = function (data, enc) {\n    if (\"string\" === typeof data) {\n      enc = enc || \"utf8\"\n      data = new Buffer(data, enc)\n    }\n\n    var l = this._len += data.length\n    var s = this._s = (this._s || 0)\n    var f = 0\n    var buffer = this._block\n\n    while (s < l) {\n      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))\n      var ch = (t - f)\n\n      for (var i = 0; i < ch; i++) {\n        buffer[(s % this._blockSize) + i] = data[i + f]\n      }\n\n      s += ch\n      f += ch\n\n      if ((s % this._blockSize) === 0) {\n        this._update(buffer)\n      }\n    }\n    this._s = s\n\n    return this\n  }\n\n  Hash.prototype.digest = function (enc) {\n    // Suppose the length of the message M, in bits, is l\n    var l = this._len * 8\n\n    // Append the bit 1 to the end of the message\n    this._block[this._len % this._blockSize] = 0x80\n\n    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize\n    this._block.fill(0, this._len % this._blockSize + 1)\n\n    if (l % (this._blockSize * 8) >= this._finalSize * 8) {\n      this._update(this._block)\n      this._block.fill(0)\n    }\n\n    // to this append the block which is equal to the number l written in binary\n    // TODO: handle case where l is > Math.pow(2, 29)\n    this._block.writeInt32BE(l, this._blockSize - 4)\n\n    var hash = this._update(this._block) || this._hash()\n\n    return enc ? hash.toString(enc) : hash\n  }\n\n  Hash.prototype._update = function () {\n    throw new Error('_update must be implemented by subclass')\n  }\n\n  return Hash\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sha.js/hash.js\n// module id = 68\n// module chunks = 0","/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar inherits = require('util').inherits\n\nmodule.exports = function (Buffer, Hash) {\n\n  var A = 0|0\n  var B = 4|0\n  var C = 8|0\n  var D = 12|0\n  var E = 16|0\n\n  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)\n\n  var POOL = []\n\n  function Sha1 () {\n    if(POOL.length)\n      return POOL.pop().init()\n\n    if(!(this instanceof Sha1)) return new Sha1()\n    this._w = W\n    Hash.call(this, 16*4, 14*4)\n\n    this._h = null\n    this.init()\n  }\n\n  inherits(Sha1, Hash)\n\n  Sha1.prototype.init = function () {\n    this._a = 0x67452301\n    this._b = 0xefcdab89\n    this._c = 0x98badcfe\n    this._d = 0x10325476\n    this._e = 0xc3d2e1f0\n\n    Hash.prototype.init.call(this)\n    return this\n  }\n\n  Sha1.prototype._POOL = POOL\n  Sha1.prototype._update = function (X) {\n\n    var a, b, c, d, e, _a, _b, _c, _d, _e\n\n    a = _a = this._a\n    b = _b = this._b\n    c = _c = this._c\n    d = _d = this._d\n    e = _e = this._e\n\n    var w = this._w\n\n    for(var j = 0; j < 80; j++) {\n      var W = w[j] = j < 16 ? X.readInt32BE(j*4)\n        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)\n\n      var t = add(\n        add(rol(a, 5), sha1_ft(j, b, c, d)),\n        add(add(e, W), sha1_kt(j))\n      )\n\n      e = d\n      d = c\n      c = rol(b, 30)\n      b = a\n      a = t\n    }\n\n    this._a = add(a, _a)\n    this._b = add(b, _b)\n    this._c = add(c, _c)\n    this._d = add(d, _d)\n    this._e = add(e, _e)\n  }\n\n  Sha1.prototype._hash = function () {\n    if(POOL.length < 100) POOL.push(this)\n    var H = new Buffer(20)\n    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)\n    H.writeInt32BE(this._a|0, A)\n    H.writeInt32BE(this._b|0, B)\n    H.writeInt32BE(this._c|0, C)\n    H.writeInt32BE(this._d|0, D)\n    H.writeInt32BE(this._e|0, E)\n    return H\n  }\n\n  /*\n   * Perform the appropriate triplet combination function for the current\n   * iteration\n   */\n  function sha1_ft(t, b, c, d) {\n    if(t < 20) return (b & c) | ((~b) & d);\n    if(t < 40) return b ^ c ^ d;\n    if(t < 60) return (b & c) | (b & d) | (c & d);\n    return b ^ c ^ d;\n  }\n\n  /*\n   * Determine the appropriate additive constant for the current iteration\n   */\n  function sha1_kt(t) {\n    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n           (t < 60) ? -1894007588 : -899497514;\n  }\n\n  /*\n   * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n   * to work around bugs in some JS interpreters.\n   * //dominictarr: this is 10 years old, so maybe this can be dropped?)\n   *\n   */\n  function add(x, y) {\n    return (x + y ) | 0\n  //lets see how this goes on testling.\n  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  //  return (msw << 16) | (lsw & 0xFFFF);\n  }\n\n  /*\n   * Bitwise rotate a 32-bit number to the left.\n   */\n  function rol(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n  }\n\n  return Sha1\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sha.js/sha1.js\n// module id = 69\n// module chunks = 0","\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = require('util').inherits\n\nmodule.exports = function (Buffer, Hash) {\n\n  var K = [\n      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n    ]\n\n  var W = new Array(64)\n\n  function Sha256() {\n    this.init()\n\n    this._w = W //new Array(64)\n\n    Hash.call(this, 16*4, 14*4)\n  }\n\n  inherits(Sha256, Hash)\n\n  Sha256.prototype.init = function () {\n\n    this._a = 0x6a09e667|0\n    this._b = 0xbb67ae85|0\n    this._c = 0x3c6ef372|0\n    this._d = 0xa54ff53a|0\n    this._e = 0x510e527f|0\n    this._f = 0x9b05688c|0\n    this._g = 0x1f83d9ab|0\n    this._h = 0x5be0cd19|0\n\n    this._len = this._s = 0\n\n    return this\n  }\n\n  function S (X, n) {\n    return (X >>> n) | (X << (32 - n));\n  }\n\n  function R (X, n) {\n    return (X >>> n);\n  }\n\n  function Ch (x, y, z) {\n    return ((x & y) ^ ((~x) & z));\n  }\n\n  function Maj (x, y, z) {\n    return ((x & y) ^ (x & z) ^ (y & z));\n  }\n\n  function Sigma0256 (x) {\n    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n  }\n\n  function Sigma1256 (x) {\n    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n  }\n\n  function Gamma0256 (x) {\n    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n  }\n\n  function Gamma1256 (x) {\n    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n  }\n\n  Sha256.prototype._update = function(M) {\n\n    var W = this._w\n    var a, b, c, d, e, f, g, h\n    var T1, T2\n\n    a = this._a | 0\n    b = this._b | 0\n    c = this._c | 0\n    d = this._d | 0\n    e = this._e | 0\n    f = this._f | 0\n    g = this._g | 0\n    h = this._h | 0\n\n    for (var j = 0; j < 64; j++) {\n      var w = W[j] = j < 16\n        ? M.readInt32BE(j * 4)\n        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]\n\n      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w\n\n      T2 = Sigma0256(a) + Maj(a, b, c);\n      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;\n    }\n\n    this._a = (a + this._a) | 0\n    this._b = (b + this._b) | 0\n    this._c = (c + this._c) | 0\n    this._d = (d + this._d) | 0\n    this._e = (e + this._e) | 0\n    this._f = (f + this._f) | 0\n    this._g = (g + this._g) | 0\n    this._h = (h + this._h) | 0\n\n  };\n\n  Sha256.prototype._hash = function () {\n    var H = new Buffer(32)\n\n    H.writeInt32BE(this._a,  0)\n    H.writeInt32BE(this._b,  4)\n    H.writeInt32BE(this._c,  8)\n    H.writeInt32BE(this._d, 12)\n    H.writeInt32BE(this._e, 16)\n    H.writeInt32BE(this._f, 20)\n    H.writeInt32BE(this._g, 24)\n    H.writeInt32BE(this._h, 28)\n\n    return H\n  }\n\n  return Sha256\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sha.js/sha256.js\n// module id = 70\n// module chunks = 0","var inherits = require('util').inherits\n\nmodule.exports = function (Buffer, Hash) {\n  var K = [\n    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n  ]\n\n  var W = new Array(160)\n\n  function Sha512() {\n    this.init()\n    this._w = W\n\n    Hash.call(this, 128, 112)\n  }\n\n  inherits(Sha512, Hash)\n\n  Sha512.prototype.init = function () {\n\n    this._a = 0x6a09e667|0\n    this._b = 0xbb67ae85|0\n    this._c = 0x3c6ef372|0\n    this._d = 0xa54ff53a|0\n    this._e = 0x510e527f|0\n    this._f = 0x9b05688c|0\n    this._g = 0x1f83d9ab|0\n    this._h = 0x5be0cd19|0\n\n    this._al = 0xf3bcc908|0\n    this._bl = 0x84caa73b|0\n    this._cl = 0xfe94f82b|0\n    this._dl = 0x5f1d36f1|0\n    this._el = 0xade682d1|0\n    this._fl = 0x2b3e6c1f|0\n    this._gl = 0xfb41bd6b|0\n    this._hl = 0x137e2179|0\n\n    this._len = this._s = 0\n\n    return this\n  }\n\n  function S (X, Xl, n) {\n    return (X >>> n) | (Xl << (32 - n))\n  }\n\n  function Ch (x, y, z) {\n    return ((x & y) ^ ((~x) & z));\n  }\n\n  function Maj (x, y, z) {\n    return ((x & y) ^ (x & z) ^ (y & z));\n  }\n\n  Sha512.prototype._update = function(M) {\n\n    var W = this._w\n    var a, b, c, d, e, f, g, h\n    var al, bl, cl, dl, el, fl, gl, hl\n\n    a = this._a | 0\n    b = this._b | 0\n    c = this._c | 0\n    d = this._d | 0\n    e = this._e | 0\n    f = this._f | 0\n    g = this._g | 0\n    h = this._h | 0\n\n    al = this._al | 0\n    bl = this._bl | 0\n    cl = this._cl | 0\n    dl = this._dl | 0\n    el = this._el | 0\n    fl = this._fl | 0\n    gl = this._gl | 0\n    hl = this._hl | 0\n\n    for (var i = 0; i < 80; i++) {\n      var j = i * 2\n\n      var Wi, Wil\n\n      if (i < 16) {\n        Wi = W[j] = M.readInt32BE(j * 4)\n        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)\n\n      } else {\n        var x  = W[j - 15*2]\n        var xl = W[j - 15*2 + 1]\n        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)\n        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)\n\n        x  = W[j - 2*2]\n        xl = W[j - 2*2 + 1]\n        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)\n        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)\n\n        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n        var Wi7  = W[j - 7*2]\n        var Wi7l = W[j - 7*2 + 1]\n\n        var Wi16  = W[j - 16*2]\n        var Wi16l = W[j - 16*2 + 1]\n\n        Wil = gamma0l + Wi7l\n        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)\n        Wil = Wil + gamma1l\n        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)\n        Wil = Wil + Wi16l\n        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)\n\n        W[j] = Wi\n        W[j + 1] = Wil\n      }\n\n      var maj = Maj(a, b, c)\n      var majl = Maj(al, bl, cl)\n\n      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)\n      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)\n      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)\n      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)\n\n      // t1 = h + sigma1 + ch + K[i] + W[i]\n      var Ki = K[j]\n      var Kil = K[j + 1]\n\n      var ch = Ch(e, f, g)\n      var chl = Ch(el, fl, gl)\n\n      var t1l = hl + sigma1l\n      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)\n      t1l = t1l + chl\n      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)\n      t1l = t1l + Kil\n      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)\n      t1l = t1l + Wil\n      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl\n      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)\n\n      h  = g\n      hl = gl\n      g  = f\n      gl = fl\n      f  = e\n      fl = el\n      el = (dl + t1l) | 0\n      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0\n      d  = c\n      dl = cl\n      c  = b\n      cl = bl\n      b  = a\n      bl = al\n      al = (t1l + t2l) | 0\n      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0\n    }\n\n    this._al = (this._al + al) | 0\n    this._bl = (this._bl + bl) | 0\n    this._cl = (this._cl + cl) | 0\n    this._dl = (this._dl + dl) | 0\n    this._el = (this._el + el) | 0\n    this._fl = (this._fl + fl) | 0\n    this._gl = (this._gl + gl) | 0\n    this._hl = (this._hl + hl) | 0\n\n    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0\n    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0\n    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0\n    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0\n    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0\n    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0\n    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0\n    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0\n  }\n\n  Sha512.prototype._hash = function () {\n    var H = new Buffer(64)\n\n    function writeInt64BE(h, l, offset) {\n      H.writeInt32BE(h, offset)\n      H.writeInt32BE(l, offset + 4)\n    }\n\n    writeInt64BE(this._a, this._al, 0)\n    writeInt64BE(this._b, this._bl, 8)\n    writeInt64BE(this._c, this._cl, 16)\n    writeInt64BE(this._d, this._dl, 24)\n    writeInt64BE(this._e, this._el, 32)\n    writeInt64BE(this._f, this._fl, 40)\n    writeInt64BE(this._g, this._gl, 48)\n    writeInt64BE(this._h, this._hl, 56)\n\n    return H\n  }\n\n  return Sha512\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sha.js/sha512.js\n// module id = 71\n// module chunks = 0","/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\nvar helpers = require('./helpers');\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length\n */\nfunction core_md5(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << ((len) % 32);\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n  }\n  return Array(a, b, c, d);\n\n}\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5_cmn(q, a, b, x, s, t)\n{\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\n}\nfunction md5_ff(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n}\nfunction md5_gg(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n}\nfunction md5_hh(a, b, c, d, x, s, t)\n{\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5_ii(a, b, c, d, x, s, t)\n{\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bit_rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function md5(buf) {\n  return helpers.hash(buf, core_md5, 16);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/crypto-browserify/md5.js\n// module id = 72\n// module chunks = 0","var intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\n\nmodule.exports = { hash: hash };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/crypto-browserify/helpers.js\n// module id = 73\n// module chunks = 0","\nmodule.exports = ripemd160\n\n\n\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n/** @preserve\n(c) 2012 by Cdric Mesnil. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// Constants table\nvar zl = [\n    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,\n    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,\n    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,\n    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];\nvar zr = [\n    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,\n    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,\n    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,\n    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,\n    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];\nvar sl = [\n     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,\n    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,\n    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,\n      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,\n    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];\nvar sr = [\n    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,\n    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,\n    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,\n    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,\n    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];\n\nvar hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];\nvar hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];\n\nvar bytesToWords = function (bytes) {\n  var words = [];\n  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {\n    words[b >>> 5] |= bytes[i] << (24 - b % 32);\n  }\n  return words;\n};\n\nvar wordsToBytes = function (words) {\n  var bytes = [];\n  for (var b = 0; b < words.length * 32; b += 8) {\n    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n  }\n  return bytes;\n};\n\nvar processBlock = function (H, M, offset) {\n\n  // Swap endian\n  for (var i = 0; i < 16; i++) {\n    var offset_i = offset + i;\n    var M_offset_i = M[offset_i];\n\n    // Swap\n    M[offset_i] = (\n        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n    );\n  }\n\n  // Working variables\n  var al, bl, cl, dl, el;\n  var ar, br, cr, dr, er;\n\n  ar = al = H[0];\n  br = bl = H[1];\n  cr = cl = H[2];\n  dr = dl = H[3];\n  er = el = H[4];\n  // Computation\n  var t;\n  for (var i = 0; i < 80; i += 1) {\n    t = (al +  M[offset+zl[i]])|0;\n    if (i<16){\n        t +=  f1(bl,cl,dl) + hl[0];\n    } else if (i<32) {\n        t +=  f2(bl,cl,dl) + hl[1];\n    } else if (i<48) {\n        t +=  f3(bl,cl,dl) + hl[2];\n    } else if (i<64) {\n        t +=  f4(bl,cl,dl) + hl[3];\n    } else {// if (i<80) {\n        t +=  f5(bl,cl,dl) + hl[4];\n    }\n    t = t|0;\n    t =  rotl(t,sl[i]);\n    t = (t+el)|0;\n    al = el;\n    el = dl;\n    dl = rotl(cl, 10);\n    cl = bl;\n    bl = t;\n\n    t = (ar + M[offset+zr[i]])|0;\n    if (i<16){\n        t +=  f5(br,cr,dr) + hr[0];\n    } else if (i<32) {\n        t +=  f4(br,cr,dr) + hr[1];\n    } else if (i<48) {\n        t +=  f3(br,cr,dr) + hr[2];\n    } else if (i<64) {\n        t +=  f2(br,cr,dr) + hr[3];\n    } else {// if (i<80) {\n        t +=  f1(br,cr,dr) + hr[4];\n    }\n    t = t|0;\n    t =  rotl(t,sr[i]) ;\n    t = (t+er)|0;\n    ar = er;\n    er = dr;\n    dr = rotl(cr, 10);\n    cr = br;\n    br = t;\n  }\n  // Intermediate hash value\n  t    = (H[1] + cl + dr)|0;\n  H[1] = (H[2] + dl + er)|0;\n  H[2] = (H[3] + el + ar)|0;\n  H[3] = (H[4] + al + br)|0;\n  H[4] = (H[0] + bl + cr)|0;\n  H[0] =  t;\n};\n\nfunction f1(x, y, z) {\n  return ((x) ^ (y) ^ (z));\n}\n\nfunction f2(x, y, z) {\n  return (((x)&(y)) | ((~x)&(z)));\n}\n\nfunction f3(x, y, z) {\n  return (((x) | (~(y))) ^ (z));\n}\n\nfunction f4(x, y, z) {\n  return (((x) & (z)) | ((y)&(~(z))));\n}\n\nfunction f5(x, y, z) {\n  return ((x) ^ ((y) |(~(z))));\n}\n\nfunction rotl(x,n) {\n  return (x<<n) | (x>>>(32-n));\n}\n\nfunction ripemd160(message) {\n  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];\n\n  if (typeof message == 'string')\n    message = new Buffer(message, 'utf8');\n\n  var m = bytesToWords(message);\n\n  var nBitsLeft = message.length * 8;\n  var nBitsTotal = message.length * 8;\n\n  // Add padding\n  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |\n      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)\n  );\n\n  for (var i=0 ; i<m.length; i += 16) {\n    processBlock(H, m, i);\n  }\n\n  // Swap endian\n  for (var i = 0; i < 5; i++) {\n      // Shortcut\n    var H_i = H[i];\n\n    // Swap\n    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n  }\n\n  var digestbytes = wordsToBytes(H);\n  return new Buffer(digestbytes);\n}\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ripemd160/lib/ripemd160.js\n// module id = 74\n// module chunks = 0","var createHash = require('./create-hash')\n\nvar zeroBuffer = new Buffer(128)\nzeroBuffer.fill(0)\n\nmodule.exports = Hmac\n\nfunction Hmac (alg, key) {\n  if(!(this instanceof Hmac)) return new Hmac(alg, key)\n  this._opad = opad\n  this._alg = alg\n\n  var blocksize = (alg === 'sha512') ? 128 : 64\n\n  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key\n\n  if(key.length > blocksize) {\n    key = createHash(alg).update(key).digest()\n  } else if(key.length < blocksize) {\n    key = Buffer.concat([key, zeroBuffer], blocksize)\n  }\n\n  var ipad = this._ipad = new Buffer(blocksize)\n  var opad = this._opad = new Buffer(blocksize)\n\n  for(var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  this._hash = createHash(alg).update(ipad)\n}\n\nHmac.prototype.update = function (data, enc) {\n  this._hash.update(data, enc)\n  return this\n}\n\nHmac.prototype.digest = function (enc) {\n  var h = this._hash.digest()\n  return createHash(this._alg).update(this._opad).update(h).digest(enc)\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/crypto-browserify/create-hmac.js\n// module id = 75\n// module chunks = 0","var pbkdf2Export = require('pbkdf2-compat/pbkdf2')\n\nmodule.exports = function (crypto, exports) {\n  exports = exports || {}\n\n  var exported = pbkdf2Export(crypto)\n\n  exports.pbkdf2 = exported.pbkdf2\n  exports.pbkdf2Sync = exported.pbkdf2Sync\n\n  return exports\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/crypto-browserify/pbkdf2.js\n// module id = 76\n// module chunks = 0","module.exports = function(crypto) {\n  function pbkdf2(password, salt, iterations, keylen, digest, callback) {\n    if ('function' === typeof digest) {\n      callback = digest\n      digest = undefined\n    }\n\n    if ('function' !== typeof callback)\n      throw new Error('No callback provided to pbkdf2')\n\n    setTimeout(function() {\n      var result\n\n      try {\n        result = pbkdf2Sync(password, salt, iterations, keylen, digest)\n      } catch (e) {\n        return callback(e)\n      }\n\n      callback(undefined, result)\n    })\n  }\n\n  function pbkdf2Sync(password, salt, iterations, keylen, digest) {\n    if ('number' !== typeof iterations)\n      throw new TypeError('Iterations not a number')\n\n    if (iterations < 0)\n      throw new TypeError('Bad iterations')\n\n    if ('number' !== typeof keylen)\n      throw new TypeError('Key length not a number')\n\n    if (keylen < 0)\n      throw new TypeError('Bad key length')\n\n    digest = digest || 'sha1'\n\n    if (!Buffer.isBuffer(password)) password = new Buffer(password)\n    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)\n\n    var hLen, l = 1, r, T\n    var DK = new Buffer(keylen)\n    var block1 = new Buffer(salt.length + 4)\n    salt.copy(block1, 0, 0, salt.length)\n\n    for (var i = 1; i <= l; i++) {\n      block1.writeUInt32BE(i, salt.length)\n\n      var U = crypto.createHmac(digest, password).update(block1).digest()\n\n      if (!hLen) {\n        hLen = U.length\n        T = new Buffer(hLen)\n        l = Math.ceil(keylen / hLen)\n        r = keylen - (l - 1) * hLen\n\n        if (keylen > (Math.pow(2, 32) - 1) * hLen)\n          throw new TypeError('keylen exceeds maximum length')\n      }\n\n      U.copy(T, 0, 0, hLen)\n\n      for (var j = 1; j < iterations; j++) {\n        U = crypto.createHmac(digest, password).update(U).digest()\n\n        for (var k = 0; k < hLen; k++) {\n          T[k] ^= U[k]\n        }\n      }\n\n      var destPos = (i - 1) * hLen\n      var len = (i == l ? r : hLen)\n      T.copy(DK, destPos, 0, len)\n    }\n\n    return DK\n  }\n\n  return {\n    pbkdf2: pbkdf2,\n    pbkdf2Sync: pbkdf2Sync\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pbkdf2-compat/pbkdf2.js\n// module id = 77\n// module chunks = 0","module.exports = function (crypto, exports) {\n  exports = exports || {};\n  var ciphers = require('./encrypter')(crypto);\n  exports.createCipher = ciphers.createCipher;\n  exports.createCipheriv = ciphers.createCipheriv;\n  var deciphers = require('./decrypter')(crypto);\n  exports.createDecipher = deciphers.createDecipher;\n  exports.createDecipheriv = deciphers.createDecipheriv;\n  var modes = require('./modes');\n  function listCiphers () {\n    return Object.keys(modes);\n  }\n  exports.listCiphers = listCiphers;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/inject.js\n// module id = 78\n// module chunks = 0","var aes = require('./aes');\nvar Transform = require('./cipherBase');\nvar inherits = require('inherits');\nvar modes = require('./modes');\nvar ebtk = require('./EVP_BytesToKey');\nvar StreamCipher = require('./streamCipher');\ninherits(Cipher, Transform);\nfunction Cipher(mode, key, iv) {\n  if (!(this instanceof Cipher)) {\n    return new Cipher(mode, key, iv);\n  }\n  Transform.call(this);\n  this._cache = new Splitter();\n  this._cipher = new aes.AES(key);\n  this._prev = new Buffer(iv.length);\n  iv.copy(this._prev);\n  this._mode = mode;\n}\nCipher.prototype._transform = function (data, _, next) {\n  this._cache.add(data);\n  var chunk;\n  var thing;\n  while ((chunk = this._cache.get())) {\n    thing = this._mode.encrypt(this, chunk);\n    this.push(thing);\n  }\n  next();\n};\nCipher.prototype._flush = function (next) {\n  var chunk = this._cache.flush();\n  this.push(this._mode.encrypt(this, chunk));\n  this._cipher.scrub();\n  next();\n};\n\n\nfunction Splitter() {\n   if (!(this instanceof Splitter)) {\n    return new Splitter();\n  }\n  this.cache = new Buffer('');\n}\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data]);\n};\n\nSplitter.prototype.get = function () {\n  if (this.cache.length > 15) {\n    var out = this.cache.slice(0, 16);\n    this.cache = this.cache.slice(16);\n    return out;\n  }\n  return null;\n};\nSplitter.prototype.flush = function () {\n  var len = 16 - this.cache.length;\n  var padBuff = new Buffer(len);\n\n  var i = -1;\n  while (++i < len) {\n    padBuff.writeUInt8(len, i);\n  }\n  var out = Buffer.concat([this.cache, padBuff]);\n  return out;\n};\nvar modelist = {\n  ECB: require('./modes/ecb'),\n  CBC: require('./modes/cbc'),\n  CFB: require('./modes/cfb'),\n  OFB: require('./modes/ofb'),\n  CTR: require('./modes/ctr')\n};\nmodule.exports = function (crypto) {\n  function createCipheriv(suite, password, iv) {\n    var config = modes[suite];\n    if (!config) {\n      throw new TypeError('invalid suite type');\n    }\n    if (typeof iv === 'string') {\n      iv = new Buffer(iv);\n    }\n    if (typeof password === 'string') {\n      password = new Buffer(password);\n    }\n    if (password.length !== config.key/8) {\n      throw new TypeError('invalid key length ' + password.length);\n    }\n    if (iv.length !== config.iv) {\n      throw new TypeError('invalid iv length ' + iv.length);\n    }\n    if (config.type === 'stream') {\n      return new StreamCipher(modelist[config.mode], password, iv);\n    }\n    return new Cipher(modelist[config.mode], password, iv);\n  }\n  function createCipher (suite, password) {\n    var config = modes[suite];\n    if (!config) {\n      throw new TypeError('invalid suite type');\n    }\n    var keys = ebtk(crypto, password, config.key, config.iv);\n    return createCipheriv(suite, keys.key, keys.iv);\n  }\n  return {\n    createCipher: createCipher,\n    createCipheriv: createCipheriv\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/encrypter.js\n// module id = 79\n// module chunks = 0","var uint_max = Math.pow(2, 32);\nfunction fixup_uint32(x) {\n    var ret, x_pos;\n    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;\n    return ret;\n}\nfunction scrub_vec(v) {\n  var i, _i, _ref;\n  for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n    v[i] = 0;\n  }\n  return false;\n}\n\nfunction Global() {\n  var i;\n  this.SBOX = [];\n  this.INV_SBOX = [];\n  this.SUB_MIX = (function() {\n    var _i, _results;\n    _results = [];\n    for (i = _i = 0; _i < 4; i = ++_i) {\n      _results.push([]);\n    }\n    return _results;\n  })();\n  this.INV_SUB_MIX = (function() {\n    var _i, _results;\n    _results = [];\n    for (i = _i = 0; _i < 4; i = ++_i) {\n      _results.push([]);\n    }\n    return _results;\n  })();\n  this.init();\n  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n}\n\nGlobal.prototype.init = function() {\n  var d, i, sx, t, x, x2, x4, x8, xi, _i;\n  d = (function() {\n    var _i, _results;\n    _results = [];\n    for (i = _i = 0; _i < 256; i = ++_i) {\n      if (i < 128) {\n        _results.push(i << 1);\n      } else {\n        _results.push((i << 1) ^ 0x11b);\n      }\n    }\n    return _results;\n  })();\n  x = 0;\n  xi = 0;\n  for (i = _i = 0; _i < 256; i = ++_i) {\n    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n    this.SBOX[x] = sx;\n    this.INV_SBOX[sx] = x;\n    x2 = d[x];\n    x4 = d[x2];\n    x8 = d[x4];\n    t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);\n    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);\n    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);\n    this.SUB_MIX[3][x] = t;\n    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);\n    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);\n    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);\n    this.INV_SUB_MIX[3][sx] = t;\n    if (x === 0) {\n      x = xi = 1;\n    } else {\n      x = x2 ^ d[d[d[x8 ^ x2]]];\n      xi ^= d[d[xi]];\n    }\n  }\n  return true;\n};\n\nvar G = new Global();\n\n\nAES.blockSize = 4 * 4;\n\nAES.prototype.blockSize = AES.blockSize;\n\nAES.keySize = 256 / 8;\n\nAES.prototype.keySize = AES.keySize;\n\nAES.ivSize = AES.blockSize;\n\nAES.prototype.ivSize = AES.ivSize;\n\n function bufferToArray(buf) {\n  var len = buf.length/4;\n  var out = new Array(len);\n  var i = -1;\n  while (++i < len) {\n    out[i] = buf.readUInt32BE(i * 4);\n  }\n  return out;\n }\nfunction AES(key) {\n  this._key = bufferToArray(key);\n  this._doReset();\n}\n\nAES.prototype._doReset = function() {\n  var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;\n  keyWords = this._key;\n  keySize = keyWords.length;\n  this._nRounds = keySize + 6;\n  ksRows = (this._nRounds + 1) * 4;\n  this._keySchedule = [];\n  for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {\n    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);\n  }\n  this._invKeySchedule = [];\n  for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {\n    ksRow = ksRows - invKsRow;\n    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];\n    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];\n  }\n  return true;\n};\n\nAES.prototype.encryptBlock = function(M) {\n  M = bufferToArray(new Buffer(M));\n  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);\n  var buf = new Buffer(16);\n  buf.writeUInt32BE(out[0], 0);\n  buf.writeUInt32BE(out[1], 4);\n  buf.writeUInt32BE(out[2], 8);\n  buf.writeUInt32BE(out[3], 12);\n  return buf;\n};\n\nAES.prototype.decryptBlock = function(M) {\n  M = bufferToArray(new Buffer(M));\n  var temp = [M[3], M[1]];\n  M[1] = temp[0];\n  M[3] = temp[1];\n  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);\n  var buf = new Buffer(16);\n  buf.writeUInt32BE(out[0], 0);\n  buf.writeUInt32BE(out[3], 4);\n  buf.writeUInt32BE(out[2], 8);\n  buf.writeUInt32BE(out[1], 12);\n  return buf;\n};\n\nAES.prototype.scrub = function() {\n  scrub_vec(this._keySchedule);\n  scrub_vec(this._invKeySchedule);\n  scrub_vec(this._key);\n};\n\nAES.prototype._doCryptBlock = function(M, keySchedule, SUB_MIX, SBOX) {\n  var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;\n\n  s0 = M[0] ^ keySchedule[0];\n  s1 = M[1] ^ keySchedule[1];\n  s2 = M[2] ^ keySchedule[2];\n  s3 = M[3] ^ keySchedule[3];\n  ksRow = 4;\n  for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {\n    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];\n    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];\n    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];\n    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];\n    s0 = t0;\n    s1 = t1;\n    s2 = t2;\n    s3 = t3;\n  }\n  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n  return [\n    fixup_uint32(t0),\n    fixup_uint32(t1),\n    fixup_uint32(t2),\n    fixup_uint32(t3)\n  ];\n\n};\n\n\n\n\n  exports.AES = AES;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/aes.js\n// module id = 80\n// module chunks = 0","var Transform = require('stream').Transform;\nvar inherits = require('inherits');\n\nmodule.exports = CipherBase;\ninherits(CipherBase, Transform);\nfunction CipherBase() {\n  Transform.call(this);\n}\nCipherBase.prototype.update = function (data, inputEnd, outputEnc) {\n  this.write(data, inputEnd);\n  var outData = new Buffer('');\n  var chunk;\n  while ((chunk = this.read())) {\n    outData = Buffer.concat([outData, chunk]);\n  }\n  if (outputEnc) {\n    outData = outData.toString(outputEnc);\n  }\n  return outData;\n};\nCipherBase.prototype.final = function (outputEnc) {\n  this.end();\n  var outData = new Buffer('');\n  var chunk;\n  while ((chunk = this.read())) {\n    outData = Buffer.concat([outData, chunk]);\n  }\n  if (outputEnc) {\n    outData = outData.toString(outputEnc);\n  }\n  return outData;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/cipherBase.js\n// module id = 81\n// module chunks = 0","exports['aes-128-ecb'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 0,\n  mode: 'ECB',\n  type: 'block'\n};\nexports['aes-192-ecb'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 0,\n  mode: 'ECB',\n  type: 'block'\n};\nexports['aes-256-ecb'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 0,\n  mode: 'ECB',\n  type: 'block'\n};\nexports['aes-128-cbc'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'CBC',\n  type: 'block'\n};\nexports['aes-192-cbc'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'CBC',\n  type: 'block'\n};\nexports['aes-256-cbc'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'CBC',\n  type: 'block'\n};\nexports['aes128'] = exports['aes-128-cbc'];\nexports['aes192'] = exports['aes-192-cbc'];\nexports['aes256'] = exports['aes-256-cbc'];\nexports['aes-128-cfb'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'CFB',\n  type: 'stream'\n};\nexports['aes-192-cfb'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'CFB',\n  type: 'stream'\n};\nexports['aes-256-cfb'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'CFB',\n  type: 'stream'\n};\nexports['aes-128-ofb'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'OFB',\n  type: 'stream'\n};\nexports['aes-192-ofb'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'OFB',\n  type: 'stream'\n};\nexports['aes-256-ofb'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'OFB',\n  type: 'stream'\n};\nexports['aes-128-ctr'] = {\n  cipher: 'AES',\n  key: 128,\n  iv: 16,\n  mode: 'CTR',\n  type: 'stream'\n};\nexports['aes-192-ctr'] = {\n  cipher: 'AES',\n  key: 192,\n  iv: 16,\n  mode: 'CTR',\n  type: 'stream'\n};\nexports['aes-256-ctr'] = {\n  cipher: 'AES',\n  key: 256,\n  iv: 16,\n  mode: 'CTR',\n  type: 'stream'\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/modes.js\n// module id = 82\n// module chunks = 0","\nmodule.exports = function (crypto, password, keyLen, ivLen) {\n  keyLen = keyLen/8;\n  ivLen = ivLen || 0;\n  var ki = 0;\n  var ii = 0;\n  var key = new Buffer(keyLen);\n  var iv = new Buffer(ivLen);\n  var addmd = 0;\n  var md, md_buf;\n  var i;\n  while (true) {\n    md = crypto.createHash('md5');\n    if(addmd++ > 0) {\n       md.update(md_buf);\n    }\n    md.update(password);\n    md_buf = md.digest();\n    i = 0;\n    if(keyLen > 0) {\n      while(true) {\n        if(keyLen === 0) {\n          break;\n        }\n        if(i === md_buf.length) {\n          break;\n        }\n        key[ki++] = md_buf[i];\n        keyLen--;\n        i++;\n       }\n    }\n    if(ivLen > 0 && i !== md_buf.length) {\n      while(true) {\n        if(ivLen === 0) {\n          break;\n        }\n        if(i === md_buf.length) {\n          break;\n        }\n       iv[ii++] = md_buf[i];\n       ivLen--;\n       i++;\n     }\n   }\n   if(keyLen === 0 && ivLen === 0) {\n      break;\n    }\n  }\n  for(i=0;i<md_buf.length;i++) {\n    md_buf[i] = 0;\n  }\n  return {\n    key: key,\n    iv: iv\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/EVP_BytesToKey.js\n// module id = 83\n// module chunks = 0","var aes = require('./aes');\nvar Transform = require('./cipherBase');\nvar inherits = require('inherits');\n\ninherits(StreamCipher, Transform);\nmodule.exports = StreamCipher;\nfunction StreamCipher(mode, key, iv, decrypt) {\n  if (!(this instanceof StreamCipher)) {\n    return new StreamCipher(mode, key, iv);\n  }\n  Transform.call(this);\n  this._cipher = new aes.AES(key);\n  this._prev = new Buffer(iv.length);\n  this._cache = new Buffer('');\n  this._secCache = new Buffer('');\n  this._decrypt = decrypt;\n  iv.copy(this._prev);\n  this._mode = mode;\n}\nStreamCipher.prototype._transform = function (chunk, _, next) {\n  next(null, this._mode.encrypt(this, chunk, this._decrypt));\n};\nStreamCipher.prototype._flush = function (next) {\n  this._cipher.scrub();\n  next();\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/streamCipher.js\n// module id = 84\n// module chunks = 0","exports.encrypt = function (self, block) {\n  return self._cipher.encryptBlock(block);\n};\nexports.decrypt = function (self, block) {\n  return self._cipher.decryptBlock(block);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/modes/ecb.js\n// module id = 85\n// module chunks = 0","var xor = require('../xor');\nexports.encrypt = function (self, block) {\n  var data = xor(block, self._prev);\n  self._prev = self._cipher.encryptBlock(data);\n  return self._prev;\n};\nexports.decrypt = function (self, block) {\n  var pad = self._prev;\n  self._prev = block;\n  var out = self._cipher.decryptBlock(block);\n  return xor(out, pad);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/modes/cbc.js\n// module id = 86\n// module chunks = 0","module.exports = xor;\nfunction xor(a, b) {\n  var len = Math.min(a.length, b.length);\n  var out = new Buffer(len);\n  var i = -1;\n  while (++i < len) {\n    out.writeUInt8(a[i] ^ b[i], i);\n  }\n  return out;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/xor.js\n// module id = 87\n// module chunks = 0","var xor = require('../xor');\nexports.encrypt = function (self, data, decrypt) {\n  var out = new Buffer('');\n  var len;\n  while (data.length) {\n    if (self._cache.length === 0) {\n      self._cache = self._cipher.encryptBlock(self._prev);\n      self._prev = new Buffer('');\n    }\n    if (self._cache.length <= data.length) {\n      len = self._cache.length;\n      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);\n      data = data.slice(len);\n    } else {\n      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);\n      break;\n    }\n  }\n  return out;\n};\nfunction encryptStart(self, data, decrypt) {\n  var len = data.length;\n  var out = xor(data, self._cache);\n  self._cache = self._cache.slice(len);\n  self._prev = Buffer.concat([self._prev, decrypt?data:out]);\n  return out;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/modes/cfb.js\n// module id = 88\n// module chunks = 0","var xor = require('../xor');\nfunction getBlock(self) {\n  self._prev = self._cipher.encryptBlock(self._prev);\n  return self._prev;\n}\nexports.encrypt = function (self, chunk) {\n  while (self._cache.length < chunk.length) {\n    self._cache = Buffer.concat([self._cache, getBlock(self)]);\n  }\n  var pad = self._cache.slice(0, chunk.length);\n  self._cache = self._cache.slice(chunk.length);\n  return xor(chunk, pad);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/modes/ofb.js\n// module id = 89\n// module chunks = 0","var xor = require('../xor');\nfunction getBlock(self) {\n  var out = self._cipher.encryptBlock(self._prev);\n  incr32(self._prev);\n  return out;\n}\nexports.encrypt = function (self, chunk) {\n  while (self._cache.length < chunk.length) {\n    self._cache = Buffer.concat([self._cache, getBlock(self)]);\n  }\n  var pad = self._cache.slice(0, chunk.length);\n  self._cache = self._cache.slice(chunk.length);\n  return xor(chunk, pad);\n};\nfunction incr32(iv) {\n  var len = iv.length;\n  var item;\n  while (len--) {\n    item = iv.readUInt8(len);\n    if (item === 255) {\n      iv.writeUInt8(0, len);\n    } else {\n      item++;\n      iv.writeUInt8(item, len);\n      break;\n    }\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/modes/ctr.js\n// module id = 90\n// module chunks = 0","var aes = require('./aes');\nvar Transform = require('./cipherBase');\nvar inherits = require('inherits');\nvar modes = require('./modes');\nvar StreamCipher = require('./streamCipher');\nvar ebtk = require('./EVP_BytesToKey');\n\ninherits(Decipher, Transform);\nfunction Decipher(mode, key, iv) {\n  if (!(this instanceof Decipher)) {\n    return new Decipher(mode, key, iv);\n  }\n  Transform.call(this);\n  this._cache = new Splitter();\n  this._last = void 0;\n  this._cipher = new aes.AES(key);\n  this._prev = new Buffer(iv.length);\n  iv.copy(this._prev);\n  this._mode = mode;\n}\nDecipher.prototype._transform = function (data, _, next) {\n  this._cache.add(data);\n  var chunk;\n  var thing;\n  while ((chunk = this._cache.get())) {\n    thing = this._mode.decrypt(this, chunk);\n    this.push(thing);\n  }\n  next();\n};\nDecipher.prototype._flush = function (next) {\n  var chunk = this._cache.flush();\n  if (!chunk) {\n    return next;\n  }\n\n  this.push(unpad(this._mode.decrypt(this, chunk)));\n\n  next();\n};\n\nfunction Splitter() {\n   if (!(this instanceof Splitter)) {\n    return new Splitter();\n  }\n  this.cache = new Buffer('');\n}\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data]);\n};\n\nSplitter.prototype.get = function () {\n  if (this.cache.length > 16) {\n    var out = this.cache.slice(0, 16);\n    this.cache = this.cache.slice(16);\n    return out;\n  }\n  return null;\n};\nSplitter.prototype.flush = function () {\n  if (this.cache.length) {\n    return this.cache;\n  }\n};\nfunction unpad(last) {\n  var padded = last[15];\n  if (padded === 16) {\n    return;\n  }\n  return last.slice(0, 16 - padded);\n}\n\nvar modelist = {\n  ECB: require('./modes/ecb'),\n  CBC: require('./modes/cbc'),\n  CFB: require('./modes/cfb'),\n  OFB: require('./modes/ofb'),\n  CTR: require('./modes/ctr')\n};\n\nmodule.exports = function (crypto) {\n  function createDecipheriv(suite, password, iv) {\n    var config = modes[suite];\n    if (!config) {\n      throw new TypeError('invalid suite type');\n    }\n    if (typeof iv === 'string') {\n      iv = new Buffer(iv);\n    }\n    if (typeof password === 'string') {\n      password = new Buffer(password);\n    }\n    if (password.length !== config.key/8) {\n      throw new TypeError('invalid key length ' + password.length);\n    }\n    if (iv.length !== config.iv) {\n      throw new TypeError('invalid iv length ' + iv.length);\n    }\n    if (config.type === 'stream') {\n      return new StreamCipher(modelist[config.mode], password, iv, true);\n    }\n    return new Decipher(modelist[config.mode], password, iv);\n  }\n\n  function createDecipher (suite, password) {\n    var config = modes[suite];\n    if (!config) {\n      throw new TypeError('invalid suite type');\n    }\n    var keys = ebtk(crypto, password, config.key, config.iv);\n    return createDecipheriv(suite, keys.key, keys.iv);\n  }\n  return {\n    createDecipher: createDecipher,\n    createDecipheriv: createDecipheriv\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-aes/decrypter.js\n// module id = 91\n// module chunks = 0","var map = {\n\t\"./agent\": 93,\n\t\"./agent.js\": 93,\n\t\"./aws-info\": 100,\n\t\"./aws-info.js\": 100,\n\t\"./collector/api\": 97,\n\t\"./collector/api.js\": 97,\n\t\"./collector/facts\": 98,\n\t\"./collector/facts.js\": 98,\n\t\"./collector/http-agents\": 154,\n\t\"./collector/http-agents.js\": 154,\n\t\"./collector/parse-response\": 152,\n\t\"./collector/parse-response.js\": 152,\n\t\"./collector/remote-method\": 136,\n\t\"./collector/remote-method.js\": 136,\n\t\"./collector/ssl/certificates\": 165,\n\t\"./collector/ssl/certificates.js\": 165,\n\t\"./config\": 57,\n\t\"./config.default\": 192,\n\t\"./config.default.js\": 192,\n\t\"./config.js\": 57,\n\t\"./db/parse-sql\": 193,\n\t\"./db/parse-sql.js\": 193,\n\t\"./db/parsed-statement\": 195,\n\t\"./db/parsed-statement.js\": 195,\n\t\"./db/statement-matcher\": 194,\n\t\"./db/statement-matcher.js\": 194,\n\t\"./db/tracer\": 182,\n\t\"./db/tracer.js\": 182,\n\t\"./db/util\": 196,\n\t\"./db/util.js\": 196,\n\t\"./environment\": 185,\n\t\"./environment.js\": 185,\n\t\"./errors/aggregator\": 166,\n\t\"./errors/aggregator.js\": 166,\n\t\"./errors/index\": 169,\n\t\"./errors/index.js\": 169,\n\t\"./feature_flags\": 60,\n\t\"./feature_flags.js\": 60,\n\t\"./instrumentation/bluebird\": 197,\n\t\"./instrumentation/bluebird.js\": 197,\n\t\"./instrumentation/cassandra-driver\": 200,\n\t\"./instrumentation/cassandra-driver.js\": 200,\n\t\"./instrumentation/connect\": 201,\n\t\"./instrumentation/connect.js\": 201,\n\t\"./instrumentation/core/child_process\": 202,\n\t\"./instrumentation/core/child_process.js\": 202,\n\t\"./instrumentation/core/crypto\": 203,\n\t\"./instrumentation/core/crypto.js\": 203,\n\t\"./instrumentation/core/dns\": 204,\n\t\"./instrumentation/core/dns.js\": 204,\n\t\"./instrumentation/core/domain\": 205,\n\t\"./instrumentation/core/domain.js\": 205,\n\t\"./instrumentation/core/fs\": 206,\n\t\"./instrumentation/core/fs.js\": 206,\n\t\"./instrumentation/core/globals\": 208,\n\t\"./instrumentation/core/globals.js\": 208,\n\t\"./instrumentation/core/http\": 209,\n\t\"./instrumentation/core/http.js\": 209,\n\t\"./instrumentation/core/net\": 215,\n\t\"./instrumentation/core/net.js\": 215,\n\t\"./instrumentation/core/timers\": 216,\n\t\"./instrumentation/core/timers.js\": 216,\n\t\"./instrumentation/core/zlib\": 217,\n\t\"./instrumentation/core/zlib.js\": 217,\n\t\"./instrumentation/director\": 218,\n\t\"./instrumentation/director.js\": 218,\n\t\"./instrumentation/express\": 219,\n\t\"./instrumentation/express.js\": 219,\n\t\"./instrumentation/express/common\": 222,\n\t\"./instrumentation/express/common.js\": 222,\n\t\"./instrumentation/express/express-2\": 221,\n\t\"./instrumentation/express/express-2.js\": 221,\n\t\"./instrumentation/generic-pool\": 223,\n\t\"./instrumentation/generic-pool.js\": 223,\n\t\"./instrumentation/hapi\": 224,\n\t\"./instrumentation/hapi.js\": 224,\n\t\"./instrumentation/ioredis\": 225,\n\t\"./instrumentation/ioredis.js\": 225,\n\t\"./instrumentation/memcached\": 227,\n\t\"./instrumentation/memcached.js\": 227,\n\t\"./instrumentation/mongodb\": 229,\n\t\"./instrumentation/mongodb.js\": 229,\n\t\"./instrumentation/mysql\": 230,\n\t\"./instrumentation/mysql.js\": 230,\n\t\"./instrumentation/node-cassandra-cql\": 231,\n\t\"./instrumentation/node-cassandra-cql.js\": 231,\n\t\"./instrumentation/oracle\": 233,\n\t\"./instrumentation/oracle.js\": 233,\n\t\"./instrumentation/pg\": 234,\n\t\"./instrumentation/pg.js\": 234,\n\t\"./instrumentation/promise\": 198,\n\t\"./instrumentation/promise.js\": 198,\n\t\"./instrumentation/q\": 235,\n\t\"./instrumentation/q.js\": 235,\n\t\"./instrumentation/redis\": 236,\n\t\"./instrumentation/redis.js\": 236,\n\t\"./instrumentation/restify\": 237,\n\t\"./instrumentation/restify.js\": 237,\n\t\"./instrumentations\": 181,\n\t\"./instrumentations.js\": 181,\n\t\"./logger\": 12,\n\t\"./logger.js\": 12,\n\t\"./metrics/index\": 170,\n\t\"./metrics/index.js\": 170,\n\t\"./metrics/mapper\": 178,\n\t\"./metrics/mapper.js\": 178,\n\t\"./metrics/names\": 59,\n\t\"./metrics/names.js\": 59,\n\t\"./metrics/normalizer\": 173,\n\t\"./metrics/normalizer.js\": 173,\n\t\"./metrics/normalizer/rule\": 176,\n\t\"./metrics/normalizer/rule.js\": 176,\n\t\"./metrics/normalizer/tx_segment\": 177,\n\t\"./metrics/normalizer/tx_segment.js\": 177,\n\t\"./metrics/recorders/cassandra\": 232,\n\t\"./metrics/recorders/cassandra.js\": 232,\n\t\"./metrics/recorders/custom\": 238,\n\t\"./metrics/recorders/custom.js\": 238,\n\t\"./metrics/recorders/express\": 220,\n\t\"./metrics/recorders/express.js\": 220,\n\t\"./metrics/recorders/generic\": 207,\n\t\"./metrics/recorders/generic.js\": 207,\n\t\"./metrics/recorders/http\": 210,\n\t\"./metrics/recorders/http.js\": 210,\n\t\"./metrics/recorders/http_external\": 213,\n\t\"./metrics/recorders/http_external.js\": 213,\n\t\"./metrics/recorders/memcached\": 228,\n\t\"./metrics/recorders/memcached.js\": 228,\n\t\"./metrics/recorders/other\": 239,\n\t\"./metrics/recorders/other.js\": 239,\n\t\"./metrics/recorders/redis\": 226,\n\t\"./metrics/recorders/redis.js\": 226,\n\t\"./parse-dockerinfo\": 133,\n\t\"./parse-dockerinfo.js\": 133,\n\t\"./parse-proc-cpuinfo\": 132,\n\t\"./parse-proc-cpuinfo.js\": 132,\n\t\"./parse-proc-meminfo\": 134,\n\t\"./parse-proc-meminfo.js\": 134,\n\t\"./reservoir\": 94,\n\t\"./reservoir.js\": 94,\n\t\"./sampler\": 95,\n\t\"./sampler.js\": 95,\n\t\"./shimmer\": 199,\n\t\"./shimmer.js\": 199,\n\t\"./stats/apdex\": 172,\n\t\"./stats/apdex.js\": 172,\n\t\"./stats/index\": 171,\n\t\"./stats/index.js\": 171,\n\t\"./system-info\": 99,\n\t\"./system-info.js\": 99,\n\t\"./timer\": 96,\n\t\"./timer.js\": 96,\n\t\"./transaction/index\": 187,\n\t\"./transaction/index.js\": 187,\n\t\"./transaction/name-state\": 191,\n\t\"./transaction/name-state.js\": 191,\n\t\"./transaction/trace/aggregator\": 179,\n\t\"./transaction/trace/aggregator.js\": 179,\n\t\"./transaction/trace/index\": 188,\n\t\"./transaction/trace/index.js\": 188,\n\t\"./transaction/trace/segment\": 189,\n\t\"./transaction/trace/segment.js\": 189,\n\t\"./transaction/tracer/index\": 186,\n\t\"./transaction/tracer/index.js\": 186,\n\t\"./transaction/tracer/instrumentation/outbound\": 212,\n\t\"./transaction/tracer/instrumentation/outbound.js\": 212,\n\t\"./uninstrumented\": 180,\n\t\"./uninstrumented.js\": 180,\n\t\"./util/arrays\": 174,\n\t\"./util/arrays.js\": 174,\n\t\"./util/cat\": 211,\n\t\"./util/cat.js\": 211,\n\t\"./util/codec\": 184,\n\t\"./util/codec.js\": 184,\n\t\"./util/copy\": 167,\n\t\"./util/copy.js\": 167,\n\t\"./util/deep-equal\": 175,\n\t\"./util/deep-equal.js\": 175,\n\t\"./util/flatten\": 61,\n\t\"./util/flatten.js\": 61,\n\t\"./util/hashes\": 62,\n\t\"./util/hashes.js\": 62,\n\t\"./util/label-parser\": 135,\n\t\"./util/label-parser.js\": 135,\n\t\"./util/logger\": 13,\n\t\"./util/logger.js\": 13,\n\t\"./util/safe-json\": 14,\n\t\"./util/safe-json.js\": 14,\n\t\"./util/sql/obfuscate\": 183,\n\t\"./util/sql/obfuscate.js\": 183,\n\t\"./util/stream-sink\": 153,\n\t\"./util/stream-sink.js\": 153,\n\t\"./util/sum-children\": 190,\n\t\"./util/sum-children.js\": 190,\n\t\"./util/urltils\": 168,\n\t\"./util/urltils.js\": 168\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 92;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib ^\\.\\/.*$\n// module id = 92\n// module chunks = 0","'use strict'\n\nvar util = require('util')\nvar EventEmitter = require('events').EventEmitter\nvar Reservoir = require('./reservoir.js')\nvar logger = require('./logger.js')\nvar sampler = require('./sampler.js')\nvar NAMES = require('./metrics/names.js')\nvar CollectorAPI = require('./collector/api.js')\nvar ErrorAggregator = require('./errors/aggregator')\nvar Metrics = require('./metrics')\nvar MetricNormalizer = require('./metrics/normalizer.js')\nvar TxSegmentNormalizer = require('./metrics/normalizer/tx_segment.js')\nvar MetricMapper = require('./metrics/mapper.js')\nvar TraceAggregator = require('./transaction/trace/aggregator.js')\nvar hashes = require('./util/hashes')\nvar uninstrumented = require('./uninstrumented.js')\nvar QueryTracer = require('./db/tracer')\n\n/*\n *\n * CONSTANTS\n *\n */\n\nvar STATES = [\n  'stopped',      // start state\n  'starting',     // handshaking with NR\n  'connected',    // connected to collector\n  'disconnected', // disconnected from collector\n  'started',      // up and running\n  'stopping',     // shutting down\n  'errored'       // stopped due to error\n]\n\n// just to make clear what's going on\nvar TO_MILLIS = 1e3\nvar FROM_MILLIS = 1e-3\n\n// Check for already loaded modules and warn about them. This must be executed\n// only once, at the first require of this file, or else we have problems in\n// unit tests.\nuninstrumented.check()\n\n/**\n * There's a lot of stuff in this constructor, due to Agent acting as the\n * orchestrator for New Relic within instrumented applications.\n *\n * This constructor can throw if, for some reason, the configuration isn't\n * available. Don't try to recover here, because without configuration the\n * agent can't be brought up to a useful state.\n */\nfunction Agent(config) {\n  EventEmitter.call(this)\n\n  if (!config) throw new Error(\"Agent must be created with a configuration!\")\n\n  // The agent base attributes which last throughout its lifetime.\n  this._state = 'stopped'\n  this.config = config\n  this.environment = require('./environment')\n  this.version = this.config.version\n  this.collector = new CollectorAPI(this)\n\n  // Reset the agent to add all the sub-objects it needs. These object are the\n  // ones that get re-created if the agent is told to restart from the collector.\n  this.events = null\n  this.customEvents = null\n  this.errors = null\n  this.mapper = null\n  this.metricNameNormalizer = null\n  this.metrics = null\n  this.transactionNameNormalizer = null\n  this.urlNormalizer = null\n  this.txSegmentNormalizer = null\n  this.userNormalizer = null\n  this.reset()\n\n  // Transaction tracing.\n  this.tracer = this._setupTracer()\n  this.traces = new TraceAggregator(this.config)\n\n  // Query tracing.\n  this.queries = new QueryTracer(this.config)\n\n  // Set up all the configuration events the agent needs to listen for.\n  var self = this\n  this.config.on('apdex_t', this._apdexTChange.bind(this))\n  this.config.on('data_report_period', this._harvesterIntervalChange.bind(this))\n  this.config.on('agent_enabled', this._enabledChange.bind(this))\n  this.config.on('change', this._configChange.bind(this))\n  this.config.on('metric_name_rules', function updateMetricNameNormalizer() {\n    self.metricNameNormalizer.load.apply(self.metricNameNormalizer, arguments)\n  })\n  this.config.on('transaction_name_rules', function updateTransactionNameNormalizer() {\n    self.transactionNameNormalizer.load.apply(self.transactionNameNormalizer, arguments)\n  })\n  this.config.on('url_rules', function updateUrlNormalizer() {\n    self.urlNormalizer.load.apply(self.urlNormalizer, arguments)\n  })\n  this.config.on('transaction_segment_terms', function updateSegmentNormalizer() {\n    self.txSegmentNormalizer.load.apply(self.txSegmentNormalizer, arguments)\n  })\n\n  // Entity tracking metrics.\n  this.totalActiveSegments = 0\n  this.segmentsCreatedInHarvest = 0\n  this.segmentsClearedInHarvest = 0\n  this.activeTransactions = 0\n\n  // Hidden class optimizations.\n  this.harvesterHandle = null\n\n  // Finally, add listeners for the agent's own events.\n  this.on('transactionFinished', this._transactionFinished.bind(this))\n}\nutil.inherits(Agent, EventEmitter)\n\n/**\n * The agent is meant to only exist once per application, but the singleton is\n * managed by index.js. An agent will be created even if the agent's disabled by\n * the configuration.\n *\n * @config {boolean} agent_enabled Whether to start up the agent.\n *\n * @param {Function} callback Continuation and error handler.\n */\nAgent.prototype.start = function start(callback) {\n  if (!callback) throw new TypeError(\"callback required!\")\n\n  var agent = this\n\n  this.setState('starting')\n\n  if (this.config.agent_enabled !== true) {\n    logger.warn(\"The New Relic Node.js agent is disabled by its configuration. \" +\n                \"Not starting!\")\n\n    this.setState('stopped')\n    return process.nextTick(callback)\n  }\n\n  if (!(this.config.license_key)) {\n    logger.error(\"A valid account license key cannot be found. \" +\n                 \"Has a license key been specified in the agent configuration \" +\n                 \"file or via the NEW_RELIC_LICENSE_KEY environment variable?\")\n\n    this.setState('errored')\n    return process.nextTick(function cb_nextTick() {\n      callback(new Error(\"Not starting without license key!\"))\n    })\n  }\n\n  sampler.start(agent)\n\n  logger.info(\"Starting New Relic for Node.js connection process.\")\n\n  this.collector.connect(function cb_connect(error, config) {\n    if (error) {\n      agent.setState('errored')\n      return callback(error, config)\n    }\n\n    if (agent.collector.isConnected() && !agent.config.no_immediate_harvest) {\n      // harvest immediately for quicker data display, but after at least 1\n      // second or the collector will throw away the data.\n      setTimeout(function one_sec_delayed_harvest() {\n        agent.harvest(function cb_harvest(error) {\n          agent._startHarvester(agent.config.data_report_period)\n\n          agent.setState('started')\n          callback(error, config)\n        })\n      }, 1000)\n    } else {\n      process.nextTick(function cb_nextTick() {\n        callback(null, config)\n      })\n    }\n  })\n}\n\n/**\n * Any memory claimed by the agent will be retained after stopping.\n *\n * FIXME: make it possible to dispose of the agent, as well as do a\n * \"hard\" restart. This requires working with shimmer to strip the\n * current instrumentation and patch to the module loader.\n */\nAgent.prototype.stop = function stop(callback) {\n  if (!callback) throw new TypeError(\"callback required!\")\n\n  var agent = this\n\n  this.setState('stopping')\n  this._stopHarvester()\n  sampler.stop()\n\n  if (this.collector.isConnected()) {\n    this.collector.shutdown(function cb_shutdown(error) {\n      if (error) {\n        agent.setState('errored')\n        logger.warn(error, \"Got error shutting down connection to New Relic:\")\n      } else {\n        agent.setState('stopped')\n        logger.info(\"Stopped New Relic for Node.js.\")\n      }\n\n      callback(error)\n    })\n  } else {\n    process.nextTick(callback)\n  }\n}\n\n/**\n * Builds all of the sub-properties of the agent that rely on configurations.\n */\nAgent.prototype.reset = function reset() {\n  // Insights events.\n  if (!this.events) {\n    this.events = new Reservoir()\n  }\n  this.events.setLimit(this.config.transaction_events.max_samples_per_minute)\n  if (!this.customEvents) {\n    this.customEvents = new Reservoir()\n  }\n  this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)\n\n  // Error tracing.\n  if (!this.errors) {\n    this.errors = new ErrorAggregator(this.config)\n  }\n  this.errors.reconfigure(this.config)\n\n  // Metrics.\n  this.mapper = new MetricMapper()\n  this.metricNameNormalizer = new MetricNormalizer(this.config, 'metric name')\n  this.metrics = new Metrics(this.config.apdex_t, this.mapper, this.metricNameNormalizer)\n\n  // Transaction naming.\n  this.transactionNameNormalizer = new MetricNormalizer(this.config, 'transaction name')\n  this.urlNormalizer = new MetricNormalizer(this.config, 'URL')\n\n  // Segment term based tx renaming for MGI mitigation.\n  this.txSegmentNormalizer = new TxSegmentNormalizer()\n\n  // User naming and ignoring rules.\n  this.userNormalizer = new MetricNormalizer(this.config, 'user')\n  this.userNormalizer.loadFromConfig()\n\n  // Supportability.\n  if (this.config.debug.internal_metrics) {\n    this.config.debug.supportability = new Metrics(\n      this.config.apdex_t,\n      this.mapper,\n      this.metricNameNormalizer\n    )\n  }\n}\n\n/**\n * On agent startup, an interval timer is started that calls this method once\n * a minute, which in turn invokes the pieces of the harvest cycle. It calls\n * the various collector API methods in order, bailing out if one of them fails,\n * to ensure that the agents don't pummel the collector if it's already\n * struggling.\n */\nAgent.prototype.harvest = function harvest(callback) {\n  if (!callback) throw new TypeError(\"callback required!\")\n\n  var agent = this\n  var harvestSteps = [\n    '_sendMetrics',\n    '_sendErrors',\n    '_sendTrace',\n    '_sendEvents',\n    '_sendCustomEvents',\n    '_sendQueries',\n    '_sendErrorEvents'\n  ]\n\n  logger.trace({\n    segmentTotal: this.totalActiveSegments,\n    harvestCreated: this.segmentsCreatedInHarvest,\n    harvestCleared: this.segmentsClearedInHarvest,\n    activeTransactions: this.activeTransactions\n  }, 'Entity stats on harvest')\n\n  this.segmentsCreatedInHarvest = 0\n  this.segmentsClearedInHarvest = 0\n\n  if (!this.collector.isConnected()) {\n    return process.nextTick(function cb_nextTick() {\n      callback(new Error(\"Not connected to New Relic!\"))\n    })\n  }\n  runHarvestStep(0)\n\n  function runHarvestStep(n) {\n    agent[harvestSteps[n++]](next)\n\n    function next(error) {\n      if (error || n >= harvestSteps.length) return callback(error)\n      runHarvestStep(n)\n    }\n  }\n}\n\n/**\n * Public interface for passing configuration data from the collector\n * on to the configuration, in an effort to keep them at least somewhat\n * decoupled.\n *\n * @param {object} configuration New config JSON from the collector.\n */\nAgent.prototype.reconfigure = function reconfigure(configuration) {\n  if (!configuration) throw new TypeError(\"must pass configuration\")\n\n  this.config.onConnect(configuration)\n}\n\n/**\n * Make it easier to determine what state the agent thinks it's in (needed\n * for a few tests, but fragile).\n *\n * FIXME: remove the need for this\n *\n * @param {string} newState The new state of the agent.\n */\nAgent.prototype.setState = function setState(newState) {\n  if (STATES.indexOf(newState) === -1) {\n    throw new TypeError(\"Invalid state \" + newState)\n  }\n  logger.debug(\"Agent state changed from %s to %s.\", this._state, newState)\n  this._state = newState\n  this.emit(this._state)\n}\n\n/**\n * Server-side configuration value.\n *\n * @param {number} apdexT Apdex tolerating value, in seconds.\n */\nAgent.prototype._apdexTChange = function _apdexTChange(apdexT) {\n  logger.debug(\"Apdex tolerating value changed to %s.\", apdexT)\n  this.metrics.apdexT = apdexT\n  if (this.config.debug.supportability) {\n    this.config.debug.supportability.apdexT = apdexT\n  }\n}\n\n/**\n * Server-side configuration value. When run, forces a harvest cycle\n * so as to not cause the agent to go too long without reporting.\n *\n * @param {number} interval Time in seconds between harvest runs.\n */\nAgent.prototype._harvesterIntervalChange = _harvesterIntervalChange\n\nfunction _harvesterIntervalChange(interval, callback) {\n  var agent = this\n\n  // only change the setup if the harvester is currently running\n  if (this.harvesterHandle) {\n    // force a harvest now, to be safe\n    this.harvest(function cb_harvest(error) {\n      agent._restartHarvester(interval)\n      if (callback) callback(error)\n    })\n  } else if (callback) {\n    process.nextTick(callback)\n  }\n}\n\n/**\n * Restart the harvest cycle timer.\n *\n * @param {number} harvestSeconds How many seconds between harvests.\n */\nAgent.prototype._restartHarvester = function _restartHarvester(harvestSeconds) {\n  this._stopHarvester()\n  this._startHarvester(harvestSeconds)\n}\n\n/**\n * Safely stop the harvest cycle timer.\n */\nAgent.prototype._stopHarvester = function _stopHarvester() {\n  if (this.harvesterHandle) clearInterval(this.harvesterHandle)\n  this.harvesterHandle = undefined\n}\n\n/**\n * Safely start the harvest cycle timer, and ensure that the harvest\n * cycle won't keep an application from exiting if nothing else is\n * happening to keep it up.\n *\n * @param {number} harvestSeconds How many seconds between harvests.\n */\nAgent.prototype._startHarvester = function _startHarvester(harvestSeconds) {\n  var agent = this\n\n  function onError(error) {\n    if (error) {\n      logger.info(error, \"Error on submission to New Relic (data held for redelivery):\")\n    }\n  }\n\n  function harvester() {\n    agent.harvest(onError)\n  }\n\n  this.harvesterHandle = setInterval(harvester, harvestSeconds * TO_MILLIS)\n  // timer.unref is 0.9+\n  if (this.harvesterHandle.unref) this.harvesterHandle.unref()\n}\n\n/**\n * `agent_enabled` changed. This will generally only happen because of a high\n * security mode mismatch between the agent and the collector. This only\n * expects to have to stop the agent. No provisions have been made, nor\n * testing have been done to make sure it is safe to start the agent back up.\n */\nAgent.prototype._enabledChange = function _enabledChange() {\n  if (this.config.agent_enabled === false) {\n    logger.warn('agent_enabled has been changed to false, stopping the agent.')\n    this.stop(function nop() {})\n  }\n}\n\n/**\n * Report new settings to collector after a configuration has changed. This\n * always occurs after handling a response from a connect call.\n */\nAgent.prototype._configChange = function _configChange() {\n  this.collector.reportSettings()\n}\n\n/**\n * To develop the current transaction tracer, I created a tracing tracer that\n * tracks when transactions, segments and function calls are proxied. This is\n * used by the tests, but can also be dumped and logged, and is useful for\n * figuring out where in the execution chain tracing is breaking down.\n *\n * @param object config Agent configuration.\n *\n * @returns Tracer Either a debugging or production transaction tracer.\n */\nAgent.prototype._setupTracer = function _setupTracer() {\n  var Tracer = require('./transaction/tracer')\n  return new Tracer(this)\n}\n\n/**\n * The pieces of supportability metrics are scattered all over the place -- only\n * send supportability metrics if they're explicitly enabled in the\n * configuration.\n *\n * @param {Function} callback Gets any delivery errors.\n */\nAgent.prototype._sendMetrics = function _sendMetrics(callback) {\n  var agent = this\n\n  if (this.collector.isConnected()) {\n    if (this.errors.getTotalErrorCount() > 0) {\n      var count = this.errors.getTotalErrorCount()\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount(count)\n\n      count = this.errors.getWebTransactionsErrorCount()\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount(count)\n\n      count = this.errors.getBackgroundTransactionsErrorCount()\n      this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount(count)\n    }\n\n    if (this.config.debug.supportability) {\n      this.metrics.merge(this.config.debug.supportability)\n    }\n\n    // Send uninstrumented supportability metrics every harvest cycle\n    uninstrumented.createMetrics(this.metrics)\n\n    this._processCustomEvents()\n    this._processErrorEvents()\n\n    // wait to check until all the standard stuff has been added\n    if (this.metrics.toJSON().length < 1) {\n      logger.debug(\"No metrics to send.\")\n      return process.nextTick(callback)\n    }\n\n    var metrics = this.metrics\n    var beginSeconds = metrics.started * FROM_MILLIS\n    var endSeconds = Date.now() * FROM_MILLIS\n    var payload = [this.config.run_id, beginSeconds, endSeconds, metrics]\n\n\n    // reset now to avoid losing metrics that come in after delivery starts\n    this.metrics = new Metrics(\n      this.config.apdex_t,\n      this.mapper,\n      this.metricNameNormalizer\n    )\n\n    this.collector.metricData(payload, function cb_metricData(error, rules) {\n      if (error) agent.metrics.merge(metrics)\n      if (rules) agent.mapper.load(rules)\n\n      callback(error)\n    })\n  } else {\n    process.nextTick(function cb_nextTick() {\n      callback(new Error(\"not connected to New Relic (metrics will be held)\"))\n    })\n  }\n}\n\n/**\n * This function takes the custom events reservoir, gets stats on it for\n * metric purposes, then instantiates a new custom events reservoir. This is\n * so the stats are consistent with what actually gets pushed by the later\n * call to _sendCustomEvents.\n */\nAgent.prototype._processCustomEvents = function _processCustomEvents() {\n  this.customEventsPool = this.customEvents.toArray()\n\n  // Create the metrics so they are at least set to 0\n  var dropped = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.DROPPED)\n  var seen = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SEEN)\n  var sent = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SENT)\n\n  // Bail out if there are no events\n  if (this.customEventsPool.length === 0) {\n    return\n  }\n\n  if (this.config.custom_insights_events.enabled) {\n    // Record their values\n    var diff = this.customEvents.overflow()\n    dropped.incrementCallCount(diff)\n    seen.incrementCallCount(this.customEvents.seen)\n    sent.incrementCallCount(this.customEvents.seen - diff)\n\n    // Log any warnings about dropping events\n    if (diff) {\n      logger.warn('Dropped %s custom events out of %s.', diff, this.customEvents.seen)\n    }\n\n    // Create a new reservoir now (instead of at send time) so metrics match\n    // what we actually send.\n    this.customEvents = new Reservoir(\n      this.config.custom_insights_events.max_samples_stored\n    )\n  } else if (this.customEventsPool.length > 0) {\n    // We have events and custom events are disabled. Clear everything out so we\n    // don't hold onto memory that we shouldn't. Only time this could happen is\n    // if the server sent down settings disabling custom events in the middle of\n    // a harvest cycle.\n    this.customEventsPool = []\n    this.customEvents = new Reservoir(\n      this.config.custom_insights_events.max_samples_stored\n    )\n  }\n}\n\n/**\n * This function takes the error events reservoir, gets stats on it for\n * metric purposes, then instantiates a new error events reservoir. This is\n * so the stats are consistent with what actually gets pushed by the later\n * call to _sendErrorEvents.\n */\nAgent.prototype._processErrorEvents = function _processErrorEvents() {\n  var events = this.errors.getEvents()\n\n  this._lastErrorEvents = [\n    this.errors.getEventsLimit(),\n    this.errors.getEventsSeen(),\n    events\n  ]\n\n  // Create the metrics so they are at least set to 0\n  var seen = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SEEN)\n  var sent = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SENT)\n\n  // Bail out if there are no events\n  if (events.length === 0) {\n    return\n  }\n\n  if (this.config.error_collector.capture_events) {\n    // Record their values\n    var diff = this.errors.events.overflow()\n    seen.incrementCallCount(this.errors.events.seen)\n    sent.incrementCallCount(this.errors.events.seen - diff)\n\n    // Log any warnings about dropping events\n    if (diff) {\n      logger.warn('Dropped %s error events out of %s.', diff, this.errors.events.seen)\n    }\n\n    // clear the reservoir now (instead of at send time) so metrics match\n    // what we actually send.\n    this.errors.clearEvents()\n  } else if (events.length > 0) {\n    // We have events and error events are disabled. Clear everything out so we\n    // don't hold onto memory that we shouldn't. Only time this could happen is\n    // if the server sent down settings disabling error events in the middle of\n    // a harvest cycle.\n    this._lastErrorEvents = []\n    this.errors.clearEvents()\n  }\n}\n\n/**\n * The error tracer doesn't know about the agent, and the connection\n * doesn't know about the error tracer. Only the agent knows about both.\n *\n * @param {Function} callback Gets any delivery errors.\n */\nAgent.prototype._sendErrors = function _sendErrors(callback) {\n  var agent = this\n\n  if (this.config.collect_errors && this.config.error_collector.enabled) {\n    if (!this.collector.isConnected()) {\n      return process.nextTick(function cb_nextTick() {\n        callback(new Error(\"not connected to New Relic (errors will be held)\"))\n      })\n    } else if (this.errors.getTotalErrorCount() < 1) {\n      logger.debug(\"No errors to send.\")\n      return process.nextTick(callback)\n    }\n\n    var errors = this.errors.getErrors()\n    var payload = [this.config.run_id, errors]\n\n    // reset now to avoid losing errors that come in after delivery starts\n    this.errors.clearErrors()\n\n    this.collector.errorData(payload, function cb_errorData(error) {\n      if (error) agent.errors.merge(errors)\n\n      callback(error)\n    })\n  } else {\n    /**\n     * Reset the errors object even if collection is disabled due to error\n     * counting. Also covers the case where the error collector gets disabled\n     * in the middle of a harvest cycle so the agent doesn't continue to hold\n     * on to the errors it had collected during the harvest cycle so far.\n     */\n    this.errors.clearErrors()\n    process.nextTick(callback)\n  }\n}\n\n/**\n * The trace aggregator has its own harvester, which is already\n * asynchronous, due to its need to compress the nested transaction\n * trace data.\n *\n * @param {Function} callback Gets any encoding or delivery errors.\n */\nAgent.prototype._sendTrace = function _sendTrace(callback) {\n  var agent = this\n  if (this.config.collect_traces && this.config.transaction_tracer.enabled) {\n    if (!this.collector.isConnected()) {\n      return process.nextTick(function cb_nextTick() {\n        callback(new Error(\"not connected to New Relic (slow trace data will be held)\"))\n      })\n    }\n\n    this.traces.harvest(function cb_harvest(error, traces, trace) {\n      if (error || !traces || traces.length === 0) return callback(error)\n\n      var payload = [agent.config.run_id, traces]\n      agent.collector.transactionSampleData(\n        payload,\n        function cb_transactionSampleData(error) {\n          if (!error) agent.traces.reset(trace)\n\n          callback(error)\n        }\n      )\n    })\n  } else {\n    process.nextTick(callback)\n  }\n}\n\nAgent.prototype._sendEvents = function _sendEvents(callback) {\n  if (this.config.transaction_events.enabled) {\n    var agent = this\n    var events = agent.events\n    var sample = events.toArray()\n    var run_id = agent.config.run_id\n\n    // bail if there are no events\n    if (sample.length < 1) {\n      return process.nextTick(callback)\n    }\n\n    var metrics = {\n      reservoir_size: events.limit,\n      events_seen: events.seen\n    }\n\n    var payload = [\n      run_id,\n      metrics,\n      sample\n    ]\n\n    // clear events\n    agent.events = new Reservoir(agent.config.transaction_events.max_samples_per_minute)\n\n    // send data to collector\n    agent.collector.analyticsEvents(payload, function cb_analyticsEvents(err) {\n      if (err && err.statusCode === 413 ) {\n        logger.warn('request too large; event data dropped')\n      } else if (err) {\n        logger.warn('analytics events failed to send; re-sampling')\n\n        // boost the limit if a connection fails\n        // and re-aggregate on failure\n        var newlimit = agent.config.transaction_events.max_samples_stored\n        agent.events.limit = newlimit\n\n        for (var k = 0; k < sample.length; k++) agent.events.add(sample[k])\n      } else {\n        // if we had to limit events and sample them, emit a warning\n        var diff = events.overflow()\n        if (diff > 0) logger.warn(\n          'analytics event overflow, dropped %d events; ' +\n           'try increasing your limit above %d',\n          diff, events.limit\n        )\n      }\n\n      callback(err)\n    })\n  } else {\n    process.nextTick(callback)\n  }\n}\n\n/**\n * This is separate from _sendEvents because of potential post size problems.\n * _processCustomEvents needs to happen before _sendCustomEvents. In the\n * normal case it will have happened in _sendMetrics but if you are testing\n * this or trying to use it directly for some reason you'll need to call\n * _processCustomEvents first.\n */\nAgent.prototype._sendCustomEvents = function _sendCustomEvents(callback) {\n  // Must be enabled and actually have events to send, otherwise bail and nextTick\n  if (this.config.custom_insights_events.enabled && this.customEventsPool.length > 0) {\n    var agent = this\n    var run_id = agent.config.run_id\n\n    var payload = [\n      run_id,\n      agent.customEventsPool\n    ]\n\n    // send data to collector\n    agent.collector.customEvents(payload, function cb_customEvents(err) {\n      if (err && err.statusCode === 413 ) {\n        var tooLarge = agent.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.TOO_LARGE)\n        tooLarge.incrementCallCount()\n        logger.warn('request too large; custom event data dropped')\n      } else if (err) {\n        var failed = agent.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.FAILED)\n        failed.incrementCallCount()\n        logger.warn('custom events failed to send; re-sampling')\n\n        for (var i = 0; i < agent.customEventsPool.length; i++) {\n          agent.customEvents.add(agent.customEventsPool[i])\n        }\n      }\n\n      callback(err)\n    })\n  } else {\n    process.nextTick(callback)\n  }\n}\n\nAgent.prototype._sendQueries = function _sendQueries(callback) {\n  var agent = this\n  var queries = this.queries\n\n  this.queries = new QueryTracer(agent.config)\n\n  if (!this.config.slow_sql.enabled) {\n    logger.debug('Slow Query is not enabled.')\n    return process.nextTick(callback)\n  }\n\n  if (Object.keys(queries.samples).length < 1) {\n    logger.debug('No queries to send.')\n    return process.nextTick(callback)\n  }\n\n  queries.prepareJSON(function gotJSON(err, data) {\n    if (err) {\n      this.queries.merge(queries)\n      logger.debug('Error while serializing query data: %s', err.message)\n      return callback(err)\n    }\n\n    agent.collector.queryData([data], function handleResponse(error) {\n      if (error) agent.queries.merge(queries)\n      callback(error)\n    })\n  })\n}\n\nAgent.prototype._sendErrorEvents = function _sendErrorEvents(callback) {\n  if (this.config.error_collector.capture_events && this._lastErrorEvents &&\n        this._lastErrorEvents[2].length > 0) {\n    var agent = this\n    var eventsLimit = this._lastErrorEvents[0]\n    var eventsSeen = this._lastErrorEvents[1]\n    var events = this._lastErrorEvents[2]\n    var run_id = agent.config.run_id\n\n    if (events.length < 1) {\n      return process.nextTick(callback)\n    }\n\n    var metrics = {\n      reservoir_size: eventsLimit,\n      events_seen: eventsSeen\n    }\n\n    var payload = [\n      run_id,\n      metrics,\n      events\n    ]\n\n    // send data to collector\n    agent.collector.errorEvents(payload, function cb_errorEvents(err) {\n      if (err && err.statusCode === 413 ) {\n        logger.warn('request too large; event data dropped')\n      } else if (err) {\n        logger.warn('error events failed to send; re-sampling')\n        agent.errors.mergeEvents(events)\n      }\n      callback(err)\n    })\n  } else {\n    process.nextTick(callback)\n  }\n}\n\nAgent.prototype._addIntrinsicAttrsFromTransaction = _addIntrinsicAttrsFromTransaction\n\nfunction _addIntrinsicAttrsFromTransaction(transaction) {\n  var intrinsicAttributes = {\n    webDuration: transaction.timer.duration / 1000,\n    timestamp: transaction.timer.start,\n    name: transaction.name,\n    duration: transaction.timer.duration / 1000,\n    type: 'Transaction',\n    error: transaction.hasErrors()\n  }\n\n  var metric = transaction.metrics.getMetric(NAMES.QUEUETIME)\n  if (metric) {\n    intrinsicAttributes.queueDuration = metric.total\n  }\n\n  metric = transaction.metrics.getMetric(NAMES.EXTERNAL.ALL)\n  if (metric) {\n    intrinsicAttributes.externalDuration = metric.total\n    intrinsicAttributes.externalCallCount = metric.callCount\n  }\n\n  metric = transaction.metrics.getMetric(NAMES.DB.ALL)\n  if (metric) {\n    intrinsicAttributes.databaseDuration = metric.total\n    intrinsicAttributes.databaseCallCount = metric.callCount\n  }\n\n  // FLAG: cat\n  if (this.config.feature_flag.cat) {\n    if (!transaction.invalidIncomingExternalTransaction &&\n         (\n           transaction.referringTransactionGuid ||\n           transaction.includesOutboundRequests()\n         )\n       ) {\n      intrinsicAttributes['nr.guid'] = transaction.id\n      intrinsicAttributes['nr.tripId'] = transaction.tripId || transaction.id\n      intrinsicAttributes['nr.pathHash'] = hashes.calculatePathHash(\n        this.config.applications()[0],\n        transaction.name || transaction.nameState.getName(),\n        transaction.referringPathHash\n      )\n      if (transaction.referringPathHash) {\n        intrinsicAttributes['nr.referringPathHash'] = transaction.referringPathHash\n      }\n      if (transaction.referringTransactionGuid) {\n        var refId = transaction.referringTransactionGuid\n        intrinsicAttributes['nr.referringTransactionGuid'] = refId\n      }\n      var alternatePathHashes = transaction.alternatePathHashes()\n      if (alternatePathHashes) {\n        intrinsicAttributes['nr.alternatePathHashes'] = alternatePathHashes\n      }\n      if (transaction.webSegment) {\n        var apdex = (this.config.web_transactions_apdex[transaction.name] ||\n                     this.config.apdex_t)\n        var duration = transaction.webSegment.getDurationInMillis() / 1000\n        intrinsicAttributes['nr.apdexPerfZone'] = calculateApdexZone(duration, apdex)\n      }\n    }\n  }\n\n  if (transaction.syntheticsData) {\n    intrinsicAttributes[\"nr.syntheticsResourceId\"] = transaction.syntheticsData.resourceId\n    intrinsicAttributes[\"nr.syntheticsJobId\"] = transaction.syntheticsData.jobId\n    intrinsicAttributes[\"nr.syntheticsMonitorId\"] = transaction.syntheticsData.monitorId\n  }\n\n  return intrinsicAttributes\n}\n\nfunction calculateApdexZone(duration, apdexT) {\n  if (duration <= apdexT) {\n    return 'S' // satisfied\n  }\n\n  if (duration <= apdexT * 4) {\n    return 'T' // tolerating\n  }\n\n  return 'F' // frustrated\n}\n\nAgent.prototype._addEventFromTransaction = _addEventFromTransaction\n\nfunction _addEventFromTransaction(transaction) {\n  if (!this.config.transaction_events.enabled) return\n\n  var intrinsicAttributes = this._addIntrinsicAttrsFromTransaction(transaction)\n  var userAttributes = transaction.trace.custom\n  var agentAttributes = transaction.trace.parameters\n\n  var event = [\n    intrinsicAttributes,\n    userAttributes,\n    agentAttributes\n  ]\n\n  this.events.add(event)\n}\n\n/**\n * Put all the logic for handing finalized transactions off to the tracers and\n * metric collections in one place.\n *\n * @param {Transaction} transaction Newly-finalized transaction.\n */\nAgent.prototype._transactionFinished = function _transactionFinished(transaction) {\n  // only available when this.config.debug.tracer_tracing is true\n  if (transaction.describer) {\n    logger.trace({trace_dump: transaction.describer.verbose}, 'Dumped transaction state.')\n  }\n\n  // Allow the API to explicitly set the ignored status on bg-tx.\n  // This is handled for web-tx when setName is called on the tx.\n  if (!transaction.isWeb() && transaction.forceIgnore !== null) {\n    transaction.ignore = transaction.forceIgnore\n  }\n\n  if (!transaction.ignore) {\n    if (transaction.forceIgnore === false) {\n      logger.debug(\"Explicitly not ignoring %s.\", transaction.name)\n    }\n    this.metrics.merge(transaction.metrics)\n    this.errors.onTransactionFinished(transaction, this.metrics)\n    this.traces.add(transaction)\n\n    var trace = transaction.trace\n    trace.intrinsics = transaction.getIntrinsicAttributes()\n\n    this._addEventFromTransaction(transaction)\n  } else if (transaction.forceIgnore === true) {\n    logger.debug(\"Explicitly ignoring %s.\", transaction.name)\n  } else {\n    logger.debug(\"Ignoring %s.\", transaction.name)\n  }\n\n  this.activeTransactions--\n  this.totalActiveSegments -= transaction.numSegments\n  this.segmentsClearedInHarvest += transaction.numSegments\n}\n\n/**\n * Get the current transaction (if there is one) from the tracer.\n *\n * @returns {Transaction} The current transaction.\n */\nAgent.prototype.getTransaction = function getTransaction() {\n  return this.tracer.getTransaction()\n}\n\nmodule.exports = Agent\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/agent.js\n// module id = 93\n// module chunks = 0","'use strict'\n\n// from http://en.wikipedia.org/wiki/Reservoir_sampling\n\nfunction Reservoir(limit) {\n  this.limit = limit || 10\n  this.seen = 0\n  this._data = []\n}\n\nReservoir.prototype.overflow = function overflow() {\n  var diff = this.seen - this.limit\n  return diff >= 0 ? diff : 0\n}\n\nReservoir.prototype.add = function add(item) {\n  if (this.seen < this.limit) {\n    this._data.push(item)\n  } else {\n    // Take a number between 0 and n + 1, drop the element at that index\n    // from the array. If the element to drop is the (n + 1)th, the new item is\n    // not added, otherwise the new item replaces the item that was\n    // dropped.\n    // This is effectively the same as adding the new element to the\n    // end, swapping the last element (the new one) with a random element in the list,\n    // then dropping the last element (the potentially swapped one) in the list.\n    var toReplace = Math.floor(Math.random() * (this.seen + 2))\n    if (toReplace < this.limit) this._data[toReplace] = item\n  }\n  this.seen++\n}\n\nReservoir.prototype.toArray = function toArray() {\n  return this._data\n}\n\nReservoir.prototype.merge = function merge(items) {\n  if (!items || !items.length) return\n  if (items === this._data) return\n  for (var i = 0; i < items.length; i++) {\n    this.add(items[i])\n  }\n}\n\nReservoir.prototype.setLimit = function setLimit(newLimit) {\n  this.limit = newLimit\n  if (this._data.length > newLimit) {\n    this._data = this._data.slice(0, newLimit)\n  }\n}\n\nmodule.exports = Reservoir\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/reservoir.js\n// module id = 94\n// module chunks = 0","'use strict'\n\nvar NAMES = require('./metrics/names')\nvar logger = require('./logger').child({component: 'sampler'})\nvar Timer = require('./timer')\nvar os = require('os')\n\n/*\n *\n * CONSTANTS\n *\n */\nvar MILLIS = 1e3\nvar MICROS = 1e6\nvar NANOS = 1e9\nvar CPUS = os.cpus().length\nvar SAMPLE_INTERVAL = 15 * MILLIS\n\nvar samplers = []\n\nfunction Sampler(sampler, interval) {\n  this.id = setInterval(sampler, interval)\n  // timer.unref only in 0.9+\n  if (this.id.unref) this.id.unref()\n}\n\nSampler.prototype.stop = function stop() {\n  clearInterval(this.id)\n}\n\nfunction recordQueueTime(agent, timer) {\n  timer.end()\n  agent.metrics.measureMilliseconds(NAMES.EVENTS.WAIT, null, timer.getDurationInMillis())\n}\n\nfunction sampleMemory(agent) {\n  return function memorySampler() {\n    try {\n      var mem = process.memoryUsage()\n      agent.metrics.measureBytes(NAMES.MEMORY.PHYSICAL, mem.rss)\n      agent.metrics.measureBytes(NAMES.MEMORY.USED_HEAP, mem.heapUsed)\n      agent.metrics.measureBytes(NAMES.MEMORY.MAX_HEAP, mem.heapTotal)\n      agent.metrics.measureBytes(NAMES.MEMORY.FREE_HEAP, mem.heapTotal - mem.heapUsed)\n      agent.metrics.measureBytes(NAMES.MEMORY.USED_NONHEAP, mem.rss - mem.heapTotal)\n      logger.trace('Recorded memory:', mem)\n    } catch (e) {\n      logger.debug('Could not record memory usage', e)\n    }\n  }\n}\n\nfunction checkEvents(agent) {\n  return function eventSampler() {\n    var timer = new Timer()\n    timer.begin()\n    setTimeout(recordQueueTime.bind(null, agent, timer), 0)\n  }\n}\n\nfunction getCpuSample(lastSample) {\n  try {\n    return process.cpuUsage(lastSample)\n  } catch (e) {\n    logger.debug('Could not record cpu usage', e)\n    return null\n  }\n}\n\nfunction generateCPUMetricRecorder(agent) {\n  var lastSampleTime\n  // userTime and sysTime are in seconds\n  return function recordCPUMetrics(userTime, sysTime) {\n    var elapsedUptime\n    if (!lastSampleTime) {\n      elapsedUptime = process.uptime()\n    } else {\n      elapsedUptime = (Date.now() - lastSampleTime) / MILLIS\n    }\n\n    var totalCpuTime = CPUS * elapsedUptime\n\n    lastSampleTime = Date.now()\n\n    var userUtil = userTime / totalCpuTime\n    var sysUtil  = sysTime / totalCpuTime\n\n    recordValue(agent, NAMES.CPU.USER_TIME, userTime)\n    recordValue(agent, NAMES.CPU.SYSTEM_TIME, sysTime)\n    recordValue(agent, NAMES.CPU.USER_UTILIZATION, userUtil)\n    recordValue(agent, NAMES.CPU.SYSTEM_UTILIZATION, sysUtil)\n  }\n}\n\nfunction sampleCpu(agent) {\n  var lastSample\n  var recordCPU = generateCPUMetricRecorder(agent)\n  return function cpuSampler() {\n    var cpuSample = getCpuSample(lastSample)\n    lastSample = getCpuSample()\n\n    if (lastSample == null) {\n      return\n    }\n\n    recordCPU(cpuSample.user / MICROS, cpuSample.system / MICROS)\n  }\n}\n\nfunction sampleCpuNative(agent, nativeMetrics) {\n  var recordCPU = generateCPUMetricRecorder(agent)\n  nativeMetrics.on('usage', function collectResourceUsage(usage) {\n    recordCPU(usage.diff.ru_utime / MILLIS, usage.diff.ru_stime / MILLIS)\n  })\n\n  return function cpuSampler() {\n    // NOOP?\n  }\n}\n\nfunction sampleGc(agent, nativeMetrics) {\n  // Hook into the stats event to accumulate total pause time and record per-run\n  // pause time metric.\n  nativeMetrics.on('gc', function onGCStatsEvent(stats) {\n    var duration = stats.duration / NANOS\n    recordValue(agent, NAMES.GC.PAUSE_TIME, duration)\n\n    if (stats.type) {\n      recordValue(agent, NAMES.GC.PREFIX + stats.type, duration)\n    } else {\n      logger.debug(stats, 'Unknown GC type %j', stats.typeId)\n    }\n  })\n\n  return function gcSampler() {\n    // NOOP?\n  }\n}\n\nvar sampler = module.exports = {\n  state: 'stopped',\n  sampleMemory: sampleMemory,\n  checkEvents: checkEvents,\n  sampleCpu: sampleCpu,\n  sampleGc: sampleGc,\n  nativeMetrics: null,\n\n  start: function start(agent) {\n    samplers.push(new Sampler(sampleMemory(agent), 5 * MILLIS))\n    samplers.push(new Sampler(checkEvents(agent), SAMPLE_INTERVAL))\n    var metricFeatureFlag = agent.config.feature_flag.native_metrics\n\n    // This requires a native module which may have failed to build.\n    if (!this.nativeMetrics) {\n      if (metricFeatureFlag) {\n        try {\n          this.nativeMetrics = require('@newrelic/native-metrics')({\n            timeout: SAMPLE_INTERVAL\n          })\n        } catch (err) {\n          logger.info(\n            {error: {message: err.message, stack: err.stack}},\n            'Not adding native metric sampler.'\n          )\n          agent.metrics.getOrCreateMetric(\n            NAMES.SUPPORTABILITY.DEPENDENCIES + '/NoNativeMetricsModule'\n          ).incrementCallCount()\n        }\n      } else {\n        logger.info('Feature flag for native metrics is false')\n      }\n    } else if (!this.nativeMetrics.bound) {\n      this.nativeMetrics.bind(SAMPLE_INTERVAL)\n    }\n\n    // Add GC events if available.\n    if (this.nativeMetrics && this.nativeMetrics.gcEnabled) {\n      samplers.push(new Sampler(sampleGc(agent, this.nativeMetrics), SAMPLE_INTERVAL))\n    }\n\n    // Add CPU sampling using the built-in data if available, otherwise pulling\n    // from the native module.\n    if (process.cpuUsage) { // introduced in 6.1.0\n      samplers.push(new Sampler(sampleCpu(agent), SAMPLE_INTERVAL))\n    } else if (this.nativeMetrics && this.nativeMetrics.usageEnabled) {\n      samplers.push(\n        new Sampler(sampleCpuNative(agent, this.nativeMetrics), SAMPLE_INTERVAL)\n      )\n    } else {\n      logger.debug('Not adding CPU metric sampler.')\n    }\n\n    sampler.state = 'running'\n  },\n\n  stop: function stop() {\n    samplers.forEach(function forEachSampler(s) {\n      s.stop()\n    })\n    samplers = []\n    sampler.state = 'stopped'\n    if (this.nativeMetrics) {\n      this.nativeMetrics.unbind()\n      this.nativeMetrics.removeAllListeners()\n\n      // Setting this.nativeMetrics to null allows us to config a new\n      // nativeMetrics object after the first start call.\n      this.nativeMetrics = null\n    }\n  }\n}\n\nfunction recordValue(agent, metric, value) {\n  var stats = agent.metrics.getOrCreateMetric(metric)\n  stats.recordValue(value)\n  logger.trace('Recorded metric %s: %j', metric, value)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/sampler.js\n// module id = 95\n// module chunks = 0","'use strict'\n\n/**\n\n * Explicit enumeration of the states a transaction can be in:\n *\n * PENDING upon instantiation (implicitly, no start time set)\n * RUNNING while timer is running (implicitly, start time is set but no stop\n *   time is set).\n * STOPPED timer has been completed (implicitly, start time and stop time\n *   are set, but the timer has not yet been harvested).\n * DEAD timer has been harvested and can only have its duration read.\n */\nvar PENDING = 1\nvar RUNNING = 2\nvar STOPPED = 3\n\n\nfunction hrToMillis(hr) {\n  // process.hrTime gives you [second, nanosecond] duration pairs\n  return (hr[0] * 1e3) + (hr[1] / 1e6)\n}\n\n/**\n * A mildly tricky timer that tracks its own state and allows its duration\n * to be set manually.\n */\nfunction Timer() {\n  this.state = PENDING\n  this.touched = false\n  this.duration = null\n  this.hrDuration = null\n  this.hrstart = null\n  this.durationInMillis = null\n}\n\n/**\n * Start measuring time elapsed.\n *\n * Uses process.hrtime if available, Date.now() otherwise.\n */\nTimer.prototype.begin = function begin() {\n  if (this.state > PENDING) return\n\n  this.start = Date.now()\n  // need to put a guard on this for compatibility with Node < 0.8\n  if (process.hrtime) this.hrstart = process.hrtime()\n  this.state = RUNNING\n}\n\n/**\n * End measurement.\n */\nTimer.prototype.end = function end() {\n  if (this.state > RUNNING) return\n  if (this.state === PENDING) this.begin()\n  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)\n  this.touched = true\n  this.duration = Date.now() - this.start\n  this.state = STOPPED\n}\n\n/**\n * Update the duration of the timer without ending it..\n */\nTimer.prototype.touch = function touch() {\n  this.touched = true\n  if (this.state > RUNNING) return\n  if (this.state === PENDING) this.begin()\n\n  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)\n  this.duration = Date.now() - this.start\n}\n\n/**\n * End the segment if it is still running, if touched use that time instead of\n * \"now\". Returns a boolean indicating whether the end time changed.\n */\nTimer.prototype.softEnd = function softEnd() {\n  if (this.state > RUNNING) return false\n  if (this.state === PENDING) this.begin()\n\n  this.state = STOPPED\n\n  if (this.touched) return false\n  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)\n  this.touched = true\n  this.duration = Date.now() - this.start\n  return true\n}\n\n/**\n * @return {bool} Is this timer currently running?\n */\nTimer.prototype.isRunning = function isRunning() {\n  return this.state === RUNNING\n}\n\n/**\n * @return {bool} Is this timer still alive?\n */\nTimer.prototype.isActive = function isActive() {\n  return this.state < STOPPED\n}\n\n/**\n * @return {bool} Has the timer been touched or ended?\n */\nTimer.prototype.hasEnd = function hasEnd() {\n  return !!this.hrDuration\n}\n\n/*\n * Sets duration and stops the timer, since the passed-in duration will take precendence\n * over the measured duration.\n * @param {number} duration The duration the timer should report.\n */\nTimer.prototype.overwriteDurationInMillis = overwriteDurationInMillis\nfunction overwriteDurationInMillis(duration) {\n  this.touched = true\n  this.durationInMillis = duration\n  this.state = STOPPED\n}\n\n/**\n * When testing, it's convenient to be able to control time. Stops the timer\n * as a byproduct.\n *\n * @param {number} duration How long the timer ran.\n * @param {number} start When the timer started running (optional).\n */\nTimer.prototype.setDurationInMillis = function setDurationInMillis(duration, start) {\n  if (this.state > RUNNING) return\n  if (this.state === PENDING)\n  if (!start && start !== 0) this.begin()\n\n  this.state = STOPPED\n  this.durationInMillis = duration\n\n  // this assignment is incorrect, process.hrtime doesn't time from epoch, which\n  // is the assumption being made here.  since hrstart isn't used\n  // anywhere except to calculate duration, and we are setting duration\n  // this is fine.\n  this.hrstart = [Math.floor(start / 1e3), start % 1e3 * 1e6]\n  this.start = start\n}\n\n/**\n * Returns how long the timer has been running (if it's still running) or\n * how long it ran (if it's been ended or touched).\n */\nTimer.prototype.getDurationInMillis = function getDurationInMillis() {\n  if (this.state === PENDING) return 0\n\n  // only set by setDurationInMillis\n  if (this.durationInMillis !== null && this.durationInMillis >= 0) {\n    return this.durationInMillis\n  }\n\n  // prioritize .end() and .touch()\n  if (this.hrDuration) {\n    return hrToMillis(this.hrDuration)\n  }\n\n  if (this.duration) {\n    return this.duration\n  }\n\n  if (process.hrtime) {\n    return hrToMillis(process.hrtime(this.hrstart))\n  }\n\n  return Date.now() - this.start\n}\n\n/**\n * Get a single object containing the interval this timer was active.\n *\n * @return {Array} 2-tuple of start time in milliseconds, end time in\n *                 milliseconds.\n */\nTimer.prototype.toRange = function toRange() {\n  return [this.start, this.start + this.getDurationInMillis()]\n}\n\n/**\n * Abstract away the nonsense related to having both an\n * hrtime start time and a regular one, and always return\n * milliseconds since start.\n *\n * @param {Timer} other The point relative to which this timer started.\n * @return {number} The offset in (floating-point) milliseconds.\n */\nTimer.prototype.startedRelativeTo = function startedRelativeTo(other) {\n  if (this.hrstart && other.hrstart && process.hrtime) {\n    var s = this.hrstart[0] - other.hrstart[0]\n    var ns = this.hrstart[1] - other.hrstart[1]\n\n\n    return hrToMillis([s, ns])\n  }\n\n  return this.start - other.start\n}\n\n/**\n * Returns true if this timer ends after the other.\n */\nTimer.prototype.endsAfter = function compare(other) {\n  return (this.getDurationInMillis() + this.start) >\n    (other.getDurationInMillis() + other.start)\n}\n\n\nmodule.exports = Timer\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/timer.js\n// module id = 96\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger').child({component: 'collector_api'})\nvar facts = require('./facts.js')\nvar RemoteMethod = require('./remote-method.js')\n\n\n/*\n *\n * CONSTANTS\n *\n */\n\n// just to make clear what's going on\nvar TO_MILLIS = 1e3\n\n// taken directly from Python agent's newrelic.core.application\nvar BACKOFFS = [\n  {interval: 15, warn: false},\n  {interval: 15, warn: false},\n  {interval: 30, warn: false},\n  {interval: 60, warn: true},\n  {interval: 120, warn: false},\n  {interval: 300, warn: false}\n]\n\nvar ERRORS = {\n  INVALID_LICENSE: 'NewRelic::Agent::LicenseException',\n  LIMIT_EXCEEDED: 'NewRelic::Agent::InternalLimitExceeded',\n  RESTART: 'NewRelic::Agent::ForceRestartException',\n  DISCONNECT: 'NewRelic::Agent::ForceDisconnectException',\n  MAINTENANCE: 'NewRelic::Agent::MaintenanceError',\n  RUNTIME: 'RuntimeError'\n}\n\nvar HTTP_REQUEST_TOO_LARGE = 413\nvar HTTP_UNSUPPORTED_MEDIA_TYPE = 415\nvar HTTP_SERVER_INTERNAL = 500\nvar HTTP_LOL_COLLECTOR = 503\n\n\nfunction dumpErrors(errors, name) {\n  var index = 1\n\n  errors.forEach(function cb_forEach(error) {\n    logger.trace(error, \"Error %s during %s:\", index++, name)\n\n    if (error.laterErrors) {\n      error.laterErrors.forEach(function cb_forEach(laterError) {\n        logger.trace(laterError, \"Error %s during %s:\", index++, name)\n      })\n    }\n  })\n}\n\nfunction CollectorAPI(agent) {\n  this._agent = agent\n\n  /* RemoteMethods can be reused and have little per-object state, so why not\n   * save some GC time?\n   */\n  this._methods = {\n    redirect: new RemoteMethod('get_redirect_host', agent.config),\n    handshake: new RemoteMethod('connect', agent.config),\n    settings: new RemoteMethod('agent_settings', agent.config),\n    errors: new RemoteMethod('error_data', agent.config),\n    metrics: new RemoteMethod('metric_data', agent.config),\n    traces: new RemoteMethod('transaction_sample_data', agent.config),\n    shutdown: new RemoteMethod('shutdown', agent.config),\n    events: new RemoteMethod('analytic_event_data', agent.config),\n    customEvents: new RemoteMethod('custom_event_data', agent.config),\n    queryData: new RemoteMethod('sql_trace_data', agent.config),\n    errorEvents: new RemoteMethod('error_event_data', agent.config)\n  }\n}\n\nCollectorAPI.prototype.connect = function connect(callback) {\n  if (!callback) throw new TypeError(\"callback is required\")\n\n  var api = this\n  var attempts = 1\n  var max = BACKOFFS.length\n  var errors = []\n\n\n  function retry(error, response, body) {\n    if (error) errors.push(error)\n\n    if (!error || attempts >= max) {\n      dumpErrors(errors, 'connect')\n      return callback(error, response, body)\n    }\n\n    // failing high-security mode compliance will cause a disconnect\n    if (error.class === ERRORS.DISCONNECT) {\n      logger.error(\"The New Relic collector rejected this agent.\")\n      logger.error(error.message)\n    }\n\n    var backoff = BACKOFFS[attempts - 1]\n    if (backoff.warn) {\n      logger.warn(\n        \"No connection has been established to New Relic after %s attempts.\",\n        attempts\n      )\n    }\n\n    logger.debug(\n      \"Failed attempting to connect to New Relic, waiting %ss to retry.\",\n      backoff.interval\n    )\n\n    attempts++\n\n    setTimeout(function again() {\n      api._login(retry)\n    }, backoff.interval * TO_MILLIS)\n  }\n\n  this._login(retry)\n}\n\nCollectorAPI.prototype._login = function _login(callback) {\n  var methods = this._methods\n  var agent = this._agent\n\n\n  methods.redirect.invoke(null, function cb_invoke(error, collector, body) {\n    if (error) return callback(error, collector, body)\n    if (!collector) {\n      logger.error(\n        \"Requesting this account's collector from %s failed; trying default.\",\n        agent.config.host\n      )\n    } else {\n      var parts = collector.split(':')\n      if (parts.length > 2) {\n        logger.error(\n          \"Requesting collector from %s returned bogus result '%s'; trying default.\",\n          agent.config.host,\n          collector\n        )\n      } else {\n        logger.debug(\n          \"Requesting this account's collector from %s returned %s; reconfiguring.\",\n          agent.config.host,\n          collector\n        )\n\n        agent.config.host = parts[0]\n        if (parts.length > 1) {\n          agent.config.port = parts[1]\n        }\n      }\n    }\n\n    facts(agent, function getEnvDict(environmentDict) {\n      // The collector really likes arrays.\n      // In fact, it kind of insists on them.\n      var environment = [environmentDict]\n\n      methods.handshake.invoke(environment, function cb_invoke(error, config, body) {\n        if (error) return callback(error, config, body)\n        if (!config || !config.agent_run_id) {\n          return callback(new Error(\"No agent run ID received from handshake.\"), config)\n        }\n\n        agent.setState('connected')\n        logger.info(\n          \"Connected to %s:%d with agent run ID %s.\",\n          agent.config.host,\n          agent.config.port,\n          config.agent_run_id\n        )\n\n        // pass configuration data from the API so automatic reconnect works\n        agent.reconfigure(config)\n\n        callback(null, config, body)\n      })\n    })\n  })\n}\n\n/**\n * Send current public agent settings to collector. This should always be\n * invoked after a successful connect response with server-side settings, but\n * will also be invoked on any other config changes.\n *\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.reportSettings = function reportSettings(callback) {\n  // The second argument to the callback is always empty data\n  this._methods.settings.invoke(\n    [this._agent.config.publicSettings()],\n    function cb_invoke(error, unused, body) {\n      if (error) dumpErrors([error], 'agent_settings')\n\n      if (callback) callback(error, body)\n    }\n  )\n}\n\n/**\n * Send already-formatted error data by calling error_data. For\n * performance reasons, the API methods do no validation, but the\n * collector expects data in an exact format. It expects a JSON array\n * containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. An array of one or more errors. See lib/error.js for details.\n *\n * @param {Array}    errors   The encoded errors list.\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.errorData = function errorData(errors, callback) {\n  if (!errors) throw new TypeError(\"must pass errors to send\")\n  if (!callback) throw new TypeError(\"callback is required\")\n\n  this._runLifecycle(this._methods.errors, errors, callback)\n}\n\n/**\n * Send already-formatted metric data by calling metric_data. For\n * performance reasons, the API methods do no validation, but the collector\n * expects data in an exact format format. It expects a JSON array containing\n * the following 4 elements:\n *\n * 1. The agent run ID.\n * 2. The time the metric data started being collected, in seconds since the\n *    epoch.\n * 3. The time the metric data finished being collected, in seconds since the\n *    epoch.\n * 4. An array of 1 or more metric arrays. See lib/metrics.js for details.\n *\n * @param {Array}    metrics  The encoded metrics list.\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.metricData = function metricData(metrics, callback) {\n  if (!metrics) throw new TypeError(\"must pass metrics to send\")\n  if (!callback) throw new TypeError(\"callback is required\")\n\n  this._runLifecycle(this._methods.metrics, metrics, callback)\n}\n\nCollectorAPI.prototype.analyticsEvents = function analyticsEvents(events, callback) {\n  if (!events) throw new TypeError(\"must pass events to send\")\n  if (!callback) throw new TypeError(\"callback is required\")\n  this._runLifecycle(this._methods.events, events, callback)\n}\n\nCollectorAPI.prototype.customEvents = function customEvents(events, callback) {\n  if (!events) throw new TypeError(\"must pass events to send\")\n  if (!callback) throw new TypeError(\"callback is required\")\n  this._runLifecycle(this._methods.customEvents, events, callback)\n}\n\n/**\n * Send already-formatted slow SQL data by calling\n * sql_trace_data. For performance reasons, the API methods\n * do no validation, but the collector expects data in an exact format\n * format. It expects a JSON array containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. The encoded slow SQL data.\n *\n * @param {Array}    queries  The encoded slow SQL data.\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.queryData = function queryData(queries, callback) {\n  if (!queries) throw new TypeError(\"must pass queries to send\")\n  if (!callback) throw new TypeError(\"callback is required\")\n  this._runLifecycle(this._methods.queryData, queries, callback)\n}\n\nCollectorAPI.prototype.errorEvents = function errorEvents(events, callback) {\n  if (!events) throw new TypeError(\"must pass queries to send\")\n  if (!callback) throw new TypeError(\"callback is required\")\n  this._runLifecycle(this._methods.errorEvents, events, callback)\n}\n\n/**\n * Send already-formatted slow trace data by calling\n * transaction_sample_data. For performance reasons, the API methods\n * do no validation, but the collector expects data in an exact format\n * format. It expects a JSON array containing the following 2 elements:\n *\n * 1. The agent run ID.\n * 2. The encoded slow trace data. This is the most complicated data\n *    format handled by the module, and documenting it is almost beyond the\n *    scope of comments. See lib/transaction/trace.js for details.\n *\n * @param {Array}    trace    The encoded trace data.\n * @param {Function} callback The continuation / error handler.\n */\nCollectorAPI.prototype.transactionSampleData =\n  function transactionSampleData(trace, callback) {\n  if (!trace) throw new TypeError(\"must pass slow trace data to send\")\n  if (!callback) throw new TypeError(\"callback is required\")\n\n  this._runLifecycle(this._methods.traces, trace, callback)\n}\n\n\n/**\n * Sends no data aside from the message itself. Clears the run ID, which\n * effectively disconnects the agent from the collector.\n *\n * @param Function callback Runs after the run ID has been cleared.\n */\nCollectorAPI.prototype.shutdown = function shutdown(callback) {\n  if (!callback) throw new TypeError(\"callback is required\")\n\n  var agent = this._agent\n  this._methods.shutdown.invoke(null, function closed(error, returned, body) {\n    if (error) {\n      dumpErrors([error], 'shutdown')\n    } else {\n      agent.setState('disconnected')\n      logger.info(\n        \"Disconnected from New Relic; clearing run ID %s.\",\n        agent.config.run_id\n      )\n      agent.config.run_id = undefined\n    }\n\n    callback(error, returned, body)\n  })\n}\n\nCollectorAPI.prototype._restart = function _restart(callback) {\n  var api = this\n  this.shutdown(function reconnect() {\n    api.connect(callback)\n  })\n}\n\nCollectorAPI.prototype._runLifecycle = function _runLifecycle(method, body, callback) {\n  if (!this.isConnected()) {\n    logger.warn(\"Not connected to New Relic. Not calling.\", method.name)\n    return callback(new Error(\"Not connected to collector.\", null, null))\n  }\n\n  var api = this\n  function standardHandler(error, returned, json) {\n    if (!error) return callback(error, returned, json)\n\n    dumpErrors([error], method.name)\n\n    if (error.statusCode === HTTP_REQUEST_TOO_LARGE) {\n      logger.error(\n        error,\n        \"This call of %s sent New Relic too much data; discarding (%s):\",\n        method.name,\n        HTTP_REQUEST_TOO_LARGE\n      )\n      return callback(null, returned, json)\n    } else if (error.statusCode === HTTP_UNSUPPORTED_MEDIA_TYPE) {\n      logger.error(\n        error,\n        \"The New Relic collector couldn't deserialize data; discarding for %s (%s):\",\n        method.name,\n        HTTP_UNSUPPORTED_MEDIA_TYPE\n      )\n      return callback(null, returned, json)\n    } else if (error.statusCode === HTTP_LOL_COLLECTOR) {\n      logger.debug(\n        error,\n        \"New Relic is experiencing a spot of bother; please hold on (%s):\",\n        HTTP_LOL_COLLECTOR\n      )\n      return callback(error, returned, json)\n    } else if (error.statusCode === HTTP_SERVER_INTERNAL) {\n      logger.error(\n        error,\n        \"New Relic's servers encountered a severe internal error on %s (%s):\",\n        method.name,\n        HTTP_SERVER_INTERNAL\n      )\n      return callback(error, returned, json)\n    } else if (error.class === ERRORS.INVALID_LICENSE) {\n      logger.error(\n        error,\n        \"Your New Relic license key appears to be invalid. Please double-check it:\"\n      )\n\n      return callback(error, returned, json)\n    } else if (error.class === ERRORS.LIMIT_EXCEEDED) {\n      logger.error(\n        error,\n        \"New Relic ran into a weird problem with %s. Let support@newrelic.com know:\",\n        method.name\n      )\n      return callback(null, returned, json)\n    } else if (error.class === ERRORS.RESTART) {\n      logger.info(\n        error,\n        \"The New Relic collector requested a connection restart on %s:\",\n        method.name\n      )\n\n      return api._restart(function cb__restart() {\n        method.invoke(body, standardHandler)\n      })\n    } else if (error.class === ERRORS.DISCONNECT) {\n      logger.error(error, \"The New Relic collector is shutting down this agent:\")\n\n      return api._agent.stop(function cb_stop() {\n        callback(error, returned, json)\n      })\n    } else if (error.class === ERRORS.MAINTENANCE) {\n      logger.info(\n        error,\n        \"The New Relic server for your account is currently undergoing maintenance. \" +\n          \"Data will be held until it can be submitted (failed on %s):\",\n        method.name\n      )\n      return callback(error, returned, json)\n    } else if (error.class === ERRORS.RUNTIME) {\n      logger.warn(\n        error,\n        \"Calling %s on New Relic failed due to a runtime error. \" +\n          \"Data will be held until it can be submitted:\",\n        method.name\n      )\n      return callback(error, returned, json)\n    }\n    logger.error(\n      error,\n      \"Calling %s on New Relic failed unexpectedly. \" +\n        \"Data will be held until it can be submitted:\",\n      method.name\n    )\n    return callback(error, returned, json)\n  }\n\n  method.invoke(body, standardHandler)\n}\n\nCollectorAPI.prototype.isConnected = function isConnected() {\n  return !!this._agent.config.run_id\n}\n\nmodule.exports = CollectorAPI\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/collector/api.js\n// module id = 97\n// module chunks = 0","'use strict'\n\nvar fetchSystemInfo = require('../system-info')\nvar parse_labels = require('../util/label-parser')\n\nmodule.exports = facts\n\nfunction facts(agent, callback) {\n  fetchSystemInfo(agent, function cb_fetchSystemInfo(systemInfo) {\n    var hostname = agent.config.getHostnameSafe()\n    var results = {\n      utilization: {\n        metadata_version: 2,\n        logical_processors: systemInfo.logicalProcessors,\n        total_ram_mib: systemInfo.memory,\n        hostname: hostname\n      },\n      pid: process.pid,\n      host: hostname,\n      display_host: agent.config.getDisplayHost() || hostname,\n      language: 'nodejs',\n      app_name: agent.config.applications(),\n      agent_version: agent.version,\n      environment: agent.environment,\n      settings: agent.config.publicSettings(),\n      high_security: agent.config.high_security,\n      labels: parse_labels(agent.config.labels)\n    }\n\n    // TODO:  After reconfiguring agent startup to wait for the server to start\n    //        or for the first transaction, add the `port` for the server too.\n    // NOTE: The concat is necessary to prevent sort from happening in-place.\n    results.identifier = [\n      'nodejs',\n      results.host,\n      results.app_name.concat([]).sort().join(',')\n    ].join(':')\n\n    if (systemInfo.aws || systemInfo.docker) {\n      results.utilization.vendors = {}\n      if (systemInfo.aws) {\n        results.utilization.vendors.aws = systemInfo.aws\n      }\n      if (systemInfo.docker) {\n        results.utilization.vendors.docker = systemInfo.docker\n      }\n    }\n    if (systemInfo.config) {\n      results.utilization.config = systemInfo.config\n    }\n    return callback(results)\n  })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/collector/facts.js\n// module id = 98\n// module chunks = 0","'use strict'\n\nvar exec = require('child_process').exec\nvar fetchAWSInfo = require('./aws-info')\nvar fs = require('fs')\nvar logger = require('./logger.js').child({component: 'system-info'})\nvar os = require('os')\nvar parseCpuInfo = require('./parse-proc-cpuinfo')\nvar parseDockerInfo = require('./parse-dockerinfo')\nvar parseMemInfo = require('./parse-proc-meminfo')\nvar platform = os.platform()\n\nmodule.exports = fetchSystemInfo\n\nfunction isInteger(i) {\n  return i === parseInt(i, 10)\n}\n\nfunction fetchSystemInfo(agent, callback) {\n  var config = agent.config\n  var systemInfo = {\n    processorArch: os.arch()\n  }\n\n  var utilizationConfig = {}\n  if (config.utilization) {\n    var configProcessors = config.utilization.logical_processors\n    var configRam = config.utilization.total_ram_mib\n    var configHostname = config.utilization.billing_hostname\n\n    if (configProcessors) {\n      var parsedConfigProcessors = parseFloat(configProcessors, 10)\n      if (!isNaN(parsedConfigProcessors) && isInteger(parsedConfigProcessors)) {\n        utilizationConfig.logical_processors = parsedConfigProcessors\n      } else {\n        logger.info(\n          '%s supplied in config for utilization.logical_processors, expected a number',\n          configProcessors\n        )\n      }\n    }\n\n    if (configRam) {\n      var parsedConfigRam = parseFloat(configRam, 10)\n      if (!isNaN(parsedConfigRam) && isInteger(parsedConfigRam)) {\n        utilizationConfig.total_ram_mib = parsedConfigRam\n      } else {\n        logger.info(\n          '%s supplied in config for utilization.total_ram_mib, expected a number',\n          configRam\n        )\n      }\n    }\n\n    if (configHostname) {\n      if (typeof configHostname === 'string') {\n        utilizationConfig.hostname = configHostname\n      } else {\n        logger.info(\n          '%s supplied in config for utilization.Hostname, expected a string',\n          configHostname\n        )\n      }\n    }\n\n    if (Object.keys(utilizationConfig).length > 0) {\n      systemInfo.config = utilizationConfig\n    }\n  }\n\n  var tasksDone = 0\n  var numTasks = 5\n  function finishedResponse() {\n    if (++tasksDone === numTasks) return callback(systemInfo)\n  }\n\n  module.exports._getProcessorStats(function getProcessCB(processorStats) {\n    systemInfo.packages = processorStats.packages\n    systemInfo.logicalProcessors = processorStats.logical\n    systemInfo.cores = processorStats.cores\n    finishedResponse()\n  })\n  module.exports._getMemoryStats(function getMemCB(memory) {\n    systemInfo.memory = memory\n    finishedResponse()\n  })\n  getKernelVersion(function getVersionCB(kernelVersion) {\n    systemInfo.kernelVersion = kernelVersion\n    finishedResponse()\n  })\n  module.exports._getDockerContainerId(agent, function getContainerId(containerId) {\n    if (containerId) {\n      systemInfo.docker = {\n        id: containerId\n      }\n    }\n    finishedResponse()\n  })\n  fetchAWSInfo(agent, function getAWSInfo(aws) {\n    systemInfo.aws = aws\n    finishedResponse()\n  })\n}\n\n// placed on module for mocking purposes in tests\nmodule.exports._getProcessorStats = function getProcessorStats(callback) {\n  var processorStats = {\n    logical: null,\n    cores: null,\n    packages: null\n  }\n\n  if (platform.match(/darwin/i)) {\n    getSysctlValue(['hw.packages'], function getPackages(packages) {\n      getSysctlValue(['hw.physicalcpu_max', 'hw.physicalcpu'],\n      function getCores(cores) {\n        getSysctlValue(['hw.logicalcpu_max', 'hw.logicalcpu', 'hw.ncpu'],\n        function getLogicalCpu(logical) {\n          processorStats.logical = parseFloat(logical, 10)\n          processorStats.cores = parseFloat(cores, 10)\n          processorStats.packages = parseFloat(packages, 10)\n\n          for (var key in processorStats) {\n            if (!processorStats[key] || !isInteger(processorStats[key])) {\n              processorStats[key] = null\n            }\n          }\n\n          callback(processorStats)\n        })\n      })\n    })\n  } else if (platform.match(/bsd/i)) {\n    getSysctlValue(['hw.ncpu'], function getLogicalCpu(logical) {\n      processorStats.logical = logical\n      callback(processorStats)\n    })\n  } else if (platform.match(/linux/i)) {\n    readProc('/proc/cpuinfo', function parseProc(data) {\n      callback(parseCpuInfo(data))\n    })\n  } else {\n    logger.debug('Unknown platform: ' + platform + ', could not retrieve processor info')\n    callback(processorStats)\n  }\n}\n\n// placed on module for mocking purposes in tests\nmodule.exports._getMemoryStats = function getMemoryStats(callback) {\n  if (platform.match(/darwin/i)) {\n    getSysctlValue(['hw.memsize'], function getMem(memory) {\n      callback(parseInt(memory, 10) / (1024 * 1024))\n    })\n  } else if (platform.match(/bsd/i)) {\n    getSysctlValue(['hw.realmem'], function getMem(memory) {\n      callback(parseInt(memory, 10) / (1024 * 1024))\n    })\n  } else if (platform.match(/linux/i)) {\n    readProc('/proc/meminfo', function parseProc(data) {\n      callback(parseMemInfo(data))\n    })\n  } else {\n    logger.debug('Unknown platform: ' + platform + ', could not retrieve memory info')\n    callback(null)\n  }\n}\n\nfunction getKernelVersion(callback) {\n  if (platform.match(/darwin/i)) {\n    getSysctlValue(['kern.version'], function getMem(version) {\n      callback(version)\n    })\n  } else if (platform.match(/bsd/i)) {\n    getSysctlValue(['kern.version'], function getMem(version) {\n      callback(version)\n    })\n  } else if (platform.match(/linux/i)) {\n    readProc('/proc/version', function parseProc(data) {\n      callback(data)\n    })\n  } else {\n    logger.debug('Unknown platform' + platform + ', could not read kernel version')\n    callback(null)\n  }\n}\n\nmodule.exports._getDockerContainerId = function getDockerContainerId(agent, callback) {\n  if (!platform.match(/linux/i)) {\n    logger.debug('Platform is not a flavor of linux, omitting docker info')\n    callback(null)\n  } else {\n    readProc('/proc/self/cgroup', function getCGroup(data) {\n      if (!data) callback(null)\n      else callback(parseDockerInfo(agent, data))\n    })\n  }\n}\n\nfunction getSysctlValue(names, callback) {\n  if (!names) return callback(null)\n  var returned = false\n  var ran = 0\n  names.forEach(function sysctlName(name) {\n    exec('sysctl -n ' + name, respond)\n\n    function respond(err, stdout, stderr) {\n      if (returned) return\n      if (err) {\n        logger.debug('Error when trying to run: sysctl -n ' + name + ': %s', err.message)\n        callback(null)\n        returned = true\n      } else if (!stderr) {\n        callback(stdout)\n        returned = true\n      }\n      if (++ran === names.length && !returned) {\n        logger.debug('No sysctl info found for names: ' + names.toString())\n        callback(null)\n      }\n    }\n  })\n}\n\nfunction readProc(path, callback) {\n  fs.readFile(path, function readProcFile(err, data) {\n    if (err) {\n      logger.error('Error when trying to read ' + path, err)\n      callback(null)\n    } else {\n      callback(data.toString())\n    }\n  })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/system-info.js\n// module id = 99\n// module chunks = 0","'use strict'\n\nvar logger = require('./logger.js').child({component: 'aws-info'})\nvar http = require('http')\nvar NAMES = require('./metrics/names.js')\nvar concat = require('concat-stream')\n\nmodule.exports = fetchAWSInfo\nmodule.exports.clearCache = function clearAWSCache() {\n  resultDict = null\n}\n\nvar resultDict\n\nfunction fetchAWSInfo(agent, callback) {\n  if (!agent.config.utilization || !agent.config.utilization.detect_aws) {\n    return callback(null)\n  }\n\n  if (resultDict) {\n    return callback(resultDict)\n  }\n\n  var awsQuery = module.exports._awsQuery\n\n  awsQuery('instance-type', agent, function getInstanceType(type) {\n    if (!type) return callback(null)\n    awsQuery('instance-id', agent, function getInstanceId(id) {\n      if (!id) return callback(null)\n      awsQuery('placement/availability-zone', agent, function getZone(zone) {\n        if (!zone) return callback(null)\n        resultDict = {\n          type: type,\n          id: id,\n          zone: zone\n        }\n        return callback(resultDict)\n      })\n    })\n  })\n}\n\n\nmodule.exports._awsQuery = function awsQuery(key, agent, callback) {\n  var instanceHost = '169.254.169.254'\n  var apiVersion = '2008-02-01'\n  var url = ['http:/', instanceHost, apiVersion, 'meta-data', key].join('/')\n  var req = http.get(url, function awsRequest(res) {\n    res.pipe(concat(respond))\n    function respond(data) {\n      var valid = checkResponseString(data)\n      if (!valid) {\n        var awsError = agent.metrics.getOrCreateMetric(NAMES.UTILIZATION.AWS_ERROR)\n        awsError.incrementCallCount()\n        logger.debug('Response for attribute ' + key + ': %s'\n          , data)\n        data = null\n      } else {\n        data = data.toString('utf8')\n      }\n\n      agent.removeListener('errored', abortRequest)\n      agent.removeListener('stopped', abortRequest)\n      callback(data)\n    }\n  })\n  req.setTimeout(1000, function awsTimeout() {\n    logger.debug('Request for attribute %s timed out', key)\n    callback(null)\n  })\n  req.on('error', function awsError(err) {\n    logger.debug('Message for attribute %s: %s', key, err.message)\n    callback(null)\n  })\n\n  agent.once('errored', abortRequest)\n  agent.once('stopped', abortRequest)\n\n  function abortRequest() {\n    logger.debug('Abborting request for attribute %s', key)\n    req.abort()\n    agent.removeListener('errored', abortRequest)\n    agent.removeListener('stopped', abortRequest)\n  }\n}\n\nfunction checkResponseString(str) {\n  var validCharacters = /[0-9a-zA-Z_ ./-]/\n  var valid = str.length <= 255 && str.length > 0\n\n  var i = 0\n  var len = str.length\n\n  while (valid && i < len) {\n    valid = valid && (str[i] > 127 || String.fromCharCode(str[i]).match(validCharacters))\n    i++\n  }\n\n  return valid\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/aws-info.js\n// module id = 100\n// module chunks = 0","var ClientRequest = require('./lib/request')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-http/index.js\n// module id = 101\n// module chunks = 0","var capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\nvar toArrayBuffer = require('to-arraybuffer')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else if (capability.vbArray && preferBinary) {\n\t\treturn 'text:vbarray'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || 'timeout' in opts) {\n\t\t// If the use of XHR should be preferred and includes preserving the 'content-type' header.\n\t\t// Force XHR to be used since the Fetch API does not yet support timeouts.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar self = this\n\treturn self._headers[name.toLowerCase()].value\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH' || opts.method === 'MERGE') {\n\t\tif (capability.blobConstructor) {\n\t\t\tbody = new global.Blob(self._body.map(function (buffer) {\n\t\t\t\treturn toArrayBuffer(buffer)\n\t\t\t}), {\n\t\t\t\ttype: (headersObj['content-type'] || {}).value || ''\n\t\t\t})\n\t\t} else {\n\t\t\t// get utf8 string\n\t\t\tbody = Buffer.concat(self._body).toString()\n\t\t}\n\t}\n\n\tif (self._mode === 'fetch') {\n\t\tvar headers = Object.keys(headersObj).map(function (name) {\n\t\t\treturn [headersObj[name].name, headersObj[name].value]\n\t\t})\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headers,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin'\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode.split(':')[0]\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('timeout' in opts) {\n\t\t\txhr.timeout = opts.timeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('timeout')\n\t\t\t}\n\t\t}\n\n\t\tObject.keys(headersObj).forEach(function (name) {\n\t\t\txhr.setRequestHeader(headersObj[name].name, headersObj[name].value)\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress()\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {\n\tvar self = this\n\tself._destroyed = true\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\t// Currently, there isn't a way to truly abort a fetch.\n\t// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setTimeout = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'user-agent',\n\t'via'\n]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-http/lib/request.js\n// module id = 102\n// module chunks = 0","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.blobConstructor = false\ntry {\n\tnew Blob([new ArrayBuffer(1)])\n\texports.blobConstructor = true\n} catch (e) {}\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n// Safari 7.1 appears to have fixed this bug.\nvar haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'\nvar haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&\n\tcheckTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nexports.vbArray = isFunction(global.VBArray)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-http/lib/capability.js\n// module id = 103\n// module chunks = 0","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function(header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\n\t\t// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(new Buffer(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function(err) {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {}\n\nIncomingMessage.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text:vbarray': // For IE9\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\ttry {\n\t\t\t\t// This fails in IE8\n\t\t\t\tresponse = new global.VBArray(xhr.responseBody).toArray()\n\t\t\t} catch (e) {}\n\t\t\tif (response !== null) {\n\t\t\t\tself.push(new Buffer(response))\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Falls through in IE8\t\n\t\tcase 'text':\n\t\t\ttry { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n\t\t\t\tresponse = xhr.responseText\n\t\t\t} catch (e) {\n\t\t\t\tself._mode = 'text:vbarray'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = new Buffer(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tself.push(null)\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-http/lib/response.js\n// module id = 104\n// module chunks = 0","var Buffer = require('buffer').Buffer\n\nmodule.exports = function (buf) {\n\t// If the buffer is backed by a Uint8Array, a faster version will work\n\tif (buf instanceof Uint8Array) {\n\t\t// If the buffer isn't a subarray, return the underlying ArrayBuffer\n\t\tif (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n\t\t\treturn buf.buffer\n\t\t} else if (typeof buf.buffer.slice === 'function') {\n\t\t\t// Otherwise we need to get a proper copy\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)\n\t\t}\n\t}\n\n\tif (Buffer.isBuffer(buf)) {\n\t\t// This is the slow version that will work with any Buffer\n\t\t// implementation (even in old browsers)\n\t\tvar arrayCopy = new Uint8Array(buf.length)\n\t\tvar len = buf.length\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tarrayCopy[i] = buf[i]\n\t\t}\n\t\treturn arrayCopy.buffer\n\t} else {\n\t\tthrow new Error('Argument must be a Buffer')\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/to-arraybuffer/index.js\n// module id = 105\n// module chunks = 0","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xtend/immutable.js\n// module id = 106\n// module chunks = 0","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/builtin-status-codes/browser.js\n// module id = 107\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/url/url.js\n// module id = 108\n// module chunks = 0","/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/url/~/punycode/punycode.js\n// module id = 109\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 110\n// module chunks = 0","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/url/util.js\n// module id = 111\n// module chunks = 0","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/querystring/index.js\n// module id = 112\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/querystring/decode.js\n// module id = 113\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/querystring/encode.js\n// module id = 114\n// module chunks = 0","var Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\n\nif (typeof Uint8Array === 'undefined') {\n  var U8 = require('typedarray').Uint8Array\n} else {\n  var U8 = Uint8Array\n}\n\nfunction ConcatStream(opts, cb) {\n  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n  if (!opts) opts = {}\n\n  var encoding = opts.encoding\n  var shouldInferEncoding = false\n\n  if (!encoding) {\n    shouldInferEncoding = true\n  } else {\n    encoding =  String(encoding).toLowerCase()\n    if (encoding === 'u8' || encoding === 'uint8') {\n      encoding = 'uint8array'\n    }\n  }\n\n  Writable.call(this, { objectMode: true })\n\n  this.encoding = encoding\n  this.shouldInferEncoding = shouldInferEncoding\n\n  if (cb) this.on('finish', function () { cb(this.getBody()) })\n  this.body = []\n}\n\nmodule.exports = ConcatStream\ninherits(ConcatStream, Writable)\n\nConcatStream.prototype._write = function(chunk, enc, next) {\n  this.body.push(chunk)\n  next()\n}\n\nConcatStream.prototype.inferEncoding = function (buff) {\n  var firstBuffer = buff === undefined ? this.body[0] : buff;\n  if (Buffer.isBuffer(firstBuffer)) return 'buffer'\n  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'\n  if (Array.isArray(firstBuffer)) return 'array'\n  if (typeof firstBuffer === 'string') return 'string'\n  if (Object.prototype.toString.call(firstBuffer) === \"[object Object]\") return 'object'\n  return 'buffer'\n}\n\nConcatStream.prototype.getBody = function () {\n  if (!this.encoding && this.body.length === 0) return []\n  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()\n  if (this.encoding === 'array') return arrayConcat(this.body)\n  if (this.encoding === 'string') return stringConcat(this.body)\n  if (this.encoding === 'buffer') return bufferConcat(this.body)\n  if (this.encoding === 'uint8array') return u8Concat(this.body)\n  return this.body\n}\n\nvar isArray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]'\n}\n\nfunction isArrayish (arr) {\n  return /Array\\]$/.test(Object.prototype.toString.call(arr))\n}\n\nfunction isBufferish (p) {\n  return typeof p === 'string' || isArrayish(p) || (p && typeof p.subarray === 'function')\n}\n\nfunction stringConcat (parts) {\n  var strings = []\n  var needsToString = false\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i]\n    if (typeof p === 'string') {\n      strings.push(p)\n    } else if (Buffer.isBuffer(p)) {\n      strings.push(p)\n    } else if (isBufferish(p)) {\n      strings.push(new Buffer(p))\n    } else {\n      strings.push(new Buffer(String(p)))\n    }\n  }\n  if (Buffer.isBuffer(parts[0])) {\n    strings = Buffer.concat(strings)\n    strings = strings.toString('utf8')\n  } else {\n    strings = strings.join('')\n  }\n  return strings\n}\n\nfunction bufferConcat (parts) {\n  var bufs = []\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i]\n    if (Buffer.isBuffer(p)) {\n      bufs.push(p)\n    } else if (isBufferish(p)) {\n      bufs.push(new Buffer(p))\n    } else {\n      bufs.push(new Buffer(String(p)))\n    }\n  }\n  return Buffer.concat(bufs)\n}\n\nfunction arrayConcat (parts) {\n  var res = []\n  for (var i = 0; i < parts.length; i++) {\n    res.push.apply(res, parts[i])\n  }\n  return res\n}\n\nfunction u8Concat (parts) {\n  var len = 0\n  for (var i = 0; i < parts.length; i++) {\n    if (typeof parts[i] === 'string') {\n      parts[i] = new Buffer(parts[i])\n    }\n    len += parts[i].length\n  }\n  var u8 = new U8(len)\n  for (var i = 0, offset = 0; i < parts.length; i++) {\n    var part = parts[i]\n    for (var j = 0; j < part.length; j++) {\n      u8[offset++] = part[j]\n    }\n  }\n  return u8\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/index.js\n// module id = 115\n// module chunks = 0","var Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\nif (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/readable.js\n// module id = 116\n// module chunks = 0","'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n/*<replacement>*/\nvar bufferShim = require('buffer-shims');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = bufferShim.from(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var _e = new Error('stream.unshift() after end event');\n      stream.emit('error', _e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function (ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = bufferShim.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_readable.js\n// module id = 117\n// module chunks = 0","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/~/process-nextick-args/index.js\n// module id = 118\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/~/isarray/index.js\n// module id = 119\n// module chunks = 0","'use strict';\n\nvar buffer = require('buffer');\nvar Buffer = buffer.Buffer;\nvar SlowBuffer = buffer.SlowBuffer;\nvar MAX_LEN = buffer.kMaxLength || 2147483647;\nexports.alloc = function alloc(size, fill, encoding) {\n  if (typeof Buffer.alloc === 'function') {\n    return Buffer.alloc(size, fill, encoding);\n  }\n  if (typeof encoding === 'number') {\n    throw new TypeError('encoding must not be number');\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size > MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  var enc = encoding;\n  var _fill = fill;\n  if (_fill === undefined) {\n    enc = undefined;\n    _fill = 0;\n  }\n  var buf = new Buffer(size);\n  if (typeof _fill === 'string') {\n    var fillBuf = new Buffer(_fill, enc);\n    var flen = fillBuf.length;\n    var i = -1;\n    while (++i < size) {\n      buf[i] = fillBuf[i % flen];\n    }\n  } else {\n    buf.fill(_fill);\n  }\n  return buf;\n}\nexports.allocUnsafe = function allocUnsafe(size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    return Buffer.allocUnsafe(size);\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size > MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  return new Buffer(size);\n}\nexports.from = function from(value, encodingOrOffset, length) {\n  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {\n    return Buffer.from(value, encodingOrOffset, length);\n  }\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n  if (typeof value === 'string') {\n    return new Buffer(value, encodingOrOffset);\n  }\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    var offset = encodingOrOffset;\n    if (arguments.length === 1) {\n      return new Buffer(value);\n    }\n    if (typeof offset === 'undefined') {\n      offset = 0;\n    }\n    var len = length;\n    if (typeof len === 'undefined') {\n      len = value.byteLength - offset;\n    }\n    if (offset >= value.byteLength) {\n      throw new RangeError('\\'offset\\' is out of bounds');\n    }\n    if (len > value.byteLength - offset) {\n      throw new RangeError('\\'length\\' is out of bounds');\n    }\n    return new Buffer(value.slice(offset, offset + len));\n  }\n  if (Buffer.isBuffer(value)) {\n    var out = new Buffer(value.length);\n    value.copy(out, 0, 0, value.length);\n    return out;\n  }\n  if (value) {\n    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {\n      return new Buffer(value);\n    }\n    if (value.type === 'Buffer' && Array.isArray(value.data)) {\n      return new Buffer(value.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');\n}\nexports.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  if (typeof Buffer.allocUnsafeSlow === 'function') {\n    return Buffer.allocUnsafeSlow(size);\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size >= MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  return new SlowBuffer(size);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/~/buffer-shims/index.js\n// module id = 120\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/~/core-util-is/lib/util.js\n// module id = 121\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/inherits/inherits_browser.js\n// module id = 122\n// module chunks = 0","/* (ignored) */\n\n\n//////////////////\n// WEBPACK FOOTER\n// util (ignored)\n// module id = 123\n// module chunks = 0","'use strict';\n\nvar Buffer = require('buffer').Buffer;\n/*<replacement>*/\nvar bufferShim = require('buffer-shims');\n/*</replacement>*/\n\nmodule.exports = BufferList;\n\nfunction BufferList() {\n  this.head = null;\n  this.tail = null;\n  this.length = 0;\n}\n\nBufferList.prototype.push = function (v) {\n  var entry = { data: v, next: null };\n  if (this.length > 0) this.tail.next = entry;else this.head = entry;\n  this.tail = entry;\n  ++this.length;\n};\n\nBufferList.prototype.unshift = function (v) {\n  var entry = { data: v, next: this.head };\n  if (this.length === 0) this.tail = entry;\n  this.head = entry;\n  ++this.length;\n};\n\nBufferList.prototype.shift = function () {\n  if (this.length === 0) return;\n  var ret = this.head.data;\n  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n  --this.length;\n  return ret;\n};\n\nBufferList.prototype.clear = function () {\n  this.head = this.tail = null;\n  this.length = 0;\n};\n\nBufferList.prototype.join = function (s) {\n  if (this.length === 0) return '';\n  var p = this.head;\n  var ret = '' + p.data;\n  while (p = p.next) {\n    ret += s + p.data;\n  }return ret;\n};\n\nBufferList.prototype.concat = function (n) {\n  if (this.length === 0) return bufferShim.alloc(0);\n  if (this.length === 1) return this.head.data;\n  var ret = bufferShim.allocUnsafe(n >>> 0);\n  var p = this.head;\n  var i = 0;\n  while (p) {\n    p.data.copy(ret, i);\n    i += p.data.length;\n    p = p.next;\n  }\n  return ret;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/lib/internal/streams/BufferList.js\n// module id = 124\n// module chunks = 0","// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_duplex.js\n// module id = 125\n// module chunks = 0","// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n/*<replacement>*/\nvar bufferShim = require('buffer-shims');\n/*</replacement>*/\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n  // Always throw error if a null is written\n  // if we are not in object mode then throw\n  // if it is not a buffer, string, or undefined.\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = bufferShim.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_writable.js\n// module id = 126\n// module chunks = 0","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/~/util-deprecate/browser.js\n// module id = 127\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/~/string_decoder/index.js\n// module id = 128\n// module chunks = 0","// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_transform.js\n// module id = 129\n// module chunks = 0","// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/readable-stream/lib/_stream_passthrough.js\n// module id = 130\n// module chunks = 0","var undefined = (void 0); // Paranoia\n\n// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n// create, and consume so much memory, that the browser appears frozen.\nvar MAX_ARRAY_LENGTH = 1e5;\n\n// Approximations of internal ECMAScript conversion functions\nvar ECMAScript = (function() {\n  // Stash a copy in case other scripts modify these\n  var opts = Object.prototype.toString,\n      ophop = Object.prototype.hasOwnProperty;\n\n  return {\n    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n    Class: function(v) { return opts.call(v).replace(/^\\[object *|\\]$/g, ''); },\n    HasProperty: function(o, p) { return p in o; },\n    HasOwnProperty: function(o, p) { return ophop.call(o, p); },\n    IsCallable: function(o) { return typeof o === 'function'; },\n    ToInt32: function(v) { return v >> 0; },\n    ToUint32: function(v) { return v >>> 0; }\n  };\n}());\n\n// Snapshot intrinsics\nvar LN2 = Math.LN2,\n    abs = Math.abs,\n    floor = Math.floor,\n    log = Math.log,\n    min = Math.min,\n    pow = Math.pow,\n    round = Math.round;\n\n// ES5: lock down object properties\nfunction configureProperties(obj) {\n  if (getOwnPropNames && defineProp) {\n    var props = getOwnPropNames(obj), i;\n    for (i = 0; i < props.length; i += 1) {\n      defineProp(obj, props[i], {\n        value: obj[props[i]],\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n}\n\n// emulate ES5 getter/setter API using legacy APIs\n// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\nvar defineProp\nif (Object.defineProperty && (function() {\n      try {\n        Object.defineProperty({}, 'x', {});\n        return true;\n      } catch (e) {\n        return false;\n      }\n    })()) {\n  defineProp = Object.defineProperty;\n} else {\n  defineProp = function(o, p, desc) {\n    if (!o === Object(o)) throw new TypeError(\"Object.defineProperty called on non-object\");\n    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }\n    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }\n    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }\n    return o;\n  };\n}\n\nvar getOwnPropNames = Object.getOwnPropertyNames || function (o) {\n  if (o !== Object(o)) throw new TypeError(\"Object.getOwnPropertyNames called on non-object\");\n  var props = [], p;\n  for (p in o) {\n    if (ECMAScript.HasOwnProperty(o, p)) {\n      props.push(p);\n    }\n  }\n  return props;\n};\n\n// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n// for index in 0 ... obj.length\nfunction makeArrayAccessors(obj) {\n  if (!defineProp) { return; }\n\n  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError(\"Array too large for polyfill\");\n\n  function makeArrayAccessor(index) {\n    defineProp(obj, index, {\n      'get': function() { return obj._getter(index); },\n      'set': function(v) { obj._setter(index, v); },\n      enumerable: true,\n      configurable: false\n    });\n  }\n\n  var i;\n  for (i = 0; i < obj.length; i += 1) {\n    makeArrayAccessor(i);\n  }\n}\n\n// Internal conversion functions:\n//    pack<Type>()   - take a number (interpreted as Type), output a byte array\n//    unpack<Type>() - take a byte array, output a Type-like number\n\nfunction as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }\nfunction as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }\n\nfunction packI8(n) { return [n & 0xff]; }\nfunction unpackI8(bytes) { return as_signed(bytes[0], 8); }\n\nfunction packU8(n) { return [n & 0xff]; }\nfunction unpackU8(bytes) { return as_unsigned(bytes[0], 8); }\n\nfunction packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }\n\nfunction packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\nfunction unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }\n\nfunction packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\nfunction unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }\n\nfunction packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\nfunction unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\nfunction packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\nfunction unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\nfunction packIEEE754(v, ebits, fbits) {\n\n  var bias = (1 << (ebits - 1)) - 1,\n      s, e, f, ln,\n      i, bits, str, bytes;\n\n  function roundToEven(n) {\n    var w = floor(n), f = n - w;\n    if (f < 0.5)\n      return w;\n    if (f > 0.5)\n      return w + 1;\n    return w % 2 ? w + 1 : w;\n  }\n\n  // Compute sign, exponent, fraction\n  if (v !== v) {\n    // NaN\n    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;\n  } else if (v === Infinity || v === -Infinity) {\n    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;\n  } else if (v === 0) {\n    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;\n  } else {\n    s = v < 0;\n    v = abs(v);\n\n    if (v >= pow(2, 1 - bias)) {\n      e = min(floor(log(v) / LN2), 1023);\n      f = roundToEven(v / pow(2, e) * pow(2, fbits));\n      if (f / pow(2, fbits) >= 2) {\n        e = e + 1;\n        f = 1;\n      }\n      if (e > bias) {\n        // Overflow\n        e = (1 << ebits) - 1;\n        f = 0;\n      } else {\n        // Normalized\n        e = e + bias;\n        f = f - pow(2, fbits);\n      }\n    } else {\n      // Denormalized\n      e = 0;\n      f = roundToEven(v / pow(2, 1 - bias - fbits));\n    }\n  }\n\n  // Pack sign, exponent, fraction\n  bits = [];\n  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }\n  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }\n  bits.push(s ? 1 : 0);\n  bits.reverse();\n  str = bits.join('');\n\n  // Bits to bytes\n  bytes = [];\n  while (str.length) {\n    bytes.push(parseInt(str.substring(0, 8), 2));\n    str = str.substring(8);\n  }\n  return bytes;\n}\n\nfunction unpackIEEE754(bytes, ebits, fbits) {\n\n  // Bytes to bits\n  var bits = [], i, j, b, str,\n      bias, s, e, f;\n\n  for (i = bytes.length; i; i -= 1) {\n    b = bytes[i - 1];\n    for (j = 8; j; j -= 1) {\n      bits.push(b % 2 ? 1 : 0); b = b >> 1;\n    }\n  }\n  bits.reverse();\n  str = bits.join('');\n\n  // Unpack sign, exponent, fraction\n  bias = (1 << (ebits - 1)) - 1;\n  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n  e = parseInt(str.substring(1, 1 + ebits), 2);\n  f = parseInt(str.substring(1 + ebits), 2);\n\n  // Produce number\n  if (e === (1 << ebits) - 1) {\n    return f !== 0 ? NaN : s * Infinity;\n  } else if (e > 0) {\n    // Normalized\n    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n  } else if (f !== 0) {\n    // Denormalized\n    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n  } else {\n    return s < 0 ? -0 : 0;\n  }\n}\n\nfunction unpackF64(b) { return unpackIEEE754(b, 11, 52); }\nfunction packF64(v) { return packIEEE754(v, 11, 52); }\nfunction unpackF32(b) { return unpackIEEE754(b, 8, 23); }\nfunction packF32(v) { return packIEEE754(v, 8, 23); }\n\n\n//\n// 3 The ArrayBuffer Type\n//\n\n(function() {\n\n  /** @constructor */\n  var ArrayBuffer = function ArrayBuffer(length) {\n    length = ECMAScript.ToInt32(length);\n    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');\n\n    this.byteLength = length;\n    this._bytes = [];\n    this._bytes.length = length;\n\n    var i;\n    for (i = 0; i < this.byteLength; i += 1) {\n      this._bytes[i] = 0;\n    }\n\n    configureProperties(this);\n  };\n\n  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;\n\n  //\n  // 4 The ArrayBufferView Type\n  //\n\n  // NOTE: this constructor is not exported\n  /** @constructor */\n  var ArrayBufferView = function ArrayBufferView() {\n    //this.buffer = null;\n    //this.byteOffset = 0;\n    //this.byteLength = 0;\n  };\n\n  //\n  // 5 The Typed Array View Types\n  //\n\n  function makeConstructor(bytesPerElement, pack, unpack) {\n    // Each TypedArray type requires a distinct constructor instance with\n    // identical logic, which this produces.\n\n    var ctor;\n    ctor = function(buffer, byteOffset, length) {\n      var array, sequence, i, s;\n\n      if (!arguments.length || typeof arguments[0] === 'number') {\n        // Constructor(unsigned long length)\n        this.length = ECMAScript.ToInt32(arguments[0]);\n        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');\n\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {\n        // Constructor(TypedArray array)\n        array = arguments[0];\n\n        this.length = array.length;\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n\n        for (i = 0; i < this.length; i += 1) {\n          this._setter(i, array._getter(i));\n        }\n      } else if (typeof arguments[0] === 'object' &&\n                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(sequence<type> array)\n        sequence = arguments[0];\n\n        this.length = ECMAScript.ToUint32(sequence.length);\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n\n        for (i = 0; i < this.length; i += 1) {\n          s = sequence[i];\n          this._setter(i, Number(s));\n        }\n      } else if (typeof arguments[0] === 'object' &&\n                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(ArrayBuffer buffer,\n        //             optional unsigned long byteOffset, optional unsigned long length)\n        this.buffer = buffer;\n\n        this.byteOffset = ECMAScript.ToUint32(byteOffset);\n        if (this.byteOffset > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset out of range\");\n        }\n\n        if (this.byteOffset % this.BYTES_PER_ELEMENT) {\n          // The given byteOffset must be a multiple of the element\n          // size of the specific type, otherwise an exception is raised.\n          throw new RangeError(\"ArrayBuffer length minus the byteOffset is not a multiple of the element size.\");\n        }\n\n        if (arguments.length < 3) {\n          this.byteLength = this.buffer.byteLength - this.byteOffset;\n\n          if (this.byteLength % this.BYTES_PER_ELEMENT) {\n            throw new RangeError(\"length of buffer minus byteOffset not a multiple of the element size\");\n          }\n          this.length = this.byteLength / this.BYTES_PER_ELEMENT;\n        } else {\n          this.length = ECMAScript.ToUint32(length);\n          this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        }\n\n        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n\n      this.constructor = ctor;\n\n      configureProperties(this);\n      makeArrayAccessors(this);\n    };\n\n    ctor.prototype = new ArrayBufferView();\n    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;\n    ctor.prototype._pack = pack;\n    ctor.prototype._unpack = unpack;\n    ctor.BYTES_PER_ELEMENT = bytesPerElement;\n\n    // getter type (unsigned long index);\n    ctor.prototype._getter = function(index) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n\n      var bytes = [], i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        bytes.push(this.buffer._bytes[o]);\n      }\n      return this._unpack(bytes);\n    };\n\n    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n    ctor.prototype.get = ctor.prototype._getter;\n\n    // setter void (unsigned long index, type value);\n    ctor.prototype._setter = function(index, value) {\n      if (arguments.length < 2) throw new SyntaxError(\"Not enough arguments\");\n\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n\n      var bytes = this._pack(value), i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        this.buffer._bytes[o] = bytes[i];\n      }\n    };\n\n    // void set(TypedArray array, optional unsigned long offset);\n    // void set(sequence<type> array, optional unsigned long offset);\n    ctor.prototype.set = function(index, value) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n      var array, sequence, offset, len,\n          i, s, d,\n          byteOffset, byteLength, tmp;\n\n      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {\n        // void set(TypedArray array, optional unsigned long offset);\n        array = arguments[0];\n        offset = ECMAScript.ToUint32(arguments[1]);\n\n        if (offset + array.length > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n\n        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n        byteLength = array.length * this.BYTES_PER_ELEMENT;\n\n        if (array.buffer === this.buffer) {\n          tmp = [];\n          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n            tmp[i] = array.buffer._bytes[s];\n          }\n          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n            this.buffer._bytes[d] = tmp[i];\n          }\n        } else {\n          for (i = 0, s = array.byteOffset, d = byteOffset;\n               i < byteLength; i += 1, s += 1, d += 1) {\n            this.buffer._bytes[d] = array.buffer._bytes[s];\n          }\n        }\n      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {\n        // void set(sequence<type> array, optional unsigned long offset);\n        sequence = arguments[0];\n        len = ECMAScript.ToUint32(sequence.length);\n        offset = ECMAScript.ToUint32(arguments[1]);\n\n        if (offset + len > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n\n        for (i = 0; i < len; i += 1) {\n          s = sequence[i];\n          this._setter(offset + i, Number(s));\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n    };\n\n    // TypedArray subarray(long begin, optional long end);\n    ctor.prototype.subarray = function(start, end) {\n      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n      start = ECMAScript.ToInt32(start);\n      end = ECMAScript.ToInt32(end);\n\n      if (arguments.length < 1) { start = 0; }\n      if (arguments.length < 2) { end = this.length; }\n\n      if (start < 0) { start = this.length + start; }\n      if (end < 0) { end = this.length + end; }\n\n      start = clamp(start, 0, this.length);\n      end = clamp(end, 0, this.length);\n\n      var len = end - start;\n      if (len < 0) {\n        len = 0;\n      }\n\n      return new this.constructor(\n        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n    };\n\n    return ctor;\n  }\n\n  var Int8Array = makeConstructor(1, packI8, unpackI8);\n  var Uint8Array = makeConstructor(1, packU8, unpackU8);\n  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);\n  var Int16Array = makeConstructor(2, packI16, unpackI16);\n  var Uint16Array = makeConstructor(2, packU16, unpackU16);\n  var Int32Array = makeConstructor(4, packI32, unpackI32);\n  var Uint32Array = makeConstructor(4, packU32, unpackU32);\n  var Float32Array = makeConstructor(4, packF32, unpackF32);\n  var Float64Array = makeConstructor(8, packF64, unpackF64);\n\n  exports.Int8Array = exports.Int8Array || Int8Array;\n  exports.Uint8Array = exports.Uint8Array || Uint8Array;\n  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;\n  exports.Int16Array = exports.Int16Array || Int16Array;\n  exports.Uint16Array = exports.Uint16Array || Uint16Array;\n  exports.Int32Array = exports.Int32Array || Int32Array;\n  exports.Uint32Array = exports.Uint32Array || Uint32Array;\n  exports.Float32Array = exports.Float32Array || Float32Array;\n  exports.Float64Array = exports.Float64Array || Float64Array;\n}());\n\n//\n// 6 The DataView View Type\n//\n\n(function() {\n  function r(array, index) {\n    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];\n  }\n\n  var IS_BIG_ENDIAN = (function() {\n    var u16array = new(exports.Uint16Array)([0x1234]),\n        u8array = new(exports.Uint8Array)(u16array.buffer);\n    return r(u8array, 0) === 0x12;\n  }());\n\n  // Constructor(ArrayBuffer buffer,\n  //             optional unsigned long byteOffset,\n  //             optional unsigned long byteLength)\n  /** @constructor */\n  var DataView = function DataView(buffer, byteOffset, byteLength) {\n    if (arguments.length === 0) {\n      buffer = new exports.ArrayBuffer(0);\n    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {\n      throw new TypeError(\"TypeError\");\n    }\n\n    this.buffer = buffer || new exports.ArrayBuffer(0);\n\n    this.byteOffset = ECMAScript.ToUint32(byteOffset);\n    if (this.byteOffset > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset out of range\");\n    }\n\n    if (arguments.length < 3) {\n      this.byteLength = this.buffer.byteLength - this.byteOffset;\n    } else {\n      this.byteLength = ECMAScript.ToUint32(byteLength);\n    }\n\n    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n    }\n\n    configureProperties(this);\n  };\n\n  function makeGetter(arrayType) {\n    return function(byteOffset, littleEndian) {\n\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n      byteOffset += this.byteOffset;\n\n      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n          bytes = [], i;\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(uint8Array, i));\n      }\n\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);\n    };\n  }\n\n  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);\n  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);\n  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);\n  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);\n  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);\n  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);\n  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);\n  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);\n\n  function makeSetter(arrayType) {\n    return function(byteOffset, value, littleEndian) {\n\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n\n      // Get bytes\n      var typeArray = new arrayType([value]),\n          byteArray = new exports.Uint8Array(typeArray.buffer),\n          bytes = [], i, byteView;\n\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(byteArray, i));\n      }\n\n      // Flip if necessary\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      // Write them\n      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n      byteView.set(bytes);\n    };\n  }\n\n  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);\n  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);\n  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);\n  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);\n  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);\n  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);\n  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);\n  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);\n\n  exports.DataView = exports.DataView || DataView;\n\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/concat-stream/~/typedarray/index.js\n// module id = 131\n// module chunks = 0","'use strict'\n\nvar logger = require('./logger.js').child({component: 'proc-cpuinfo'})\nmodule.exports = parseProcCPUInfo\n\nfunction parseProcCPUInfo(data) {\n  var relevantAttributes = [\n    'processor',\n    'physical id',\n    'cpu cores',\n    'core id'\n  ]\n\n  var processorStats = {\n    logical: null,\n    cores: null,\n    packages: null\n  }\n\n  // seperate the processors\n  var splitData = data.split('\\n')\n    .map(function formatAttribute(attr) {\n      return attr.split(':')\n        .map(function eliminateExtraWhitespace(s) {\n          return s.replace(/\\\\r|\\\\t| {2,}/g, '').trim()\n        })\n    })\n\n  var validData = splitData.filter(function checkForValidAttrs(a) {\n    return a.length === 2 && relevantAttributes.indexOf(a[0]) !== -1\n  })\n  if (validData.length === 0) {\n    logger.debug('No applicable cpu attributes found')\n    return processorStats\n  }\n\n  splitData = collapseMultilineValues(splitData)\n\n  var processors = seperateProcessors(splitData)\n\n  processorStats = countProcessorStats(processors)\n  if (!processorStats.cores) {\n    if (processorStats.logical === 1) {\n      // some older, single-core processors might not list ids,\n      // so we'll mark them 1\n      processorStats.cores = 1\n      processorStats.packages = 1\n    } else {\n      // there is no way of knowing how many packages\n      // or cores there are\n      processorStats.cores = null\n      processorStats.packages = null\n    }\n  }\n  return processorStats\n}\n\n// some values are split up over multiple lines, these won't be broken\n// by split(':'), and should be folded into the last seen valid value\nfunction collapseMultilineValues(li) {\n  var tmp = []\n  var last\n  for (var i = 0; i < li.length; ++i) {\n    if (li[i].length === 2) {\n      // store the last valid entry to append invalid entries to\n      last = li[i]\n      tmp.push(last)\n    } else {\n      last[1] += li[i][0]\n    }\n  }\n\n  return tmp\n}\n\n// walk through the processed list of key, value pairs and populate\n// objects till you find a collision\nfunction seperateProcessors(processorData) {\n  var processors = []\n  var processor = {}\n  for (var i = 0; i < processorData.length; ++i) {\n    var key = processorData[i][0]\n    var value = processorData[i][1]\n    if (processor[key] !== undefined) {\n      processors.push(processor)\n      processor = {}\n    }\n    processor[key] = value\n  }\n  processors.push(processor)\n  return processors\n}\n\nfunction countProcessorStats(processors) {\n  var phys = []\n  var cores = []\n\n  for (var i = 0; i < processors.length; i++) {\n    var processor = processors[i]\n    if (processor['physical id'] &&\n        processor['cpu cores'] &&\n        phys.indexOf(processor['physical id']) === -1) {\n      phys.push(processor['physical id'])\n      cores.push(processor['cpu cores'])\n    }\n  }\n\n  return {\n    logical: processors.length,\n    cores: cores\n      .map(function convertToInt(s) {\n        return parseInt(s, 10)\n      })\n      .reduce(function sum(a, b) {\n        return a + b\n      }, 0),\n    packages: phys.length\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/parse-proc-cpuinfo.js\n// module id = 132\n// module chunks = 0","'use strict'\n\nvar logger = require('./logger.js').child({component: 'dockerinfo'})\nvar NAMES = require('./metrics/names.js')\nmodule.exports = parseDockerInfo\n\nfunction parseDockerInfo(agent, data) {\n  if (!agent.config.utilization || !agent.config.utilization.detect_docker) return null\n  var cpuCgroup = parseCgroupIds(data).cpu\n  // if we can't parse the cgroups, or if the cpu is not in a cgroup\n  var dockerError = agent.metrics.getOrCreateMetric(NAMES.UTILIZATION.DOCKER_ERROR)\n  if (!cpuCgroup) {\n    logger.debug('Could not parse cgroup data from: ' + data)\n    dockerError.incrementCallCount()\n    return null\n  }\n\n  // if cpu isn't in a cgroup\n  if (cpuCgroup === '/') return null\n\n  var patterns = [\n    /^\\/docker\\/([0-9a-f]+)$/, // docker native driver w/out systemd\n    /^\\/system\\.slice\\/docker-([0-9a-f]+)\\.scope$/, // with systemd\n    /^\\/lxc\\/([0-9a-f]+)$/ // docker lxc driver\n  ]\n  for (var i = 0; i < patterns.length; i++) {\n    var pattern = patterns[i]\n    var matches = cpuCgroup.match(pattern)\n    if (matches) {\n      var id = matches[1]\n      if (id.length !== 64) {\n        dockerError.incrementCallCount()\n        logger.debug('Encountered a malformed docker id: ', id)\n        return null\n      }\n      return id\n    }\n  }\n\n  logger.debug('Unable to recognise cgroup format')\n\n  return null\n}\n\nfunction parseCgroupIds(cgroupInfo) {\n  var cgroupIds = {}\n  cgroupInfo.split('\\n').forEach(function parseCgroupInfo(line) {\n    var parts = line.split(':')\n    if (parts.length !== 3) return\n    var subsystems = parts[1]\n    var cgroupId = parts[2]\n    subsystems.split(',').forEach(function assignGroupIds(subsystem) {\n      cgroupIds[subsystem] = cgroupId\n    })\n  })\n  return cgroupIds\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/parse-dockerinfo.js\n// module id = 133\n// module chunks = 0","'use strict'\n\nvar logger = require('./logger.js').child({component: 'proc-meminfo'})\n\nmodule.exports = parseProcMeminfo\n\nfunction parseProcMeminfo(data) {\n  var mem_total = parseInt(data.replace(/MemTotal:\\s*(\\d*)\\skB/, '$1'), 10)\n\n  if (mem_total) return mem_total / 1024\n\n  logger.debug('Unable to parse memory string:', data)\n  return null\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/parse-proc-meminfo.js\n// module id = 134\n// module chunks = 0","'use strict'\n\nmodule.exports = parse\nmodule.exports.fromString = fromString\nmodule.exports.fromMap = fromMap\n\n\n// this creates a copy of trim that can be used with map\nvar trim = Function.prototype.call.bind(String.prototype.trim)\nvar logger = require('../logger').child({component: 'label-parser'})\nvar stringifySync = require('./safe-json').stringifySync\n\nfunction parse(labels) {\n  var results\n\n  if (!labels) {\n    return []\n  } else if (typeof labels === 'string') {\n    results = fromString(labels)\n  } else if (labels) {\n    results = fromMap(labels)\n  }\n\n  results.warnings.forEach(function logWarnings(messaage) {\n    logger.warn(messaage)\n  })\n\n  return results.labels\n}\n\nfunction fromString(raw) {\n  var map = {}\n\n  if (!raw) {\n    return {labels: [], warnings: []}\n  }\n\n  var pairs = raw.split(';').map(trim)\n  var parts\n\n\n  while (!pairs[pairs.length - 1]) {\n    pairs.pop()\n  }\n\n  while (!pairs[0]) {\n    pairs.shift()\n  }\n\n  for (var i = 0, l = pairs.length; i < l; ++i) {\n    parts = pairs[i].split(':').map(trim)\n\n    if (parts.length !== 2) {\n      return warn('Could not create a Label pair from ' + parts[i])\n    } else if (!parts[0]) {\n      return warn('Label key can not be empty')\n    } else if (!parts[1]) {\n      return warn('Label value can not be empty')\n    }\n\n    map[parts[0]] = parts[1]\n  }\n\n  return fromMap(map)\n\n  function warn(message) {\n    return {labels: [], warnings: [\n      'Invalid Label String: ' + raw,\n       message\n    ]}\n  }\n}\n\nfunction fromMap(map) {\n  var warnings = []\n  var labels = []\n\n  Object.keys(map).forEach(function processKeys(key) {\n    var type = truncate(key, 255)\n\n    if (!map[key] || typeof map[key] !== 'string') {\n      return warnings.push(\n        'Label value for ' + type +\n        'should be a string with a length between 1 and 255 characters'\n      )\n    }\n\n    var value = truncate(map[key], 255)\n\n    if (type !== key) {\n      warnings.push('Label key too long: ' + type)\n    }\n\n    if (value !== map[key]) {\n      warnings.push('Label value too long: ' + value)\n    }\n\n    labels.push({label_type: type, label_value: value})\n  })\n\n  if (labels.length > 64) {\n    warnings.push('Too many Labels, list truncated to 64')\n    labels = labels.slice(0, 64)\n  }\n\n  if (warnings.length) {\n    warnings.unshift('Partially Invalid Label Setting: ' + stringifySync(map))\n  }\n\n  return {labels: labels, warnings: warnings}\n}\n\nfunction truncate(str, max) {\n  var len = 0\n  var chr\n  for (var i = 0, l = str.length; i < l; ++i) {\n    chr = str.charCodeAt(i)\n    if (chr >= 0xD800 && chr <= 0xDBFF && i !== l) {\n      i += 1\n    }\n\n    if (++len === max) {\n      break\n    }\n  }\n\n  return str.slice(0, i + 1)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/label-parser.js\n// module id = 135\n// module chunks = 0","'use strict'\n\nvar util = require('util')\nvar url = require('url')\nvar http = require('http')\nvar https = require('https')\nvar zlib = require('zlib')\nvar logger = require('../logger.js').child({component: 'remote_method_invoke'})\nvar parse = require('./parse-response.js')\nvar Sink = require('../util/stream-sink.js')\nvar agents = require('./http-agents.js')\nvar certificates = require('./ssl/certificates.js')\n\n/*\n *\n * CONSTANTS\n *\n */\nvar PROTOCOL_VERSION = 14\nvar RUN_ID_NAME = 'run_id'\nvar RAW_METHOD_PATH = '/agent_listener/invoke_raw_method'\n  // see job/collector-master/javadoc/com/nr/servlet/AgentListener.html on NR Jenkins\nvar USER_AGENT_FORMAT = \"NewRelic-NodeAgent/%s (nodejs %s %s-%s)\"\nvar ENCODING_HEADER = 'CONTENT-ENCODING'\nvar CONTENT_TYPE_HEADER = 'Content-Type'\nvar DEFAULT_ENCODING = 'identity'\nvar DEFAULT_CONTENT_TYPE = 'application/json'\nvar COMPRESSED_CONTENT_TYPE = 'application/octet-stream'\n\n\nfunction RemoteMethod(name, config) {\n  if (!name) {\n    throw new TypeError(\"Must include name of method to invoke on collector.\")\n  }\n\n  this.name = name\n  this._config = config\n}\n\nRemoteMethod.prototype.serialize = function serialize(payload, callback) {\n  try {\n    var res = JSON.stringify(payload)\n  } catch (error) {\n    logger.error(error, \"Unable to serialize payload for method %s.\", this.name)\n    return process.nextTick(function cb_nextTick() {\n      return callback(error)\n    })\n  }\n  return callback(null, res)\n}\n\n/**\n * The primary operation on RemoteMethod objects. If you're calling anything on\n * RemoteMethod objects aside from invoke (and you're not writing test code),\n * you're doing it wrong.\n *\n * @param object   payload    Serializable payload.\n * @param Function callback   What to do next. Gets passed any error.\n */\nRemoteMethod.prototype.invoke = function call(payload, callback) {\n  if (!payload) payload = []\n\n  this.serialize(payload, function cb_serialize(err, serialized) {\n    if (err) return callback(err)\n    this._post(serialized, callback)\n  }.bind(this))\n}\n\n/**\n * Take a serialized payload and create a response wrapper for it before\n * invoking the method on the collector.\n *\n * @param string   methodName Name of method to invoke on collector.\n * @param string   data       Serialized payload.\n * @param Function callback   What to do next. Gets passed any error.\n */\nRemoteMethod.prototype._post = function _post(data, callback) {\n  var method = this\n\n  // set up standard response handling\n  function onResponse(response) {\n    response.on('end', function handle_end() {\n      logger.debug(\n        \"Finished receiving data back from the collector for %s.\",\n        method.name\n      )\n    })\n\n    response.setEncoding('utf8')\n    response.pipe(new Sink(parse(method.name, response, callback)))\n  }\n\n  var options = {\n    port: this._config.port,\n    host: this._config.host,\n    compressed: this._shouldCompress(data),\n    path: this._path(),\n    onError: callback,\n    onResponse: onResponse\n  }\n\n  if (options.compressed) {\n    logger.trace({data: data}, \"Sending %s on collector API with (COMPRESSED)\", this.name)\n\n    var useGzip = this._config.compressed_content_encoding === 'gzip'\n    var compressor = useGzip ? zlib.gzip : zlib.deflate\n    compressor(data, function cb_compressor(err, compressed) {\n      if (err) {\n        logger.warn(err, \"Error compressing JSON for delivery. Not sending.\")\n        return callback(err)\n      }\n\n      options.body = compressed\n      method._safeRequest(options)\n    })\n  } else {\n    logger.debug({data: data}, \"Calling %s on collector API\", this.name)\n\n    options.body = data\n    this._safeRequest(options)\n  }\n}\n\n/**\n * http.request does its own DNS lookup, and if it fails, will cause\n * dns.lookup to throw asynchronously instead of passing the error to\n * the callback (which is obviously awesome). To prevent New Relic from\n * crashing people's applications, verify that lookup works and bail out\n * early if not.\n *\n * Also, ensure that all the necessary parameters are set before\n * actually making the request. Useful to put here to simplify test code\n * that calls _request directly.\n *\n * @param object options A dictionary of request parameters.\n */\nRemoteMethod.prototype._safeRequest = function _safeRequest(options) {\n  if (!options) throw new Error(\"Must include options to make request!\")\n  if (!options.host) throw new Error(\"Must include collector hostname!\")\n  if (!options.port) throw new Error(\"Must include collector port!\")\n  if (!options.onError) throw new Error(\"Must include error handler!\")\n  if (!options.onResponse) throw new Error(\"Must include response handler!\")\n  if (!options.body) throw new Error(\"Must include body to send to collector!\")\n  if (!options.path) throw new Error(\"Must include URL to request!\")\n\n  var protocol = this._config.ssl ? 'https' : 'http'\n  var logconfig = this._config.logging\n  var audit_log = this._config.audit_log\n  var logevent = util.format({\n    body: Buffer.isBuffer(options.body) ? 'Buffer ' + options.body.length : options.body\n  }, \"Posting to %s://%s:%s%s\",\n    protocol,\n    options.host,\n    options.port,\n    options.path\n  )\n  // if trace level is not explicity enabled\n  // check to see if the audit log is enabled\n  if ((typeof logconfig !== 'undefined') && logconfig.level !== 'trace') {\n    if (audit_log.enabled &&\n          // if the filter property is empty, then always log the event\n          // otherwise check to see if the filter includes this method\n          (audit_log.endpoints.length > 0 ?\n           audit_log.endpoints.indexOf(this.name) > -1 : true)) {\n      logger.info(logevent)\n    }\n  } else {\n    logger.trace(logevent)\n  }\n\n\n  this._request(options)\n}\n\n/**\n * Generate the request headers and wire up the request. There are many\n * parameters used to make a request:\n *\n * @param string   options.host       Hostname (or proxy hostname) for collector.\n * @param string   options.port       Port (or proxy port) for collector.\n * @param string   options.path       URL path for method being invoked on collector.\n * @param string   options.body       Serialized payload to be sent to collector.\n * @param boolean  options.compressed Whether the payload has been compressed.\n * @param Function options.onError    Error handler for this request (probably the\n *                                    original callback given to .send).\n * @param Function options.onResponse Response handler for this request (created by\n *                                    ._post).\n */\nRemoteMethod.prototype._request = function _request(options) {\n  var requestOptions = {\n    method: this._config.put_for_data_send ? 'PUT' : 'POST',\n    setHost: false,         // See below\n    host: options.host,     // Set explicitly in the headers\n    port: options.port,\n    path: options.path,\n    headers: this._headers(options.body, options.compressed),\n    __NR__connection: true  // Who measures the metrics measurer?\n  }\n  var request\n\n  var isProxy = !!(\n    this._config.proxy ||\n    this._config.proxy_port ||\n    this._config.proxy_host\n  )\n\n  if (isProxy) {\n    // proxy\n    requestOptions.agent = agents.proxyAgent(this._config)\n    request = https.request(requestOptions)\n\n    // FIXME: The agent keeps this connection open when using the proxy.\n    // This will prevent the application from shutting down correctly.\n    // Explicitly destroy the socket when the response is completed.\n    //\n    // This goes against keep-alive, but for now letting the application die\n    // gracefully is more important.\n    request.on('response', function cb_on_response(sock) {\n      sock.on('end', function cb_on_end() {\n        sock.destroy()\n      })\n    })\n  } else if (this._config.ssl) {\n    if (this._config.certificates && this._config.certificates.length > 0) {\n      logger.debug(\n        'Adding custom certificate to the cert bundle.'\n      )\n      requestOptions.ca = this._config.certificates.concat(certificates)\n    }\n    requestOptions.agent = agents.https\n    request = https.request(requestOptions)\n  } else {\n    requestOptions.agent = agents.http\n    request = http.request(requestOptions)\n  }\n\n  request.on('error', options.onError)\n  request.on('response', options.onResponse)\n\n  request.end(options.body)\n}\n\n/**\n * See the constants list for the format string (and the URL that explains it).\n */\nRemoteMethod.prototype._userAgent = function _userAgent() {\n  return util.format(USER_AGENT_FORMAT,\n                     this._config.version,\n                     process.versions.node,\n                     process.platform,\n                     process.arch)\n}\n\n/**\n * Generate a URL the collector understands.\n *\n * @returns string The URL path to be POSTed to.\n */\nRemoteMethod.prototype._path = function _path() {\n  var query = {\n      marshal_format: 'json',\n      protocol_version: PROTOCOL_VERSION,\n      license_key: this._config.license_key,\n      method: this.name\n  }\n\n  if (this._config.run_id) query[RUN_ID_NAME] = this._config.run_id\n\n  var formatted = url.format({\n    pathname: RAW_METHOD_PATH,\n    query: query\n  })\n\n  return formatted\n}\n\n/**\n * @param {number}  length      - Length of data to be sent.\n * @param {bool}    compressed  - The compression method used, if any.\n */\nRemoteMethod.prototype._headers = function _headers(body, compressed) {\n  var agent = this._userAgent()\n\n  var headers = {\n    // select the virtual host on the server end\n    'Host': this._config.host,\n    'User-Agent': agent,\n    'Connection': 'Keep-Alive',\n    'Content-Length': byteLength(body)\n  }\n\n  if (compressed) {\n    headers[ENCODING_HEADER] = this._config.compressed_content_encoding\n    headers[CONTENT_TYPE_HEADER] = COMPRESSED_CONTENT_TYPE\n  } else {\n    headers[ENCODING_HEADER] = DEFAULT_ENCODING\n    headers[CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE\n  }\n\n  return headers\n}\n\n/**\n * FLN pretty much decided on his own recognizance that 64K was a good point\n * at which to compress a server response. There's only a loose consensus that\n * the threshold should probably be much higher than this, if only to keep the\n * load on the collector down.\n *\n * FIXME: come up with a better heuristic\n */\nRemoteMethod.prototype._shouldCompress = function _shouldCompress(data) {\n  return data && byteLength(data) > 65536\n}\n\nfunction byteLength(data) {\n  if (!data) {\n    return 0\n  }\n\n  if (data instanceof Buffer) {\n    return data.length\n  }\n\n  return Buffer.byteLength(data, 'utf8')\n}\n\nmodule.exports = RemoteMethod\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/collector/remote-method.js\n// module id = 136\n// module chunks = 0","var http = require('http');\n\nvar https = module.exports;\n\nfor (var key in http) {\n    if (http.hasOwnProperty(key)) https[key] = http[key];\n};\n\nhttps.request = function (params, cb) {\n    if (!params) params = {};\n    params.scheme = 'https';\n    params.protocol = 'https:';\n    return http.request.call(this, params, cb);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/https-browserify/index.js\n// module id = 137\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Transform = require('_stream_transform');\n\nvar binding = require('./binding');\nvar util = require('util');\nvar assert = require('assert').ok;\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = (16 * 1024);\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nObject.keys(binding).forEach(function(k) {\n  if (k.match(/^Z/)) exports[k] = binding[k];\n});\n\n// translation table for return codes.\nexports.codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nObject.keys(exports.codes).forEach(function(k) {\n  exports.codes[exports.codes[k]] = k;\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function(o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function(o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function(o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function(o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function(o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function(o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function(o) {\n  return new Unzip(o);\n};\n\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function(buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function(buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function(buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf = Buffer.concat(buffers, nread);\n    buffers = [];\n    callback(null, buf);\n    engine.close();\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string')\n    buffer = new Buffer(buffer);\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('Not a string or buffer');\n\n  var flushFlag = binding.Z_FINISH;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush) {\n    if (opts.flush !== binding.Z_NO_FLUSH &&\n        opts.flush !== binding.Z_PARTIAL_FLUSH &&\n        opts.flush !== binding.Z_SYNC_FLUSH &&\n        opts.flush !== binding.Z_FULL_FLUSH &&\n        opts.flush !== binding.Z_FINISH &&\n        opts.flush !== binding.Z_BLOCK) {\n      throw new Error('Invalid flush flag: ' + opts.flush);\n    }\n  }\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK ||\n        opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||\n        opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL ||\n        opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||\n        opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED &&\n        opts.strategy != exports.Z_HUFFMAN_ONLY &&\n        opts.strategy != exports.Z_RLE &&\n        opts.strategy != exports.Z_FIXED &&\n        opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._binding = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._binding.onerror = function(message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    self._binding = null;\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,\n                     level,\n                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,\n                     strategy,\n                     opts.dictionary);\n\n  this._buffer = new Buffer(this._chunkSize);\n  this._offset = 0;\n  this._closed = false;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function(level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL ||\n      level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED &&\n      strategy != exports.Z_HUFFMAN_ONLY &&\n      strategy != exports.Z_RLE &&\n      strategy != exports.Z_FIXED &&\n      strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function() {\n      self._binding.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function() {\n  return this._binding.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function(callback) {\n  this._transform(new Buffer(0), '', callback);\n};\n\nZlib.prototype.flush = function(kind, callback) {\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || (kind === void 0 && !callback)) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback)\n      process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback)\n      this.once('end', callback);\n  } else if (ws.needDrain) {\n    var self = this;\n    this.once('drain', function() {\n      self.flush(callback);\n    });\n  } else {\n    this._flushFlag = kind;\n    this.write(new Buffer(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function(callback) {\n  if (callback)\n    process.nextTick(callback);\n\n  if (this._closed)\n    return;\n\n  this._closed = true;\n\n  this._binding.close();\n\n  var self = this;\n  process.nextTick(function() {\n    self.emit('close');\n  });\n};\n\nZlib.prototype._transform = function(chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (!chunk === null && !Buffer.isBuffer(chunk))\n    return cb(new Error('invalid input'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last)\n    flushFlag = binding.Z_FINISH;\n  else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  var self = this;\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function(chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function(er) {\n      error = er;\n    });\n\n    do {\n      var res = this._binding.writeSync(flushFlag,\n                                        chunk, // in\n                                        inOff, // in_off\n                                        availInBefore, // in_len\n                                        this._buffer, // out\n                                        this._offset, //out_off\n                                        availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    this.close();\n\n    return buf;\n  }\n\n  var req = this._binding.write(flushFlag,\n                                chunk, // in\n                                inOff, // in_off\n                                availInBefore, // in_len\n                                this._buffer, // out\n                                this._offset, //out_off\n                                availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    if (self._hadError)\n      return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = new Buffer(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      if (!async)\n        return true;\n\n      var newReq = self._binding.write(flushFlag,\n                                       chunk,\n                                       inOff,\n                                       availInBefore,\n                                       self._buffer,\n                                       self._offset,\n                                       self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async)\n      return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-zlib/src/index.js\n// module id = 138\n// module chunks = 0","var msg = require('pako/lib/zlib/messages');\nvar zstream = require('pako/lib/zlib/zstream');\nvar zlib_deflate = require('pako/lib/zlib/deflate.js');\nvar zlib_inflate = require('pako/lib/zlib/inflate.js');\nvar constants = require('pako/lib/zlib/constants');\n\nfor (var key in constants) {\n  exports[key] = constants[key];\n}\n\n// zlib modes\nexports.NONE = 0;\nexports.DEFLATE = 1;\nexports.INFLATE = 2;\nexports.GZIP = 3;\nexports.GUNZIP = 4;\nexports.DEFLATERAW = 5;\nexports.INFLATERAW = 6;\nexports.UNZIP = 7;\n\n/**\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\n */\nfunction Zlib(mode) {\n  if (mode < exports.DEFLATE || mode > exports.UNZIP)\n    throw new TypeError(\"Bad argument\");\n    \n  this.mode = mode;\n  this.init_done = false;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.windowBits = 0;\n  this.level = 0;\n  this.memLevel = 0;\n  this.strategy = 0;\n  this.dictionary = null;\n}\n\nZlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {\n  this.windowBits = windowBits;\n  this.level = level;\n  this.memLevel = memLevel;\n  this.strategy = strategy;\n  // dictionary not supported.\n  \n  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)\n    this.windowBits += 16;\n    \n  if (this.mode === exports.UNZIP)\n    this.windowBits += 32;\n    \n  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)\n    this.windowBits = -this.windowBits;\n    \n  this.strm = new zstream();\n  \n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflateInit2(\n        this.strm,\n        this.level,\n        exports.Z_DEFLATED,\n        this.windowBits,\n        this.memLevel,\n        this.strategy\n      );\n      break;\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n    case exports.UNZIP:\n      var status  = zlib_inflate.inflateInit2(\n        this.strm,\n        this.windowBits\n      );\n      break;\n    default:\n      throw new Error(\"Unknown mode \" + this.mode);\n  }\n  \n  if (status !== exports.Z_OK) {\n    this._error(status);\n    return;\n  }\n  \n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\nZlib.prototype.params = function() {\n  throw new Error(\"deflateParams Not supported\");\n};\n\nZlib.prototype._writeCheck = function() {\n  if (!this.init_done)\n    throw new Error(\"write before init\");\n    \n  if (this.mode === exports.NONE)\n    throw new Error(\"already finalized\");\n    \n  if (this.write_in_progress)\n    throw new Error(\"write already in progress\");\n    \n  if (this.pending_close)\n    throw new Error(\"close is pending\");\n};\n\nZlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    \n  this._writeCheck();\n  this.write_in_progress = true;\n  \n  var self = this;\n  process.nextTick(function() {\n    self.write_in_progress = false;\n    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);\n    self.callback(res[0], res[1]);\n    \n    if (self.pending_close)\n      self.close();\n  });\n  \n  return this;\n};\n\n// set method for Node buffers, used by pako\nfunction bufferSet(data, offset) {\n  for (var i = 0; i < data.length; i++) {\n    this[offset + i] = data[i];\n  }\n}\n\nZlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {\n  this._writeCheck();\n  return this._write(flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {\n  this.write_in_progress = true;\n  \n  if (flush !== exports.Z_NO_FLUSH &&\n      flush !== exports.Z_PARTIAL_FLUSH &&\n      flush !== exports.Z_SYNC_FLUSH &&\n      flush !== exports.Z_FULL_FLUSH &&\n      flush !== exports.Z_FINISH &&\n      flush !== exports.Z_BLOCK) {\n    throw new Error(\"Invalid flush value\");\n  }\n  \n  if (input == null) {\n    input = new Buffer(0);\n    in_len = 0;\n    in_off = 0;\n  }\n  \n  if (out._set)\n    out.set = out._set;\n  else\n    out.set = bufferSet;\n  \n  var strm = this.strm;\n  strm.avail_in = in_len;\n  strm.input = input;\n  strm.next_in = in_off;\n  strm.avail_out = out_len;\n  strm.output = out;\n  strm.next_out = out_off;\n  \n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflate(strm, flush);\n      break;\n    case exports.UNZIP:\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n      var status = zlib_inflate.inflate(strm, flush);\n      break;\n    default:\n      throw new Error(\"Unknown mode \" + this.mode);\n  }\n  \n  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {\n    this._error(status);\n  }\n  \n  this.write_in_progress = false;\n  return [strm.avail_in, strm.avail_out];\n};\n\nZlib.prototype.close = function() {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n  \n  this.pending_close = false;\n  \n  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n    zlib_deflate.deflateEnd(this.strm);\n  } else {\n    zlib_inflate.inflateEnd(this.strm);\n  }\n  \n  this.mode = exports.NONE;\n};\n\nZlib.prototype.reset = function() {\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n      var status = zlib_deflate.deflateReset(this.strm);\n      break;\n    case exports.INFLATE:\n    case exports.INFLATERAW:\n      var status = zlib_inflate.inflateReset(this.strm);\n      break;\n  }\n  \n  if (status !== exports.Z_OK) {\n    this._error(status);\n  }\n};\n\nZlib.prototype._error = function(status) {\n  this.onerror(msg[status] + ': ' + this.strm.msg, status);\n  \n  this.write_in_progress = false;\n  if (this.pending_close)\n    this.close();\n};\n\nexports.Zlib = Zlib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/browserify-zlib/src/binding.js\n// module id = 139\n// module chunks = 0","'use strict';\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/messages.js\n// module id = 140\n// module chunks = 0","'use strict';\n\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/zstream.js\n// module id = 141\n// module chunks = 0","'use strict';\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/deflate.js\n// module id = 142\n// module chunks = 0","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (source.hasOwnProperty(p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/utils/common.js\n// module id = 143\n// module chunks = 0","'use strict';\n\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/trees.js\n// module id = 144\n// module chunks = 0","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn't worth to make additional optimizationa as in original.\n// Small size is preferable.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/adler32.js\n// module id = 145\n// module chunks = 0","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/crc32.js\n// module id = 146\n// module chunks = 0","'use strict';\n\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n    case HEAD:\n      if (state.wrap === 0) {\n        state.mode = TYPEDO;\n        break;\n      }\n      //=== NEEDBITS(16);\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n        state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = FLAGS;\n        break;\n      }\n      state.flags = 0;           /* expect zlib header */\n      if (state.head) {\n        state.head.done = false;\n      }\n      if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n        strm.msg = 'incorrect header check';\n        state.mode = BAD;\n        break;\n      }\n      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n      len = (hold & 0x0f)/*BITS(4)*/ + 8;\n      if (state.wbits === 0) {\n        state.wbits = len;\n      }\n      else if (len > state.wbits) {\n        strm.msg = 'invalid window size';\n        state.mode = BAD;\n        break;\n      }\n      state.dmax = 1 << len;\n      //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = hold & 0x200 ? DICTID : TYPE;\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      break;\n    case FLAGS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.flags = hold;\n      if ((state.flags & 0xff) !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      if (state.flags & 0xe000) {\n        strm.msg = 'unknown header flags set';\n        state.mode = BAD;\n        break;\n      }\n      if (state.head) {\n        state.head.text = ((hold >> 8) & 1);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = TIME;\n      /* falls through */\n    case TIME:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.time = hold;\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC4(state.check, hold)\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        hbuf[2] = (hold >>> 16) & 0xff;\n        hbuf[3] = (hold >>> 24) & 0xff;\n        state.check = crc32(state.check, hbuf, 4, 0);\n        //===\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = OS;\n      /* falls through */\n    case OS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.xflags = (hold & 0xff);\n        state.head.os = (hold >> 8);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = EXLEN;\n      /* falls through */\n    case EXLEN:\n      if (state.flags & 0x0400) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length = hold;\n        if (state.head) {\n          state.head.extra_len = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      else if (state.head) {\n        state.head.extra = null/*Z_NULL*/;\n      }\n      state.mode = EXTRA;\n      /* falls through */\n    case EXTRA:\n      if (state.flags & 0x0400) {\n        copy = state.length;\n        if (copy > have) { copy = have; }\n        if (copy) {\n          if (state.head) {\n            len = state.head.extra_len - state.length;\n            if (!state.head.extra) {\n              // Use untyped array for more conveniend processing later\n              state.head.extra = new Array(state.head.extra_len);\n            }\n            utils.arraySet(\n              state.head.extra,\n              input,\n              next,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              copy,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              len\n            );\n            //zmemcpy(state.head.extra + len, next,\n            //        len + copy > state.head.extra_max ?\n            //        state.head.extra_max - len : copy);\n          }\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          state.length -= copy;\n        }\n        if (state.length) { break inf_leave; }\n      }\n      state.length = 0;\n      state.mode = NAME;\n      /* falls through */\n    case NAME:\n      if (state.flags & 0x0800) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          // TODO: 2 or 1 bytes?\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.name_max*/)) {\n            state.head.name += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.name = null;\n      }\n      state.length = 0;\n      state.mode = COMMENT;\n      /* falls through */\n    case COMMENT:\n      if (state.flags & 0x1000) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.comm_max*/)) {\n            state.head.comment += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.comment = null;\n      }\n      state.mode = HCRC;\n      /* falls through */\n    case HCRC:\n      if (state.flags & 0x0200) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.check & 0xffff)) {\n          strm.msg = 'header crc mismatch';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      if (state.head) {\n        state.head.hcrc = ((state.flags >> 9) & 1);\n        state.head.done = true;\n      }\n      strm.adler = state.check = 0;\n      state.mode = TYPE;\n      break;\n    case DICTID:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      strm.adler = state.check = zswap32(hold);\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = DICT;\n      /* falls through */\n    case DICT:\n      if (state.havedict === 0) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        return Z_NEED_DICT;\n      }\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      /* falls through */\n    case TYPE:\n      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case TYPEDO:\n      if (state.last) {\n        //--- BYTEBITS() ---//\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        state.mode = CHECK;\n        break;\n      }\n      //=== NEEDBITS(3); */\n      while (bits < 3) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.last = (hold & 0x01)/*BITS(1)*/;\n      //--- DROPBITS(1) ---//\n      hold >>>= 1;\n      bits -= 1;\n      //---//\n\n      switch ((hold & 0x03)/*BITS(2)*/) {\n      case 0:                             /* stored block */\n        //Tracev((stderr, \"inflate:     stored block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = STORED;\n        break;\n      case 1:                             /* fixed block */\n        fixedtables(state);\n        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = LEN_;             /* decode codes */\n        if (flush === Z_TREES) {\n          //--- DROPBITS(2) ---//\n          hold >>>= 2;\n          bits -= 2;\n          //---//\n          break inf_leave;\n        }\n        break;\n      case 2:                             /* dynamic block */\n        //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = TABLE;\n        break;\n      case 3:\n        strm.msg = 'invalid block type';\n        state.mode = BAD;\n      }\n      //--- DROPBITS(2) ---//\n      hold >>>= 2;\n      bits -= 2;\n      //---//\n      break;\n    case STORED:\n      //--- BYTEBITS() ---// /* go to byte boundary */\n      hold >>>= bits & 7;\n      bits -= bits & 7;\n      //---//\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n        strm.msg = 'invalid stored block lengths';\n        state.mode = BAD;\n        break;\n      }\n      state.length = hold & 0xffff;\n      //Tracev((stderr, \"inflate:       stored length %u\\n\",\n      //        state.length));\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = COPY_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case COPY_:\n      state.mode = COPY;\n      /* falls through */\n    case COPY:\n      copy = state.length;\n      if (copy) {\n        if (copy > have) { copy = have; }\n        if (copy > left) { copy = left; }\n        if (copy === 0) { break inf_leave; }\n        //--- zmemcpy(put, next, copy); ---\n        utils.arraySet(output, input, next, copy, put);\n        //---//\n        have -= copy;\n        next += copy;\n        left -= copy;\n        put += copy;\n        state.length -= copy;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       stored end\\n\"));\n      state.mode = TYPE;\n      break;\n    case TABLE:\n      //=== NEEDBITS(14); */\n      while (bits < 14) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n      if (state.nlen > 286 || state.ndist > 30) {\n        strm.msg = 'too many length or distance symbols';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n      state.have = 0;\n      state.mode = LENLENS;\n      /* falls through */\n    case LENLENS:\n      while (state.have < state.ncode) {\n        //=== NEEDBITS(3);\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n        //--- DROPBITS(3) ---//\n        hold >>>= 3;\n        bits -= 3;\n        //---//\n      }\n      while (state.have < 19) {\n        state.lens[order[state.have++]] = 0;\n      }\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      //state.next = state.codes;\n      //state.lencode = state.next;\n      // Switch to use dynamic table\n      state.lencode = state.lendyn;\n      state.lenbits = 7;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n      state.lenbits = opts.bits;\n\n      if (ret) {\n        strm.msg = 'invalid code lengths set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n      state.have = 0;\n      state.mode = CODELENS;\n      /* falls through */\n    case CODELENS:\n      while (state.have < state.nlen + state.ndist) {\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_val < 16) {\n          //--- DROPBITS(here.bits) ---//\n          hold >>>= here_bits;\n          bits -= here_bits;\n          //---//\n          state.lens[state.have++] = here_val;\n        }\n        else {\n          if (here_val === 16) {\n            //=== NEEDBITS(here.bits + 2);\n            n = here_bits + 2;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            if (state.have === 0) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            len = state.lens[state.have - 1];\n            copy = 3 + (hold & 0x03);//BITS(2);\n            //--- DROPBITS(2) ---//\n            hold >>>= 2;\n            bits -= 2;\n            //---//\n          }\n          else if (here_val === 17) {\n            //=== NEEDBITS(here.bits + 3);\n            n = here_bits + 3;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 3 + (hold & 0x07);//BITS(3);\n            //--- DROPBITS(3) ---//\n            hold >>>= 3;\n            bits -= 3;\n            //---//\n          }\n          else {\n            //=== NEEDBITS(here.bits + 7);\n            n = here_bits + 7;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 11 + (hold & 0x7f);//BITS(7);\n            //--- DROPBITS(7) ---//\n            hold >>>= 7;\n            bits -= 7;\n            //---//\n          }\n          if (state.have + copy > state.nlen + state.ndist) {\n            strm.msg = 'invalid bit length repeat';\n            state.mode = BAD;\n            break;\n          }\n          while (copy--) {\n            state.lens[state.have++] = len;\n          }\n        }\n      }\n\n      /* handle error breaks in while */\n      if (state.mode === BAD) { break; }\n\n      /* check for end-of-block code (better have one) */\n      if (state.lens[256] === 0) {\n        strm.msg = 'invalid code -- missing end-of-block';\n        state.mode = BAD;\n        break;\n      }\n\n      /* build code tables -- note: do not change the lenbits or distbits\n         values here (9 and 6) without reading the comments in inftrees.h\n         concerning the ENOUGH constants, which depend on those values */\n      state.lenbits = 9;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.lenbits = opts.bits;\n      // state.lencode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid literal/lengths set';\n        state.mode = BAD;\n        break;\n      }\n\n      state.distbits = 6;\n      //state.distcode.copy(state.codes);\n      // Switch to use dynamic table\n      state.distcode = state.distdyn;\n      opts = { bits: state.distbits };\n      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.distbits = opts.bits;\n      // state.distcode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid distances set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, 'inflate:       codes ok\\n'));\n      state.mode = LEN_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case LEN_:\n      state.mode = LEN;\n      /* falls through */\n    case LEN:\n      if (have >= 6 && left >= 258) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        inflate_fast(strm, _out);\n        //--- LOAD() ---\n        put = strm.next_out;\n        output = strm.output;\n        left = strm.avail_out;\n        next = strm.next_in;\n        input = strm.input;\n        have = strm.avail_in;\n        hold = state.hold;\n        bits = state.bits;\n        //---\n\n        if (state.mode === TYPE) {\n          state.back = -1;\n        }\n        break;\n      }\n      state.back = 0;\n      for (;;) {\n        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if (here_bits <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if (here_op && (here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.lencode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      state.length = here_val;\n      if (here_op === 0) {\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        state.mode = LIT;\n        break;\n      }\n      if (here_op & 32) {\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.back = -1;\n        state.mode = TYPE;\n        break;\n      }\n      if (here_op & 64) {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break;\n      }\n      state.extra = here_op & 15;\n      state.mode = LENEXT;\n      /* falls through */\n    case LENEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n      //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n      state.was = state.length;\n      state.mode = DIST;\n      /* falls through */\n    case DIST:\n      for (;;) {\n        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if ((here_bits) <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if ((here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.distcode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      if (here_op & 64) {\n        strm.msg = 'invalid distance code';\n        state.mode = BAD;\n        break;\n      }\n      state.offset = here_val;\n      state.extra = (here_op) & 15;\n      state.mode = DISTEXT;\n      /* falls through */\n    case DISTEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n//#ifdef INFLATE_STRICT\n      if (state.offset > state.dmax) {\n        strm.msg = 'invalid distance too far back';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n      state.mode = MATCH;\n      /* falls through */\n    case MATCH:\n      if (left === 0) { break inf_leave; }\n      copy = _out - left;\n      if (state.offset > copy) {         /* copy from window */\n        copy = state.offset - copy;\n        if (copy > state.whave) {\n          if (state.sane) {\n            strm.msg = 'invalid distance too far back';\n            state.mode = BAD;\n            break;\n          }\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n        }\n        if (copy > state.wnext) {\n          copy -= state.wnext;\n          from = state.wsize - copy;\n        }\n        else {\n          from = state.wnext - copy;\n        }\n        if (copy > state.length) { copy = state.length; }\n        from_source = state.window;\n      }\n      else {                              /* copy from output */\n        from_source = output;\n        from = put - state.offset;\n        copy = state.length;\n      }\n      if (copy > left) { copy = left; }\n      left -= copy;\n      state.length -= copy;\n      do {\n        output[put++] = from_source[from++];\n      } while (--copy);\n      if (state.length === 0) { state.mode = LEN; }\n      break;\n    case LIT:\n      if (left === 0) { break inf_leave; }\n      output[put++] = state.length;\n      left--;\n      state.mode = LEN;\n      break;\n    case CHECK:\n      if (state.wrap) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          // Use '|' insdead of '+' to make sure that result is signed\n          hold |= input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        _out -= left;\n        strm.total_out += _out;\n        state.total += _out;\n        if (_out) {\n          strm.adler = state.check =\n              /*UPDATE(state.check, put - _out, _out);*/\n              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n        }\n        _out = left;\n        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n        if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n          strm.msg = 'incorrect data check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n      }\n      state.mode = LENGTH;\n      /* falls through */\n    case LENGTH:\n      if (state.wrap && state.flags) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.total & 0xffffffff)) {\n          strm.msg = 'incorrect length check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n      }\n      state.mode = DONE;\n      /* falls through */\n    case DONE:\n      ret = Z_STREAM_END;\n      break inf_leave;\n    case BAD:\n      ret = Z_DATA_ERROR;\n      break inf_leave;\n    case MEM:\n      return Z_MEM_ERROR;\n    case SYNC:\n      /* falls through */\n    default:\n      return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/inflate.js\n// module id = 147\n// module chunks = 0","'use strict';\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/inffast.js\n// module id = 148\n// module chunks = 0","'use strict';\n\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  var i = 0;\n  /* process all codes and make table entries */\n  for (;;) {\n    i++;\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/inftrees.js\n// module id = 149\n// module chunks = 0","'use strict';\n\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pako/lib/zlib/constants.js\n// module id = 150\n// module chunks = 0","'use strict';\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/assert/assert.js\n// module id = 151\n// module chunks = 0","'use strict'\n\nvar format = require('util').format\nvar logger = require('../logger').child({component: 'new_relic_response'})\n\n\n/*\n *\n * CONSTANTS\n *\n */\nvar RESPONSE_VALUE_NAME = 'return_value'\nvar EXCEPTION_VALUE_NAME = 'exception'\n\n\n/**\n * The collector has many ways of indicating failure, and isn't\n * necessarily consistent. Because there can either be a failure at\n * the network level, a nonstandard HTTP status code on the response,\n * or a JSON-encoded exception in the response body, there's a lot of\n * conditional logic in here that tries to grab as much information\n * about errors as possible, and to parse out the return value as often\n * as possible.\n *\n * @param string         name     Remote method name that was invoked.\n * @param ServerResponse response HTTP response stream\n * @param Function       callback Function that will be called with any\n *                                error, the value returned by the server\n *                                (if any), and the raw JSON of the\n *                                server's response.\n *\n * @returns Function Another callback that is meant to be invoked with\n *                   any errors from reading the response stream, as\n *                   well as a string containing the full response.\n */\nmodule.exports = function parse(name, response, callback) {\n  if (!name) throw new TypeError('collector method name required!')\n  if (!response) throw new TypeError('HTTP response required!')\n  if (!callback) throw new TypeError('callback required!')\n\n  return function parser(inError, body) {\n    /* jshint maxdepth:4 */\n\n    var code = response.statusCode\n    var errors = []\n    var errorClass\n    var json\n    var returned\n\n\n    if (code !== 200) logger.debug(\"Got %s as a response code from the collector.\", code)\n\n    if (inError) errors.push(inError)\n\n    if (body) {\n      try {\n        json = JSON.parse(body)\n\n        // Can be super verbose, but useful for debugging.\n        logger.trace({response: json}, \"Deserialized from collector:\")\n\n        // If we get messages back from the collector, be polite and pass them along.\n        returned = json[RESPONSE_VALUE_NAME]\n        if (returned && returned.messages) {\n          returned.messages.forEach(function cb_forEach(element) {\n            logger.info(element.message)\n          })\n        }\n\n        /* Wait to deal with errors in the response until any messages have\n         * been passed along. Otherwise, ensure that there was a return\n         * value, raising an error if not.\n         *\n         * Some errors are only interesting if the status code indicates\n         * that the request went bad already, so filter out adding more\n         * errors when statusCode is not OK (200).\n         */\n        var exception = json[EXCEPTION_VALUE_NAME]\n        if (exception) {\n          if (exception.message) {\n            errors.push(new Error(exception.message))\n          } else if (code === 200 ) {\n            errors.push(new Error('New Relic internal error'))\n          }\n\n          if (exception.error_type) errorClass = exception.error_type\n        } else if (code === 200 && returned === undefined) {\n          errors.push(new Error(format('No data found in response to %s.', name)))\n        }\n      } catch (error) {\n        logger.trace(error, 'Could not parse response from the collector: %s', body)\n        errors.push(error)\n      }\n    } else {\n      errors.push(new Error(format('No body found in response to %s.', name)))\n    }\n\n    if (code !== 200) {\n      errors.push(new Error(format('Got HTTP %s in response to %s.', code, name)))\n    }\n\n    var error\n    if (errors.length > 0) {\n      error = errors.shift()\n      error.statusCode = code\n      // Preserve a consistent hidden class (cheaper than sub-classing Error).\n      error.class = errorClass ? errorClass : undefined\n      error.laterErrors = (errors.length > 0) ? errors : undefined\n    }\n\n    // Raw json is useful for testing and logging.\n    process.nextTick(function cb_nextTick() {\n      callback(error, returned, json)\n    })\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/collector/parse-response.js\n// module id = 152\n// module chunks = 0","'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\n\n\n/**\n * Pipe a readable stream into this sink that fulfills the Writable Stream\n * contract and the callback will be fired when the stream has been completely\n * read.\n */\nfunction StreamSink(callback) {\n  EventEmitter.call(this)\n\n  this.callback = callback\n  this.sink = ''\n  this.writable = true\n\n  var sink = this\n  this.on('error', function handle_error(error) {\n    sink.writable = false\n    callback(error)\n  })\n}\nutil.inherits(StreamSink, EventEmitter)\n\nStreamSink.prototype.write = function write(string) {\n  if (!this.writable) {\n    this.emit('error', new Error(\"Sink no longer writable!\"))\n    return false\n  }\n\n  // Explicitly copy buffer contents so we are sure to release references to\n  // the TLS slab buffer region.\n  this.sink += string.toString()\n\n  return true\n}\n\nStreamSink.prototype.end = function end() {\n  this.writable = false\n\n  this.callback(null, this.sink)\n}\n\nStreamSink.prototype.destroy = function destroy() {\n  this.emit('close')\n  this.writable = false\n\n  delete this.sink\n}\n\nmodule.exports = StreamSink\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/stream-sink.js\n// module id = 153\n// module chunks = 0","'use strict'\n\nvar parse = require('url').parse\nvar extend = require('util')._extend\nvar HTTPAgent = require('yakaa')\nvar SSLAgent = HTTPAgent.SSL\nvar ProxyAgent = require('https-proxy-agent')\nvar logger = require('../logger').child({component: 'http-agent'})\nvar certificates = require('./ssl/certificates.js')\n\nvar CIPHERS = \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:\" +\n              \"ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:\" +\n              \"DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:\" +\n              \"ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:\" +\n              \"ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:\" +\n              \"ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:\" +\n              \"ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:\" +\n              \"DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:\" +\n              \"DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:\" +\n              \"AES128-GCM-SHA256:AES256-GCM-SHA384:AES128:AES256:HIGH:\" +\n              \"!aNULL:!eNULL:!EXPORT:!DES:!3DES:!MD5:!PSK:!RC4\"\n\nvar baseConfig = {\n  keepAlive: true,\n  keepAliveTimeoutMsecs: 500,\n  maxSockets: 1 // requests are serialized\n}\n\nvar httpsConfig = extend({\n  rejectUnauthorized: true,\n  ciphers: CIPHERS\n}, baseConfig)\n\nexports.httpAgent = new HTTPAgent(baseConfig)\n\nexports.httpsAgent = new SSLAgent(httpsConfig)\n\nexports.proxyAgent = function proxyAgent(config) {\n  var opts = proxyOptions(config)\n  var proxy_url = opts.proxy_url\n\n  var proxy_opts = {\n    host: proxy_url.host,\n    port: proxy_url.port,\n    protocol: proxy_url.protocol,\n    secureEndpoint: config.ssl,\n    auth: proxy_url.auth,\n    ca: opts.certificates\n  }\n\n  logger.info({\n    host: proxy_opts.host,\n    port: proxy_opts.port,\n    auth: !!proxy_opts.auth,\n    protocol: proxy_url.protocol\n  }, 'using proxy')\n\n  var proxy = new ProxyAgent(proxy_opts)\n\n  return proxy\n}\n\nfunction proxyOptions(config) {\n  if (config.proxy) {\n    var parsed_url = parse(config.proxy)\n\n    var proxy_url = {\n      protocol: parsed_url.protocol || 'http:',\n      host: parsed_url.hostname,\n      port: parsed_url.port || 80,\n      auth: parsed_url.auth\n    }\n  } else {\n    var proxy_auth = config.proxy_user\n    if (config.proxy_pass !== '') {\n      proxy_auth += ':' + config.proxy_pass\n    }\n\n    // Unless a proxy config is provided, default to HTTP.\n    proxy_url = {\n      protocol: 'http:',\n      host: config.proxy_host || 'localhost',\n      port: config.proxy_port || 80,\n      auth: proxy_auth\n    }\n  }\n\n  var opts = {\n    proxy_url: proxy_url\n  }\n\n  // merge user certificates with built-in certs\n\n  if (config.certificates && config.certificates.length > 0) {\n    logger.info(\n      'Using a proxy with a special cert. This enables our cert bundle which, combined ' +\n      'with some versions of node, exacerbates a leak in node core TLS.'\n    )\n    opts.certificates = config.certificates.concat(certificates)\n  }\n\n  return opts\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/collector/http-agents.js\n// module id = 154\n// module chunks = 0","'use strict';\n\nvar Agent = require('./http.js');\nAgent.SSL = require('./https.js');\n\nmodule.exports = Agent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/yakaa/index.js\n// module id = 155\n// module chunks = 0","'use strict';\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar debug = require('./lib/debuglog.js')('httpagent');\n\n// New Agent code.\n\n// The largest departure from the previous implementation is that\n// an Agent instance holds connections for a variable number of host:ports.\n// Surprisingly, this is still API compatible as far as third parties are\n// concerned. The only code that really notices the difference is the\n// request object.\n\n// Another departure is that all code related to HTTP parsing is in\n// ClientRequest.onSocket(). The Agent is now *strictly*\n// concerned with managing a connection pool.\n\nfunction Agent(options) {\n  if (!(this instanceof Agent)) return new Agent(options);\n\n  EventEmitter.call(this);\n\n  this.defaultPort = 80;\n  this.protocol    = 'http:';\n\n  this.options = util._extend({}, options);\n  // don't confuse net and make it think that we're connecting to a pipe\n  this.options.path = null;\n\n  this.requests    = {};\n  this.sockets     = {};\n  this.freeSockets = {};\n\n  this.keepAliveMsecs = this.options.keepAliveMsecs || 1000;\n  this.keepAlive      = this.options.keepAlive || false;\n\n  this.maxSockets     = this.options.maxSockets || Agent.defaultMaxSockets;\n  this.maxFreeSockets = this.options.maxFreeSockets || 256;\n\n  var self = this;\n  this.on('free', function(socket, options) {\n    var name = self.getName(options);\n    debug('agent.on(free)', name);\n\n    if (!self.isSocketDestroyed(socket) && self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket);\n      if (self.requests[name].length === 0) {\n        // don't leak\n        delete self.requests[name];\n      }\n    }\n    else {\n      // If there are no pending requests, then put it in\n      // the freeSockets pool, but only if we're allowed to do so.\n      var req = socket._httpMessage;\n      if (req && req.shouldKeepAlive && !self.isSocketDestroyed(socket) && self.options.keepAlive) {\n        var freeSockets = self.freeSockets[name];\n        var freeLen     = freeSockets ? freeSockets.length : 0;\n        var count       = freeLen;\n\n        if (self.sockets[name]) count += self.sockets[name].length;\n\n        debug('potentially pooling', freeLen, count);\n\n        if (count > self.maxSockets || freeLen >= self.maxFreeSockets) {\n          debug('destroying socket', name);\n          self.removeSocket(socket, options);\n          socket.destroy();\n        } else {\n          debug('pooling socket', name);\n          freeSockets = freeSockets || [];\n          self.freeSockets[name] = freeSockets;\n          socket.setKeepAlive(true, self.keepAliveMsecs);\n\n          if (socket.unref) {\n            socket.unref();\n          }\n          else if (socket.socket &&\n                   socket.socket._handle &&\n                   socket.socket._handle.unref) {\n            socket.socket._handle.unref();\n          }\n\n          socket._httpMessage = null;\n          self.removeSocket(socket, options);\n          freeSockets.push(socket);\n\n          // set timeout on idle sockets\n          if (options.keepAliveTimeoutMsecs !== undefined) {\n            socket._yakaa_timeout = setTimeout(function () {\n              self.emit('yakaa_destroy');\n              socket.destroySoon();\n            }, options.keepAliveTimeoutMsecs);\n          }\n\n        }\n      } else {\n        self.removeSocket(socket, options);\n        socket.destroy();\n      }\n    }\n  });\n}\n\nutil.inherits(Agent, EventEmitter);\nexports.Agent = Agent;\n\nAgent.defaultMaxSockets = Infinity;\n\nAgent.prototype.createConnection = net.createConnection;\n\nAgent.prototype.isSocketDestroyed = function(socket) {\n    // Different Node versions have different names for the property\n    return socket.destroyed || socket._destroyed;\n};\n\n// Get the key for a given set of request options\nAgent.prototype.getName = function(options) {\n  var name = '';\n\n  if (options.host)\n    name += options.host;\n  else\n    name += 'localhost';\n\n  name += ':';\n  if (options.port)\n    name += options.port;\n  name += ':';\n  if (options.localAddress)\n    name += options.localAddress;\n  name += ':';\n  return name;\n};\n\nAgent.prototype.addRequest = function(req, options) {\n  debug('addRequest');\n  // Legacy API: addRequest(req, host, port, path)\n  if (typeof options === 'string') {\n    options = {\n      host: options,\n      port: arguments[2],\n      path: arguments[3]\n    };\n  }\n\n  var name = this.getName(options);\n  if (!this.sockets[name]) {\n    this.sockets[name] = [];\n  }\n\n  var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;\n  var sockLen = freeLen + this.sockets[name].length;\n\n  if (freeLen) {\n    // we have a free socket, so use that.\n    var socket = this.freeSockets[name].shift();\n    debug('have free socket');\n\n    // mark socket as non-idle so it doesn't get destroyed mid-request\n    if (socket._yakaa_timeout) {\n      clearTimeout(socket._yakaa_timeout);\n      delete socket._yakaa_timeout;\n    }\n\n    // don't leak\n    if (!this.freeSockets[name].length)\n      delete this.freeSockets[name];\n\n    if (socket.ref) {\n      socket.ref();\n    }\n    else if (socket.socket && socket.socket._handle && socket.socket._handle.ref) {\n      socket.socket._handle.ref();\n    }\n\n    req.onSocket(socket);\n    this.sockets[name].push(socket);\n  } else if (sockLen < this.maxSockets) {\n    debug('call onSocket', name, sockLen, freeLen);\n    // If we are under maxSockets create a new one.\n    req.onSocket(this.createSocket(req, options));\n  } else {\n    debug('wait for socket');\n    // We are over limit so we'll add it to the queue.\n    if (!this.requests[name]) {\n      this.requests[name] = [];\n    }\n    this.requests[name].push(req);\n  }\n};\n\nAgent.prototype.createSocket = function(req, options) {\n  debug('createSocket');\n  var self = this;\n  options = util._extend({}, options);\n  options = util._extend(options, self.options);\n\n  options.servername = options.host;\n  if (req) {\n    var hostHeader = req.getHeader('host');\n    if (hostHeader) {\n      options.servername = hostHeader.replace(/:.*$/, '');\n    }\n  }\n\n  var name = self.getName(options);\n\n  debug('createConnection', name, options);\n  options.encoding = null;\n  var s = self.createConnection(options);\n  if (!self.sockets[name]) {\n    self.sockets[name] = [];\n  }\n  this.sockets[name].push(s);\n  debug('sockets', name, this.sockets[name].length);\n\n  function onFree() {\n    self.emit('free', s, options);\n  }\n  s.on('free', onFree);\n\n  function onClose() {\n    debug('CLIENT socket onClose');\n    // This is the only place where sockets get removed from the Agent.\n    // If you want to remove a socket from the pool, just close it.\n    // All socket errors end in a close event anyway.\n    self.removeSocket(s, options);\n  }\n  s.on('close', onClose);\n\n  function onRemove() {\n    // We need this function for cases like HTTP 'upgrade'\n    // (defined by WebSockets) where we need to remove a socket from the\n    // pool because it'll be locked up indefinitely\n    debug('CLIENT socket onRemove');\n    self.removeSocket(s, options);\n    s.removeListener('close', onClose);\n    s.removeListener('free', onFree);\n    s.removeListener('agentRemove', onRemove);\n  }\n  s.on('agentRemove', onRemove);\n  return s;\n};\n\nAgent.prototype.removeSocket = function(s, options) {\n  var name = this.getName(options);\n  debug('removeSocket', name, 'destroyed:', this.isSocketDestroyed(s));\n  var sets = [this.sockets];\n\n  this.emit('yakaa_remove', s);\n\n  // If the socket was destroyed, remove it from the free buffers too.\n  if (this.isSocketDestroyed(s))\n    sets.push(this.freeSockets);\n\n  sets.forEach(function(sockets) {\n    if (sockets[name]) {\n      var index = sockets[name].indexOf(s);\n      if (index !== -1) {\n        sockets[name].splice(index, 1);\n        // Don't leak\n        if (sockets[name].length === 0) delete sockets[name];\n      }\n    }\n  });\n\n  if (this.requests[name] && this.requests[name].length) {\n    debug('removeSocket, have a request, make a socket');\n    var req = this.requests[name][0];\n    // If we have pending requests and a socket gets closed make a new one\n    this.createSocket(req, options).emit('free');\n  }\n};\n\nAgent.prototype.destroy = function() {\n  var sets = [this.freeSockets, this.sockets];\n  sets.forEach(function(set) {\n    Object.keys(set).forEach(function(name) {\n      set[name].forEach(function(socket) {\n        socket.destroy();\n      });\n    });\n  });\n};\n\nmodule.exports = Agent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/yakaa/http.js\n// module id = 156\n// module chunks = 0","'use strict';\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar format = require('util').format;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\nvar debugs = {};\nvar debugEnviron;\nfunction debuglog(set) {\n  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = format.apply(null, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    }\n    else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n}\n\nmodule.exports = debuglog;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/yakaa/lib/debuglog.js\n// module id = 157\n// module chunks = 0","'use strict';\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nvar tls = require('tls');\nvar inherits = require('util').inherits;\nvar Agent = require('./http.js');\nvar debug = require('./lib/debuglog.js')('httpsagent');\n\n// HTTPS agents.\nfunction createConnection(port, host, options) {\n  if (isObject(port)) {\n    options = port;\n  }\n  else if (isObject(host)) {\n    options = host;\n  }\n  else if (isObject(options)) {\n    options = options;\n  }\n  else {\n    options = {};\n  }\n\n  if (isNumber(port)) {\n    options.port = port;\n  }\n\n  if (isString(host)) {\n    options.host = host;\n  }\n\n  debug('createConnection', options);\n  return tls.connect(options);\n}\n\n\nfunction SSLAgent(options) {\n  Agent.call(this, options);\n  this.defaultPort = 443;\n  this.protocol = 'https:';\n}\ninherits(SSLAgent, Agent);\n\nSSLAgent.prototype.createConnection = createConnection;\n\nSSLAgent.prototype.getName = function(options) {\n  var name = Agent.prototype.getName.call(this, options);\n\n  // name += ':';\n  // if (options.ca)\n  //   name += options.ca;\n\n  name += ':';\n  if (options.cert)\n    name += options.cert;\n\n  name += ':';\n  if (options.ciphers)\n    name += options.ciphers;\n\n  name += ':';\n  if (options.key)\n    name += options.key;\n\n  name += ':';\n  if (options.pfx)\n    name += options.pfx;\n\n  // name += ':';\n  // if (!isUndefined(options.rejectUnauthorized))\n  //   name += options.rejectUnauthorized;\n\n  return name;\n};\n\nmodule.exports = SSLAgent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/yakaa/https.js\n// module id = 158\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar net = require('net');\nvar tls = require('tls');\nvar url = require('url');\nvar extend = require('extend');\nvar Agent = require('agent-base');\nvar inherits = require('util').inherits;\nvar debug = require('debug')('https-proxy-agent');\n\n/**\n * Module exports.\n */\n\nmodule.exports = HttpsProxyAgent;\n\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the\n * specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * @api public\n */\n\nfunction HttpsProxyAgent (opts) {\n  if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts) throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n  debug('creating new HttpsProxyAgent instance: %j', opts);\n  Agent.call(this, connect);\n\n  var proxy = extend({}, opts);\n\n  // if `true`, then connect to the proxy server over TLS. defaults to `false`.\n  this.secureProxy = proxy.protocol ? /^https:?$/i.test(proxy.protocol) : false;\n\n  // if `true`, then connect to the destination endpoint over TLS, defaults to `true`\n  this.secureEndpoint = opts.secureEndpoint !== false;\n\n  // prefer `hostname` over `host`, and set the `port` if needed\n  proxy.host = proxy.hostname || proxy.host;\n  proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);\n\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  }\n\n  this.proxy = proxy;\n}\ninherits(HttpsProxyAgent, Agent);\n\n/**\n * Default options for the \"connect\" opts object.\n */\n\nvar defaults = { port: 80 };\nvar secureDefaults = { port: 443 };\n\n/**\n * Called when the node-core HTTP client library is creating a new HTTP request.\n *\n * @api public\n */\n\nfunction connect (req, _opts, fn) {\n\n  var proxy = this.proxy;\n  var secureProxy = this.secureProxy;\n  var secureEndpoint = this.secureEndpoint;\n\n  // create a socket connection to the proxy server\n  var socket;\n  if (secureProxy) {\n    socket = tls.connect(proxy);\n  } else {\n    socket = net.connect(proxy);\n  }\n\n  // these `opts` are the connect options to connect to the destination endpoint\n  // XXX: we mix in the proxy options so that TLS options like\n  // `rejectUnauthorized` get passed to the destination endpoint as well\n  var proxyOpts = extend({}, proxy);\n  delete proxyOpts.host;\n  delete proxyOpts.hostname;\n  delete proxyOpts.port;\n  var opts = extend({}, proxyOpts, secureEndpoint ? secureDefaults : defaults, _opts);\n\n  // we need to buffer any HTTP traffic that happens with the proxy before we get\n  // the CONNECT response, so that if the response is anything other than an \"200\"\n  // response code, then we can re-play the \"data\" events on the socket once the\n  // HTTP parser is hooked up...\n  var buffers = [];\n  var buffersLength = 0;\n\n  function read () {\n    var b = socket.read();\n    if (b) ondata(b);\n    else socket.once('readable', read);\n  }\n\n  function cleanup () {\n    socket.removeListener('data', ondata);\n    socket.removeListener('end', onend);\n    socket.removeListener('error', onerror);\n    socket.removeListener('close', onclose);\n    socket.removeListener('readable', read);\n  }\n\n  function onclose (err) {\n    debug('onclose had error', err);\n  }\n\n  function onend () {\n    debug('onend');\n  }\n\n  function onerror (err) {\n    cleanup();\n    fn(err);\n  }\n\n  function ondata (b) {\n    buffers.push(b);\n    buffersLength += b.length;\n    var buffered = Buffer.concat(buffers, buffersLength);\n    var str = buffered.toString('ascii');\n\n    if (!~str.indexOf('\\r\\n\\r\\n')) {\n      // keep buffering\n      debug('have not received end of HTTP headers yet...');\n      if (socket.read) {\n        read();\n      } else {\n        socket.once('data', ondata);\n      }\n      return;\n    }\n\n    var firstLine = str.substring(0, str.indexOf('\\r\\n'));\n    var statusCode = +firstLine.split(' ')[1];\n    debug('got proxy server response: \"%s\"', firstLine);\n    //console.log('statusCode: %d', statusCode);\n    //console.log(b.length, b, b.toString());\n\n    if (200 == statusCode) {\n      // 200 Connected status code!\n      var sock = socket;\n\n      // nullify the buffered data since we won't be needing it\n      buffers = buffered = null;\n\n      if (secureEndpoint) {\n        // since the proxy is connecting to an SSL server, we have\n        // to upgrade this socket connection to an SSL connection\n        debug('upgrading proxy-connected socket to TLS connection: \"%s\"', opts.host);\n        opts.socket = socket;\n        opts.servername = opts.host;\n        opts.host = null;\n        opts.hostname = null;\n        opts.port = null;\n        sock = tls.connect(opts);\n      }\n\n      cleanup();\n      fn(null, sock);\n    } else {\n      // some other status code that's not 200... need to re-play the HTTP header\n      // \"data\" events onto the socket once the HTTP machinery is attached so that\n      // the user can parse and handle the error status code\n      cleanup();\n\n      // save a reference to the concat'd Buffer for the `onsocket` callback\n      buffers = buffered;\n\n      // need to wait for the \"socket\" event to re-play the \"data\" events\n      req.once('socket', onsocket);\n      fn(null, socket);\n    }\n  }\n\n  function onsocket (socket) {\n    // replay the \"buffers\" Buffer onto the `socket`, since at this point\n    // the HTTP module machinery has been hooked up for the user\n    if ('function' == typeof socket.ondata) {\n      // node <= v0.11.3, the `ondata` function is set on the socket\n      socket.ondata(buffers, 0, buffers.length);\n    } else if (socket.listeners('data').length > 0) {\n      // node > v0.11.3, the \"data\" event is listened for directly\n      socket.emit('data', buffers);\n    } else {\n      // never?\n      throw new Error('should not happen...');\n    }\n\n    // nullify the cached Buffer instance\n    buffers = null;\n  }\n\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n  socket.on('end', onend);\n\n  if (socket.read) {\n    read();\n  } else {\n    socket.once('data', ondata);\n  }\n\n  var hostname = opts.host + ':' + opts.port;\n  var msg = 'CONNECT ' + hostname + ' HTTP/1.1\\r\\n';\n  var auth = proxy.auth;\n  if (auth) {\n    msg += 'Proxy-Authorization: Basic ' + new Buffer(auth).toString('base64') + '\\r\\n';\n  }\n  msg += 'Host: ' + hostname + '\\r\\n' +\n         'Connection: close\\r\\n' +\n         '\\r\\n';\n  socket.write(msg);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/https-proxy-agent/https-proxy-agent.js\n// module id = 159\n// module chunks = 0","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {/**/}\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/https-proxy-agent/~/extend/index.js\n// module id = 160\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * Module exports.\n */\n\nmodule.exports = Agent;\n\n/**\n *\n * @api public\n */\n\nfunction Agent (callback) {\n  if (!(this instanceof Agent)) return new Agent(callback);\n  if ('function' != typeof callback) throw new Error('Must pass a \"callback function\"');\n  EventEmitter.call(this);\n  this.callback = callback;\n}\ninherits(Agent, EventEmitter);\n\n/**\n * Called by node-core's \"_http_client.js\" module when creating\n * a new HTTP request with this Agent instance.\n *\n * @api public\n */\n\nAgent.prototype.addRequest = function (req, host, port, localAddress) {\n  var opts;\n  if ('object' == typeof host) {\n    // >= v0.11.x API\n    opts = host;\n    if (opts.host && opts.path) {\n      // if both a `host` and `path` are specified then it's most likely the\n      // result of a `url.parse()` call... we need to remove the `path` portion so\n      // that `net.connect()` doesn't attempt to open that as a unix socket file.\n      delete opts.path;\n    }\n  } else {\n    // <= v0.10.x API\n    opts = { host: host, port: port };\n    if (null != localAddress) {\n      opts.localAddress = localAddress;\n    }\n  }\n\n  // hint to use \"Connection: close\"\n  // XXX: non-documented `http` module API :(\n  req._last = true;\n  req.shouldKeepAlive = false;\n\n  // create the `net.Socket` instance\n  var sync = true;\n  this.callback(req, opts, function (err, socket) {\n    function emitErr () {\n      req.emit('error', err);\n      // For Safety. Some additional errors might fire later on\n      // and we need to make sure we don't double-fire the error event.\n      req._hadError = true;\n    }\n    if (err) {\n      if (sync) {\n        // need to defer the \"error\" event, when sync, because by now the `req`\n        // instance hasn't event been passed back to the user yet...\n        process.nextTick(emitErr);\n      } else {\n        emitErr();\n      }\n    } else {\n      req.onSocket(socket);\n    }\n  });\n  sync = false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/https-proxy-agent/~/agent-base/agent.js\n// module id = 161\n// module chunks = 0","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  try {\n    return exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (typeof process !== 'undefined' && 'env' in process) {\n    return process.env.DEBUG;\n  }\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/https-proxy-agent/~/debug/src/browser.js\n// module id = 162\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug.default = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/https-proxy-agent/~/debug/src/debug.js\n// module id = 163\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/https-proxy-agent/~/debug/~/ms/index.js\n// module id = 164\n// module chunks = 0","'use strict'\n\n/**\n * certificates.js - CA bundle for SSL communication with RPM.\n *\n * This file contains the X509 certificates used to communicate with New Relic\n * over SSL.\n */\n\nmodule.exports = [\n  // AddTrustExternalCARoot\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEU\\n\" +\n  \"MBIGA1UEChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFs\\n\" +\n  \"IFRUUCBOZXR3b3JrMSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290\\n\" +\n  \"MB4XDTAwMDUzMDEwNDgzOFoXDTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0Ux\\n\" +\n  \"FDASBgNVBAoTC0FkZFRydXN0IEFCMSYwJAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5h\\n\" +\n  \"bCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1c3QgRXh0ZXJuYWwgQ0EgUm9v\\n\" +\n  \"dDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3GjPm8gAELTngTlvt\\n\" +\n  \"H7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCwSXrbLpX9\\n\" +\n  \"uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX\\n\" +\n  \"mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LX\\n\" +\n  \"a0Tkx63ubUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzN\\n\" +\n  \"E0S3ySvdQwAl+mG5aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0\\n\" +\n  \"WicCAwEAAaOB3DCB2TAdBgNVHQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYD\\n\" +\n  \"VR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgZkGA1UdIwSBkTCBjoAUrb2YejS0\\n\" +\n  \"Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRU\\n\" +\n  \"cnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwgVFRQIE5ldHdvcmsx\\n\" +\n  \"IjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJKoZIhvcN\\n\" +\n  \"AQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH\\n\" +\n  \"YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw5\\n\" +\n  \"6wwCURQtjr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvC\\n\" +\n  \"Nr4TDea9Y355e6cJDUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEX\\n\" +\n  \"c4g/VhsxOBi0cQ+azcgOno4uG+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5a\\n\" +\n  \"mnkPIAou1Z5jJh5VkpTYghdae9C8x49OhgQ=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // DigiCertAssuredIDRootCA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDtzCCAp+gAwIBAgIQDOfg5RfYRv6P5WD8G/AwOTANBgkqhkiG9w0BAQUFADBl\\n\" +\n  \"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\\n\" +\n  \"d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJv\\n\" +\n  \"b3QgQ0EwHhcNMDYxMTEwMDAwMDAwWhcNMzExMTEwMDAwMDAwWjBlMQswCQYDVQQG\\n\" +\n  \"EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNl\\n\" +\n  \"cnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgQ0EwggEi\\n\" +\n  \"MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCtDhXO5EOAXLGH87dg+XESpa7c\\n\" +\n  \"JpSIqvTO9SA5KFhgDPiA2qkVlTJhPLWxKISKityfCgyDF3qPkKyK53lTXDGEKvYP\\n\" +\n  \"mDI2dsze3Tyoou9q+yHyUmHfnyDXH+Kx2f4YZNISW1/5WBg1vEfNoTb5a3/UsDg+\\n\" +\n  \"wRvDjDPZ2C8Y/igPs6eD1sNuRMBhNZYW/lmci3Zt1/GiSw0r/wty2p5g0I6QNcZ4\\n\" +\n  \"VYcgoc/lbQrISXwxmDNsIumH0DJaoroTghHtORedmTpyoeb6pNnVFzF1roV9Iq4/\\n\" +\n  \"AUaG9ih5yLHa5FcXxH4cDrC0kqZWs72yl+2qp/C3xag/lRbQ/6GW6whfGHdPAgMB\\n\" +\n  \"AAGjYzBhMA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQW\\n\" +\n  \"BBRF66Kv9JLLgjEtUYunpyGd823IDzAfBgNVHSMEGDAWgBRF66Kv9JLLgjEtUYun\\n\" +\n  \"pyGd823IDzANBgkqhkiG9w0BAQUFAAOCAQEAog683+Lt8ONyc3pklL/3cmbYMuRC\\n\" +\n  \"dWKuh+vy1dneVrOfzM4UKLkNl2BcEkxY5NM9g0lFWJc1aRqoR+pWxnmrEthngYTf\\n\" +\n  \"fwk8lOa4JiwgvT2zKIn3X/8i4peEH+ll74fg38FnSbNd67IJKusm7Xi+fT8r87cm\\n\" +\n  \"NW1fiQG2SVufAQWbqz0lwcy2f8Lxb4bG+mRo64EtlOtCt/qMHt1i8b5QZ7dsvfPx\\n\" +\n  \"H2sMNgcWfzd8qVttevESRmCD1ycEvkvOl77DZypoEd+A5wwzZr8TDRRu838fYxAe\\n\" +\n  \"+o0bJW1sj6W3YQGx0qMmoRBxna3iw/nDmVG3KwcIzi7mULKn+gpFL6Lw8g==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // DigiCertAssuredIDRootG2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDljCCAn6gAwIBAgIQC5McOtY5Z+pnI7/Dr5r0SzANBgkqhkiG9w0BAQsFADBl\\n\" +\n  \"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\\n\" +\n  \"d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJv\\n\" +\n  \"b3QgRzIwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQG\\n\" +\n  \"EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNl\\n\" +\n  \"cnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzIwggEi\\n\" +\n  \"MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDZ5ygvUj82ckmIkzTz+GoeMVSA\\n\" +\n  \"n61UQbVH35ao1K+ALbkKz3X9iaV9JPrjIgwrvJUXCzO/GU1BBpAAvQxNEP4Htecc\\n\" +\n  \"biJVMWWXvdMX0h5i89vqbFCMP4QMls+3ywPgym2hFEwbid3tALBSfK+RbLE4E9Hp\\n\" +\n  \"EgjAALAcKxHad3A2m67OeYfcgnDmCXRwVWmvo2ifv922ebPynXApVfSr/5Vh88lA\\n\" +\n  \"bx3RvpO704gqu52/clpWcTs/1PPRCv4o76Pu2ZmvA9OPYLfykqGxvYmJHzDNw6Yu\\n\" +\n  \"YjOuFgJ3RFrngQo8p0Quebg/BLxcoIfhG69Rjs3sLPr4/m3wOnyqi+RnlTGNAgMB\\n\" +\n  \"AAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQW\\n\" +\n  \"BBTOw0q5mVXyuNtgv6l+vVa1lzan1jANBgkqhkiG9w0BAQsFAAOCAQEAyqVVjOPI\\n\" +\n  \"QW5pJ6d1Ee88hjZv0p3GeDgdaZaikmkuOGybfQTUiaWxMTeKySHMq2zNixya1r9I\\n\" +\n  \"0jJmwYrA8y8678Dj1JGG0VDjA9tzd29KOVPt3ibHtX2vK0LRdWLjSisCx1BL4Gni\\n\" +\n  \"lmwORGYQRI+tBev4eaymG+g3NJ1TyWGqolKvSnAWhsI6yLETcDbYz+70CjTVW0z9\\n\" +\n  \"B5yiutkBclzzTcHdDrEcDcRjvq30FPuJ7KJBDkzMyFdA0G4Dqs0MjomZmWzwPDCv\\n\" +\n  \"ON9vvKO+KSAnq3T/EyJ43pdSVR6DtVQgA+6uwE9W3jfMw3+qBCe703e4YtsXfJwo\\n\" +\n  \"IhNzbM8m9Yop5w==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // DigiCertAssuredIDRootG3\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIICRjCCAc2gAwIBAgIQC6Fa+h3foLVJRK/NJKBs7DAKBggqhkjOPQQDAzBlMQsw\\n\" +\n  \"CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu\\n\" +\n  \"ZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3Qg\\n\" +\n  \"RzMwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQGEwJV\\n\" +\n  \"UzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu\\n\" +\n  \"Y29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzMwdjAQBgcq\\n\" +\n  \"hkjOPQIBBgUrgQQAIgNiAAQZ57ysRGXtzbg/WPuNsVepRC0FFfLvC/8QdJ+1YlJf\\n\" +\n  \"Zn4f5dwbRXkLzMZTCp2NXQLZqVneAlr2lSoOjThKiknGvMYDOAdfVdp+CW7if17Q\\n\" +\n  \"RSAPWXYQ1qAk8C3eNvJsKTmjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/\\n\" +\n  \"BAQDAgGGMB0GA1UdDgQWBBTL0L2p4ZgFUaFNN6KDec6NHSrkhDAKBggqhkjOPQQD\\n\" +\n  \"AwNnADBkAjAlpIFFAmsSS3V0T8gj43DydXLefInwz5FyYZ5eEJJZVrmDxxDnOOlY\\n\" +\n  \"JjZ91eQ0hjkCMHw2U/Aw5WJjOpnitqM7mzT6HtoQknFekROn3aRukswy1vUhZscv\\n\" +\n  \"6pZjamVFkpUBtA==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // DigiCertGlobalRootCA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh\\n\" +\n  \"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\\n\" +\n  \"d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\\n\" +\n  \"QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT\\n\" +\n  \"MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\\n\" +\n  \"b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG\\n\" +\n  \"9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB\\n\" +\n  \"CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97\\n\" +\n  \"nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt\\n\" +\n  \"43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P\\n\" +\n  \"T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4\\n\" +\n  \"gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO\\n\" +\n  \"BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR\\n\" +\n  \"TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw\\n\" +\n  \"DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr\\n\" +\n  \"hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg\\n\" +\n  \"06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF\\n\" +\n  \"PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\\n\" +\n  \"YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk\\n\" +\n  \"CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // DigiCertGlobalRootG2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDjjCCAnagAwIBAgIQAzrx5qcRqaC7KGSxHQn65TANBgkqhkiG9w0BAQsFADBh\\n\" +\n  \"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\\n\" +\n  \"d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBH\\n\" +\n  \"MjAeFw0xMzA4MDExMjAwMDBaFw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVT\\n\" +\n  \"MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\\n\" +\n  \"b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IEcyMIIBIjANBgkqhkiG\\n\" +\n  \"9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuzfNNNx7a8myaJCtSnX/RrohCgiN9RlUyfuI\\n\" +\n  \"2/Ou8jqJkTx65qsGGmvPrC3oXgkkRLpimn7Wo6h+4FR1IAWsULecYxpsMNzaHxmx\\n\" +\n  \"1x7e/dfgy5SDN67sH0NO3Xss0r0upS/kqbitOtSZpLYl6ZtrAGCSYP9PIUkY92eQ\\n\" +\n  \"q2EGnI/yuum06ZIya7XzV+hdG82MHauVBJVJ8zUtluNJbd134/tJS7SsVQepj5Wz\\n\" +\n  \"tCO7TG1F8PapspUwtP1MVYwnSlcUfIKdzXOS0xZKBgyMUNGPHgm+F6HmIcr9g+UQ\\n\" +\n  \"vIOlCsRnKPZzFBQ9RnbDhxSJITRNrw9FDKZJobq7nMWxM4MphQIDAQABo0IwQDAP\\n\" +\n  \"BgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUTiJUIBiV\\n\" +\n  \"5uNu5g/6+rkS7QYXjzkwDQYJKoZIhvcNAQELBQADggEBAGBnKJRvDkhj6zHd6mcY\\n\" +\n  \"1Yl9PMWLSn/pvtsrF9+wX3N3KjITOYFnQoQj8kVnNeyIv/iPsGEMNKSuIEyExtv4\\n\" +\n  \"NeF22d+mQrvHRAiGfzZ0JFrabA0UWTW98kndth/Jsw1HKj2ZL7tcu7XUIOGZX1NG\\n\" +\n  \"Fdtom/DzMNU+MeKNhJ7jitralj41E6Vf8PlwUHBHQRFXGU7Aj64GxJUTFy8bJZ91\\n\" +\n  \"8rGOmaFvE7FBcf6IKshPECBV1/MUReXgRPTqh5Uykw7+U0b6LJ3/iyK5S9kJRaTe\\n\" +\n  \"pLiaWN0bfVKfjllDiIGknibVb63dDcY3fe0Dkhvld1927jyNxF1WW6LZZm6zNTfl\\n\" +\n  \"MrY=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // DigiCertGlobalRootG3\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIICPzCCAcWgAwIBAgIQBVVWvPJepDU1w6QP1atFcjAKBggqhkjOPQQDAzBhMQsw\\n\" +\n  \"CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu\\n\" +\n  \"ZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBHMzAe\\n\" +\n  \"Fw0xMzA4MDExMjAwMDBaFw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVTMRUw\\n\" +\n  \"EwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20x\\n\" +\n  \"IDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IEczMHYwEAYHKoZIzj0CAQYF\\n\" +\n  \"K4EEACIDYgAE3afZu4q4C/sLfyHS8L6+c/MzXRq8NOrexpu80JX28MzQC7phW1FG\\n\" +\n  \"fp4tn+6OYwwX7Adw9c+ELkCDnOg/QW07rdOkFFk2eJ0DQ+4QE2xy3q6Ip6FrtUPO\\n\" +\n  \"Z9wj/wMco+I+o0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAd\\n\" +\n  \"BgNVHQ4EFgQUs9tIpPmhxdiuNkHMEWNpYim8S8YwCgYIKoZIzj0EAwMDaAAwZQIx\\n\" +\n  \"AK288mw/EkrRLTnDCgmXc/SINoyIJ7vmiI1Qhadj+Z4y3maTD/HMsQmP3Wyr+mt/\\n\" +\n  \"oAIwOWZbwmSNuJ5Q3KjVSaLtx9zRSX8XAbjIho9OjIgrqJqpisXRAL34VOKa5Vt8\\n\" +\n  \"sycX\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // DigiCertHighAssuranceEVRootCA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBs\\n\" +\n  \"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\\n\" +\n  \"d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j\\n\" +\n  \"ZSBFViBSb290IENBMB4XDTA2MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDEL\\n\" +\n  \"MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3\\n\" +\n  \"LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNlcnQgSGlnaCBBc3N1cmFuY2Ug\\n\" +\n  \"RVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMbM5XPm\\n\" +\n  \"+9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlBWTrT3JTW\\n\" +\n  \"PNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM\\n\" +\n  \"xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFB\\n\" +\n  \"Ik5lYYeBQVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3\\n\" +\n  \"hzBWBOURtCmAEvF5OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsg\\n\" +\n  \"EsxBu24LUTi4S8sCAwEAAaNjMGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQF\\n\" +\n  \"MAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9HAdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaA\\n\" +\n  \"FLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3DQEBBQUAA4IBAQAcGgaX3Nec\\n\" +\n  \"nzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1ntlMMUu4kehDLI6z\\n\" +\n  \"eM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VHMWEZ71jF\\n\" +\n  \"hS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2\\n\" +\n  \"Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCe\\n\" +\n  \"vEsXCS+0yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep\\n\" +\n  \"+OkuE6N36B9K\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // DigiCertTrustedRootG4\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"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\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // Equifax_Secure_Certificate_Authority\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDIDCCAomgAwIBAgIENd70zzANBgkqhkiG9w0BAQUFADBOMQswCQYDVQQGEwJV\\n\" +\n  \"UzEQMA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2Vy\\n\" +\n  \"dGlmaWNhdGUgQXV0aG9yaXR5MB4XDTk4MDgyMjE2NDE1MVoXDTE4MDgyMjE2NDE1\\n\" +\n  \"MVowTjELMAkGA1UEBhMCVVMxEDAOBgNVBAoTB0VxdWlmYXgxLTArBgNVBAsTJEVx\\n\" +\n  \"dWlmYXggU2VjdXJlIENlcnRpZmljYXRlIEF1dGhvcml0eTCBnzANBgkqhkiG9w0B\\n\" +\n  \"AQEFAAOBjQAwgYkCgYEAwV2xWGcIYu6gmi0fCG2RFGiYCh7+2gRvE4RiIcPRfM6f\\n\" +\n  \"BeC4AfBONOziipUEZKzxa1NfBbPLZ4C/QgKO/t0BCezhABRP/PvwDN1Dulsr4R+A\\n\" +\n  \"cJkVV5MW8Q+XarfCaCMczE1ZMKxRHjuvK9buY0V7xdlfUNLjUA86iOe/FP3gx7kC\\n\" +\n  \"AwEAAaOCAQkwggEFMHAGA1UdHwRpMGcwZaBjoGGkXzBdMQswCQYDVQQGEwJVUzEQ\\n\" +\n  \"MA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2VydGlm\\n\" +\n  \"aWNhdGUgQXV0aG9yaXR5MQ0wCwYDVQQDEwRDUkwxMBoGA1UdEAQTMBGBDzIwMTgw\\n\" +\n  \"ODIyMTY0MTUxWjALBgNVHQ8EBAMCAQYwHwYDVR0jBBgwFoAUSOZo+SvSspXXR9gj\\n\" +\n  \"IBBPM5iQn9QwHQYDVR0OBBYEFEjmaPkr0rKV10fYIyAQTzOYkJ/UMAwGA1UdEwQF\\n\" +\n  \"MAMBAf8wGgYJKoZIhvZ9B0EABA0wCxsFVjMuMGMDAgbAMA0GCSqGSIb3DQEBBQUA\\n\" +\n  \"A4GBAFjOKer89961zgK5F7WF0bnj4JXMJTENAKaSbn+2kmOeUJXRmm/kEd5jhW6Y\\n\" +\n  \"7qj/WsjTVbJmcVfewCHrPSqnI0kBBIZCe/zuf6IWUrVnZ9NA2zsmWLIodz2uFHdh\\n\" +\n  \"1voqZiegDfqnc1zqcPGUIWVEX/r87yloqaKHee9570+sB3c4\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GeoTrust_Global_CA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDVDCCAjygAwIBAgIDAjRWMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\\n\" +\n  \"MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i\\n\" +\n  \"YWwgQ0EwHhcNMDIwNTIxMDQwMDAwWhcNMjIwNTIxMDQwMDAwWjBCMQswCQYDVQQG\\n\" +\n  \"EwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEbMBkGA1UEAxMSR2VvVHJ1c3Qg\\n\" +\n  \"R2xvYmFsIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2swYYzD9\\n\" +\n  \"9BcjGlZ+W988bDjkcbd4kdS8odhM+KhDtgPpTSEHCIjaWC9mOSm9BXiLnTjoBbdq\\n\" +\n  \"fnGk5sRgprDvgOSJKA+eJdbtg/OtppHHmMlCGDUUna2YRpIuT8rxh0PBFpVXLVDv\\n\" +\n  \"iS2Aelet8u5fa9IAjbkU+BQVNdnARqN7csiRv8lVK83Qlz6cJmTM386DGXHKTubU\\n\" +\n  \"1XupGc1V3sjs0l44U+VcT4wt/lAjNvxm5suOpDkZALeVAjmRCw7+OC7RHQWa9k0+\\n\" +\n  \"bw8HHa8sHo9gOeL6NlMTOdReJivbPagUvTLrGAMoUgRx5aszPeE4uwc2hGKceeoW\\n\" +\n  \"MPRfwCvocWvk+QIDAQABo1MwUTAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTA\\n\" +\n  \"ephojYn7qwVkDBF9qn1luMrMTjAfBgNVHSMEGDAWgBTAephojYn7qwVkDBF9qn1l\\n\" +\n  \"uMrMTjANBgkqhkiG9w0BAQUFAAOCAQEANeMpauUvXVSOKVCUn5kaFOSPeCpilKIn\\n\" +\n  \"Z57QzxpeR+nBsqTP3UEaBU6bS+5Kb1VSsyShNwrrZHYqLizz/Tt1kL/6cdjHPTfS\\n\" +\n  \"tQWVYrmm3ok9Nns4d0iXrKYgjy6myQzCsplFAMfOEVEiIuCl6rYVSAlk6l5PdPcF\\n\" +\n  \"PseKUgzbFbS9bZvlxrFUaKnjaZC2mqUPuLk/IH2uSrW4nOQdtqvmlKXBx4Ot2/Un\\n\" +\n  \"hw4EbNX/3aBd7YdStysVAq45pmp06drE57xNNB6pXE0zX5IJL4hmXXeXxx12E6nV\\n\" +\n  \"5fEWCRE11azbJHFwLJhWC9kXtNHjUStedejV0NxPNO3CBWaAocvmMw==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GeoTrust_Global_CA2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDZjCCAk6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBEMQswCQYDVQQGEwJVUzEW\\n\" +\n  \"MBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEdMBsGA1UEAxMUR2VvVHJ1c3QgR2xvYmFs\\n\" +\n  \"IENBIDIwHhcNMDQwMzA0MDUwMDAwWhcNMTkwMzA0MDUwMDAwWjBEMQswCQYDVQQG\\n\" +\n  \"EwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEdMBsGA1UEAxMUR2VvVHJ1c3Qg\\n\" +\n  \"R2xvYmFsIENBIDIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDvPE1A\\n\" +\n  \"PRDfO1MA4Wf+lGAVPoWI8YkNkMgoI5kF6CsgncbzYEbYwbLVjDHZ3CB5JIG/NTL8\\n\" +\n  \"Y2nbsSpr7iFY8gjpeMtvy/wWUsiRxP89c96xPqfCfWbB9X5SJBri1WeR0IIQ13hL\\n\" +\n  \"TytCOb1kLUCgsBDTOEhGiKEMuzozKmKY+wCdE1l/bztyqu6mD4b5BWHqZ38MN5aL\\n\" +\n  \"5mkWRxHCJ1kDs6ZgwiFAVvqgx306E+PsV8ez1q6diYD3Aecs9pYrEw15LNnA5IZ7\\n\" +\n  \"S4wMcoKK+xfNAGw6EzywhIdLFnopsk/bHdQL82Y3vdj2V7teJHq4PIu5+pIaGoSe\\n\" +\n  \"2HSPqht/XvT+RSIhAgMBAAGjYzBhMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\\n\" +\n  \"FHE4NvICMVNHK266ZUapEBVYIAUJMB8GA1UdIwQYMBaAFHE4NvICMVNHK266ZUap\\n\" +\n  \"EBVYIAUJMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQUFAAOCAQEAA/e1K6td\\n\" +\n  \"EPx7srJerJsOflN4WT5CBP51o62sgU7XAotexC3IUnbHLB/8gTKY0UvGkpMzNTEv\\n\" +\n  \"/NgdRN3ggX+d6YvhZJFiCzkIjKx0nVnZellSlxG5FntvRdOW2TF9AjYPnDtuzywN\\n\" +\n  \"A0ZF66D0f0hExghAzN4bcLUprbqLOzRldRtxIR0sFAqwlpW41uryZfspuk/qkZN0\\n\" +\n  \"abby/+Ea0AzRdoXLiiW9l14sbxWZJue2Kf8i7MkCx1YAzUm5s2x7UwQa4qjJqhIF\\n\" +\n  \"I8LO57sEAszAR6LkxCkvW0VXiVHuPOtSCP8HNR6fNWpHSlaY0VqFH4z1Ir+rzoPz\\n\" +\n  \"4iIprn2DQKi6bA==\\n\" +\n  \"-----END CERTIFICATE----- \\n\",\n\n  // GeoTrust_Primary_CA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDfDCCAmSgAwIBAgIQGKy1av1pthU6Y2yv2vrEoTANBgkqhkiG9w0BAQUFADBY\\n\" +\n  \"MQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjExMC8GA1UEAxMo\\n\" +\n  \"R2VvVHJ1c3QgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjEx\\n\" +\n  \"MjcwMDAwMDBaFw0zNjA3MTYyMzU5NTlaMFgxCzAJBgNVBAYTAlVTMRYwFAYDVQQK\\n\" +\n  \"Ew1HZW9UcnVzdCBJbmMuMTEwLwYDVQQDEyhHZW9UcnVzdCBQcmltYXJ5IENlcnRp\\n\" +\n  \"ZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC\\n\" +\n  \"AQEAvrgVe//UfH1nrYNke8hCUy3f9oQIIGHWAVlqnEQRr+92/ZV+zmEwu3qDXwK9\\n\" +\n  \"AWbK7hWNb6EwnL2hhZ6UOvNWiAAxz9juapYC2e0DjPt1befquFUWBRaa9OBesYjA\\n\" +\n  \"ZIVcFU2Ix7e64HXprQU9nceJSOC7KMgD4TCTZF5SwFlwIjVXiIrxlQqD17wxcwE0\\n\" +\n  \"7e9GceBrAqg1cmuXm2bgyxx5X9gaBGgeRwLmnWDiNpcB3841kt++Z8dtd1k7j53W\\n\" +\n  \"kBWUvEI0EME5+bEnPn7WinXFsq+W06Lem+SYvn3h6YGttm/81w7a4DSwDRp35+MI\\n\" +\n  \"mO9Y+pyEtzavwt+s0vQQBnBxNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4G\\n\" +\n  \"A1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQULNVQQZcVi/CPNmFbSvtr2ZnJM5IwDQYJ\\n\" +\n  \"KoZIhvcNAQEFBQADggEBAFpwfyzdtzRP9YZRqSa+S7iq8XEN3GHHoOo0Hnp3DwQ1\\n\" +\n  \"6CePbJC/kRYkRj5KTs4rFtULUh38H2eiAkUxT87z+gOneZ1TatnaYzr4gNfTmeGl\\n\" +\n  \"4b7UVXGYNTq+k+qurUKykG/g/CFNNWMziUnWm07Kx+dOCQD32sfvmWKZd7aVIl6K\\n\" +\n  \"oKv0uHiYyjgZmclynnjNS6yvGaBzEi38wkG6gZHaFloxt/m0cYASSJlyc1pZU8Fj\\n\" +\n  \"UjPtp8nSOQJw+uCxQmYpqptR7TBUIhRf2asdweSU8Pj1K/fqynhG1riR/aYNKxoU\\n\" +\n  \"AT6A8EKglQdebc3MS6RFjasS6LPeWuWgfOgPIh1a6Vk=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GeoTrust_Primary_CA_G2_ECC\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIICrjCCAjWgAwIBAgIQPLL0SAoA4v7rJDteYD7DazAKBggqhkjOPQQDAzCBmDEL\\n\" +\n  \"MAkGA1UEBhMCVVMxFjAUBgNVBAoTDUdlb1RydXN0IEluYy4xOTA3BgNVBAsTMChj\\n\" +\n  \"KSAyMDA3IEdlb1RydXN0IEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTE2\\n\" +\n  \"MDQGA1UEAxMtR2VvVHJ1c3QgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0\\n\" +\n  \"eSAtIEcyMB4XDTA3MTEwNTAwMDAwMFoXDTM4MDExODIzNTk1OVowgZgxCzAJBgNV\\n\" +\n  \"BAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMTkwNwYDVQQLEzAoYykgMjAw\\n\" +\n  \"NyBHZW9UcnVzdCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxNjA0BgNV\\n\" +\n  \"BAMTLUdlb1RydXN0IFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBH\\n\" +\n  \"MjB2MBAGByqGSM49AgEGBSuBBAAiA2IABBWx6P0DFUPlrOuHNxFi79KDNlJ9RVcL\\n\" +\n  \"So17VDs6bl8VAsBQps8lL33KSLjHUGMcKiEIfJo22Av+0SbFWDEwKCXzXV2juLal\\n\" +\n  \"tJLtbCyf691DiaI8S0iRHVDsJt/WYC69IaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO\\n\" +\n  \"BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFBVfNVdRVfslsq0DafwBo/q+EVXVMAoG\\n\" +\n  \"CCqGSM49BAMDA2cAMGQCMGSWWaboCd6LuvpaiIjwH5HTRqjySkwCY/tsXzjbLkGT\\n\" +\n  \"qQ7mndwxHLKgpxgceeHHNgIwOlavmnRs9vuD4DPTCF+hnMJbn0bWtsuRBmOiBucz\\n\" +\n  \"rD6ogRLQy7rQkgu2npaqBA+K\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GeoTrust_Universal_CA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"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\\n\" +\n  \"-----END CERTIFICATE----- \\n\",\n\n  // GeoTrust_Universal_CA2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIFbDCCA1SgAwIBAgIBATANBgkqhkiG9w0BAQUFADBHMQswCQYDVQQGEwJVUzEW\\n\" +\n  \"MBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEgMB4GA1UEAxMXR2VvVHJ1c3QgVW5pdmVy\\n\" +\n  \"c2FsIENBIDIwHhcNMDQwMzA0MDUwMDAwWhcNMjkwMzA0MDUwMDAwWjBHMQswCQYD\\n\" +\n  \"VQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEgMB4GA1UEAxMXR2VvVHJ1\\n\" +\n  \"c3QgVW5pdmVyc2FsIENBIDIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC\\n\" +\n  \"AQCzVFLByT7y2dyxUxpZKeexw0Uo5dfR7cXFS6GqdHtXr0om/Nj1XqduGdt0DE81\\n\" +\n  \"WzILAePb63p3NeqqWuDW6KFXlPCQo3RWlEQwAx5cTiuFJnSCegx2oG9NzkEtoBUG\\n\" +\n  \"FF+3Qs17j1hhNNwqCPkuwwGmIkQcTAeC5lvO0Ep8BNMZcyfwqph/Lq9O64ceJHdq\\n\" +\n  \"XbboW0W63MOhBW9Wjo8QJqVJwy7XQYci4E+GymC16qFjwAGXEHm9ADwSbSsVsaxL\\n\" +\n  \"se4YuU6W3Nx2/zu+z18DwPw76L5GG//aQMJS9/7jOvdqdzXQ2o3rXhhqMcceujwb\\n\" +\n  \"KNZrVMaqW9eiLBsZzKIC9ptZvTdrhrVtgrrY6slWvKk2WP0+GfPtDCapkzj4T8Fd\\n\" +\n  \"IgbQl+rhrcZV4IErKIM6+vR7IVEAvlI4zs1meaj0gVbi0IMJR1FbUGrP20gaXT73\\n\" +\n  \"y/Zl92zxlfgCOzJWgjl6W70viRu/obTo/3+NjN8D8WBOWBFM66M/ECuDmgFz2ZRt\\n\" +\n  \"hAAnZqzwcEAJQpKtT5MNYQlRJNiS1QuUYbKHsu3/mjX/hVTK7URDrBs8FmtISgoc\\n\" +\n  \"QIgfksILAAX/8sgCSqSqqcyZlpwvWOB94b67B9xfBHJcMTTD7F8t4D1kkCLm0ey4\\n\" +\n  \"Lt1ZrtmhN79UNdxzMk+MBB4zsslG8dhcyFVQyWi9qLo2CQIDAQABo2MwYTAPBgNV\\n\" +\n  \"HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR281Xh+qQ2+/CfXGJx7Tz0RzgQKzAfBgNV\\n\" +\n  \"HSMEGDAWgBR281Xh+qQ2+/CfXGJx7Tz0RzgQKzAOBgNVHQ8BAf8EBAMCAYYwDQYJ\\n\" +\n  \"KoZIhvcNAQEFBQADggIBAGbBxiPz2eAubl/oz66wsCVNK/g7WJtAJDday6sWSf+z\\n\" +\n  \"dXkzoS9tcBc0kf5nfo/sm+VegqlVHy/c1FEHEv6sFj4sNcZj/NwQ6w2jqtB8zNHQ\\n\" +\n  \"L1EuxBRa3ugZ4T7GzKQp5y6EqgYweHZUcyiYWTjgAA1i00J9IZ+uPTqM1fp3DRgr\\n\" +\n  \"Fg5fNuH8KrUwJM/gYwx7WBr+mbpCErGR9Hxo4sjoryzqyX6uuyo9DRXcNJW2GHSo\\n\" +\n  \"ag/HtPQTxORb7QrSpJdMKu0vbBKJPfEncKpqA1Ihn0CoZ1Dy81of398j9tx4TuaY\\n\" +\n  \"T1U6U+Pv8vSfx3zYWK8pIpe44L2RLrB27FcRz+8pRPPphXpgY+RdM4kX2TGq2tbz\\n\" +\n  \"GDVyz4crL2MjhF2EjD9XoIj8mZEoJmmZ1I+XRL6O1UixpCgp8RW04eWe3fiPpm8m\\n\" +\n  \"1wk8OhwRDqZsN/etRIcsKMfYdIKz0G9KV7s1KSegi+ghp4dkNl3M2Basx7InQJJV\\n\" +\n  \"OCiNUW7dFGdTbHFcJoRNdVq2fmBWqU2t+5sel/MN2dKXVHfaPRK34B7vCAas+YWH\\n\" +\n  \"6aLcr34YEoP9VhdBLtUpgn2Z9DH2canPLAEnpQW5qrJITirvn5NSUZU8UnOOVkwX\\n\" +\n  \"QMAJKOSLakhT2+zNVVXxxvjpoixMptEmX36vWkzaH6byHCx+rgIW0lbQL1dTR+iS\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GlobalSign_Root_CA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\\n\" +\n  \"A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\\n\" +\n  \"b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\\n\" +\n  \"MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\\n\" +\n  \"YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\\n\" +\n  \"aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\\n\" +\n  \"jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\\n\" +\n  \"xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\\n\" +\n  \"1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\\n\" +\n  \"snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\\n\" +\n  \"U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\\n\" +\n  \"9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\\n\" +\n  \"BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\\n\" +\n  \"AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\\n\" +\n  \"yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\\n\" +\n  \"38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\\n\" +\n  \"AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\\n\" +\n  \"DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\\n\" +\n  \"HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GlobalSign_Root_CA_ECC_R4\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIB4TCCAYegAwIBAgIRKjikHJYKBN5CsiilC+g0mAIwCgYIKoZIzj0EAwIwUDEk\\n\" +\n  \"MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI0MRMwEQYDVQQKEwpH\\n\" +\n  \"bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoX\\n\" +\n  \"DTM4MDExOTAzMTQwN1owUDEkMCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBD\\n\" +\n  \"QSAtIFI0MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu\\n\" +\n  \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEuMZ5049sJQ6fLjkZHAOkrprlOQcJ\\n\" +\n  \"FspjsbmG+IpXwVfOQvpzofdlQv8ewQCybnMO/8ch5RikqtlxP6jUuc6MHaNCMEAw\\n\" +\n  \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFSwe61F\\n\" +\n  \"uOJAf/sKbvu+M8k8o4TVMAoGCCqGSM49BAMCA0gAMEUCIQDckqGgE6bPA7DmxCGX\\n\" +\n  \"kPoUVy0D7O48027KqGx2vKLeuwIgJ6iFJzWbVsaj8kfSt24bAgAXqmemFZHe+pTs\\n\" +\n  \"ewv4n4Q=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GlobalSign_Root_CA_ECC_R5\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIICHjCCAaSgAwIBAgIRYFlJ4CYuu1X5CneKcflK2GwwCgYIKoZIzj0EAwMwUDEk\\n\" +\n  \"MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI1MRMwEQYDVQQKEwpH\\n\" +\n  \"bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoX\\n\" +\n  \"DTM4MDExOTAzMTQwN1owUDEkMCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBD\\n\" +\n  \"QSAtIFI1MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu\\n\" +\n  \"MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAER0UOlvt9Xb/pOdEh+J8LttV7HpI6SFkc\\n\" +\n  \"8GIxLcB6KP4ap1yztsyX50XUWPrRd21DosCHZTQKH3rd6zwzocWdTaRvQZU4f8ke\\n\" +\n  \"hOvRnkmSh5SHDDqFSmafnVmTTZdhBoZKo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYD\\n\" +\n  \"VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUPeYpSJvqB8ohREom3m7e0oPQn1kwCgYI\\n\" +\n  \"KoZIzj0EAwMDaAAwZQIxAOVpEslu28YxuglB4Zf4+/2a4n0Sye18ZNPLBSWLVtmg\\n\" +\n  \"515dTguDnFt2KaAJJiFqYgIwcdK1j1zqO+F4CYWodZI7yFz9SO8NdCKoCOJuxUnO\\n\" +\n  \"xwy8p2Fp8fc74SrL+SvzZpA3\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GlobalSign_Root_CA_R3\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\\n\" +\n  \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\\n\" +\n  \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\\n\" +\n  \"MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\\n\" +\n  \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\\n\" +\n  \"hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\\n\" +\n  \"RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\\n\" +\n  \"gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\\n\" +\n  \"KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\\n\" +\n  \"QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\\n\" +\n  \"XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\\n\" +\n  \"DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\\n\" +\n  \"LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\\n\" +\n  \"RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\\n\" +\n  \"jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\\n\" +\n  \"6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\\n\" +\n  \"mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\\n\" +\n  \"Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\\n\" +\n  \"WD9f\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // GlobalSign_Root_CA_RC2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4G\\n\" +\n  \"A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNp\\n\" +\n  \"Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1\\n\" +\n  \"MDgwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEG\\n\" +\n  \"A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\\n\" +\n  \"hvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8omUVCxKs+IVSbC9N/hHD6ErPL\\n\" +\n  \"v4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7SqbKSaZeqKeMWhG8\\n\" +\n  \"eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQBoZfXklq\\n\" +\n  \"tTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd\\n\" +\n  \"C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pa\\n\" +\n  \"zq+r1feqCapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCB\\n\" +\n  \"mTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IH\\n\" +\n  \"V2ccHsBqBt5ZtJot39wZhi4wNgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5n\\n\" +\n  \"bG9iYWxzaWduLm5ldC9yb290LXIyLmNybDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG\\n\" +\n  \"3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEAmYFThxxol4aR7OBKuEQLq4Gs\\n\" +\n  \"J0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkIk7mpM0sYmsL4h4hO\\n\" +\n  \"291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRDLenVOavS\\n\" +\n  \"ot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd\\n\" +\n  \"AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7\\n\" +\n  \"TBj0/VLZjmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-2G2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDAzCCAmwCEQC5L2DMiJ+hekYJuFtwbIqvMA0GCSqGSIb3DQEBBQUAMIHBMQsw\\n\" +\n  \"CQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xPDA6BgNVBAsTM0Ns\\n\" +\n  \"YXNzIDIgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBH\\n\" +\n  \"MjE6MDgGA1UECxMxKGMpIDE5OTggVmVyaVNpZ24sIEluYy4gLSBGb3IgYXV0aG9y\\n\" +\n  \"aXplZCB1c2Ugb25seTEfMB0GA1UECxMWVmVyaVNpZ24gVHJ1c3QgTmV0d29yazAe\\n\" +\n  \"Fw05ODA1MTgwMDAwMDBaFw0yODA4MDEyMzU5NTlaMIHBMQswCQYDVQQGEwJVUzEX\\n\" +\n  \"MBUGA1UEChMOVmVyaVNpZ24sIEluYy4xPDA6BgNVBAsTM0NsYXNzIDIgUHVibGlj\\n\" +\n  \"IFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHMjE6MDgGA1UECxMx\\n\" +\n  \"KGMpIDE5OTggVmVyaVNpZ24sIEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25s\\n\" +\n  \"eTEfMB0GA1UECxMWVmVyaVNpZ24gVHJ1c3QgTmV0d29yazCBnzANBgkqhkiG9w0B\\n\" +\n  \"AQEFAAOBjQAwgYkCgYEAp4gBIXQs5xoD8JjhlzwPIQjxnNuX6Zr8wgQGE75fUsjM\\n\" +\n  \"HiwSViy4AWkszJkfrbCWrnkE8hM5wXuYuggs6MKEEyyqaekJ9MepAqRCwiNPStjw\\n\" +\n  \"DqL7MWzJ5m+ZJwf15vRMeJ5t60aG+rmGyVTyssSv1EYcWskVMP8NbPUtDm3Of3cC\\n\" +\n  \"AwEAATANBgkqhkiG9w0BAQUFAAOBgQByLvl/0fFx+8Se9sVeUYpAmLho+Jscg9ji\\n\" +\n  \"nb3/7aHmZuovCfTK1+qlK5X2JGCGTUQug6XELaDTrnhpb3LabK4I8GOSN+a7xDAX\\n\" +\n  \"rXfMSTWqz9iP0b63GJZHc2pUIjRkLbYWm1lbtFFZOrMLFPQS32eg9K0yZF6xRnIn\\n\" +\n  \"jBJ7xUS0rg==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-2G3\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEGTCCAwECEGFwy0mMX5hFKeewptlQW3owDQYJKoZIhvcNAQEFBQAwgcoxCzAJ\\n\" +\n  \"BgNVBAYTAlVTMRcwFQYDVQQKEw5WZXJpU2lnbiwgSW5jLjEfMB0GA1UECxMWVmVy\\n\" +\n  \"aVNpZ24gVHJ1c3QgTmV0d29yazE6MDgGA1UECxMxKGMpIDE5OTkgVmVyaVNpZ24s\\n\" +\n  \"IEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTFFMEMGA1UEAxM8VmVyaVNp\\n\" +\n  \"Z24gQ2xhc3MgMiBQdWJsaWMgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0\\n\" +\n  \"eSAtIEczMB4XDTk5MTAwMTAwMDAwMFoXDTM2MDcxNjIzNTk1OVowgcoxCzAJBgNV\\n\" +\n  \"BAYTAlVTMRcwFQYDVQQKEw5WZXJpU2lnbiwgSW5jLjEfMB0GA1UECxMWVmVyaVNp\\n\" +\n  \"Z24gVHJ1c3QgTmV0d29yazE6MDgGA1UECxMxKGMpIDE5OTkgVmVyaVNpZ24sIElu\\n\" +\n  \"Yy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTFFMEMGA1UEAxM8VmVyaVNpZ24g\\n\" +\n  \"Q2xhc3MgMiBQdWJsaWMgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAt\\n\" +\n  \"IEczMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArwoNwtUs22e5LeWU\\n\" +\n  \"J92lvuCwTY+zYVY81nzD9M0+hsuiiOLh2KRpxbXiv8GmR1BeRjmL1Za6tW8UvxDO\\n\" +\n  \"JxOeBUebMXoT2B/Z0wI3i60sR/COgQanDTAM6/c8DyAd3HJG7qUCyFvDyVZpTMUY\\n\" +\n  \"wZF7C9UTAJu878NIPkZgIIUq1ZC2zYugzDLdt/1AVbJQHFauzI13TccgTacxdu9o\\n\" +\n  \"koqQHgiBVrKtaaNS0MscxCM9H5n+TOgWY47GCI72MfbS+uV23bUckqNJzc0BzWjN\\n\" +\n  \"qWm6o+sdDZykIKbBoMXRRkwXbdKsZj+WjOCE1Db/IlnF+RFgqF8EffIa9iVCYQ/E\\n\" +\n  \"Srg+iQIDAQABMA0GCSqGSIb3DQEBBQUAA4IBAQA0JhU8wI1NQ0kdvekhktdmnLfe\\n\" +\n  \"xbjQ5F1fdiLAJvmEOjr5jLX77GDx6M4EsMjdpwOPMPOY36TmpDHf0xwLRtxyID+u\\n\" +\n  \"7gU8pDM/CzmscHhzS5kr3zDCVLCoO1Wh/hYozUK9dG6A2ydEp85EXdQbkJgNHkKU\\n\" +\n  \"sQAsBNB0owIFImNjzYO1+8FtYmtpdf1dcEG59b98377BMnMiIYtYgXsVkXq642RI\\n\" +\n  \"sH/7NiXaldDxJBQX3RiAa0YjOVT1jmIJBB2UkKab5iXiQkWquJCtvgiPqQtCGJTP\\n\" +\n  \"cjnhsUPgKM+351psE2tJs//jGHyJizNdrDPXp/naOlXJWBD5qu9ats9LS98q\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-3\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIICPDCCAaUCEDyRMcsf9tAbDpq40ES/Er4wDQYJKoZIhvcNAQEFBQAwXzELMAkG\\n\" +\n  \"A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFz\\n\" +\n  \"cyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTk2\\n\" +\n  \"MDEyOTAwMDAwMFoXDTI4MDgwMjIzNTk1OVowXzELMAkGA1UEBhMCVVMxFzAVBgNV\\n\" +\n  \"BAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFzcyAzIFB1YmxpYyBQcmlt\\n\" +\n  \"YXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GN\\n\" +\n  \"ADCBiQKBgQDJXFme8huKARS0EN8EQNvjV69qRUCPhAwL0TPZ2RHP7gJYHyX3KqhE\\n\" +\n  \"BarsAx94f56TuZoAqiN91qyFomNFx3InzPRMxnVx0jnvT0Lwdd8KkMaOIG+YD/is\\n\" +\n  \"I19wKTakyYbnsZogy1Olhec9vn2a/iRFM9x2Fe0PonFkTGUugWhFpwIDAQABMA0G\\n\" +\n  \"CSqGSIb3DQEBBQUAA4GBABByUqkFFBkyCEHwxWsKzH4PIRnN5GfcX6kb5sroc50i\\n\" +\n  \"2JhucwNhkcV8sEVAbkSdjbCxlnRhLQ2pRdKkkirWmnWXbj9T/UWZYB2oK0z5XqcJ\\n\" +\n  \"2HUw19JlYD1n1khVdWk/kfVIC0dpImmClr7JyDiGSnoscxlIaU5rfGW/D/xwzoiQ\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-3G2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDAjCCAmsCEH3Z/gfPqB63EHln+6eJNMYwDQYJKoZIhvcNAQEFBQAwgcExCzAJ\\n\" +\n  \"BgNVBAYTAlVTMRcwFQYDVQQKEw5WZXJpU2lnbiwgSW5jLjE8MDoGA1UECxMzQ2xh\\n\" +\n  \"c3MgMyBQdWJsaWMgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEcy\\n\" +\n  \"MTowOAYDVQQLEzEoYykgMTk5OCBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3Jp\\n\" +\n  \"emVkIHVzZSBvbmx5MR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMB4X\\n\" +\n  \"DTk4MDUxODAwMDAwMFoXDTI4MDgwMTIzNTk1OVowgcExCzAJBgNVBAYTAlVTMRcw\\n\" +\n  \"FQYDVQQKEw5WZXJpU2lnbiwgSW5jLjE8MDoGA1UECxMzQ2xhc3MgMyBQdWJsaWMg\\n\" +\n  \"UHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEcyMTowOAYDVQQLEzEo\\n\" +\n  \"YykgMTk5OCBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5\\n\" +\n  \"MR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMIGfMA0GCSqGSIb3DQEB\\n\" +\n  \"AQUAA4GNADCBiQKBgQDMXtERXVxp0KvTuWpMmR9ZmDCOFoUgRm1HP9SFIIThbbP4\\n\" +\n  \"pO0M8RcPO/mn+SXXwc+EY/J8Y8+iR/LGWzOOZEAEaMGAuWQcRXfH2G71lSk8UOg0\\n\" +\n  \"13gfqLptQ5GVj0VXXn7F+8qkBOvqlzdUMG+7AUcyM83cV5tkaWH4mx0ciU9cZwID\\n\" +\n  \"AQABMA0GCSqGSIb3DQEBBQUAA4GBAFFNzb5cy5gZnBWyATl4Lk0PZ3BwmcYQWpSk\\n\" +\n  \"U01UbSuvDV1Ai2TT1+7eVmGSX6bEHRBhNtMsJzzoKQm5EWR0zLVznxxIqbxhAe7i\\n\" +\n  \"F6YM40AIOw7n60RzKprxaZLvcRTDOaxxp5EJb+RxBrO6WVcmeQD2+A2iMzAo1KpY\\n\" +\n  \"oJ2daZH9\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-3G3\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEGjCCAwICEQCbfgZJoz5iudXukEhxKe9XMA0GCSqGSIb3DQEBBQUAMIHKMQsw\\n\" +\n  \"CQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZl\\n\" +\n  \"cmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWdu\\n\" +\n  \"LCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlT\\n\" +\n  \"aWduIENsYXNzIDMgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3Jp\\n\" +\n  \"dHkgLSBHMzAeFw05OTEwMDEwMDAwMDBaFw0zNjA3MTYyMzU5NTlaMIHKMQswCQYD\\n\" +\n  \"VQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlT\\n\" +\n  \"aWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWduLCBJ\\n\" +\n  \"bmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlTaWdu\\n\" +\n  \"IENsYXNzIDMgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkg\\n\" +\n  \"LSBHMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMu6nFL8eB8aHm8b\\n\" +\n  \"N3O9+MlrlBIwT/A2R/XQkQr1F8ilYcEWQE37imGQ5XYgwREGfassbqb1EUGO+i2t\\n\" +\n  \"KmFZpGcmTNDovFJbcCAEWNF6yaRpvIMXZK0Fi7zQWM6NjPXr8EJJC52XJ2cybuGu\\n\" +\n  \"kxUccLwgTS8Y3pKI6GyFVxEa6X7jJhFUokWWVYPKMIno3Nij7SqAP395ZVc+FSBm\\n\" +\n  \"CC+Vk7+qRy+oRpfwEuL+wgorUeZ25rdGt+INpsyow0xZVYnm6FNcHOqd8GIWC6fJ\\n\" +\n  \"Xwzw3sJ2zq/3avL6QaaiMxTJ5Xpj055iN9WFZZ4O5lMkdBteHRJTW8cs54NJOxWu\\n\" +\n  \"imi5V5cCAwEAATANBgkqhkiG9w0BAQUFAAOCAQEAERSWwauSCPc/L8my/uRan2Te\\n\" +\n  \"2yFPhpk0djZX3dAVL8WtfxUfN2JzPtTnX84XA9s1+ivbrmAJXx5fj267Cz3qWhMe\\n\" +\n  \"DGBvtcC1IyIuBwvLqXTLR7sdwdela8wv0kL9Sd2nic9TutoAWii/gt/4uhMdUIaC\\n\" +\n  \"/Y4wjylGsB49Ndo4YhYYSq3mtlFs3q9i6wHQHiT+eo8SGhJouPtmmRQURVyu565p\\n\" +\n  \"F4ErWjfJXir0xuKhXFSbplQAz/DxwceYMBo7Nhbbo27q/a2ywtrvAkcTisDxszGt\\n\" +\n  \"TxzhT5yvDwyd93gN2PQ1VoDat20Xj50egWTh/sVFuq1ruQp6Tk9LhO5L8X3dEQ==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-3G4\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDhDCCAwqgAwIBAgIQL4D+I4wOIg9IZxIokYesszAKBggqhkjOPQQDAzCByjEL\\n\" +\n  \"MAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZW\\n\" +\n  \"ZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNyBWZXJpU2ln\\n\" +\n  \"biwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJp\\n\" +\n  \"U2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9y\\n\" +\n  \"aXR5IC0gRzQwHhcNMDcxMTA1MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCByjELMAkG\\n\" +\n  \"A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJp\\n\" +\n  \"U2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNyBWZXJpU2lnbiwg\\n\" +\n  \"SW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2ln\\n\" +\n  \"biBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5\\n\" +\n  \"IC0gRzQwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASnVnp8Utpkmw4tXNherJI9/gHm\\n\" +\n  \"GUo9FANL+mAnINmDiWn6VMaaGF5VKmTeBvaNSjutEDxlPZCIBIngMGGzrl0Bp3ve\\n\" +\n  \"fLK+ymVhAIau2o970ImtTR1ZmkGxvEeA3J5iw/mjgbIwga8wDwYDVR0TAQH/BAUw\\n\" +\n  \"AwEB/zAOBgNVHQ8BAf8EBAMCAQYwbQYIKwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJ\\n\" +\n  \"aW1hZ2UvZ2lmMCEwHzAHBgUrDgMCGgQUj+XTGoasjY5rw8+AatRIGCx7GS4wJRYj\\n\" +\n  \"aHR0cDovL2xvZ28udmVyaXNpZ24uY29tL3ZzbG9nby5naWYwHQYDVR0OBBYEFLMW\\n\" +\n  \"kf3upm7ktS5Jj4d4gYDs5bG1MAoGCCqGSM49BAMDA2gAMGUCMGYhDBgmYFo4e1ZC\\n\" +\n  \"4Kf8NoRRkSAsdk1DPcQdhCPQrNZ8NQbOzWm9kA3bbEhCHQ6qQgIxAJw9SDkjOVga\\n\" +\n  \"FRJZap7v1VmyHVIsmXHNxynfGyphe3HR3vPA5Q06Sqotp9iGKt0uEA==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-3G5\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIE0zCCA7ugAwIBAgIQGNrRniZ96LtKIVjNzGs7SjANBgkqhkiG9w0BAQUFADCB\\n\" +\n  \"yjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL\\n\" +\n  \"ExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJp\\n\" +\n  \"U2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxW\\n\" +\n  \"ZXJpU2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0\\n\" +\n  \"aG9yaXR5IC0gRzUwHhcNMDYxMTA4MDAwMDAwWhcNMzYwNzE2MjM1OTU5WjCByjEL\\n\" +\n  \"MAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZW\\n\" +\n  \"ZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJpU2ln\\n\" +\n  \"biwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJp\\n\" +\n  \"U2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9y\\n\" +\n  \"aXR5IC0gRzUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvJAgIKXo1\\n\" +\n  \"nmAMqudLO07cfLw8RRy7K+D+KQL5VwijZIUVJ/XxrcgxiV0i6CqqpkKzj/i5Vbex\\n\" +\n  \"t0uz/o9+B1fs70PbZmIVYc9gDaTY3vjgw2IIPVQT60nKWVSFJuUrjxuf6/WhkcIz\\n\" +\n  \"SdhDY2pSS9KP6HBRTdGJaXvHcPaz3BJ023tdS1bTlr8Vd6Gw9KIl8q8ckmcY5fQG\\n\" +\n  \"BO+QueQA5N06tRn/Arr0PO7gi+s3i+z016zy9vA9r911kTMZHRxAy3QkGSGT2RT+\\n\" +\n  \"rCpSx4/VBEnkjWNHiDxpg8v+R70rfk/Fla4OndTRQ8Bnc+MUCH7lP59zuDMKz10/\\n\" +\n  \"NIeWiu5T6CUVAgMBAAGjgbIwga8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8E\\n\" +\n  \"BAMCAQYwbQYIKwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJaW1hZ2UvZ2lmMCEwHzAH\\n\" +\n  \"BgUrDgMCGgQUj+XTGoasjY5rw8+AatRIGCx7GS4wJRYjaHR0cDovL2xvZ28udmVy\\n\" +\n  \"aXNpZ24uY29tL3ZzbG9nby5naWYwHQYDVR0OBBYEFH/TZafC3ey78DAJ80M5+gKv\\n\" +\n  \"MzEzMA0GCSqGSIb3DQEBBQUAA4IBAQCTJEowX2LP2BqYLz3q3JktvXf2pXkiOOzE\\n\" +\n  \"p6B4Eq1iDkVwZMXnl2YtmAl+X6/WzChl8gGqCBpH3vn5fJJaCGkgDdk+bW48DW7Y\\n\" +\n  \"5gaRQBi5+MHt39tBquCWIMnNZBU4gcmU7qKEKQsTb47bDN0lAtukixlE0kF6BWlK\\n\" +\n  \"WE9gyn6CagsCqiUXObXbf+eEZSqVir2G3l6BFoMtEMze/aiCKm0oHw0LxOXnGiYZ\\n\" +\n  \"4fQRbxC1lfznQgUy286dUV4otp6F01vvpX1FQHKOtw5rDgb7MzVIcbidJ4vEZV8N\\n\" +\n  \"hnacRHr2lVz2XTIIM6RUthg/aFzyQkqFOFSDX9HoLPKsEdao7WNq\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-4G3\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEGjCCAwICEQDsoKeLbnVqAc/EfMwvlF7XMA0GCSqGSIb3DQEBBQUAMIHKMQsw\\n\" +\n  \"CQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZl\\n\" +\n  \"cmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWdu\\n\" +\n  \"LCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlT\\n\" +\n  \"aWduIENsYXNzIDQgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3Jp\\n\" +\n  \"dHkgLSBHMzAeFw05OTEwMDEwMDAwMDBaFw0zNjA3MTYyMzU5NTlaMIHKMQswCQYD\\n\" +\n  \"VQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlT\\n\" +\n  \"aWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWduLCBJ\\n\" +\n  \"bmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlTaWdu\\n\" +\n  \"IENsYXNzIDQgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkg\\n\" +\n  \"LSBHMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAK3LpRFpxlmr8Y+1\\n\" +\n  \"GQ9Wzsy1HyDkniYlS+BzZYlZ3tCD5PUPtbut8XzoIfzk6AzufEUiGXaStBO3IFsJ\\n\" +\n  \"+mGuqPKljYXCKtbeZjbSmwL0qJJgfJxptI8kHtCGUvYynEFYHiK9zUVilQhu0Gbd\\n\" +\n  \"U6LM8BDcVHOLBKFGMzNcF0C5nk3T875Vg+ixiY5afJqWIpA7iCXy0lOIAgwLePLm\\n\" +\n  \"NxdLMEYH5IBtptiWLugs+BGzOA1mppvqySNb247i8xOOGlktqgLw7KSHZtzBP/XY\\n\" +\n  \"ufTsgsbSPZUd5cBPhMnZo0QoBmrXRazwa2rvTl/4EYIeOGM0ZlDUPpNz+jDDZq3/\\n\" +\n  \"ky2X7wMCAwEAATANBgkqhkiG9w0BAQUFAAOCAQEAj/ola09b5KROJ1WrIhVZPMq1\\n\" +\n  \"CtRK26vdoV9TxaBXOcLORyu+OshWv8LZJxA6sQU8wHcxuzrTBXttmhwwjIDLk5Mq\\n\" +\n  \"g6sFUYICABFna/OIYUdfA5PVWw3g8dShMjWFsjrbsIKr0csKvE+MW8VLADsfKoKm\\n\" +\n  \"fjaF3H48ZwC15DtS4KjrXRX5xm3wrR0OhbepmnMUWluPQSjA1egtTaRezarZ7c7c\\n\" +\n  \"2NU8Qh0XwRJdRTjDOPP8hS6DRkiy1yBfkjaP53kPmF6Z6PDQpLv1U70qzlmwr25/\\n\" +\n  \"bLvSHgCwIe34QWKCudiyxLtGUPMxxY8BqHTr9Xgn2uf3ZkPznoM+IKrDNWCRzg==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // VeriSign-PCA-universal\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEuTCCA6GgAwIBAgIQQBrEZCGzEyEDDrvkEhrFHTANBgkqhkiG9w0BAQsFADCB\\n\" +\n  \"vTELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQL\\n\" +\n  \"ExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwOCBWZXJp\\n\" +\n  \"U2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MTgwNgYDVQQDEy9W\\n\" +\n  \"ZXJpU2lnbiBVbml2ZXJzYWwgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAe\\n\" +\n  \"Fw0wODA0MDIwMDAwMDBaFw0zNzEyMDEyMzU5NTlaMIG9MQswCQYDVQQGEwJVUzEX\\n\" +\n  \"MBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRydXN0\\n\" +\n  \"IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAyMDA4IFZlcmlTaWduLCBJbmMuIC0gRm9y\\n\" +\n  \"IGF1dGhvcml6ZWQgdXNlIG9ubHkxODA2BgNVBAMTL1ZlcmlTaWduIFVuaXZlcnNh\\n\" +\n  \"bCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEF\\n\" +\n  \"AAOCAQ8AMIIBCgKCAQEAx2E3XrEBNNti1xWb/1hajCMj1mCOkdeQmIN65lgZOIzF\\n\" +\n  \"9uVkhbSicfvtvbnazU0AtMgtc6XHaXGVHzk8skQHnOgO+k1KxCHfKWGPMiJhgsWH\\n\" +\n  \"H26MfF8WIFFE0XBPV+rjHOPMee5Y2A7Cs0WTwCznmhcrewA3ekEzeOEz4vMQGn+H\\n\" +\n  \"LL729fdC4uW/h2KJXwBL38Xd5HVEMkE6HnFuacsLdUYI0crSK5XQz/u5QGtkjFdN\\n\" +\n  \"/BMReYTtXlT2NJ8IAfMQJQYXStrxHXpma5hgZqTZ79IugvHw7wnqRMkVauIDbjPT\\n\" +\n  \"rJ9VAMf2CGqUuV/c4DPxhGD5WycRtPwW8rtWaoAljQIDAQABo4GyMIGvMA8GA1Ud\\n\" +\n  \"EwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMG0GCCsGAQUFBwEMBGEwX6FdoFsw\\n\" +\n  \"WTBXMFUWCWltYWdlL2dpZjAhMB8wBwYFKw4DAhoEFI/l0xqGrI2Oa8PPgGrUSBgs\\n\" +\n  \"exkuMCUWI2h0dHA6Ly9sb2dvLnZlcmlzaWduLmNvbS92c2xvZ28uZ2lmMB0GA1Ud\\n\" +\n  \"DgQWBBS2d/ppSEefUxLVwuoHMnYH0ZcHGTANBgkqhkiG9w0BAQsFAAOCAQEASvj4\\n\" +\n  \"sAPmLGd75JR3Y8xuTPl9Dg3cyLk1uXBPY/ok+myDjEedO2Pzmvl2MpWRsXe8rJq+\\n\" +\n  \"seQxIcaBlVZaDrHC1LGmWazxY8u4TB1ZkErvkBYoH1quEPuBUDgMbMzxPcP1Y+Oz\\n\" +\n  \"4yHJJDnp/RVmRvQbEdBNc6N9Rvk97ahfYtTxP/jgdFcrGJ2BtMQo2pSXpXDrrB2+\\n\" +\n  \"BxHw1dvd5Yzw1TKwg+ZX4o+/vqGqvz0dtdQ46tewXDpPaj+PwGZsY6rp2aQW9IHR\\n\" +\n  \"lRQOfc2VNNnSj3BzgXucfr2YYdhFh5iQxeuGMMY1v/D/w1WIg0vvBZIGcfK4mJO3\\n\" +\n  \"7M2CYfE45k+XmCpajQ==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // gd-class2-root\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEADCCAuigAwIBAgIBADANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJVUzEh\\n\" +\n  \"MB8GA1UEChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBE\\n\" +\n  \"YWRkeSBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA0MDYyOTE3\\n\" +\n  \"MDYyMFoXDTM0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRo\\n\" +\n  \"ZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3Mg\\n\" +\n  \"MiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN\\n\" +\n  \"ADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XCA\\n\" +\n  \"PVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux6w\\n\" +\n  \"wdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLOtXi\\n\" +\n  \"EqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWoriMY\\n\" +\n  \"avx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZEewo+\\n\" +\n  \"YihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjgcAwgb0wHQYDVR0OBBYEFNLE\\n\" +\n  \"sNKR1EwRcbNhyz2h/t2oatTjMIGNBgNVHSMEgYUwgYKAFNLEsNKR1EwRcbNhyz2h\\n\" +\n  \"/t2oatTjoWekZTBjMQswCQYDVQQGEwJVUzEhMB8GA1UEChMYVGhlIEdvIERhZGR5\\n\" +\n  \"IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRkeSBDbGFzcyAyIENlcnRpZmlj\\n\" +\n  \"YXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQAD\\n\" +\n  \"ggEBADJL87LKPpH8EsahB4yOd6AzBhRckB4Y9wimPQoZ+YeAEW5p5JYXMP80kWNy\\n\" +\n  \"OO7MHAGjHZQopDH2esRU1/blMVgDoszOYtuURXO1v0XJJLXVggKtI3lpjbi2Tc7P\\n\" +\n  \"TMozI+gciKqdi0FuFskg5YmezTvacPd+mSYgFFQlq25zheabIZ0KbIIOqPjCDPoQ\\n\" +\n  \"HmyW74cNxA9hi63ugyuV+I6ShHI56yDqg+2DzZduCLzrTia2cyvk0/ZM/iZx4mER\\n\" +\n  \"dEr/VxqHD3VILs9RaRegAhJhldXRQLIQTO7ErBBDpqWeCtWVYpoNz4iCxTIM5Cuf\\n\" +\n  \"ReYNnyicsbkqWletNw+vHX/bvZ8=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // gdroot-g2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDxTCCAq2gAwIBAgIBADANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCVVMx\\n\" +\n  \"EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAYBgNVBAoT\\n\" +\n  \"EUdvRGFkZHkuY29tLCBJbmMuMTEwLwYDVQQDEyhHbyBEYWRkeSBSb290IENlcnRp\\n\" +\n  \"ZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIz\\n\" +\n  \"NTk1OVowgYMxCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQH\\n\" +\n  \"EwpTY290dHNkYWxlMRowGAYDVQQKExFHb0RhZGR5LmNvbSwgSW5jLjExMC8GA1UE\\n\" +\n  \"AxMoR28gRGFkZHkgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIw\\n\" +\n  \"DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9xYgjx+lk09xvJGKP3gElY6SKD\\n\" +\n  \"E6bFIEMBO4Tx5oVJnyfq9oQbTqC023CYxzIBsQU+B07u9PpPL1kwIuerGVZr4oAH\\n\" +\n  \"/PMWdYA5UXvl+TW2dE6pjYIT5LY/qQOD+qK+ihVqf94Lw7YZFAXK6sOoBJQ7Rnwy\\n\" +\n  \"DfMAZiLIjWltNowRGLfTshxgtDj6AozO091GB94KPutdfMh8+7ArU6SSYmlRJQVh\\n\" +\n  \"GkSBjCypQ5Yj36w6gZoOKcUcqeldHraenjAKOc7xiID7S13MMuyFYkMlNAJWJwGR\\n\" +\n  \"tDtwKj9useiciAF9n9T521NtYJ2/LOdYq7hfRvzOxBsDPAnrSTFcaUaz4EcCAwEA\\n\" +\n  \"AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE\\n\" +\n  \"FDqahQcQZyi27/a9BUFuIMGU2g/eMA0GCSqGSIb3DQEBCwUAA4IBAQCZ21151fmX\\n\" +\n  \"WWcDYfF+OwYxdS2hII5PZYe096acvNjpL9DbWu7PdIxztDhC2gV7+AJ1uP2lsdeu\\n\" +\n  \"9tfeE8tTEH6KRtGX+rcuKxGrkLAngPnon1rpN5+r5N9ss4UXnT3ZJE95kTXWXwTr\\n\" +\n  \"gIOrmgIttRD02JDHBHNA7XIloKmf7J6raBKZV8aPEjoJpL1E/QYVN8Gb5DKj7Tjo\\n\" +\n  \"2GTzLH4U/ALqn83/B2gX2yKQOC16jdFU8WnjXzPKej17CuPKf1855eJ1usV2GDPO\\n\" +\n  \"LPAvTK33sefOT6jEm0pUBsV/fdUID+Ic/n4XuKxe9tQWskMJDE32p2u0mYRlynqI\\n\" +\n  \"4uJEvlz36hz1\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // sf-class2-root\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEDzCCAvegAwIBAgIBADANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJVUzEl\\n\" +\n  \"MCMGA1UEChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMp\\n\" +\n  \"U3RhcmZpZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQw\\n\" +\n  \"NjI5MTczOTE2WhcNMzQwNjI5MTczOTE2WjBoMQswCQYDVQQGEwJVUzElMCMGA1UE\\n\" +\n  \"ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMpU3RhcmZp\\n\" +\n  \"ZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggEgMA0GCSqGSIb3\\n\" +\n  \"DQEBAQUAA4IBDQAwggEIAoIBAQC3Msj+6XGmBIWtDBFk385N78gDGIc/oav7PKaf\\n\" +\n  \"8MOh2tTYbitTkPskpD6E8J7oX+zlJ0T1KKY/e97gKvDIr1MvnsoFAZMej2YcOadN\\n\" +\n  \"+lq2cwQlZut3f+dZxkqZJRRU6ybH838Z1TBwj6+wRir/resp7defqgSHo9T5iaU0\\n\" +\n  \"X9tDkYI22WY8sbi5gv2cOj4QyDvvBmVmepsZGD3/cVE8MC5fvj13c7JdBmzDI1aa\\n\" +\n  \"K4UmkhynArPkPw2vCHmCuDY96pzTNbO8acr1zJ3o/WSNF4Azbl5KXZnJHoe0nRrA\\n\" +\n  \"1W4TNSNe35tfPe/W93bC6j67eA0cQmdrBNj41tpvi/JEoAGrAgEDo4HFMIHCMB0G\\n\" +\n  \"A1UdDgQWBBS/X7fRzt0fhvRbVazc1xDCDqmI5zCBkgYDVR0jBIGKMIGHgBS/X7fR\\n\" +\n  \"zt0fhvRbVazc1xDCDqmI56FspGowaDELMAkGA1UEBhMCVVMxJTAjBgNVBAoTHFN0\\n\" +\n  \"YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAsTKVN0YXJmaWVsZCBD\\n\" +\n  \"bGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8w\\n\" +\n  \"DQYJKoZIhvcNAQEFBQADggEBAAWdP4id0ckaVaGsafPzWdqbAYcaT1epoXkJKtv3\\n\" +\n  \"L7IezMdeatiDh6GX70k1PncGQVhiv45YuApnP+yz3SFmH8lU+nLMPUxA2IGvd56D\\n\" +\n  \"eruix/U0F47ZEUD0/CwqTRV/p2JdLiXTAAsgGh1o+Re49L2L7ShZ3U0WixeDyLJl\\n\" +\n  \"xy16paq8U4Zt3VekyvggQQto8PT7dL5WXXp59fkdheMtlb71cZBDzI0fmgAKhynp\\n\" +\n  \"VSJYACPq4xJDKVtHCN2MQWplBqjlIapBtJUhlbl90TSrE9atvNziPTnNvT51cKEY\\n\" +\n  \"WQPJIrSPnNVeKtelttQKbfi3QBFGmh95DmK/D5fs4C8fF5Q=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // sfroot-g2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIID3TCCAsWgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBjzELMAkGA1UEBhMCVVMx\\n\" +\n  \"EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\\n\" +\n  \"HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAMTKVN0YXJmaWVs\\n\" +\n  \"ZCBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAw\\n\" +\n  \"MFoXDTM3MTIzMTIzNTk1OVowgY8xCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6\\n\" +\n  \"b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFyZmllbGQgVGVj\\n\" +\n  \"aG5vbG9naWVzLCBJbmMuMTIwMAYDVQQDEylTdGFyZmllbGQgUm9vdCBDZXJ0aWZp\\n\" +\n  \"Y2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\\n\" +\n  \"ggEBAL3twQP89o/8ArFvW59I2Z154qK3A2FWGMNHttfKPTUuiUP3oWmb3ooa/RMg\\n\" +\n  \"nLRJdzIpVv257IzdIvpy3Cdhl+72WoTsbhm5iSzchFvVdPtrX8WJpRBSiUZV9Lh1\\n\" +\n  \"HOZ/5FSuS/hVclcCGfgXcVnrHigHdMWdSL5stPSksPNkN3mSwOxGXn/hbVNMYq/N\\n\" +\n  \"Hwtjuzqd+/x5AJhhdM8mgkBj87JyahkNmcrUDnXMN/uLicFZ8WJ/X7NfZTD4p7dN\\n\" +\n  \"dloedl40wOiWVpmKs/B/pM293DIxfJHP4F8R+GuqSVzRmZTRouNjWwl2tVZi4Ut0\\n\" +\n  \"HZbUJtQIBFnQmA4O5t78w+wfkPECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO\\n\" +\n  \"BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFHwMMh+n2TB/xH1oo2Kooc6rB1snMA0G\\n\" +\n  \"CSqGSIb3DQEBCwUAA4IBAQARWfolTwNvlJk7mh+ChTnUdgWUXuEok21iXQnCoKjU\\n\" +\n  \"sHU48TRqneSfioYmUeYs0cYtbpUgSpIB7LiKZ3sx4mcujJUDJi5DnUox9g61DLu3\\n\" +\n  \"4jd/IroAow57UvtruzvE03lRTs2Q9GcHGcg8RnoNAX3FWOdt5oUwF5okxBDgBPfg\\n\" +\n  \"8n/Uqgr/Qh037ZTlZFkSIHc40zI+OIF1lnP6aI+xy84fxez6nH7PfrHxBy22/L/K\\n\" +\n  \"pL/QlwVKvOoYKAKQvVR4CSFx09F9HdkWsKlhPdAKACL8x3vLCWRFCztAgfd9fDL1\\n\" +\n  \"mMpYjn0q7pBZc2T5NnReJaH1ZgUufzkVqSr7UIuOhWn0\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // sfsroot-g2\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx\\n\" +\n  \"EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\\n\" +\n  \"HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs\\n\" +\n  \"ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5\\n\" +\n  \"MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD\\n\" +\n  \"VQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy\\n\" +\n  \"ZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy\\n\" +\n  \"dmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI\\n\" +\n  \"hvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p\\n\" +\n  \"OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2\\n\" +\n  \"8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K\\n\" +\n  \"Ts9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe\\n\" +\n  \"hRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk\\n\" +\n  \"6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw\\n\" +\n  \"DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q\\n\" +\n  \"AdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI\\n\" +\n  \"bw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB\\n\" +\n  \"ve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z\\n\" +\n  \"qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd\\n\" +\n  \"iEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn\\n\" +\n  \"0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN\\n\" +\n  \"sSi6\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // sfsroot\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEfjCCA2agAwIBAgIBADANBgkqhkiG9w0BAQUFADCBzzELMAkGA1UEBhMCVVMx\\n\" +\n  \"EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\\n\" +\n  \"HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOjA4BgNVBAsTMWh0dHA6Ly9j\\n\" +\n  \"ZXJ0aWZpY2F0ZXMuc3RhcmZpZWxkdGVjaC5jb20vcmVwb3NpdG9yeS8xNjA0BgNV\\n\" +\n  \"BAMTLVN0YXJmaWVsZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0\\n\" +\n  \"eTAeFw0wODA2MDIwMDAwMDBaFw0yOTEyMzEyMzU5NTlaMIHPMQswCQYDVQQGEwJV\\n\" +\n  \"UzEQMA4GA1UECBMHQXJpem9uYTETMBEGA1UEBxMKU2NvdHRzZGFsZTElMCMGA1UE\\n\" +\n  \"ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjE6MDgGA1UECxMxaHR0cDov\\n\" +\n  \"L2NlcnRpZmljYXRlcy5zdGFyZmllbGR0ZWNoLmNvbS9yZXBvc2l0b3J5LzE2MDQG\\n\" +\n  \"A1UEAxMtU3RhcmZpZWxkIFNlcnZpY2VzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y\\n\" +\n  \"aXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8sxWKk3mFjdal+pt\\n\" +\n  \"NTjREJvbuNypBAmVMy4JxQB7GnhCj8j0BY7+0miDHk6ZzRfbRz5Q84nS59yY+wX4\\n\" +\n  \"qtZj9FRNwXEDsB8bdrMaNDBz8SgyYIP9tJzXttIiN3wZqjveExBpblwG02+j8mZa\\n\" +\n  \"dkJIr4DRVFk91LnU2+25qzmZ9O5iq+F4cnvYOI1AtszcEgBwQ4Vp2Bjjyldyn7Tf\\n\" +\n  \"P/wiqEJS9XdbmfBWLSZwFjYSwieeV6Z80CPxedyjk1goOD2frTZD7jf7+PlDrchW\\n\" +\n  \"8pQSXkLrc7gTDcum1Ya5qihqVAOhPw8p6wkA6D9eon8XPaEr+L7QdR2khOOrF2UG\\n\" +\n  \"UgCvsQIDAQABo2MwYTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAd\\n\" +\n  \"BgNVHQ4EFgQUtMZ/GkPMm3VdL8RL8ouYEOnxURAwHwYDVR0jBBgwFoAUtMZ/GkPM\\n\" +\n  \"m3VdL8RL8ouYEOnxURAwDQYJKoZIhvcNAQEFBQADggEBAKyAu8QlBQtYpOR+KX6v\\n\" +\n  \"vDvsLcBELvmR4NI7MieQLfaACVzCq2Uk2jgQRsRJ0v2aqyhId4jG6W/RR5HVNU8U\\n\" +\n  \"CahbQAcdfHFWy4lC1L9hwCL3Lt+r83JDi0DolOuwJtrRE9Or0DYtLjqVs3cuFTkY\\n\" +\n  \"DGm6qoDt8VNOM5toBOKgMC7X0V3UpmadhObnuzyJuzad/BepPVUrivubxEyE/9/S\\n\" +\n  \"vmkbdLCo9uqwnLIpdIFMaDqaf3MlOfUT4GaRadRXS7furUXgLMOI076USYkf/3DV\\n\" +\n  \"W205E7Ady5jmZ2MNY/b7w9dhcoOIP3B+U8meiVTWT399cbmu8WCLd2Ds+L/6aqOc\\n\" +\n  \"ASI=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // thawte_Premium_Server_CA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDNjCCAp+gAwIBAgIQNhIilsXjOKUgodJfTNcJVDANBgkqhkiG9w0BAQUFADCB\\n\" +\n  \"zjELMAkGA1UEBhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBxMJ\\n\" +\n  \"Q2FwZSBUb3duMR0wGwYDVQQKExRUaGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UE\\n\" +\n  \"CxMfQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjEhMB8GA1UEAxMYVGhh\\n\" +\n  \"d3RlIFByZW1pdW0gU2VydmVyIENBMSgwJgYJKoZIhvcNAQkBFhlwcmVtaXVtLXNl\\n\" +\n  \"cnZlckB0aGF3dGUuY29tMB4XDTk2MDgwMTAwMDAwMFoXDTIxMDEwMTIzNTk1OVow\\n\" +\n  \"gc4xCzAJBgNVBAYTAlpBMRUwEwYDVQQIEwxXZXN0ZXJuIENhcGUxEjAQBgNVBAcT\\n\" +\n  \"CUNhcGUgVG93bjEdMBsGA1UEChMUVGhhd3RlIENvbnN1bHRpbmcgY2MxKDAmBgNV\\n\" +\n  \"BAsTH0NlcnRpZmljYXRpb24gU2VydmljZXMgRGl2aXNpb24xITAfBgNVBAMTGFRo\\n\" +\n  \"YXd0ZSBQcmVtaXVtIFNlcnZlciBDQTEoMCYGCSqGSIb3DQEJARYZcHJlbWl1bS1z\\n\" +\n  \"ZXJ2ZXJAdGhhd3RlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA0jY2\\n\" +\n  \"aovXwlue2oFBYo847kkEVdbQ7xwblRZH7xhINTpS9CtqBo87L+pW46+GjZ4X9560\\n\" +\n  \"ZXUCTe/LCaIhUdib0GfQug2SBhRz1JPLlyoAnFxODLz6FVL88kRu2hFKbgifLy3j\\n\" +\n  \"+ao6hnO2RlNYyIkFvYMRuHM/qgeN9EJN50CdHDcCAwEAAaMTMBEwDwYDVR0TAQH/\\n\" +\n  \"BAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQBlkKyID1bZ5jA01CbH0FDxkt5r1DmI\\n\" +\n  \"CSLGpmODA/eZd9iy5Ri4XWPz1HP7bJyZePFLeH0ZJMMrAoT4vCLZiiLXoPxx7JGH\\n\" +\n  \"IPG47LHlVYCsPVLIOQ7C8MAFT9aCdYy9X9LcdpoFEsmvcsPcJX6kTY4XpeCHf+Ga\\n\" +\n  \"WuFg3GQjPEIuTQ==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // thawte_Primary_Root_CA-G2_ECC\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIICiDCCAg2gAwIBAgIQNfwmXNmET8k9Jj1Xm67XVjAKBggqhkjOPQQDAzCBhDEL\\n\" +\n  \"MAkGA1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjE4MDYGA1UECxMvKGMp\\n\" +\n  \"IDIwMDcgdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxJDAi\\n\" +\n  \"BgNVBAMTG3RoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EgLSBHMjAeFw0wNzExMDUwMDAw\\n\" +\n  \"MDBaFw0zODAxMTgyMzU5NTlaMIGEMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMdGhh\\n\" +\n  \"d3RlLCBJbmMuMTgwNgYDVQQLEy8oYykgMjAwNyB0aGF3dGUsIEluYy4gLSBGb3Ig\\n\" +\n  \"YXV0aG9yaXplZCB1c2Ugb25seTEkMCIGA1UEAxMbdGhhd3RlIFByaW1hcnkgUm9v\\n\" +\n  \"dCBDQSAtIEcyMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEotWcgnuVnfFSeIf+iha/\\n\" +\n  \"BebfowJPDQfGAFG6DAJSLSKkQjnE/o/qycG+1E3/n3qe4rF8mq2nhglzh9HnmuN6\\n\" +\n  \"papu+7qzcMBniKI11KOasf2twu8x+qi58/sIxpHR+ymVo0IwQDAPBgNVHRMBAf8E\\n\" +\n  \"BTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUmtgAMADna3+FGO6Lts6K\\n\" +\n  \"DPgR4bswCgYIKoZIzj0EAwMDaQAwZgIxAN344FdHW6fmCsO99YCKlzUNG4k8VIZ3\\n\" +\n  \"KMqh9HneteY4sPBlcIx/AlTCv//YoT7ZzwIxAMSNlPzcU9LcnXgWHxUzI1NS41ox\\n\" +\n  \"XZ3Krr0TKUQNJ1uo52icEvdYPy5yAlejj6EULg==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // thawte_Primary_Root_CA-G3_SHA256\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEKjCCAxKgAwIBAgIQYAGXt0an6rS0mtZLL/eQ+zANBgkqhkiG9w0BAQsFADCB\\n\" +\n  \"rjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMf\\n\" +\n  \"Q2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYGA1UECxMvKGMpIDIw\\n\" +\n  \"MDggdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxJDAiBgNV\\n\" +\n  \"BAMTG3RoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EgLSBHMzAeFw0wODA0MDIwMDAwMDBa\\n\" +\n  \"Fw0zNzEyMDEyMzU5NTlaMIGuMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMdGhhd3Rl\\n\" +\n  \"LCBJbmMuMSgwJgYDVQQLEx9DZXJ0aWZpY2F0aW9uIFNlcnZpY2VzIERpdmlzaW9u\\n\" +\n  \"MTgwNgYDVQQLEy8oYykgMjAwOCB0aGF3dGUsIEluYy4gLSBGb3IgYXV0aG9yaXpl\\n\" +\n  \"ZCB1c2Ugb25seTEkMCIGA1UEAxMbdGhhd3RlIFByaW1hcnkgUm9vdCBDQSAtIEcz\\n\" +\n  \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsr8nLPvb2FvdeHsbnndm\\n\" +\n  \"gcs+vHyu86YnmjSjaDFxODNi5PNxZnmxqWWjpYvVj2AtP0LMqmsywCPLLEHd5N/8\\n\" +\n  \"YZzic7IilRFDGF/Eth9XbAoFWCLINkw6fKXRz4aviKdEAhN0cXMKQlkC+BsUa0Lf\\n\" +\n  \"b1+6a4KinVvnSr0eAXLbS3ToO39/fR8EtCab4LRarEc9VbjXsCZSKAExQGbY2SS9\\n\" +\n  \"9irY7CFJXJv2eul/VTV+lmuNk5Mny5K76qxAwJ/C+IDPXfRa3M50hqY+bAtTyr2S\\n\" +\n  \"zhkGcuYMXDhpxwTWvGzOW/b3aJzcJRVIiKHpqfiYnODz1TEoYRFsZ5aNOZnLwkUk\\n\" +\n  \"OQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNV\\n\" +\n  \"HQ4EFgQUrWyqlGCc7eT/+j4KdCtjA/e2Wb8wDQYJKoZIhvcNAQELBQADggEBABpA\\n\" +\n  \"2JVlrAmSicY59BDlqQ5mU1143vokkbvnRFHfxhY0Cu9qRFHqKweKA3rD6z8KLFIW\\n\" +\n  \"oCtDuSWQP3CpMyVtRRooOyfPqsMpQhvfO0zAMzRbQYi/aytlryjvsvXDqmbOe1bu\\n\" +\n  \"t8jLZ8HJnBoYuMTDSQPxYA5QzUbF83d597YV4Djbxy8ooAw/dyZ02SUS2jHaGh7c\\n\" +\n  \"KUGRIjxpp7sC8rZcJwOJ9Abqm+RyguOhCcHpABnTPtRwa7pxpqpYrvS76Wy274fM\\n\" +\n  \"m7v/OeZWYdMKp8RcTGB7BXcmer/YB1IsYvdwY9k5vG8cwnncdimvzsUsZAReiDZu\\n\" +\n  \"MdRAGmI0Nj81Aa6sY6A=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // thawte_Primary_Root_CA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEIDCCAwigAwIBAgIQNE7VVyDV7exJ9C/ON9srbTANBgkqhkiG9w0BAQUFADCB\\n\" +\n  \"qTELMAkGA1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMf\\n\" +\n  \"Q2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYGA1UECxMvKGMpIDIw\\n\" +\n  \"MDYgdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxHzAdBgNV\\n\" +\n  \"BAMTFnRoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EwHhcNMDYxMTE3MDAwMDAwWhcNMzYw\\n\" +\n  \"NzE2MjM1OTU5WjCBqTELMAkGA1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5j\\n\" +\n  \"LjEoMCYGA1UECxMfQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYG\\n\" +\n  \"A1UECxMvKGMpIDIwMDYgdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNl\\n\" +\n  \"IG9ubHkxHzAdBgNVBAMTFnRoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EwggEiMA0GCSqG\\n\" +\n  \"SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCsoPD7gFnUnMekz52hWXMJEEUMDSxuaPFs\\n\" +\n  \"W0hoSVk3/AszGcJ3f8wQLZU0HObrTQmnHNK4yZc2AreJ1CRfBsDMRJSUjQJib+ta\\n\" +\n  \"3RGNKJpchJAQeg29dGYvajig4tVUROsdB58Hum/u6f1OCyn1PoSgAfGcq/gcfomk\\n\" +\n  \"6KHYcWUNo1F77rzSImANuVud37r8UVsLr5iy6S7pBOhih94ryNdOwUxkHt3Ph1i6\\n\" +\n  \"Sk/KaAcdHJ1KxtUvkcx8cXIcxcBn6zL9yZJclNqFwJu/U30rCfSMnZEfl2pSy94J\\n\" +\n  \"NqR32HuHUETVPm4pafs5SSYeCaWAe0At6+gnhcn+Yf1+5nyXHdWdAgMBAAGjQjBA\\n\" +\n  \"MA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBR7W0XP\\n\" +\n  \"r87Lev0xkhpqtvNG61dIUDANBgkqhkiG9w0BAQUFAAOCAQEAeRHAS7ORtvzw6WfU\\n\" +\n  \"DW5FvlXok9LOAz/t2iWwHVfLHjp2oEzsUHboZHIMpKnxuIvW1oeEuzLlQRHAd9mz\\n\" +\n  \"YJ3rG9XRbkREqaYB7FViHXe4XI5ISXycO1cRrK1zN44veFyQaEfZYGDm/Ac9IiAX\\n\" +\n  \"xPcW6cTYcvnIc3zfFi8VqT79aie2oetaupgf1eNNZAqdE8hhuvU5HIe6uL17In/2\\n\" +\n  \"/qxAeeWsEG89jxt5dovEN7MhGITlNgDrYyCZuen+MwS7QcjBAvlEYyCegc5C09Y/\\n\" +\n  \"LHbTY5xZ3Y+m4Q6gLkH3LpVHz7z9M/P2C2F+fpErgUfCJzDupxBdN49cOSvkBPB7\\n\" +\n  \"jVaMaA==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // thawte_Server_CA\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDIjCCAougAwIBAgIQNKT/9jCvTKU8MxdCoZRmdTANBgkqhkiG9w0BAQUFADCB\\n\" +\n  \"xDELMAkGA1UEBhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBxMJ\\n\" +\n  \"Q2FwZSBUb3duMR0wGwYDVQQKExRUaGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UE\\n\" +\n  \"CxMfQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjEZMBcGA1UEAxMQVGhh\\n\" +\n  \"d3RlIFNlcnZlciBDQTEmMCQGCSqGSIb3DQEJARYXc2VydmVyLWNlcnRzQHRoYXd0\\n\" +\n  \"ZS5jb20wHhcNOTYwODAxMDAwMDAwWhcNMjEwMTAxMjM1OTU5WjCBxDELMAkGA1UE\\n\" +\n  \"BhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBxMJQ2FwZSBUb3du\\n\" +\n  \"MR0wGwYDVQQKExRUaGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UECxMfQ2VydGlm\\n\" +\n  \"aWNhdGlvbiBTZXJ2aWNlcyBEaXZpc2lvbjEZMBcGA1UEAxMQVGhhd3RlIFNlcnZl\\n\" +\n  \"ciBDQTEmMCQGCSqGSIb3DQEJARYXc2VydmVyLWNlcnRzQHRoYXd0ZS5jb20wgZ8w\\n\" +\n  \"DQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBANOkUG7I/1Zr5s9dtuoMaHVHoqrC2oQl\\n\" +\n  \"/Kj0R1HahbUgdJSGHg91yekIYfUGbTBuFRkC6VLAYttNmZ7iagxEOM3+vuNkCXDF\\n\" +\n  \"/rFrKbYvScg71CcEJRCXL+eQbcAoQpnXTEPew/UhbVSfXcNY4cDk2VuwuNy0e982\\n\" +\n  \"OsK1ZiIS1ocNAgMBAAGjEzARMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEF\\n\" +\n  \"BQADgYEAvkBpQW/G28GnvwfAReTQtUMeTJUzNelewj4o9qgNUNX/4gwP/FACjq6R\\n\" +\n  \"ua00io2fJ3GqGcxL6ATK1BdrEhrWxl/WzV7/iXa/2EjYWb0IiokdV81FHlK6EpqE\\n\" +\n  \"+hiJX+j5MDVqAWC5mYCDhQpu2vTJj15zLTFKY6B08h+LItIpPus=\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // trustcenter_TC_Universal_CA_III\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIID4TCCAsmgAwIBAgIOYyUAAQACFI0zFQLkbPQwDQYJKoZIhvcNAQEFBQAwezEL\\n\" +\n  \"MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxJDAiBgNV\\n\" +\n  \"BAsTG1RDIFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQTEoMCYGA1UEAxMfVEMgVHJ1\\n\" +\n  \"c3RDZW50ZXIgVW5pdmVyc2FsIENBIElJSTAeFw0wOTA5MDkwODE1MjdaFw0yOTEy\\n\" +\n  \"MzEyMzU5NTlaMHsxCzAJBgNVBAYTAkRFMRwwGgYDVQQKExNUQyBUcnVzdENlbnRl\\n\" +\n  \"ciBHbWJIMSQwIgYDVQQLExtUQyBUcnVzdENlbnRlciBVbml2ZXJzYWwgQ0ExKDAm\\n\" +\n  \"BgNVBAMTH1RDIFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQSBJSUkwggEiMA0GCSqG\\n\" +\n  \"SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDC2pxisLlxErALyBpXsq6DFJmzNEubkKLF\\n\" +\n  \"5+cvAqBNLaT6hdqbJYUtQCggbergvbFIgyIpRJ9Og+41URNzdNW88jBmlFPAQDYv\\n\" +\n  \"DIRlzg9uwliT6CwLOunBjvvya8o84pxOjuT5fdMnnxvVZ3iHLX8LR7PH6MlIfK8v\\n\" +\n  \"zArZQe+f/prhsq75U7Xl6UafYOPfjdN/+5Z+s7Vy+EutCHnNaYlAJ/Uqwa1D7KRT\\n\" +\n  \"yGG299J5KmcYdkhtWyUB0SbFt1dpIxVbYYqt8Bst2a9c8SaQaanVDED1M4BDj5yj\\n\" +\n  \"dipFtK+/fz6HP3bFzSreIMUWWMv5G/UPyw0RUmS40nZid4PxWJ//AgMBAAGjYzBh\\n\" +\n  \"MB8GA1UdIwQYMBaAFFbn4VslQ4Dg9ozhcbyO5YAvxEjiMA8GA1UdEwEB/wQFMAMB\\n\" +\n  \"Af8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRW5+FbJUOA4PaM4XG8juWAL8RI\\n\" +\n  \"4jANBgkqhkiG9w0BAQUFAAOCAQEAg8ev6n9NCjw5sWi+e22JLumzCecYV42Fmhfz\\n\" +\n  \"dkJQEw/HkG8zrcVJYCtsSVgZ1OK+t7+rSbyUyKu+KGwWaODIl0YgoGhnYIg5IFHY\\n\" +\n  \"aAERzqf2EQf27OysGh+yZm5WZ2B6dF7AbZc2rrUNXWZzwCUyRdhKBgePxLcHsU0G\\n\" +\n  \"DeGl6/R1yrqc0L2z0zIkTO5+4nYES0lT2PLpVDP85XEfPRRclkvxOvIAu2y0+pZV\\n\" +\n  \"CIgJwcyRGSmwIC3/yzikQOEXvnlhgP8HA4ZMTnsGnxGGjYnuJ8Tb4rwZjgvDwxPH\\n\" +\n  \"LQNjO9Po5KIqwoIIlBZU8O8fJ5AluA0OKBtHd0e9HKgl8ZS0Zg==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // trustcenter_Universal_CA-I\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIID3TCCAsWgAwIBAgIOHaIAAQAC7LdggHiNtgYwDQYJKoZIhvcNAQEFBQAweTEL\\n\" +\n  \"MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxJDAiBgNV\\n\" +\n  \"BAsTG1RDIFRydXN0Q2VudGVyIFVuaXZlcnNhbCBDQTEmMCQGA1UEAxMdVEMgVHJ1\\n\" +\n  \"c3RDZW50ZXIgVW5pdmVyc2FsIENBIEkwHhcNMDYwMzIyMTU1NDI4WhcNMjUxMjMx\\n\" +\n  \"MjI1OTU5WjB5MQswCQYDVQQGEwJERTEcMBoGA1UEChMTVEMgVHJ1c3RDZW50ZXIg\\n\" +\n  \"R21iSDEkMCIGA1UECxMbVEMgVHJ1c3RDZW50ZXIgVW5pdmVyc2FsIENBMSYwJAYD\\n\" +\n  \"VQQDEx1UQyBUcnVzdENlbnRlciBVbml2ZXJzYWwgQ0EgSTCCASIwDQYJKoZIhvcN\\n\" +\n  \"AQEBBQADggEPADCCAQoCggEBAKR3I5ZEr5D0MacQ9CaHnPM42Q9e3s9B6DGtxnSR\\n\" +\n  \"JJZ4Hgmgm5qVSkr1YnwCqMqs+1oEdjneX/H5s7/zA1hV0qq34wQi0fiU2iIIAI3T\\n\" +\n  \"fCZdzHd55yx4Oagmcw6iXSVphU9VDprvxrlE4Vc93x9UIuVvZaozhDrzznq+VZeu\\n\" +\n  \"jRIPFDPiUHDDSYcTvFHe15gSWu86gzOSBnWLknwSaHtwag+1m7Z3W0hZneTvWq3z\\n\" +\n  \"wZ7U10VOylY0Ibw+F1tvdwxIAUMpsN0/lm7mlaoMwCC2/T42J5zjXM9OgdwZu5GQ\\n\" +\n  \"fezmlwQek8wiSdeXhrYTCjxDI3d+8NzmzSQfO4ObNDqDNOMCAwEAAaNjMGEwHwYD\\n\" +\n  \"VR0jBBgwFoAUkqR1LKSevoFE63n8isWVpesQdXMwDwYDVR0TAQH/BAUwAwEB/zAO\\n\" +\n  \"BgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFJKkdSyknr6BROt5/IrFlaXrEHVzMA0G\\n\" +\n  \"CSqGSIb3DQEBBQUAA4IBAQAo0uCG1eb4e/CX3CJrO5UUVg8RMKWaTzqwOuAGy2X1\\n\" +\n  \"7caXJ/4l8lfmXpWMPmRgFVp/Lw0BxbFg/UU1z/CyvwbZ71q+s2IhtNerNXxTPqYn\\n\" +\n  \"8aEt2hojnczd7Dwtnic0XQ/CNnm8yUpiLe1r2X1BQ3y2qsrtYbE3ghUJGooWMNjs\\n\" +\n  \"ydZHcnhLEEYUjl8Or+zHL6sQ17bxbuyGssLoDZJz3KL0Dzq/YSMQiZxIQG5wALPT\\n\" +\n  \"ujdEWBF6AmqI8Dc08BnprNRlc/ZpjGSUOnmFKbAWKwyCPwacx/0QK54PLLae4xW/\\n\" +\n  \"2TYcuiUaUj0a7CIMHOCkoj3w6DnPgcB77V0fb8XQC9eY\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // trustcenter_Universal_CA-II\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"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\\n\" +\n  \"NvAsGnE8EXbfXRo+VGN4a2V+Hw==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // trustcenter_class_2_ii\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEqjCCA5KgAwIBAgIOLmoAAQACH9dSISwRXDswDQYJKoZIhvcNAQEFBQAwdjEL\\n\" +\n  \"MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxIjAgBgNV\\n\" +\n  \"BAsTGVRDIFRydXN0Q2VudGVyIENsYXNzIDIgQ0ExJTAjBgNVBAMTHFRDIFRydXN0\\n\" +\n  \"Q2VudGVyIENsYXNzIDIgQ0EgSUkwHhcNMDYwMTEyMTQzODQzWhcNMjUxMjMxMjI1\\n\" +\n  \"OTU5WjB2MQswCQYDVQQGEwJERTEcMBoGA1UEChMTVEMgVHJ1c3RDZW50ZXIgR21i\\n\" +\n  \"SDEiMCAGA1UECxMZVEMgVHJ1c3RDZW50ZXIgQ2xhc3MgMiBDQTElMCMGA1UEAxMc\\n\" +\n  \"VEMgVHJ1c3RDZW50ZXIgQ2xhc3MgMiBDQSBJSTCCASIwDQYJKoZIhvcNAQEBBQAD\\n\" +\n  \"ggEPADCCAQoCggEBAKuAh5uO8MN8h9foJIIRszzdQ2Lu+MNF2ujhoF/RKrLqk2jf\\n\" +\n  \"tMjWQ+nEdVl//OEd+DFwIxuInie5e/060smp6RQvkL4DUsFJzfb95AhmC1eKokKg\\n\" +\n  \"uNV/aVyQMrKXDcpK3EY+AlWJU+MaWss2xgdW94zPEfRMuzBwBJWl9jmM/XOBCH2J\\n\" +\n  \"XjIeIqkiRUuwZi4wzJ9l/fzLganx4Duvo4bRierERXlQXa7pIXSSTYtZgo+U4+lK\\n\" +\n  \"8edJsBTj9WLL1XK9H7nSn6DNqPoByNkN39r8R52zyFTfSUrxIan+GE7uSNQZu+99\\n\" +\n  \"5OKdy1u2bv/jzVrndIIFuoAlOMvkaZ6vQaoahPUCAwEAAaOCATQwggEwMA8GA1Ud\\n\" +\n  \"EwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBTjq1RMgKHbVkO3\\n\" +\n  \"kUrL84J6E1wIqzCB7QYDVR0fBIHlMIHiMIHfoIHcoIHZhjVodHRwOi8vd3d3LnRy\\n\" +\n  \"dXN0Y2VudGVyLmRlL2NybC92Mi90Y19jbGFzc18yX2NhX0lJLmNybIaBn2xkYXA6\\n\" +\n  \"Ly93d3cudHJ1c3RjZW50ZXIuZGUvQ049VEMlMjBUcnVzdENlbnRlciUyMENsYXNz\\n\" +\n  \"JTIwMiUyMENBJTIwSUksTz1UQyUyMFRydXN0Q2VudGVyJTIwR21iSCxPVT1yb290\\n\" +\n  \"Y2VydHMsREM9dHJ1c3RjZW50ZXIsREM9ZGU/Y2VydGlmaWNhdGVSZXZvY2F0aW9u\\n\" +\n  \"TGlzdD9iYXNlPzANBgkqhkiG9w0BAQUFAAOCAQEAjNfffu4bgBCzg/XbEeprS6iS\\n\" +\n  \"GNn3Bzn1LL4GdXpoUxUc6krtXvwjshOg0wn/9vYua0Fxec3ibf2uWWuFHbhOIprt\\n\" +\n  \"ZjluS5TmVfwLG4t3wVMTZonZKNaL80VKY7f9ewthXbhtvsPcW3nS7Yblok2+XnR8\\n\" +\n  \"au0WOB9/WIFaGusyiC2y8zl3gK9etmF1KdsjTYjKUCjLhdLTEKJZbtOTVAB6okaV\\n\" +\n  \"hgWcqRmY5TFyDADiZ9lA4CQze28suVyrZZ0srHbqNZn1l7kPJOzHdiEoZa5X6AeI\\n\" +\n  \"dUpWoNIFOqTmjZKILPPy4cHGYdtBxceb9w4aUUXCYWvcZCcXjFq32nQozZfkvQ==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // trustcenter_class_3_ii\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIEqjCCA5KgAwIBAgIOSkcAAQAC5aBd1j8AUb8wDQYJKoZIhvcNAQEFBQAwdjEL\\n\" +\n  \"MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxIjAgBgNV\\n\" +\n  \"BAsTGVRDIFRydXN0Q2VudGVyIENsYXNzIDMgQ0ExJTAjBgNVBAMTHFRDIFRydXN0\\n\" +\n  \"Q2VudGVyIENsYXNzIDMgQ0EgSUkwHhcNMDYwMTEyMTQ0MTU3WhcNMjUxMjMxMjI1\\n\" +\n  \"OTU5WjB2MQswCQYDVQQGEwJERTEcMBoGA1UEChMTVEMgVHJ1c3RDZW50ZXIgR21i\\n\" +\n  \"SDEiMCAGA1UECxMZVEMgVHJ1c3RDZW50ZXIgQ2xhc3MgMyBDQTElMCMGA1UEAxMc\\n\" +\n  \"VEMgVHJ1c3RDZW50ZXIgQ2xhc3MgMyBDQSBJSTCCASIwDQYJKoZIhvcNAQEBBQAD\\n\" +\n  \"ggEPADCCAQoCggEBALTgu1G7OVyLBMVMeRwjhjEQY0NVJz/GRcekPewJDRoeIMJW\\n\" +\n  \"Ht4bNwcwIi9v8Qbxq63WyKthoy9DxLCyLfzDlml7forkzMA5EpBCYMnMNWju2l+Q\\n\" +\n  \"Vl/NHE1bWEnrDgFPZPosPIlY2C8u4rBo6SI7dYnWRBpl8huXJh0obazovVkdKyT2\\n\" +\n  \"1oQDZogkAHhg8fir/gKya/si+zXmFtGt9i4S5Po1auUZuV3bOx4a+9P/FRQI2Alq\\n\" +\n  \"ukWdFHlgfa9Aigdzs5OW03Q0jTo3Kd5c7PXuLjHCINy+8U9/I1LZW+Jk2ZyqBwi1\\n\" +\n  \"Rb3R0DHBq1SfqdLDYmAD8bs5SpJKPQq5ncWg/jcCAwEAAaOCATQwggEwMA8GA1Ud\\n\" +\n  \"EwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBTUovyfs8PYA9NX\\n\" +\n  \"XAek0CSnwPIA1DCB7QYDVR0fBIHlMIHiMIHfoIHcoIHZhjVodHRwOi8vd3d3LnRy\\n\" +\n  \"dXN0Y2VudGVyLmRlL2NybC92Mi90Y19jbGFzc18zX2NhX0lJLmNybIaBn2xkYXA6\\n\" +\n  \"Ly93d3cudHJ1c3RjZW50ZXIuZGUvQ049VEMlMjBUcnVzdENlbnRlciUyMENsYXNz\\n\" +\n  \"JTIwMyUyMENBJTIwSUksTz1UQyUyMFRydXN0Q2VudGVyJTIwR21iSCxPVT1yb290\\n\" +\n  \"Y2VydHMsREM9dHJ1c3RjZW50ZXIsREM9ZGU/Y2VydGlmaWNhdGVSZXZvY2F0aW9u\\n\" +\n  \"TGlzdD9iYXNlPzANBgkqhkiG9w0BAQUFAAOCAQEANmDkcPcGIEPZIxpC8vijsrlN\\n\" +\n  \"irTzwppVMXzEO2eatN9NDoqTSheLG43KieHPOh6sHfGcMrSOWXaiQYUlN6AT0PV8\\n\" +\n  \"TtXqluJucsG7Kv5sbviRmEb8yRtXW+rIGjs/sFGYPAfaLFkB2otE6OF0/ado3VS6\\n\" +\n  \"g0bsyEa1+K+XwDsJHI/OcpY9M1ZwvJbL2NV9IJqDnxrcOfHFcqMRA/07QlIp2+gB\\n\" +\n  \"95tejNaNhk4Z+rwcvsUhpYeeeC422wlxo3I0+GzjBgnyXlal092Y+tTmBvTwtiBj\\n\" +\n  \"S+opvaqCZh77gaqnN60TGOaSw4HBM7uIHqHn4rS9MWwOUT1v+5ZWgOI2F9Hc5A==\\n\" +\n  \"-----END CERTIFICATE-----\\n\",\n\n  // trustcenter_class_4_ii\n  \"-----BEGIN CERTIFICATE-----\\n\" +\n  \"MIIDtjCCAp6gAwIBAgIOBcAAAQACQdAGCk3OdRAwDQYJKoZIhvcNAQEFBQAwdjEL\\n\" +\n  \"MAkGA1UEBhMCREUxHDAaBgNVBAoTE1RDIFRydXN0Q2VudGVyIEdtYkgxIjAgBgNV\\n\" +\n  \"BAsTGVRDIFRydXN0Q2VudGVyIENsYXNzIDQgQ0ExJTAjBgNVBAMTHFRDIFRydXN0\\n\" +\n  \"Q2VudGVyIENsYXNzIDQgQ0EgSUkwHhcNMDYwMzIzMTQxMDIzWhcNMjUxMjMxMjI1\\n\" +\n  \"OTU5WjB2MQswCQYDVQQGEwJERTEcMBoGA1UEChMTVEMgVHJ1c3RDZW50ZXIgR21i\\n\" +\n  \"SDEiMCAGA1UECxMZVEMgVHJ1c3RDZW50ZXIgQ2xhc3MgNCBDQTElMCMGA1UEAxMc\\n\" +\n  \"VEMgVHJ1c3RDZW50ZXIgQ2xhc3MgNCBDQSBJSTCCASIwDQYJKoZIhvcNAQEBBQAD\\n\" +\n  \"ggEPADCCAQoCggEBALXNTJytrlG7fEjFDSmGehSt2VA9CXIgDRS2Y8b+WJ7gIV7z\\n\" +\n  \"jyIZ3E6RIM1viCmis8GsKnK6i1S4QF/yqvhDhsIwXMynXX/GCEnkDjkvjhjWkd0j\\n\" +\n  \"FnmA22xIHbzB3ygQY9GB493fL3l1oht48pQB5hBiecugfQLANIJ7x8CtHUzXapZ2\\n\" +\n  \"W78mhEj9h/aECqqSB5lIPGG8ToVYx5ct/YFKocabEvVCUNFkPologiJw3fX64yhC\\n\" +\n  \"L04y87OjNopq1mJcrPoBbbTgci6VaLTxkwzGioLSHVPqfOA/QrcSWrjN2qUGZ8uh\\n\" +\n  \"d32llvCSHmcOHUJG5vnt+0dTf1cERh9GX8eu4I8CAwEAAaNCMEAwDwYDVR0TAQH/\\n\" +\n  \"BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFB/quz4lGwa9pd1iBX7G\\n\" +\n  \"TFq/6A9DMA0GCSqGSIb3DQEBBQUAA4IBAQBYpCubTPfkpJKknGWYGWIi/HIy6QRd\\n\" +\n  \"xMRwLVpG3kxHiiW5ot3u6hKvSI3vK2fbO8w0mCr3CEf/Iq978fTr4jgCMxh1KBue\\n\" +\n  \"dmWsiANy8jhHHYz1nwqIUxAUu4DlDLNdjRfuHhkcho0UZ3iMksseIUn3f9MYv5x5\\n\" +\n  \"+F0IebWqak2SNmy8eesOPXmK2PajVnBd3ttPedJ60pVchidlvqDTB4FAVd0Qy+BL\\n\" +\n  \"iILAkH0457+W4Ze6mqtCD9Of2J4VMxHL94J59bXAQVaS4d9VA61Iz9PyLrHHLVZM\\n\" +\n  \"ZHQqMc7cdalUR6SnQnIJ5+ECpkeyBM1CE+FhDOB4OiIgohxgQoaH96Xm\\n\" +\n  \"-----END CERTIFICATE-----\\n\"\n]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/collector/ssl/certificates.js\n// module id = 165\n// module chunks = 0","'use strict'\n\nvar copy = require('../util/copy')\nvar urltils = require('../util/urltils')\nvar logger = require('../logger').child({component: 'error_tracer'})\nvar NAMES = require('../metrics/names')\nvar errorsModule = require('./index')\nvar Reservoir = require('../reservoir.js')\nvar WeakMap = global.WeakMap\n\n\nvar createError = errorsModule.createError\nvar createEvent = errorsModule.createEvent\n\nmodule.exports = ErrorAggregator\n\n/*\n *\n * CONSTANTS\n *\n */\nvar MAX_ERRORS = 20\n\n/**\n * ErrorAggregator is responsible for collecting JS errors and errored-out HTTP\n * transactions, and for converting them to error traces and error events expected by\n * the collector.\n */\nfunction ErrorAggregator(config) {\n  this.config = config\n  this.errorCount = 0\n  this.webTransactionErrorCount = 0\n  this.otherTransactionErrorCount = 0\n  this.errors = []\n  if (WeakMap) {\n    this.seenObjects = new WeakMap()\n  } else {\n    this.seenObjects = []\n  }\n  this.seenStrings = {}\n\n  // reservoir used for error events\n  this.events = new Reservoir(this.config.error_collector.max_event_samples_stored)\n}\n\n/**\n * Every finished transaction goes through this handler, so do as\n * little as possible.\n */\nErrorAggregator.prototype.onTransactionFinished = onTransactionFinished\n\nfunction onTransactionFinished(transaction, metrics) {\n  if (!transaction) throw new Error(\"Error collector got a blank transaction.\")\n  if (!metrics) throw new Error(\"Error collector requires metrics to count errors.\")\n  if (transaction.ignore) return\n\n  // collect user errors even if status code is ignored\n  var collectedErrors = 0\n  var exception, i\n  if (transaction.userErrors.length > 0) {\n    for (i = 0; i < transaction.userErrors.length; i++) {\n      exception = transaction.userErrors[i]\n      if (this._collect(transaction, exception[0], exception[1], exception[2])) {\n        collectedErrors++\n      }\n    }\n  }\n\n  var hasExceptions = transaction.exceptions.length > 0\n  var isErroredTransaction = urltils.isError(this.config, transaction.statusCode)\n  var isIgnoredErrorStatusCode = urltils.isIgnoredError(this.config,\n      transaction.statusCode)\n\n  // collect other exceptions only if status code is not ignored\n  if (hasExceptions && !isIgnoredErrorStatusCode) {\n    for (i = 0; i < transaction.exceptions.length; i++) {\n      exception = transaction.exceptions[i]\n      if (this._collect(transaction, exception[0], exception[1], exception[2])) {\n        collectedErrors++\n      }\n    }\n  } else if (isErroredTransaction) {\n    if (this._collect(transaction)) {\n      collectedErrors++\n    }\n  }\n\n  // the metric should be incremented only if the error was actually collected\n  if (collectedErrors > 0) {\n    var count = metrics.getOrCreateMetric(NAMES.ERRORS.PREFIX + transaction.name)\n    count.incrementCallCount(collectedErrors)\n  }\n}\n\n/**\n * This function collects the error right away when transaction is not supplied.\n * Otherwise it delays collecting the error until the transaction ends.\n *\n * NOTE: this interface is unofficial and may change in future.\n *\n * @param {Transaction} transaction      Transaction associated with the error\n *                                       (optional).\n * @param {Error}       exception        The error to be traced.\n * @param {object}      customParameters Any custom parameters associated with\n *                                       the request (optional).\n */\nErrorAggregator.prototype.add = function add(transaction, exception, customParameters) {\n  if (!exception) return\n\n  var timestamp = Date.now()\n\n  if (transaction) {\n    transaction.addException(exception, customParameters, timestamp)\n  } else {\n    this._collect(transaction, exception, customParameters, timestamp)\n  }\n}\n\n/**\n * This function is used to collect errors specifically added using the noticeError() API.\n * Similarly to add(), it collects the error right away when transaction is not supplied.\n * Otherwise it delays collecting the error until the transaction ends.\n * The reason for separating the API errors from other exceptions is that different ignore\n * rules apply to them.\n *\n * NOTE: this interface is unofficial and may change in future.\n *\n * @param {Transaction} transaction      Transaction associated with the error\n *                                       (optional).\n * @param {Error}       exception        The error to be traced.\n * @param {object}      customParameters Any custom parameters associated with\n *                                       the request (optional).\n */\nErrorAggregator.prototype.addUserError = function addUserError(transaction, exception,\n    customParameters) {\n  if (!exception) return\n\n  var timestamp = Date.now()\n\n  if (transaction) {\n    transaction.addUserError(exception, customParameters, timestamp)\n  } else {\n    this._collect(transaction, exception, customParameters, timestamp)\n  }\n}\n\n/**\n *\n * This function takes an exception and determines whether the exception\n * has been seen before by this aggregator.  This function mutates the\n * book keeping structures to reflect the exception has been seen.\n *\n * @param {Error} exception  The error to be checked.\n *\n */\n\nErrorAggregator.prototype.haveSeen = function haveSeen(exception) {\n  if (typeof exception === 'object') {\n    if (WeakMap) {\n      if (this.seenObjects.has(exception)) {\n        return true\n      }\n\n      this.seenObjects.set(exception, true)\n    } else {\n      if (this.seenObjects.indexOf(exception) !== -1) {\n        return true\n      }\n\n      this.seenObjects.push(exception)\n    }\n  } else { // typeof exception !== 'object'\n    if (this.seenStrings[exception]) {\n      return true\n    }\n\n    this.seenStrings[exception] = true\n  }\n  return false\n}\n\n/**\n * Collects the error and also creates the error event.\n * This function uses an array of seen exceptions to ensure errors don't get\n * double-counted. It can also be used as an unofficial means of marking that\n * user errors shouldn't be traced.\n *\n * For an error to be traced, at least one of the transaction or the error\n * must be present.\n *\n * NOTE: this interface is unofficial and may change in future.\n *\n * @param {Transaction} transaction      Transaction associated with the error\n *                                       (optional).\n * @param {Error}       exception        The error to be traced (optional).\n * @param {object}      customParameters Any custom parameters associated with\n *                                       the request (optional).\n * @returns {bool}  True if the error was collected.\n */\nErrorAggregator.prototype._collect = _collect\n\nfunction _collect(transaction, exception, customParameters, timestamp) {\n  if (exception) {\n    if (this.haveSeen(exception)) {\n      return\n    }\n\n    if (typeof exception !== 'string' && !exception.message && !exception.stack) {\n      logger.trace(exception,\n        \"Got error that is not an instance of Error or string.\")\n      exception = null\n    }\n  }\n\n  if (!exception) {\n    if (!transaction) return\n    if (!transaction.statusCode) return\n    if (transaction.error) return\n  }\n\n  this.errorCount++\n\n  if (transaction) {\n    if (transaction.isWeb()) {\n      this.webTransactionErrorCount++\n    } else {\n      this.otherTransactionErrorCount++\n    }\n  }\n\n  // allow enabling & disabling the error tracer at runtime\n  // TODO: it would be better to check config in the public add() to prevents collecting\n  // errors on the transaction unnecessarily\n  if (!this.config.collect_errors ||\n      !this.config.error_collector || !this.config.error_collector.enabled) return\n\n  if (exception) {\n    logger.trace(exception, \"Got exception to trace:\")\n  }\n\n  var error = createError(transaction, exception, customParameters, this.config)\n\n  if (this.errors.length < MAX_ERRORS) {\n    logger.debug({error: error}, \"Error to be sent to collector:\")\n\n    // XXX: 2016-05-24 Remove this when APM UI is updated to use correct request_uri\n    //\n    // For right now, when this flag is enabled, the request_uri will be added\n    // to the error data. This will result in duplicated data being displayed on\n    // APM which is a no-go, so we need to remove it here. However, we want the\n    // data to still be there for error events metrics, so we need to perform a\n    // deep copy and only remove it from this data.\n    //\n    // In order to save cycles, we perform a smart deep copy in the form of a\n    // series of shallow copies down just the path that needs to change.\n    if (this.config.feature_flag.send_request_uri_attribute) {\n      var err = []\n      err.push.apply(err, error)\n      err[4] = copy.shallow(err[4])\n      err[4].agentAttributes = copy.shallow(err[4].agentAttributes)\n      delete err[4].agentAttributes.request_uri\n      this.errors.push(err)\n    } else {\n      this.errors.push(error)\n    }\n  } else {\n    logger.debug(\"Already have %d errors to send to collector, not keeping.\",\n                 MAX_ERRORS)\n  }\n\n  // add error event\n  if (this.config.error_collector.capture_events === true) {\n    this.events.add(createEvent(transaction, error, timestamp))\n  }\n  return true\n}\n\n/**\n * Returns collected errors.\n */\nErrorAggregator.prototype.getErrors = function getErrors() {\n  return this.errors\n}\n\n/**\n * Returns error events based on seen errors.\n */\nErrorAggregator.prototype.getEvents = function getEvents() {\n  return this.events.toArray()\n}\n\n/**\n * Returns maximum number of events that are collected per a harvest cycle.\n */\nErrorAggregator.prototype.getEventsLimit = function getEventsLimit() {\n  return this.events.limit\n}\n\n/**\n * Returns number of events that have been seen since the last harvest cycle.\n */\nErrorAggregator.prototype.getEventsSeen = function getEventsSeen() {\n  return this.events.seen\n}\n\n/**\n * Returns total number of collected errors.\n */\nErrorAggregator.prototype.getTotalErrorCount = function getTotalErrorCount() {\n  return this.errorCount\n}\n\n/**\n * Returns total number of errors collected during web transactions.\n */\nErrorAggregator.prototype.getWebTransactionsErrorCount =\n    function getWebTransactionsErrorCount() {\n  return this.webTransactionErrorCount\n}\n\n/**\n * Returns total number of errors collected during background transactions.\n */\nErrorAggregator.prototype.getBackgroundTransactionsErrorCount =\n    function getOtherTransactionsErrorCount() {\n  return this.otherTransactionErrorCount\n}\n\n/**\n * If the connection to the collector fails, retain as many as will fit without\n * overflowing the current error list.\n *\n * @param array errors Previously harvested errors.\n */\nErrorAggregator.prototype.merge = function merge(errors) {\n  if (!errors) return\n\n  var len = Math.min(errors.length, MAX_ERRORS - this.errors.length)\n  logger.warn(\"Merging %s (of %s) errors for next delivery.\", len, errors.length)\n  for (var i = 0; i < len; i++) this.errors.push(errors[i])\n}\n\nErrorAggregator.prototype.mergeEvents = function mergeEvents(events) {\n  this.events.merge(events)\n}\n\nErrorAggregator.prototype.clearEvents = function clearEvents() {\n  this.events = new Reservoir(this.config.error_collector.max_event_samples_stored)\n}\n\nErrorAggregator.prototype.clearErrors = function clearErrors() {\n  this.errors = []\n  this.seenStrings = {}\n  if (WeakMap) {\n    this.seenObjects = new WeakMap()\n  } else {\n    this.seenObjects = []\n  }\n  this.errorCount = 0\n  this.webTransactionErrorCount = 0\n  this.otherTransactionErrorCount = 0\n}\n\nErrorAggregator.prototype.reconfigure = function reconfigure(config) {\n  this.config = config\n  this.events.setLimit(this.config.error_collector.max_event_samples_stored)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/errors/aggregator.js\n// module id = 166\n// module chunks = 0","'use strict'\n\nexports.shallow = shallowCopy\n\n/**\n * Performs a shallow copy of all properties on the source object.\n *\n * @param {object} source     - The object to copy the properties from.\n * @param {object} [dest={}]  - The object to copy the properties to.\n *\n * @return {object} The destination object.\n */\nfunction shallowCopy(source, dest) {\n  dest = dest || {}\n  for (var k in source) {\n    if (source.hasOwnProperty(k)) {\n      dest[k] = source[k]\n    }\n  }\n  return dest\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/copy.js\n// module id = 167\n// module chunks = 0","'use strict'\n\nvar url = require('url')\n\n// TODO: Once Node v0.10 is deprecated, change this to use a `Set` instead.\nvar LOCALHOST_NAMES = {\n  \"localhost\": true,\n  \"127.0.0.1\": true,\n  \"0.0.0.0\": true,\n  \"0:0:0:0:0:0:0:1\": true,\n  \"::1\": true,\n  \"0:0:0:0:0:0:0:0\": true,\n  \"::\": true\n}\n\n/**\n * Utility functions for enforcing New Relic naming conditions on URLs,\n * and extracting and setting parameters on traces / web trace segments.\n */\nmodule.exports = {\n  /**\n   * Dictionary whose keys are all synonyms for localhost.\n   *\n   * @const\n   */\n  LOCALHOST_NAMES: LOCALHOST_NAMES,\n\n  /**\n   * Checks if the given name is in the dictionary of localhost names.\n   *\n   * @param {string} host - The hostname to lookup.\n   *\n   * @return {bool} - True if the given hostname is a synonym for localhost.\n   */\n  isLocalhost: function isLocahost(host) {\n    return LOCALHOST_NAMES.hasOwnProperty(host)\n  },\n\n  /**\n   * This was handed down from the prototype as the canonical list of status\n   * codes that short-circuit naming and normalization. The agent can be\n   * configured to mark HTTP status codes as not being errors.\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code should be ignored.\n   */\n  isError: function isError(config, code) {\n    return code >= 400 && !isIgnoredStatusCodeForErrors(config, code)\n  },\n\n  /**\n   * Returns true if the status code is an HTTP error, and it is configured to be ignored.\n   *\n   * @param {Config} config The configuration containing the error list.\n   * @param {string} code   The HTTP status code to check.\n   *\n   * @returns {bool} Whether the status code should be ignored.\n   */\n  isIgnoredError: function isIgnoredError(config, code) {\n    return code >= 400 && isIgnoredStatusCodeForErrors(config, code)\n  },\n\n  /**\n   * Get back the pieces of the URL that New Relic cares about. Apply these\n   * restrictions, in order:\n   *\n   * 1. Ensure that after parsing the URL, there's at least '/'\n   * 2. Strip off session trackers after ';' (a New Relic convention)\n   * 3. Remove trailing slash.\n   *\n   * @param {string} requestURL The URL fragment to be scrubbed.\n   * @return {string} The cleaned URL.\n   */\n  scrub: function scrub(requestURL) {\n    if (typeof requestURL === 'string') {\n      requestURL = url.parse(requestURL)\n    }\n\n    var path = requestURL.pathname\n\n    if (path) {\n      path = path.split(';')[0]\n\n      if (path !== '/' && path.charAt(path.length - 1) === '/') {\n        path = path.substring(0, path.length - 1)\n      }\n    } else {\n      path = '/'\n    }\n\n    return path\n  },\n\n  /**\n   * Extract query parameters, dealing with bare parameters and parameters with\n   * no value as appropriate:\n   *\n   * 'var1&var2=value' is not necessarily the same as 'var1=&var2=value'\n   *\n   * In my world, one is an assertion of presence, and the other is an empty\n   * variable. Some web frameworks behave this way as well, so don't lose\n   * information.\n   *\n   * @param {string} requestURL The URL to be parsed.\n   * @returns {object} The parameters parsed from the request\n   */\n  parseParameters: function parseParameters(requestURL) {\n    var parsed = requestURL\n\n    if (typeof requestURL === 'string') {\n      parsed = url.parse(requestURL, true)\n    }\n\n    var parameters = {}\n\n    if (parsed.query) {\n      var keys = Object.keys(parsed.query)\n\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        var key = keys[i]\n        if (parsed.query[key] === '' && parsed.path.indexOf(key + '=') === -1) {\n          parameters[key] = true\n        } else {\n          parameters[key] = parsed.query[key]\n        }\n      }\n    }\n\n    return parameters\n  },\n\n  /**\n   * Copy a set of request parameters from one object to another, following\n   * a few important rules:\n   *\n   * 1. Do not copy a parameter if it's in config.ignored_params.\n   * 2. Do not overwrite any existing parameters in destination, including\n   *    parameters set to null or undefined.\n   *\n   * @param {Config} config      Configuration, where `ignored_params` is\n   *                             guaranteed to be an Array.\n   * @param {object} source      Parameters to be copied (not changed).\n   * @param {object} destination Dictionary to which parameters are copied\n   *                             (mutated in place).\n   */\n  copyParameters: function copyParameters(config, source, destination) {\n    if (!(config && config.capture_params && source && destination)) return\n\n    var keys = Object.keys(source)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      if (config.ignored_params.indexOf(key) === -1 && !(key in destination)) {\n        destination[key] = source[key]\n      }\n    }\n  },\n\n  /**\n   * Copy a set of request parameters from one object to another.\n   * Existing attributes on the `destination` will be overwritten.\n   * Unlike `copyParameters`, this function will operate when\n   * `capture_params` is not enabled.\n   *\n   * @param {Config} config      Configuration, where `ignored_params` is\n   *                             guaranteed to be an Array.\n   * @param {object} source      Parameters to be copied (not changed).\n   * @param {object} destination Dictionary to which parameters are copied\n   *                             (mutated in place).\n   */\n  overwriteParameters: function overwriteParameters(config, source, destination) {\n    if (!(config && source && destination)) return\n\n    var keys = Object.keys(source)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      if (config.ignored_params.indexOf(key) === -1) {\n        destination[key] = source[key]\n      }\n    }\n  }\n}\n\nfunction isIgnoredStatusCodeForErrors(config, code) {\n  var codes = []\n  if (config &&\n      config.error_collector &&\n      config.error_collector.ignore_status_codes) {\n    codes = config.error_collector.ignore_status_codes\n  }\n  return codes.indexOf(parseInt(code, 10)) >= 0\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/urltils.js\n// module id = 168\n// module chunks = 0","'use strict'\n\nvar urltils = require('../util/urltils')\nvar NAMES = require('../metrics/names')\nvar util = require('util')\n\nmodule.exports.createError = createError\nmodule.exports.createEvent = createEvent\n\n/**\n * Given either or both of a transaction and an exception, generate an error\n * trace in the JSON format expected by the collector. Since this will be\n * used by both the HTTP instrumentation, which uses HTTP status codes to\n * determine whether a transaction is in error, and the domain-based error\n * handler, which traps actual instances of Error, try to set sensible\n * defaults for everything.\n *\n * @param {Transaction} transaction      The agent transaction, presumably\n *                                       coming out of the instrumentation.\n * @param {Error}       exception        Something trapped by an error listener.\n * @param {object}      customParameters Any custom parameters associated with\n *                                       the request (optional).\n */\nfunction createError(transaction, exception, customParameters, config) {\n  var name = 'WebTransaction/Uri/*'\n  var message = ''\n  var type = 'Error'\n  var params = {\n    request_uri: '',\n    userAttributes: {},\n    agentAttributes: {},\n    intrinsics: {}\n  }\n\n  // String errors do not provide us with as much information to provide to the\n  // user, but it is a common pattern.\n  if (typeof exception === 'string') {\n    message = exception\n  } else if (exception !== null && typeof exception === 'object' && exception.message) {\n    message = exception.message\n\n    if (exception.name) {\n      type = exception.name\n    } else if (exception.constructor && exception.constructor.name) {\n      type = exception.constructor.name\n    }\n  } else if (transaction && transaction.statusCode &&\n             urltils.isError(config, transaction.statusCode)) {\n    message = 'HttpError ' + transaction.statusCode\n  }\n\n  if (transaction) {\n    // transaction.getName is expensive due to running normalizers and ignore\n    // rules if a name hasn't been assigned yet. Also has the side effect of\n    // changing the transaction's url property or ignore status.\n    var txName = transaction.getName()\n    if (txName) {\n      name = txName\n    }\n\n    if (transaction.isWeb()) {\n      params.request_uri = transaction.getScrubbedUrl()\n    }\n\n    // Copy all of the parameters off of the transaction.\n    params.agentAttributes = transaction.trace.parameters\n    params.intrinsics = transaction.getIntrinsicAttributes()\n\n    // Custom params aren't filtered by capture_params or ignore_params, just by\n    // high security mode.\n    if (!config.high_security) {\n      urltils.overwriteParameters(config, transaction.trace.custom, params.userAttributes)\n    }\n  }\n  // This will strip out any ignored params or not include the custom params if\n  // capture params is disabled.\n  if (!config.high_security && customParameters) {\n    urltils.overwriteParameters(config, customParameters, params.userAttributes)\n  }\n\n\n  var stack = exception && exception.stack\n  if (stack) params.stack_trace = ('' + stack).split(/[\\n\\r]/g)\n\n  var res = [0, name, message, type, params]\n  if (transaction) {\n    Object.defineProperty(res, 'transaction', {\n      value: transaction.id\n    })\n  }\n  return res\n}\n\n/**\n * Creates a structure for error event that is sent to the collector.\n * The error parameter is an output of the createError() function for a given exception.\n */\nfunction createEvent(transaction, error, timestamp) {\n  var message = error[2]\n  var errorClass = error[3]\n  var paramsFromError = error[4]\n\n  var intrinsicAttributes = _getErrorEventIntrinsicAttrs(transaction, errorClass, message,\n      timestamp)\n\n  // the error structure created by createError() already performs filtering of custom\n  // and agent attributes, so it is ok to just copy them\n  var userAttributes = util._extend({}, paramsFromError.userAttributes)\n  var agentAttributes = util._extend({}, paramsFromError.agentAttributes)\n\n  var errorEvent = [\n    intrinsicAttributes,\n    userAttributes,\n    agentAttributes\n  ]\n\n  return errorEvent\n}\n\nfunction _getErrorEventIntrinsicAttrs(transaction, errorClass, message, timestamp) {\n  // the server expects seconds instead of milliseconds\n  if (timestamp) timestamp = timestamp / 1000\n\n  var attributes = {\n    type: \"TransactionError\",\n    \"error.class\": errorClass,\n    \"error.message\": message,\n    timestamp: timestamp\n  }\n\n  if (transaction) {\n    attributes.transactionName = transaction.name\n    attributes.duration = transaction.timer.getDurationInMillis() / 1000\n\n    var metric = transaction.metrics.getMetric(NAMES.QUEUETIME)\n    if (metric) {\n      attributes.queueDuration = metric.total\n    }\n\n    metric = transaction.metrics.getMetric(NAMES.EXTERNAL.ALL)\n    if (metric) {\n      attributes.externalDuration = metric.total\n      attributes.externalCallCount = metric.callCount\n    }\n\n    metric = transaction.metrics.getMetric(NAMES.DB.ALL)\n    if (metric) {\n      attributes.databaseDuration = metric.total\n      attributes.databaseCallCount = metric.callCount\n    }\n\n    if (transaction.syntheticsData) {\n      attributes[\"nr.syntheticsResourceId\"] = transaction.syntheticsData.resourceId\n      attributes[\"nr.syntheticsJobId\"] = transaction.syntheticsData.jobId\n      attributes[\"nr.syntheticsMonitorId\"] = transaction.syntheticsData.monitorId\n    }\n\n    attributes['nr.transactionGuid'] = transaction.id\n    attributes['nr.referringTransactionGuid'] = transaction.referringTransactionGuid\n\n    if (transaction.port) {\n      attributes.port = transaction.port\n    }\n  } else {\n    attributes.transactionName = 'None'\n  }\n\n  return attributes\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/errors/index.js\n// module id = 169\n// module chunks = 0","'use strict'\n\nvar Stats = require('../stats')\nvar ApdexStats = require('../stats/apdex.js')\nvar NAMES = require('./names')\n\n\n/*\n *\n * CONSTANTS\n *\n */\nvar FROM_MILLIS = 1e-3\n\n/**\n * A metric is a set of aggregated data (summary statistics) associated with a\n * metric name. Some metrics belong to scopes, which are typically the name of\n * a transaction or a background task. This class is a collection of mappings\n * from names (or scopes and names) to data, as well as functions for\n * manipulating those data directly. It also can produce a serialized\n * representation suitable for stringifying into JSON and sending to the\n * collector.\n *\n * There are several metrics collections in existence at any given time. Each\n * agent has one metrics collection, which is created at the beginning of each\n * harvest cycle. Each new transaction also gets its own metrics collection,\n * which is merged into the agent's metrics when the transaction is finalized.\n * This allows each set of metrics to be added to the harvest cycle atomically,\n * which guarantees that each transaction will not have its metrics split\n * across multiple harvest cycles. If delivery to the collector fails, the\n * metrics collection associated with the failed delivery can be merged back\n * into the metrics collection for the ongoing harvest cycle.  Finally, if so\n * configured, the agent will have an internal set of supportability metrics\n * that can be used to report information about the operation of the agent.\n *\n * Metrics can be remapped, which is a process by which they are assigned a\n * short, numerical ID by New Relic. This can shrink the serialized JSON\n * considerably. The mapping from transaction name (and scope) happens only\n * at serialization time, which allows the mappings from name to ID to happen\n * on the fly.\n *\n * @param {Number} apdexT The apdex-tolerating value, for use in creating apdex\n *                        statistics.\n * @param {MetricMapper} mapper The mapper that turns metric names into IDs.\n */\nfunction Metrics(apdexT, mapper, normalizer) {\n  if (apdexT === undefined || apdexT === null || apdexT === '') {\n    throw new Error(\"metrics must be created with apdexT\")\n  }\n  if (!mapper) throw new Error(\"metrics must be created with a mapper\")\n  if (!normalizer) throw new Error(\"metrics must be created with a name normalizer\")\n\n  this.started = Date.now()\n  this.apdexT = apdexT\n  this.mapper = mapper\n  this.normalizer = normalizer\n  this.unscoped = {} // {name : stats}\n  this.scoped = {} // {scope : {name : stats}}\n}\n\n/**\n * This is the preferred way for interacting with metrics. Set the duration\n * (and optionally the amount of that duration that was exclusive to that\n * particular metric and not any child operations to that metric) of an\n * operation. If there are no data for the name (and optional scope) existing,\n * the collection will create a set of data before recording the measurement.\n *\n * @param {string} name The name of the metric.\n * @param {string} scope (Optional) The scope to which the metric belongs.\n * @param {Number} duration The duration of the related operation, in milliseconds.\n * @param {Number} exclusive (Optional) The portion of the operation specific to this\n *                           metric.\n * @return {Stats} The aggregated data related to this metric.\n */\nMetrics.prototype.measureMilliseconds = measureMilliseconds\n\nfunction measureMilliseconds(name, scope, duration, exclusive) {\n  var stats = this.getOrCreateMetric(name, scope)\n  stats.recordValueInMillis(duration, exclusive)\n  return stats\n}\n\n/**\n * Set the size of an operation. If there are no data for the name existing,\n * the collection will create a set of data before recording the measurement.\n *\n * @param {string} name The name of the metric.\n * @param {Number} size The size of the related operation, in bytes.\n * @return {Stats} The aggregated data related to this metric.\n */\nMetrics.prototype.measureBytes = function measureBytes(name, size) {\n  var stats = this.getOrCreateMetric(name)\n  stats.recordValueInBytes(size)\n  return stats\n}\n\n/**\n * Look up the mapping from a name (and optionally a scope) to a set of metric\n * data for that name, creating the data if they don't already exist.\n *\n * @param {string} name The name of the requested metric.\n * @param {string} scope (Optional) The scope to which the metric is bound.\n * @return {Stats} The aggregated data for that name.\n */\nMetrics.prototype.getOrCreateMetric = function getOrCreateMetric(name, scope) {\n  if (!name) throw new Error('Metrics must be named')\n\n  var resolved = this._resolve(scope)\n  if (!resolved[name]) resolved[name] = new Stats()\n  return resolved[name]\n}\n\n/**\n * Look up the mapping from a name (and optionally a scope) to a set of metric\n * apdex data for that name, creating the data if they don't already exist.\n *\n * @param {string} name          The name of the requested metric.\n * @param {string} scope         The scope to which the metric is bound\n *                               (optional).\n * @param {number} overrideApdex A custom apdexT for this metric, in\n *                               milliseconds. This will be the same for\n *                               a given run, because key transaction metrics\n *                               are set at connect time via server-side\n *                               configuration.\n *\n * @return {ApdexStats} The aggregated data for that name.\n */\nMetrics.prototype.getOrCreateApdexMetric = getOrCreateApdexMetric\n\nfunction getOrCreateApdexMetric(name, scope, overrideApdex) {\n  if (!name) throw new Error('Metrics must be named')\n\n  var resolved = this._resolve(scope)\n\n  if (!resolved[name]) {\n    // Only use the given override to create the metric if this is not the\n    // global apdex AND we have a valid value.\n    var apdexT = name !== NAMES.APDEX && overrideApdex > 0\n      ? (overrideApdex * FROM_MILLIS) : this.apdexT\n    resolved[name] = new ApdexStats(apdexT)\n  }\n  return resolved[name]\n}\n\n/**\n * Look up a metric, and don't create it if it doesn't exist. Can create scopes\n * as a byproduct, but this function is only intended for use in testing, so\n * it's not a big deal.\n *\n * @param {string} name Metric name.\n * @param {string} scope (Optional) The scope, if any, to which the metric\n *                       belongs.\n * @return {object} Either a stats aggregate, an apdex stats aggregate, or\n *                  undefined.\n */\nMetrics.prototype.getMetric = function getMetric(name, scope) {\n  if (!name) throw new Error('Metrics must be named')\n\n  return this._resolve(scope)[name]\n}\n\n/**\n * Convert this collection into a representation suitable for serialization\n * by JSON.stringify and delivery to the collector. Hope you like nested\n * arrays!\n *\n * @return {Object} Set of nested arrays containing metric information.\n */\nMetrics.prototype.toJSON = function toJSON() {\n  return this._toUnscopedData().concat(this._toScopedData())\n}\n\n/**\n * Combine two sets of metric data. Intended to be used as described above,\n * either when folding a transaction's metrics into the agent's metrics for\n * later harvest, or one harvest cycle's metrics into the next when a\n * delivery attempt to the collector fails. Among the more performance-\n * critical pieces of code in the agent, so some performance tuning would\n * probably be a good idea.\n *\n * @param {Metrics} other The collection to be folded into this one.\n */\nMetrics.prototype.merge = function merge(other) {\n  this.started = Math.min(this.started, other.started)\n\n  Object.keys(other.unscoped).forEach(function cb_forEach(name) {\n    if (this.unscoped[name]) {\n      this.unscoped[name].merge(other.unscoped[name])\n    } else {\n      this.unscoped[name] = other.unscoped[name]\n    }\n  }, this)\n\n  Object.keys(other.scoped).forEach(function cb_forEach(scope) {\n    Object.keys(other.scoped[scope]).forEach(function cb_forEach(name) {\n      if (other.scoped[scope][name]) {\n        var resolved = this._resolve(scope)\n        if (resolved[name]) {\n          resolved[name].merge(other.scoped[scope][name])\n        } else {\n          resolved[name] = other.scoped[scope][name]\n        }\n      }\n    }, this)\n  }, this)\n}\n\n/**\n * Look up the metric namespace belonging to a scope, creating it if it doesn't\n * already exist.\n *\n * @param {string} scope (Optional) The scope to look up.\n * @return {object} The namespace associated with the provided scope, or the\n *                  un-scoped metrics if the scope isn't set.\n */\nMetrics.prototype._resolve = function _resolve(scope) {\n  var resolved\n\n  if (scope) {\n    if (!this.scoped[scope]) this.scoped[scope] = {}\n\n    resolved = this.scoped[scope]\n  } else {\n    resolved = this.unscoped\n  }\n\n  return resolved\n}\n\n/**\n * Map a metric to its nested-array representation, applying any name -> ID\n * mappings along the way. Split from _getScopedData for performance.\n *\n * @param {string} name The string to look up.\n */\nMetrics.prototype._getUnscopedData = function _getUnscopedData(name) {\n  if (!this.unscoped[name]) return\n\n  var normalized = this.normalizer.normalize(name)\n  if (normalized.ignore || !normalized.value) return\n\n  return [this.mapper.map(normalized.value), this.unscoped[name]]\n}\n\n/**\n * Map a metric to its nested-array representation, applying any name -> ID\n * mappings along the way. Split from _getUnscopedData for performance.\n *\n * @param {string} name The string to look up.\n */\nMetrics.prototype._getScopedData = function _getScopedData(name, scope) {\n  if (!this.scoped[scope][name]) return\n\n  var normalized = this.normalizer.normalize(name)\n  if (normalized.ignore || !normalized.value) return\n\n  return [this.mapper.map(normalized.value, scope), this.scoped[scope][name]]\n}\n\n/**\n * @return {object} A serializable version of the unscoped metrics. Intended\n *                  for use by toJSON.\n */\nMetrics.prototype._toUnscopedData = function _toUnscopedData() {\n  var metricData = []\n\n  Object.keys(this.unscoped).forEach(function cb_forEach(name) {\n    var data = this._getUnscopedData(name)\n    if (data) metricData.push(data)\n  }, this)\n\n  return metricData\n}\n\n/**\n * @return {object} A serializable version of the scoped metrics. Intended for\n *                  use by toJSON.\n */\nMetrics.prototype._toScopedData = function _toScopedData() {\n  var metricData = []\n\n  Object.keys(this.scoped).forEach(function cb_forEach(scope) {\n    Object.keys(this.scoped[scope]).forEach(function cb_forEach(name) {\n      var data = this._getScopedData(name, scope)\n      if (data) metricData.push(data)\n    }, this)\n  }, this)\n\n  return metricData\n}\n\nmodule.exports = Metrics\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/index.js\n// module id = 170\n// module chunks = 0","'use strict'\n\n/*\n *\n * CONSTANTS\n *\n */\nvar BYTES_PER_MB = 1024 * 1024\nvar FROM_MILLIS = 1e-3\n\n\n/**\n * Simple container for tracking running statistics for a metric.\n */\nfunction Stats() {\n  this.total = 0\n  this.totalExclusive = 0\n  this.min = 0\n  this.max = 0\n  this.sumOfSquares = 0\n  this.callCount = 0\n}\n\n/**\n * Update the summary statistics with a new value.\n *\n * @param {Number} totalTime Time, in seconds, of the measurement.\n * @param {Number} exclusiveTime Time that was taken by only the\n *                               current measurement (optional).\n */\nStats.prototype.recordValue = function recordValue(totalTime, exclusiveTime) {\n  // even if a caller messes up, don't break everything else\n  if (totalTime !== 0 && !totalTime) totalTime = 0\n  if (exclusiveTime !== 0 && !exclusiveTime) exclusiveTime = totalTime\n\n  if (this.callCount > 0) {\n    this.min = Math.min(totalTime, this.min)\n  } else {\n    this.min = totalTime\n  }\n  this.max = Math.max(totalTime, this.max)\n\n  this.sumOfSquares += (totalTime * totalTime)\n  this.callCount += 1\n  this.total += totalTime\n  this.totalExclusive += exclusiveTime\n}\n\n/**\n * Until the collector accepts statistics in milliseconds, this code is going\n * to have some hinky floating-point values to deal with.\n */\nStats.prototype.recordValueInMillis = recordValueInMillis\nfunction recordValueInMillis(totalTime, exclusiveTime) {\n  this.recordValue(\n    totalTime * FROM_MILLIS,\n    exclusiveTime >= 0 ? exclusiveTime * FROM_MILLIS : null\n  )\n}\n\n/**\n * Really?\n *\n * FIXME: Really?\n */\nStats.prototype.recordValueInBytes = function recordValueInBytes(bytes, exclusiveBytes) {\n  exclusiveBytes = exclusiveBytes || bytes\n  this.recordValue(bytes / BYTES_PER_MB, exclusiveBytes / BYTES_PER_MB)\n}\n\nStats.prototype.incrementCallCount = function incrementCallCount(count) {\n  if (typeof count === 'undefined') count = 1\n  this.callCount += count\n}\n\n/**\n * Fold another summary's statistics into this one.\n */\nStats.prototype.merge = function merge(other) {\n  if (other.callCount > 0) {\n    if (this.callCount > 0) {\n      this.min = Math.min(this.min, other.min)\n    } else {\n      this.min = other.min\n    }\n  }\n  this.max = Math.max(this.max, other.max)\n\n  this.total += other.total\n  this.totalExclusive += other.totalExclusive\n  this.sumOfSquares += other.sumOfSquares\n  this.callCount += other.callCount\n}\n\n/**\n * The serializer relies upon this representation, so don't change the\n * values, cardinality, or ordering of this array without ensuring that\n * it matches the version of the \"protocol\" being sent to the collector.\n *\n * @returns {Array} Number of calls,\n *                  total time in seconds,\n *                  time for this metric alone in seconds,\n *                  shortest individual time in seconds,\n *                  longest individual time in seconds,\n *                  running sum of squares.\n */\nStats.prototype.toJSON = function toJSON() {\n  return [\n    this.callCount,\n    this.total,\n    this.totalExclusive,\n    this.min,\n    this.max,\n    this.sumOfSquares\n  ]\n}\n\nmodule.exports = Stats\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/stats/index.js\n// module id = 171\n// module chunks = 0","'use strict'\n\n/*\n *\n * CONSTANTS\n *\n */\nvar FROM_MILLIS = 1e-3\n\n\nfunction ApdexStats(apdexT) {\n  if (!apdexT && apdexT !== 0) {\n    throw new Error('Apdex summary must be created with apdexT.')\n  }\n  this.apdexT = apdexT\n\n  this.satisfying = 0\n  this.tolerating = 0\n  this.frustrating = 0\n}\n\nApdexStats.prototype.recordValue = function recordValue(time, overrideApdex) {\n  var apdexT = overrideApdex || this.apdexT\n  if (time <= apdexT) {\n    ++this.satisfying\n  } else if (time <= 4 * apdexT) {\n    ++this.tolerating\n  } else {\n    ++this.frustrating\n  }\n}\n\nApdexStats.prototype.recordValueInMillis =\nfunction recordValueInMillis(timeInMillis, overrideApdex) {\n  this.recordValue(timeInMillis * FROM_MILLIS, overrideApdex * FROM_MILLIS)\n}\n\n/**\n * Used by the error handler to indicate that a user was frustrated by a page\n * error.\n */\nApdexStats.prototype.incrementFrustrating = function incrementFrustrating() {\n  ++this.frustrating\n}\n\n/**\n * When merging apdex stastics, the apdex tolerating value isn't brought along\n * for the ride.\n *\n * @param {ApdexStats} other The existing apdex stats being merged in.\n */\nApdexStats.prototype.merge = function merge(other) {\n  this.satisfying += other.satisfying\n  this.tolerating += other.tolerating\n  this.frustrating += other.frustrating\n}\n\n/**\n * This feels dirty: ApdexStats override the ordinary statistics serialization\n * format by putting satisfying, tolerating and frustrating values in the\n * first three fields in the array and setting the next two to the apdex (used\n * by calculations inside RPM), followed by 0.\n *\n * @returns {Array} A six-value array where only the first three values are\n *                  significant: satisfying, tolerating, and frustrating\n *                  load times, respectively.\n */\nApdexStats.prototype.toJSON = function toJSON() {\n  return [\n    this.satisfying,\n    this.tolerating,\n    this.frustrating,\n    this.apdexT,\n    this.apdexT,\n    0\n  ]\n}\n\nmodule.exports = ApdexStats\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/stats/apdex.js\n// module id = 172\n// module chunks = 0","'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar arrUtil = require('../util/arrays')\nvar logger = require('../logger').child({component: 'metric_normalizer'})\nvar deepEqual = require('../util/deep-equal')\nvar Rule = require('./normalizer/rule')\nvar NAMES = require('../metrics/names.js')\n\n\nfunction url(normalized, path, config) {\n  if (normalized) return NAMES.NORMALIZED + normalized\n\n  if (config.enforce_backstop) {\n    return NAMES.NORMALIZED + '/*'\n  }\n\n  return NAMES.URI + path\n}\n\nfunction plain(normalized, path) {\n  if (normalized) {\n    return normalized\n  }\n\n  return path\n}\n\n/**\n * The collector keeps track of rules that should be applied to metric names,\n * and sends these rules to the agent at connection time. These rules can\n * either change the name of the metric or indicate that metrics associated with\n * this name (which is generally a URL path) should be ignored altogether.\n *\n * @param {object} config The agent's configuration blob, which has a parameter\n *                        that indicates whether to enforce the normalization\n *                        backstop.\n */\nfunction MetricNormalizer(config, type) {\n  if (!config) throw new Error(\"normalizer must be created with configuration.\")\n  if (!type) throw new Error(\"normalizer must be created with a type.\")\n\n  EventEmitter.call(this)\n\n  this.config = config\n  this.type = type\n  // some mildly cheesy polymorphism to make normalizers work generically\n  if (type === 'URL') {\n    this.formatter = url\n  } else {\n    this.formatter = plain\n  }\n\n  this.rules = []\n}\nutil.inherits(MetricNormalizer, EventEmitter)\n\n// -------------------------------------------------------------------------- //\n\n/**\n * @typedef {Object} NormalizationResults\n *\n * @property {bool}   matched - True if a rule was found that matched.\n * @property {bool}   ignore  - True if the given input should be ignored.\n * @property {string} value   - The normalized input value.\n */\n\n// -------------------------------------------------------------------------- //\n\n/**\n * Convert the raw, de-serialized JSON response into a set of\n * NormalizationRules.\n *\n * @param object json The de-serialized JSON response sent on collector\n *                    connection.\n */\nMetricNormalizer.prototype.load = function load(json) {\n  if (json) {\n    this.rules = []\n    logger.debug(\"Received %s %s normalization rule(s) from the server\",\n      json.length, this.type)\n\n    json.forEach(function cb_forEach(ruleJSON) {\n      // no need to add the same rule twice\n      var rule = new Rule(ruleJSON)\n      if (!arrUtil.find(this.rules, deepEqual.bind(null, rule))) {\n        this.rules.push(rule)\n        logger.trace(\"Loaded %s normalization rule: %s\", this.type, rule)\n      }\n    }, this)\n\n    /* I (FLN) always forget this, so making a note: JS sort is always\n     * IN-PLACE, even though it returns the sorted array.\n     */\n    this.rules.sort(function cb_sort(a, b) {\n      return a.precedence - b.precedence\n    })\n\n    logger.debug(\"Loaded %s %s normalization rule(s).\",\n                 this.rules.length, this.type)\n  }\n}\n\n/**\n * Load any rules found in the configuration into a metric normalizer.\n *\n * Operates via side effects.\n */\nMetricNormalizer.prototype.loadFromConfig = function loadFromConfig() {\n  var rules = this.config.rules\n\n  if (rules && rules.name && rules.name.length > 0) {\n    rules.name.forEach(function cb_forEach(rule) {\n      if (!rule.pattern) {\n        return logger.error(\n          {rule: rule},\n          \"Simple naming rules require a pattern.\"\n        )\n      }\n      if (!rule.name) {\n        return logger.error(\n          {rule: rule},\n          \"Simple naming rules require a replacement name.\"\n        )\n      }\n\n      var precedence = rule.precedence\n      var terminal = rule.terminate_chain\n      var json = {\n        match_expression: rule.pattern,\n        eval_order: (typeof precedence === 'number') ? precedence : 500,\n        terminate_chain: (typeof terminal === 'boolean') ? terminal : true,\n        replace_all: rule.replace_all,\n        replacement: rule.name,\n        ignore: false\n      }\n\n      // Find where the rule should be inserted and do so.\n      var reverse = this.config.feature_flag.reverse_naming_rules\n      var insert = arrUtil.findIndex(this.rules, function findRule(r) {\n        return reverse\n          ? r.precedence >= json.eval_order\n          : r.precedence > json.eval_order\n      })\n      if (insert === -1) {\n        this.rules.push(new Rule(json))\n      } else {\n        this.rules.splice(insert, 0, new Rule(json))\n      }\n    }, this)\n  }\n\n  if (rules && rules.ignore && rules.ignore.length > 0) {\n    rules.ignore.forEach(function cb_forEach(pattern) {\n      this.addSimple(pattern)\n    }, this)\n  }\n}\n\n/**\n * Add simple, user-provided rules to the head of the match list. These rules\n * will always be highest precedence, always will terminate matching, and\n * will always apply to the URL as a whole. If no name is provided, then\n * transactions attached to the matching URLs will be ignored.\n *\n *  - `addSimple(opts)`\n *  - `addSimple(pattern [, name])`\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} [name]  The name to use for the transaction.\n */\nMetricNormalizer.prototype.addSimple = function addSimple(pattern, name) {\n  if (!pattern) return logger.error(\"Simple naming rules require a pattern.\")\n\n  var json = {\n    match_expression: pattern,\n    eval_order: 0,\n    terminate_chain: true,\n    replace_all: false,\n    replacement: null,\n    ignore: false\n  }\n\n  if (name) {\n    json.replacement = name\n  } else {\n    json.ignore = true\n  }\n\n  this.rules.unshift(new Rule(json))\n}\n\n/**\n * Turn a (scrubbed) URL path into partial metric name.\n *\n * @param {string} path - The URL path to turn into a name.\n *\n * @returns {NormalizationResults} - The results of normalization.\n */\nMetricNormalizer.prototype.normalize = function normalize(path) {\n  var last = path\n  var length = this.rules.length\n  var normalized\n  var matched = false\n  var ignored = false\n\n  // Apply each of our rules in turn.\n  for (var i = 0; i < length; i++) {\n    var rule = this.rules[i]\n    var applied = rule.apply(last)\n    if (!rule.matched) {\n      continue\n    }\n\n    if (rule.ignore) {\n      ignored = true\n    } else {\n      matched = true\n      normalized = applied\n\n      // emit event when a rule is matched\n      // we could also include an array of matched rules in the returned map, but\n      // that would increase memory overhead by creating additional array\n      this.emit('appliedRule', rule, normalized, last)\n\n      logger.trace({rule: rule, type: this.type},\n        \"Normalized %s to %s.\", last, normalized)\n      last = normalized\n    }\n\n    if (rule.isTerminal) {\n      logger.trace({rule: rule}, \"Terminating normalization.\")\n      break\n    }\n  }\n\n  // Return the normalized path.\n  return {\n    matched: matched,\n    ignore: ignored,\n    value: this.formatter(normalized, path, this.config)\n  }\n}\n\nmodule.exports = MetricNormalizer\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/normalizer.js\n// module id = 173\n// module chunks = 0","'use strict'\n\nexports.find = arrayFind\nexports.findLast = arrayFindLast\nexports.findIndex = arrayFindIndex\nexports.findLastIndex = arrayFindLastIndex\n\n/**\n * Finds the first element in an array that `pred` matches.\n *\n * Remove once Node v0.10, v0.12, v1, v2, and v3 are no longer supported.\n *\n * @deprecated With Node.js v4\n *\n * @param {Array}     arr   - The array to search.\n * @param {Function}  pred  - A predicate function which returns `true` on matches.\n * @param {*}         [ctx] - The `this` arg for `pred`.\n *\n * @return {*?} - The first matching item if found, otherwise `undefined`.\n */\nfunction arrayFind(arr, pred, ctx) {\n  var idx = arrayFindIndex(arr, pred, ctx)\n  if (idx >= 0) {\n    return arr[idx]\n  }\n}\n\n/**\n* Finds the last element in an array that `pred` matches.\n *\n * @param {Array}     arr   - The array to search.\n * @param {Function}  pred  - A predicate function which returns `true` on matches.\n * @param {*}         [ctx] - The `this` arg for `pred`.\n *\n * @return {*?} - The last matching item if found, otherwise `undefined`.\n */\nfunction arrayFindLast(arr, pred, ctx) {\n  var idx = arrayFindLastIndex(arr, pred, ctx)\n  if (idx >= 0) {\n    return arr[idx]\n  }\n}\n\n/**\n * Finds the first index of a single element in an array matching `pred`.\n *\n * Remove once Node v0.10, v0.12, v1, v2, and v3 are no longer supported.\n *\n * @deprecated With Node.js v4\n *\n * @param {Array}     arr   - The array to search.\n * @param {Function}  pred  - A predicate function which returns `true` on matches.\n * @param {*}         [ctx] - The `this` arg for `pred`.\n *\n * @return {number} - The index of the first matching item if found, otherwise `-1`.\n */\nfunction arrayFindIndex(arr, pred, ctx) {\n  for (var i = 0; i < arr.length; ++i) {\n    if (pred.call(ctx, arr[i], i, arr)) {\n      return i\n    }\n  }\n  return -1\n}\n\n/**\n * Finds the last index of a single element in an array matching `pred`.\n *\n * @param {Array}     arr   - The array to search.\n * @param {Function}  pred  - A predicate function which returns `true` on matches.\n * @param {*}         [ctx] - The `this` arg for `pred`.\n *\n * @return {number} - The index of the last matching item if found, otherwise `-1`.\n */\nfunction arrayFindLastIndex(arr, pred, ctx) {\n  for (var i = arr.length - 1; i >= 0; --i) {\n    if (pred.call(ctx, arr[i], i, arr)) {\n      return i\n    }\n  }\n  return -1\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/arrays.js\n// module id = 174\n// module chunks = 0","'use strict'\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === '[object Arguments]'\n}\n\nfunction slice(args) {\n  // Array.prototype.slice on arguments array-like is expensive\n  var l = args.length, a = [], i\n  for (i = 0; i < l; i++) {\n    a[i] = args[i]\n  }\n  return a\n}\n\n/**\n * This is a node-specific version of deepEquals, modeled on bits and pieces\n * of loads of other implementations of this algorithm, most notably the\n * one in the Node.js source and Underscore's. It doesn't throw and handles\n * cycles.\n *\n * Everybody who writes one of these functions puts the documentation\n * inline, which makes it incredibly hard to follow. Here's what this version\n * of the algorithm does, in order:\n *\n * 1. === only tests objects and and functions by reference. Null is an object.\n *    Any pair of identical entities failing this test are therefore objects\n *    (including null), which need a recursive compare by attribute.\n * 2. Since the only matching entities to get to this test must be objects, if\n *    a or b is not an object, they're clearly not the same. All unfiltered a\n *    and b getting are objects (including null).\n * 3. null is an object, but null === null. All unfiltered a and b are non-null\n *    objects.\n * 4. Buffers need to be special-cased because they live partially on the wrong\n *    side of the C++ / JavaScript barrier. Still, calling this on structures\n *    that can contain Buffers is a bad idea, because they can contain\n *    multiple megabytes of data and comparing them byte-by-byte is very\n *    expensive. buffertools is a better solution here, but this version of\n *    this code is dependency free.\n * 5. It's much faster to compare dates by numeric value than by lexical value.\n * 6. Same goes for Regexps.\n * 7. The parts of an arguments list most people care about are the arguments\n *    themselves, not the callee, which you shouldn't be looking at anyway.\n * 8. Objects are more complex:\n *    a. ensure that a and b are on the same constructor chain\n *    b. ensure that a and b have the same number of own properties (which is\n *       what Object.keys returns).\n *    c. ensure that cyclical references don't blow up the stack.\n *    d. ensure that all the key names match (faster)\n *    e. ensure that all of the associated values match, recursively (slower)\n *\n * (SOMEWHAT UNTESTED) ASSUMPTIONS:\n *\n * o Functions are only considered identical if they unify to the same\n *   reference. To anything else is to invite the wrath of the halting problem.\n * o V8 is smart enough to optimize treating an Array like any other kind of\n *   object.\n * o Users of this function are cool with mutually recursive data structures\n *   that are otherwise identical being treated as the same.\n */\nfunction deeper(a, b, ca, cb) {\n  if (a === b) {\n    return true\n  } else if (typeof a !== 'object' || typeof b !== 'object') {\n    return false\n  } else if (a === null || b === null) {\n    return false\n  } else if (Buffer.isBuffer(a) && Buffer.isBuffer(b)) {\n    if (a.length !== b.length) return false\n\n    // potentially incredibly expensive\n    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return false\n\n    return true\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime()\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source &&\n           a.global === b.global &&\n           a.multiline === b.multiline &&\n           a.lastIndex === b.lastIndex &&\n           a.ignoreCase === b.ignoreCase\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) return false\n\n    return deeper(slice(a), slice(b), ca, cb)\n  }\n\n  if (a.constructor !== b.constructor) return false\n\n  var ka = Object.keys(a), kb = Object.keys(b)\n  if (ka.length !== kb.length) return false\n\n  var cal = ca.length\n  while (cal--) if (ca[cal] === a) return cb[cal] === b\n  ca.push(a); cb.push(b)\n\n  ka.sort(); kb.sort()\n  for (var j = ka.length - 1; j >= 0; j--) if (ka[j] !== kb[j]) return false\n\n  var key\n  for (var k = ka.length - 1; k >= 0; k--) {\n    key = ka[k]\n    if (!deeper(a[key], b[key], ca, cb)) return false\n  }\n\n  ca.pop(); cb.pop()\n\n  return true\n}\n\nmodule.exports = function exports(a, b) {\n  return deeper(a, b, [], [])\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/deep-equal.js\n// module id = 175\n// module chunks = 0","'use strict'\n\nvar logger = require('../../logger').child({component: 'normalizer_rule'})\n\n\n/**\n * JavaScript just has to do things slightly differently.\n */\nvar replaceReplacer = function replaceReplacer(input) {\n  return input.replace(/\\\\/g, '$')\n}\n\n/**\n * Be liberal about accepting incomplete information, because we don't want\n * bad rules from the collector to crash client apps. Otherwise, this is a\n * fairly straightforward mapping of the concepts in metric normalization\n * rules into an object form.\n *\n * @param {Object} json A JavaScript object literal parsed out from the JSON\n *                      from the collector.\n */\nfunction NormalizerRule(json) {\n  if (!json) {\n    logger.debug(\n      \"Received incompletely specified metric normalization rule from collector.\"\n    )\n    json = {}\n  }\n\n  this.eachSegment = json.each_segment || false\n  this.precedence = json.eval_order || 0\n  this.isTerminal = json.terminate_chain || false\n  this.replacement = replaceReplacer(json.replacement || '$0')\n  this.replaceAll = json.replace_all || false\n  this.ignore = json.ignore || false\n  this.matched = false\n\n  var modifiers = 'i'\n  if (this.replaceAll) modifiers += 'g'\n\n  // don't allow this to fail\n  if (json.match_expression instanceof RegExp) {\n    this.pattern = _addRegExpFlags(json.match_expression, modifiers)\n  } else {\n    try {\n      this.pattern = new RegExp(json.match_expression || '^$', modifiers)\n    } catch (error) {\n      logger.warn(error, \"Problem compiling metric normalization rule pattern.\")\n      this.pattern = /^$/\n    }\n  }\n}\n\n/**\n * Allow the higher-level functions to operate on input uniformly.\n *\n * @param {string} input URL to potentially be split.\n */\nNormalizerRule.prototype.getSegments = function getSegments(input) {\n  if (this.eachSegment) {\n    return input.split('/')\n  }\n\n  return [input]\n}\n\n/**\n * Check if a URL matches a rule.\n *\n * Does not set {NormalizerRule#matched}.\n *\n * @param {string} input - URL to match.\n *\n * @return {bool} - True if this rule matches the given input, otherwise false.\n */\nNormalizerRule.prototype.matches = function matches(input) {\n  var segments = this.getSegments(input)\n\n  for (var i = 0; i < segments.length; ++i) {\n    if (this.pattern.test(segments[i])) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Apply the substitutions, if any, to the input.\n *\n * Also sets {NormalizerRule#matched} to true if this rule did match the given\n * input.\n *\n * String.split will return empty segments when the path has a leading slash or\n * contains a run of slashes. Don't inadvertently substitute or drop these empty\n * segments, or the normalized path will be wrong.\n *\n * XXX In Node v0.8 and Node v0.10, `RegExp#test` advances internal state and\n * XXX tracks where it left off from the previous match. This has the side\n * XXX effect that reusing the same object may cause false negatives if you do\n * XXX not reset that state. The only way to reset the state is to set\n * XXX `RegExp#lastIndex` to `0`.\n *\n * @param {string} input - URL to normalize.\n *\n * @return {string?} - The normalized url, or `null` if this is an ignore rule\n *  that matched this url.\n */\nNormalizerRule.prototype.apply = function apply(input) {\n  // For ignore rules, just see if we match and return either `null` or the\n  // original input.\n  if (this.ignore) {\n    return (this.matched = this.matches(input)) ? null : input\n  }\n\n  this.matched = false\n  return this.getSegments(input)\n    .map(function applyMap(segment) {\n      // Discussion of why we use `lastIndex` in function documentation to\n      // prevent de-opt due to long function.\n      this.pattern.lastIndex = 0\n      if (segment && this.pattern.test(segment)) {\n        this.matched = true\n        return segment.replace(this.pattern, this.replacement)\n      }\n      return segment\n    }, this)\n    .join('/')\n}\n\nNormalizerRule.prototype.toJSON = function toJSON() {\n  return {\n    eachSegment: this.eachSegment,\n    precedence: this.precedence,\n    isTerminal: this.isTerminal,\n    replacement: this.replacement,\n    replaceAll: this.replaceAll,\n    ignore: this.ignore,\n    pattern: this.pattern.source\n  }\n}\n\n/**\n * Merges the given flags with those already in a regular expression.\n *\n * @param {RegExp} re     - The regular expression to add flags to.\n * @param {string} flags  - The flags to add to the regex.\n *\n * @return {RegExp} - A regular expression with all the given flags added.\n */\nfunction _addRegExpFlags(re, flags) {\n  var foundMissing = false\n  var reFlags = _getRegExpFlags(re)\n  for (var i = 0; i < flags.length; ++i) {\n    if (reFlags.indexOf(flags[i]) === -1) {\n      foundMissing = true\n      reFlags += flags[i]\n    }\n  }\n  return foundMissing ? new RegExp(re.source, reFlags) : re\n}\n\n/**\n * Pulls all the flags for a regular expression.\n *\n * @param {RegExp} re - The regular expression to extract the flags of.\n *\n * @return {string} - The regex flags.\n */\nfunction _getRegExpFlags(re) {\n  // Available in Node >6.\n  if ('flags' in re) {\n    return re.flags\n  }\n\n  // Remove this logic once we've deprecated Node <=4, so in 2030.\n  var flags = ''\n  if (re.global) {\n    flags += 'g'\n  }\n  if (re.ignoreCase) {\n    flags += 'i'\n  }\n  if (re.multiline) {\n    flags += 'm'\n  }\n  if (re.sticky) {\n    flags += 'y'\n  }\n  if (re.unicode) {\n    flags += 'u'\n  }\n  return flags\n}\n\nmodule.exports = NormalizerRule\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/normalizer/rule.js\n// module id = 176\n// module chunks = 0","'use strict'\n\nvar logger = require('../../logger').child({component: 'tx_segment_normalizer'})\n\nmodule.exports = TxSegmentNormalizer\n\nfunction TxSegmentNormalizer() {\n  this.terms = []\n}\n\n/**\n * This normalize method is wicked. The best bet is to read the spec:\n * https://newrelic.atlassian.net/wiki/pages/viewpage.action?spaceKey=eng&title=Language+agent+transaction+segment+terms+rules\n *\n * A copy paste of the rules that were followed:\n *  1. Find the first rule where the prefix key matches the prefix of the\n *     transaction name. If no matching rules are found, abort.\n *  2. Strip the prefix from the transaction name.\n *  3. Split the rest of the transaction name into segments on slashes ('/').\n *  4. For each segment:\n *      If the segment appears in the array of strings given under the terms key,\n *      keep it unchanged. Else, replace it with a placeholder ('*')\n *  5. Collapse all adjacent placeholder segments into a single '*' segment.\n *  6. Join together the modified segments with slashes, and re-prepend the prefix.\n *\n * @param {string} path - The transaction metric path to normalize.\n *\n * @return {NormalizationResults} - The results of normalizing the given path.\n */\nTxSegmentNormalizer.prototype.normalize = function normalize(path) {\n  var currentTerm\n  var prefix\n  for (var i = 0; i < this.terms.length; i++) {\n    currentTerm = this.terms[i]\n    prefix = currentTerm.prefix\n    if (path.lastIndexOf(prefix, 0) === -1) {\n      continue\n    }\n    var fragment = path.slice(prefix.length)\n    var parts = fragment.split('/')\n    var result = []\n    var prev\n\n    var segment\n    for (var j = 0; j < parts.length; j++) {\n      segment = parts[j]\n\n      if (segment === '' && j + 1 === parts.length) break\n\n      if (currentTerm.terms.indexOf(segment) === -1) {\n        if (prev === '*') continue\n        result.push(prev = '*')\n      } else {\n        result.push(prev = segment)\n      }\n    }\n    logger.trace('Normalizing %s because of rule: %s', path, currentTerm)\n    return {\n      matched: true, // To match MetricNormalizer\n      ignore: false, // ^^\n      value: prefix + result.join('/')\n    }\n  }\n\n  return {\n    matched: false, // To match MetricNormalizer\n    ignore: false,  // ^^\n    value: path\n  }\n}\n\nTxSegmentNormalizer.prototype.load = function load(json) {\n  if (Array.isArray(json)) {\n    this.terms = filterRules(json)\n  } else {\n    logger.warn(\n      'transaction_segment_terms was not an array got: %s (%s)',\n      typeof json,\n      json\n    )\n  }\n}\n\nfunction filterRules(rules) {\n  var map = {}\n\n  for (var i = 0, l = rules.length; i < l; ++i) {\n    var prefix = rules[i].prefix\n\n    if (!prefix || typeof prefix !== 'string') continue\n\n    if (prefix[prefix.length - 1] !== '/') {\n      prefix = prefix + '/'\n      rules[i].prefix = prefix\n    }\n\n    var segments = prefix.split('/')\n    if (segments.length !== 3 || !segments[0] || !segments[1] || segments[3]) continue\n\n    if (Array.isArray(rules[i].terms)) {\n      map[prefix] = rules[i]\n    }\n  }\n\n  var keys = Object.keys(map)\n  var filtered = new Array(keys.length)\n\n  for (i = 0, l = keys.length; i < l; ++i) {\n    filtered[i] = map[keys[i]]\n  }\n\n  return filtered\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/normalizer/tx_segment.js\n// module id = 177\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger').child({component: 'mapper'})\n\n\n/**\n * To tighten up the metrics JSON, the collector will maintain a list of\n * mappings from metric names (which sometimes include scopes as well) to\n * numeric IDs. As the agent sends new metric names to the collector, the\n * collector will return corresponding metric IDs, in the expectation that the\n * agent will uses those IDs instead of the names going forward.\n *\n * @param {Array} raw A list of metric spec -> ID mappings represented as\n *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]\n */\nfunction MetricMapper(raw) {\n  this.unscoped = {}\n  this.scoped = {}\n  this.length = 0\n\n  this.load(raw)\n}\n\n/**\n * Parse the list of metric mappings returned on metric_data responses from the\n * collector. These continue to stream in as the agent runs, so keep adding to\n * the collection rather than resetting.\n *\n * https://hudson.newrelic.com/job/collector-master/javadoc/com/nr/collector/datatypes/MetricData.html\n *\n * @param {Array} raw A list of metric spec -> ID mappings represented as\n *                    2-element arrays: [{name : 'Metric', scope : 'Scope'}, 1]\n */\nMetricMapper.prototype.load = function load(raw) {\n  if (!(raw && raw.length)) {\n    logger.debug(\"No new metric mappings from server.\")\n    return\n  }\n\n  for (var i = 0; i < raw.length; i++) {\n    var spec = raw[i][0]\n    var scope = spec.scope\n    var name = spec.name\n    var id = raw[i][1]\n    var resolved\n\n\n    if (scope) {\n      if (!this.scoped[scope]) this.scoped[scope] = {}\n      resolved = this.scoped[scope]\n    } else {\n      resolved = this.unscoped\n    }\n\n    if (!resolved[name]) this.length++\n    resolved[name] = id\n    logger.trace(\"Metric spec %s has been mapped to ID %s.\", spec, id)\n  }\n  logger.debug(\"Parsed %d metric ids (%d total).\", raw.length, this.length)\n}\n\n/**\n * @param {String} name  The metric name.\n * @param {String} scope The scope for the metric, if set.\n *\n * @returns {object} Either a metric spec based on the parameters, or the\n *                   server-sent ID.\n */\nMetricMapper.prototype.map = function map(name, scope) {\n  if (scope) {\n    if (this.scoped[scope] && this.scoped[scope][name]) {\n      return this.scoped[scope][name]\n    }\n    return {name: name, scope: scope}\n  }\n\n  if (this.unscoped[name]) {\n    return this.unscoped[name]\n  }\n\n  return {name: name}\n}\n\nmodule.exports = MetricMapper\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/mapper.js\n// module id = 178\n// module chunks = 0","'use strict'\n\nvar logger = require('../../logger').child({component: 'trace-aggregator'})\n\n/*\n *\n * CONSTANTS\n *\n */\nvar TO_MILLIS = 1e3\n\n/**\n * Locus for the complicated logic surrounding the selection of slow\n * transaction traces for submission to the collector.\n *\n * @param {object} config Dictionary containing transaction tracing\n *                        parameters. Required.\n */\nfunction TraceAggregator(config) {\n  if (!config) throw new Error(\"Trace aggregator needs configuration at creation.\")\n  /*eslint-disable */\n  /*\n   * From\n   * \n   * https://newrelic.atlassian.net/wiki/display/eng/Transaction+Trace+Collection+Improvements\n   *\n   * 5 Transaction Trace Guarantee\n   *\n   * For the initial experience problem, the Agent will sample up to 1\n   * transaction per minute until it has sampled 5 transactions. This\n   * guarantees that the agent will always report some transaction traces.\n   * There is no time out for this sampling period - the agent always\n   * samples until it has collected 5 transactions. The agent doesn't\n   * simply report the first 5 transactions that it sees because it's\n   * likely (particularly for a local dev test) that all 5 transactions\n   * would be associated with one request (a single web page and its\n   * resources).\n   */\n  /*eslint-enable */\n\n\n  this.reported = 0\n  this.config = config\n\n  // Setting up top n capacity.\n  this.capacity = 1\n  if (config.transaction_tracer &&\n      config.transaction_tracer.top_n) {\n    this.capacity = config.transaction_tracer.top_n\n  }\n\n  // hidden class optimization\n  this.trace = null\n  this.syntheticsTraces = []\n  this.requestTimes = {}\n  this.noTraceSubmitted = 0\n}\n\n/**\n * For every five harvest cycles (or \"minutes\"), if no new slow transactions\n * have been added, reset the requestTime match and allow a new set of five\n * to start populating the Top N Slow Trace list.\n */\nTraceAggregator.prototype.resetTimingTracker = function resetTT() {\n  this.requestTimes = {}\n  this.noTraceSubmitted = 0\n}\n\n/**\n * Add a trace to the slow trace list, if and only if it fulfills the necessary\n * criteria.\n *\n * @param {Transaction} transaction The transaction, which we need to check\n *                                  apdexT, as well as getting the trace.\n */\nTraceAggregator.prototype.add = function add(transaction) {\n  if (this.config.collect_traces &&\n      this.config.transaction_tracer && this.config.transaction_tracer.enabled &&\n      transaction && transaction.metrics) {\n    var trace = transaction.trace\n    var name = transaction.name\n    var duration = trace.getDurationInMillis()\n    var apdexT = transaction.metrics.apdexT\n\n    if (transaction.syntheticsData && this.syntheticsTraces.length < 20) {\n      this.syntheticsTraces.push(trace)\n    } else if (this.isBetter(name, duration, apdexT)) {\n      this.trace = trace\n\n      // because of the \"first 5\" rule, this may or may not be the slowest\n      if (!this.requestTimes[name] || this.requestTimes[name] < duration) {\n        this.requestTimes[name] = duration\n      }\n    }\n\n    this.config.measureInternal('Transaction/Count', duration)\n  }\n}\n\n/**\n * If there's a slow trace to be sent, encode it and pass it along\n * to the callback, otherwise update the relevant trace diversity settings.\n *\n * @param Function callback The receiver of the encoded trace or errors.\n */\nTraceAggregator.prototype.harvest = function harvest(callback) {\n  var tracesToAggregate = 0\n  var encodedTraces = []\n  var errored = false\n  var normalTrace = null\n\n  // Synthetics\n  for (var i = 0, len = this.syntheticsTraces.length; i < len; ++i) {\n    this.syntheticsTraces[i].generateJSON(resultAggregator)\n    tracesToAggregate++\n  }\n\n  if (this.trace) {\n    var max = this.trace.transaction.agent.config.max_trace_segments\n    if (this.trace.segmentsSeen > max) {\n      logger.warn(\n        'transaction %s contained %d segments, only collecting the fist %d',\n        this.trace.transaction.name,\n        this.trace.segmentsSeen,\n        max\n      )\n    }\n    normalTrace = this.trace\n    this.noTraceSubmitted = 0\n    this.trace.generateJSON(resultAggregator)\n    tracesToAggregate++\n  } else {\n    this.noTraceSubmitted++\n    if (this.noTraceSubmitted >= 5) this.resetTimingTracker()\n  }\n\n  if (tracesToAggregate === 0) {\n    process.nextTick(function cb_nextTick() {\n      callback(null, null, null)\n    })\n  }\n\n  function resultAggregator(err, encoded) {\n    if (errored) {\n      return\n    }\n\n    if (err) {\n      errored = true\n      callback(err)\n    }\n\n    encodedTraces.push(encoded)\n\n    if (encodedTraces.length === tracesToAggregate) {\n      callback(null, encodedTraces, normalTrace)\n    }\n  }\n}\n\n/**\n * Reset the trace diversity settings after a successful harvest.\n *\n * @param {Trace} trace Because the harvest cycle can take a while,\n *                      it's possible a better trace came along\n *                      in the window between the start and end of\n *                      the harvest cycle, so don't throw that away.\n */\nTraceAggregator.prototype.reset = function reset(trace) {\n  this.reported++\n  if (trace === this.trace) this.trace = null\n  this.syntheticsTraces = []\n}\n\n/*eslint-disable */\n/**\n * Determine whether a new trace is more worth keeping than an old one.\n * This gets called on every single transactionFinished event, so return as\n * quickly as possible and call as few external functions as possible. On the\n * converse, there's some complicated logic here, so spell things out.\n *\n * All specifications are from\n * https://newrelic.atlassian.net/wiki/display/eng/Transaction+Trace+Collection+Improvements\n *\n * @param {string} name     Name of this transaction's key metric.\n * @param {number} duration Time the transaction took, in milliseconds.\n * @param {number} apdexT   Apdex tolerating threshold, in seconds.\n */\n/*eslint-enable */\nTraceAggregator.prototype.isBetter = function isBetter(name, duration, apdexT) {\n  /* 1. If the transaction duration is below the tracing threshold, the\n   *    transaction is skipped.\n   *\n   * The threshold for slow traces defaults to apdex_f, which is 4 * apdex_t.\n   */\n  var config = this.config.transaction_tracer\n  var isOverThreshold\n\n  if (config &&\n      config.transaction_threshold &&\n      config.transaction_threshold !== 'apdex_f' &&\n      typeof config.transaction_threshold === 'number') {\n    isOverThreshold = duration > config.transaction_threshold * TO_MILLIS\n  } else {\n    isOverThreshold = duration > 4 * TO_MILLIS * apdexT\n  }\n  if (!isOverThreshold) return false\n\n  /* 2. If the transaction duration is less than the duration of the current\n   *    slow transaction, the transaction is skipped.\n   */\n  var slowerThanExisting = true\n  if (this.trace) {\n    slowerThanExisting = this.trace.getDurationInMillis() < duration\n  }\n  if (!slowerThanExisting) return false\n\n  /* We always gather some slow transactions at the start, regardless of\n   * the size of Top N. This changes the behavior of the rest of the\n   * decision-making process in some subtle ways.\n   */\n  var hasMetGuarantee = this.reported >= 5\n\n  /* 3. If the transaction's name is in the transaction map and its duration\n   *    is less than the response time in the map, it is skipped.\n   */\n  var slowerThanCaptured = true\n  if (hasMetGuarantee) {\n    if (this.requestTimes[name]) {\n      slowerThanCaptured = this.requestTimes[name] < duration\n    }\n  }\n  if (!slowerThanCaptured) return false\n\n  /* Not part of enumerated rules, but necessary for Top N support:\n   * Ensure this name is either already in the request time map\n   * or that the map still hasn't hit capacity.\n   */\n  if (hasMetGuarantee &&\n      !this.requestTimes[name] &&\n      Object.keys(this.requestTimes).length >= this.capacity) {\n    return false\n  }\n\n  /* 4. The transaction is held as the slowest transaction.\n   */\n  return true\n}\n\nmodule.exports = TraceAggregator\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/transaction/trace/aggregator.js\n// module id = 179\n// module chunks = 0","'use strict'\n\nvar path = require('path')\nvar logger = require('./logger')\nvar NAMES = require('./metrics/names')\nvar INSTRUMENTATIONS = require('./instrumentations')()\n\nmodule.exports = {\n  check: check,\n  createMetrics: createMetrics\n}\n\n\n// Special case since we do some hackish stuff in lib/shimmer.js to make pg.js\n// work\nINSTRUMENTATIONS.push('pg.js')\n\n// Static variable holding list of un-instrumented modules for use in the future\nvar uninstrumented = []\n\n// Log a helpful message about un-instrumented modules\nfunction logUninstrumented() {\n  if (uninstrumented.length > 0) {\n    var message =\n      'The newrelic module must be the first module required.\\n' +\n      'The following modules were required before newrelic and are not being ' +\n      'instrumented:'\n\n    uninstrumented.forEach(function buildMessage(module) {\n      message += '\\n\\t' + module.name + ': ' + module.filename\n    })\n\n    logger.warn(message)\n  }\n}\n\n// Create Supportability/Uninstrumented/<module> metrics\n//\n// @param metrics Agent metrics aggregator\nfunction createMetrics(metrics) {\n  if (uninstrumented.length > 0) {\n    metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.UNINSTRUMENTED).incrementCallCount()\n  }\n\n  uninstrumented.forEach(function addMetrics(module) {\n    metrics.getOrCreateMetric(\n      NAMES.SUPPORTABILITY.UNINSTRUMENTED + '/' + module.name\n    ).incrementCallCount()\n  })\n}\n\n// Determine module name from filename of module's main script\n//\n// Heuristic: take the first path name that isn't 'index.js' or 'lib'.\n//\n// @param filename Filename of module's main script\n// @return Name of module\nfunction moduleNameFromFilename(filename) {\n  var name = path.basename(filename, '.js')\n  if (name !== 'index') return name\n\n  var paths = filename.split(path.sep).slice(0, -1)\n  for (var i = paths.length - 1; i >= 0; i--) {\n    if (paths[i] !== 'lib') return paths[i]\n  }\n}\n\n// Check for any instrument-able modules that have already been loaded. This does\n// not check core modules as we don't have access to the core module loader\n// cache. But, users probably are missing instrumentation for other modules if\n// they are missing instrumentation for core modules.\nfunction check() {\n  for (var filename in require.cache) {\n    if (!require.cache.hasOwnProperty(filename)) {\n      continue\n    }\n    var name = moduleNameFromFilename(filename)\n\n    if (INSTRUMENTATIONS.indexOf(name) !== -1) {\n      uninstrumented.push({name: name, filename: filename})\n    }\n  }\n\n  logUninstrumented()\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/uninstrumented.js\n// module id = 180\n// module chunks = 0","'use strict'\n\n// Return a new copy of this array every time we're called\nmodule.exports = function instrumentations() {\n  return [\n    'connect',\n    'bluebird',\n    'director',\n    'express',\n    'generic-pool',\n    'hapi',\n    'memcached',\n    'mongodb',\n    'mysql',\n    'node-cassandra-cql',\n    'cassandra-driver',\n    'pg',\n    'q',\n    'redis',\n    'ioredis',\n    'restify',\n    'oracle'\n  ]\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentations.js\n// module id = 181\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger').child({component: 'query_tracer'})\nvar obfuscate = require('../util/sql/obfuscate')\nvar Stats = require('../stats')\nvar util = require('util')\nvar crypto = require('crypto')\nvar encode = require('../util/codec.js').encode\nvar path = require('path')\n\nvar NR_ROOT = path.resolve(__dirname, '..')\n\nmodule.exports = QueryTracer\n\nfunction QueryTracer(config) {\n  if (!(this instanceof QueryTracer)) {\n    return new QueryTracer(config)\n  }\n  this.samples = {}\n  this.config = config\n}\n\nQueryTracer.prototype.removeShortest = function removeShortest() {\n  var keys = Object.keys(this.samples)\n  var shortest\n\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    var sample = this.samples[keys[i]].trace\n    if (!shortest || shortest.duration > sample.duration) {\n      shortest = sample\n    }\n  }\n\n  delete this.samples[shortest.normalized]\n}\n\nQueryTracer.prototype.merge = function merge(tracer) {\n  var keys = Object.keys(tracer.samples)\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    if (this.samples[keys[i]]) {\n      this.samples[keys[i]].merge(tracer.samples[keys[i]])\n    } else {\n      this.samples[keys[i]] = tracer.samples[keys[i]]\n    }\n  }\n}\n\nQueryTracer.prototype.addQuery = function addQuery(segment, type, query, trace) {\n  var duration = segment.getDurationInMillis()\n\n  if (duration < this.config.transaction_tracer.explain_threshold) return\n\n  var slowQuery = new SlowQuery(segment, type, query, trace)\n\n  switch (this.config.transaction_tracer.record_sql) {\n    case 'raw':\n      logger.info('recording raw sql')\n      segment.parameters.sql = slowQuery.query\n      break\n    case 'obfuscated':\n      logger.info('recording obfuscated sql')\n      segment.parameters.sql_obfuscated = slowQuery.obfuscated\n      break\n    default:\n      logger.info(\n        'not collecting slow-query because transaction_tracer.record_sql was set to %s',\n        this.config.transaction_tracer.record_sql\n      )\n      return\n  }\n  segment.parameters.backtrace = slowQuery.trace\n\n  if (!this.config.slow_sql.enabled) return\n\n  if (this.samples[slowQuery.normalized]) {\n    return this.samples[slowQuery.normalized].aggregate(slowQuery)\n  }\n\n  this.samples[slowQuery.normalized] = new QuerySample(this, slowQuery)\n\n  if (Object.keys(this.samples).length > this.config.slow_sql.max_samples) {\n    this.removeShortest()\n  }\n}\n\nQueryTracer.prototype.prepareJSON = function prepareJSON(done) {\n  var keys = Object.keys(this.samples)\n  var remaining = keys.length\n  var data = []\n\n  if (!remaining) return done(null, data)\n\n  for (var i = 0; i < keys.length; ++i) {\n    this.samples[keys[i]].prepareJSON(collect)\n  }\n\n  function collect(err, json) {\n    if (err) {\n      done(err)\n      // turn callback into a noop so it can't be called more than once\n      done = noop\n      return\n    }\n\n    data.push(json)\n    if (!--remaining) done(null, data)\n  }\n\n  function noop() {}\n}\n\nfunction QuerySample(tracer, slowQuery) {\n  Stats.call(this)\n  this.tracer = tracer\n  this.trace = slowQuery\n  this.aggregate(slowQuery)\n}\n\nutil.inherits(QuerySample, Stats)\n\nQuerySample.prototype.aggregate = function aggregate(slowQuery) {\n  this.recordValue(slowQuery.duration)\n  if (this.trace && this.trace.duration >= slowQuery.duration) return\n  this.trace = slowQuery\n}\n\nQuerySample.prototype.merge = function merge(sample) {\n  Stats.prototype.merge.call(this, sample)\n  if (this.trace.duration < sample.trace.duration) {\n    this.trace = sample.trace\n  }\n}\n\nQuerySample.prototype.prepareJSON = function prepareJSON(done) {\n  var transaction = this.trace.segment.transaction\n  var sample = this\n  var trace = sample.trace\n\n  var params = sample.getParams()\n  if (!this.tracer.config.simple_compression) {\n    encode(params, respond)\n  } else {\n    process.nextTick(respond.bind(null, null, params))\n  }\n\n  function respond(err, data) {\n    if (err) return done(err)\n\n    done(null, [\n      transaction.name,\n      transaction.url || '<unknown>',\n      trace.id,\n      getQuery(sample.tracer.config, trace),\n      trace.metric,\n      sample.callCount,\n      sample.total,\n      sample.min,\n      sample.max,\n      data\n    ])\n  }\n}\n\nQuerySample.prototype.getParams = function getParams() {\n  var segmentParams = this.trace.segment.parameters\n  var params = {\n    backtrace: this.trace.trace,\n  }\n\n  if (segmentParams.host) {\n    params.host = segmentParams.host\n  }\n\n  if (segmentParams.port_path_or_id) {\n    params.port_path_or_id = segmentParams.port_path_or_id\n  }\n\n  if (segmentParams.database_name) {\n    params.database_name = segmentParams.database_name\n  }\n\n  return params\n}\n\nfunction SlowQuery(segment, type, query, trace) {\n  this.obfuscated = obfuscate(query, type)\n  this.normalized = this.obfuscated.replace(/\\?\\s*,\\s*|\\s*/g, '')\n  this.id = normalizedHash(this.normalized)\n  this.segment = segment\n  this.query = query\n  this.metric = segment.name\n  this.trace = formatTrace(trace)\n  this.duration = segment.getDurationInMillis()\n}\n\nfunction normalizedHash(value) {\n  return parseInt(crypto.createHash('md5').update(value).digest('hex').slice(-4), 16)\n}\n\nfunction formatTrace(trace) {\n  // remove error message and instrumentation frames from stack trace\n  return trace ? trace.stack.split('\\n').slice(1).filter(notNR).join('\\n') : ''\n}\n\nfunction notNR(frame) {\n  return frame.indexOf(NR_ROOT) === -1\n}\n\nfunction getQuery(config, trace) {\n  switch (config.transaction_tracer.record_sql) {\n    case 'raw':\n      return trace.query\n    case 'obfuscated':\n      return trace.obfuscated\n    default:\n      return '?'\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/db/tracer.js\n// module id = 182\n// module chunks = 0","'use strict'\n\nmodule.exports = obfuscate\n\nvar singleQuote = /'(?:[^']|'')*?(?:\\\\'.*|'(?!'))/\nvar doubleQuote = /\"(?:[^\"]|\"\")*?(?:\\\\\".*|\"(?!\"))/\nvar dollarQuote = /(\\$(?!\\d)[^$]*?\\$).*?(?:\\1|$)/\nvar oracleQuote = /q'\\[.*?(?:\\]'|$)|q'\\{.*?(?:\\}'|$)|q'\\<.*?(?:\\>'|$)|q'\\(.*?(?:\\)'|$)/\nvar comment = /(?:#|--).*?(?=\\r|\\n|$)/\nvar multilineComment = /\\/\\*(?:[^/]|\\/[^*])*?(?:\\*\\/|\\/\\*.*)/\nvar uuid = /\\{?(?:[0-9a-f]\\-*){32}\\}?/\nvar hex = /0x[0-9a-f]+/\nvar boolean = /true|false|null/\nvar number = /\\b-?(?:[0-9]+\\.)?[0-9]+([eE][+-]?[0-9]+)?/\n\nvar dialects = {}\n\ndialects.mysql = [\n  replacer(join(\n    [doubleQuote, singleQuote, comment, multilineComment, hex, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\"|\\/\\*|\\*\\//)\n]\n\ndialects.postgres = [\n  replacer(join(\n    [dollarQuote, singleQuote, comment, multilineComment, uuid, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\/|\\$/)\n]\n\ndialects.cassandra = [\n  replacer(join(\n    [singleQuote, comment, multilineComment, uuid, hex, boolean, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\//)\n]\n\ndialects.oracle = [\n  replacer(join(\n    [oracleQuote, singleQuote, comment, multilineComment, number],\n    'gi'\n  )),\n  unmatchedPairs(/'|\\/\\*|\\*\\//)\n]\n\nfunction obfuscate(raw, dialect) {\n  if (!dialects[dialect]) throw new Error('Unknown sql implementation')\n  var replacers = dialects[dialect]\n  var obfuscated = raw\n  for (var i = 0, l = replacers.length; i < l; ++i) {\n    obfuscated = replacers[i](obfuscated)\n  }\n\n  return obfuscated\n}\n\nfunction join(expressions, flags) {\n  return new RegExp(expressions.map(toPart).join('|'), flags)\n}\n\nfunction toPart(expressions) {\n  return expressions.toString().slice(1, -1)\n}\n\nfunction replacer(regex) {\n  return function replace(sql) {\n    return sql.replace(regex, '?')\n  }\n}\n\nfunction unmatchedPairs(regex) {\n  return function check(sql) {\n    return regex.test(sql) ? '?' : sql\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/sql/obfuscate.js\n// module id = 183\n// module chunks = 0","'use strict'\n\nvar zlib = require('zlib')\n\nmodule.exports = {\n  /**\n   * Take in an object literal, and deflate and then Base64 encode it.\n   *\n   * zlib works with streams, so this must be used asynchronously.\n   *\n   * @param {object} data\n   *  The data to encode.\n   *\n   * @param {Function} callback\n   *  The callback to take the results. The first parameter is any errors from\n   *  encoding, and the second parameter is the encoded data object.\n   */\n  encode: function encode(data, callback) {\n    try {\n      zlib.deflate(JSON.stringify(data), function cb_deflate(err, raw) {\n        if (err) return callback(err)\n\n        return callback(null, raw.toString('base64'))\n      })\n    } catch (err) {\n      return callback(err)\n    }\n  },\n\n  /**\n   * Base64 decode a string, decompress it, and then turn the results back into\n   * a JavaScript object.\n   *\n   * zlib works with streams, so this must be used asynchronously.\n   *\n   * @param {object} encoded\n   *  The data to decode.\n   *\n   * @param {Function} callback\n   *  The callback to take the results. The first parameter is any errors from\n   *  decoding, and the second parameter is the decoded data object.\n   */\n  decode: function decode(encoded, callback) {\n    zlib.inflate(new Buffer(encoded, 'base64'), function cb_inflate(err, raw) {\n      if (err) return callback(err)\n\n      try {\n        return callback(null, JSON.parse(raw))\n      } catch (error) {\n        return callback(error)\n      }\n    })\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/codec.js\n// module id = 184\n// module chunks = 0","'use strict'\n\nvar path = require('path')\nvar fs = require('fs')\nvar os = require('os')\nvar logger = require('../lib/logger').child({component: 'environment'})\nvar stringifySync = require('./util/safe-json').stringifySync\n\n\nvar exists = fs.existsSync || path.existsSync\n\n// As of 1.7.0 you can no longer dynamically link v8\n// https://github.com/nodejs/io.js/commit/d726a177ed\nvar remapping = {\n  node_install_npm: \"npm installed?\",\n  node_install_waf: \"WAF build system installed?\",\n  node_use_openssl: \"OpenSSL support?\",\n  node_shared_openssl: \"Dynamically linked to OpenSSL?\",\n  node_shared_v8: \"Dynamically linked to V8?\",\n  node_shared_zlib: \"Dynamically linked to Zlib?\",\n  node_use_dtrace: \"DTrace support?\",\n  node_use_etw: \"Event Tracing for Windows (ETW) support?\"\n}\n\nvar settings = {}\n\n/**\n * Fetches the setting of the given name, defaulting to an empty array.\n *\n * @param {string} name - The name of the setting to look for.\n *\n * @return {Array.<string>} An array of values matching that name.\n */\nfunction getSetting(name) {\n  return settings[name] || []\n}\n\n/**\n * Add a setting to the module's shared settings object.\n *\n * @param {string} name   - The name of the setting value being added.\n * @param {string} value  - The value to add or the setting.\n */\nfunction addSetting(name, value) {\n  if (!settings[name]) {\n    settings[name] = [value]\n  } else if (settings[name].indexOf(value) === -1) {\n    settings[name].push(value)\n  }\n}\n\n/**\n * Remove settings with the given name.\n *\n * @param {string} name - The name of the setting to remove.\n */\nfunction clearSetting(name) {\n  delete settings[name]\n}\n\n/**\n * Build up a list of top-level packages available to an application relative to\n * the provided root.\n *\n * @param {string}  root        - Path to start listing packages from.\n * @param {Array}   [packages]  - Array to append found packages to.\n *\n * @return {Array} List of packages.\n */\nfunction listPackages(root, packages) {\n  if (!packages) {\n    packages = []\n  }\n\n  try {\n    fs.readdirSync(root).forEach(function forEachReadDirSync(dir) {\n      // Skip npm's binary directory where it stores executables.\n      if (dir === '.bin') {\n        return\n      }\n\n      var version = null\n      try {\n        var pck = path.resolve(root, dir, 'package.json')\n        version = JSON.parse(fs.readFileSync(pck)).version\n      } catch (e) {\n        logger.info('Could not load %s for environment scan', pck || dir)\n      }\n\n      packages.push([dir, version || '<unknown>'])\n    })\n  } catch (e) {\n    logger.trace(e, 'Failed to list packages in %s', root)\n  }\n\n  return packages\n}\n\n/**\n * Build up a list of dependencies from a given node_module root.\n *\n * @param {string}  root        - Path to start listing dependencies from.\n * @param {Array}   [children]  - Array to append found dependencies to.\n *\n * @return {Array} List of dependencies.\n */\nfunction listDependencies(root, children) {\n  if (!children) {\n    children = []\n  }\n\n  try {\n    fs.readdirSync(root).forEach(function forEachReadDirSync(entry) {\n      var candidate = path.resolve(root, entry, 'node_modules')\n\n      // Performing this exists check is cheaper than unwinding the stack for\n      // all the failed read attempts.\n      if (exists(candidate)) {\n        listPackages(candidate, children)\n        listDependencies(candidate, children)\n      }\n    })\n  } catch (e) {\n    logger.trace(e, 'Failed to list dependencies in %s', root)\n  }\n\n  return children\n}\n\n/**\n * Build up a list of packages, starting from the current directory.\n *\n * @param {string} start - Root directory to start generation from.\n *\n * @return {Object} Two lists, of packages and dependencies, with the\n *  appropriate names.\n */\nfunction getLocalPackages(start) {\n  var packages = []\n  var dependencies = []\n  var candidate = start\n\n  while (candidate) {\n    var root = path.resolve(candidate, 'node_modules')\n    listPackages(root, packages)\n    listDependencies(root, dependencies)\n\n    var last = candidate\n    candidate = path.dirname(candidate)\n    if (last === candidate) break\n  }\n\n  return {packages: packages, dependencies: dependencies}\n}\n\n/**\n * Generic method for getting packages and dependencies relative to a\n * provided root directory.\n *\n * @param {string} root - Where to start looking -- doesn't add node_modules.\n *\n * @return {Object} Two lists, of packages and dependencies, with the\n *  appropriate names.\n */\nfunction getPackages(root) {\n  var packages = []\n  var dependencies = []\n\n  listPackages(root, packages)\n  listDependencies(root, dependencies)\n\n  return {packages: packages, dependencies: dependencies}\n}\n\n/**\n * Generate a list of globally-installed packages, if available / accessible\n * via the environment.\n *\n * @return {Object} Two lists, of packages and dependencies, with the\n *  appropriate names.\n */\nfunction getGlobalPackages() {\n  if (process.config && process.config.variables) {\n    var prefix = process.config.variables.node_prefix\n    if (prefix) {\n      var root = path.resolve(prefix, 'lib', 'node_modules')\n      return getPackages(root)\n    }\n  }\n\n  return {packages: [], dependencies: []}\n}\n\n/**\n * Take a list of packages and reduce it to a list of pairs serialized\n * to JSON (to simplify things on the collector end) where each\n * package appears at most once, with all the versions joined into a\n * comma-delimited list.\n *\n * @return {Array.<String>[]} Sorted list of [name, version] pairs.\n */\nfunction flattenVersions(packages) {\n  var info = Object.create(null)\n  packages.forEach(function cb_forEach(pair) {\n    var p = pair[0]\n    var v = pair[1]\n\n\n    if (info[p]) {\n      if (info[p].indexOf(v) < 0) info[p].push(v)\n    } else {\n      info[p] = [v]\n    }\n  })\n\n  return Object.keys(info)\n    .map(function cb_map(key) {\n      return [key, info[key].join(', ')]\n    })\n    .sort()\n    .map(function cb_map(pair) {\n      return stringifySync(pair)\n    })\n}\n\n/**\n * There are a bunch of settings generated at build time that are useful to\n * know for troubleshooting purposes. These settings are only available in 0.7\n * and up.\n *\n * This function works entirely via side effects using the\n * addSetting function.\n */\nfunction remapConfigSettings() {\n  if (process.config && process.config.variables) {\n    var variables = process.config.variables\n    Object.keys(variables).forEach(function cb_forEach(key) {\n      if (remapping[key]) {\n        var value = variables[key]\n\n        if (value === true || value === 1) value = 'yes'\n        if (value === false || value === 0) value = 'no'\n\n        addSetting(remapping[key], value)\n      }\n    })\n  }\n}\n\n/**\n * Scrape the list of packages, following the algorithm as described in the\n * node module page:\n *\n * http://nodejs.org/docs/latest/api/modules.html\n *\n * This function works entirely via side effects using the addSetting\n * function.\n */\nfunction findPackages() {\n  var local = getLocalPackages(process.cwd())\n  var all = getGlobalPackages()\n  var other = {packages: [], dependencies: []}\n\n\n  if (process.env.NODE_PATH) {\n    var paths\n    if (process.platform === 'win32') { // why. WHY.\n      paths = process.env.NODE_PATH.split(';')\n    } else {\n      paths = process.env.NODE_PATH.split(':')\n    }\n\n    paths.forEach(function cb_forEach(nodePath) {\n      if (nodePath[0] !== '/') nodePath = path.resolve(process.cwd(), nodePath)\n      var nextSet = getPackages(nodePath)\n      other.packages.push.apply(other.packages, nextSet.packages)\n      other.dependencies.push.apply(other.dependencies, nextSet.dependencies)\n    })\n  }\n\n  var packages = local.packages\n  packages.push.apply(packages, all.packages)\n  packages.push.apply(packages, other.packages)\n\n  var dependencies = local.dependencies\n  dependencies.push.apply(dependencies, all.dependencies)\n  dependencies.push.apply(dependencies, other.dependencies)\n\n  var home\n  var homeOld\n\n  if (process.platform === 'win32') {\n    if (process.env.USERDIR) {\n      home = getPackages(path.resolve(process.env.USERDIR, '.node_modules'))\n      homeOld = getPackages(path.resolve(process.env.USERDIR, '.node_libraries'))\n    }\n  } else if (process.env.HOME) {\n    home = getPackages(path.resolve(process.env.HOME, '.node_modules'))\n    homeOld = getPackages(path.resolve(process.env.HOME, '.node_libraries'))\n  }\n\n  if (home) {\n    packages.unshift.apply(packages, home.packages)\n    dependencies.unshift.apply(dependencies, home.dependencies)\n  }\n\n  if (homeOld) {\n    packages.unshift.apply(packages, homeOld.packages)\n    dependencies.unshift.apply(dependencies, homeOld.dependencies)\n  }\n\n  addSetting('Packages', flattenVersions(packages))\n  addSetting('Dependencies', flattenVersions(dependencies))\n}\n\nfunction badOS() {\n  var badVersion = false\n\n  if (!process.versions) {\n    badVersion = true\n  } else {\n    var version = process.versions.node.split('.')\n    if (version[1] <= 8 && version[2] <= 5) badVersion = true\n  }\n\n  return badVersion &&\n         os.arch() === 'x64' &&\n         os.type() === 'SunOS'\n}\n\n/**\n * Settings actually get scraped below.\n */\nfunction gatherEnv() {\n  // in 64-bit SmartOS zones, node <= 0.8.5 pukes on os.cpus()\n  if (!badOS()) addSetting('Processors', os.cpus().length)\n\n  addSetting('OS', os.type())\n  addSetting('OS version', os.release())\n  addSetting('Node.js version', process.version)\n  addSetting('Architecture', process.arch)\n\n  if ('NODE_ENV' in process.env) {\n    addSetting('NODE_ENV', process.env.NODE_ENV)\n  }\n}\n\n/**\n * Reset settings and gather them, built to minimally refactor this file.\n */\nfunction refresh() {\n  // gather persisted settings\n  var framework = getSetting('Framework')\n  var dispatcher = getSetting('Dispatcher')\n  var packages = getSetting('Packages')\n  var dependencies = getSetting('Dependencies')\n\n  // clearing and rebuilding a global variable\n  settings = {}\n  // add persisted settings\n  if (framework.length) {\n    framework.forEach(function addFrameworks(fw) {\n      addSetting('Framework', fw)\n    })\n  }\n\n  if (dispatcher.length) {\n    dispatcher.forEach(function addDispatchers(d) {\n      addSetting('Dispatcher', d)\n    })\n  }\n\n  gatherEnv()\n  remapConfigSettings()\n\n  if (packages.length && dependencies.length) {\n    settings.Packages = packages\n    settings.Dependencies = dependencies\n  } else {\n    findPackages()\n  }\n}\n\n// initialize settings\n// TODO:  Remove this function call and make all environment loading async. At\n//        the moment, removing this causes tests to fail and it is unclear if it\n//        is an issue in the tests or in the agent.\nrefresh()\n\n/**\n * Refreshes settings and returns the settings object.\n */\nfunction toJSON() {\n  // TODO:  Do not refresh when JSON-ifying. This takes a _long_ time and blocks\n  //        the event loop. Currently, removing this causes a couple of tests to\n  //        fail (ironically from timing out).\n  refresh()\n  var items = []\n  Object.keys(settings).forEach(function settingKeysForEach(key) {\n    settings[key].forEach(function settingsValuesForEach(setting) {\n      items.push([key, setting])\n    })\n  })\n\n  return items\n}\n\nmodule.exports = {\n  setFramework: function setFramework(framework) {\n    addSetting('Framework', framework)\n  },\n  setDispatcher: function setDispatcher(dispatcher) {\n    addSetting('Dispatcher', dispatcher)\n  },\n  clearFramework: function clearFramework() {\n    clearSetting('Framework')\n  },\n  clearDispatcher: function clearDispatcher() {\n    clearSetting('Dispatcher')\n  },\n  listPackages: listPackages,\n  toJSON: toJSON,\n  get: getSetting,\n  refresh: refresh\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/environment.js\n// module id = 185\n// module chunks = 0","'use strict'\n\nvar Transaction = require('../index.js')\nvar logger = require('../../logger').child({component: 'tracer'})\n\n/*\n * CONSTANTS\n */\nvar ORIGINAL = '__NR_original'\nvar SEGMENT = '__NR_segment'\n\n\nmodule.exports = Tracer\n\nfunction Tracer(agent) {\n  if (!agent) throw new Error(\"Must be initialized with an agent.\")\n\n  this.agent = agent\n  this._segment = null\n}\n\nTracer.prototype.getTransaction = getTransaction\nTracer.prototype.getSegment = getSegment\nTracer.prototype.createSegment = createSegment\nTracer.prototype.addSegment = addSegment\nTracer.prototype.transactionProxy = transactionProxy\nTracer.prototype.transactionNestProxy = transactionNestProxy\nTracer.prototype.bindFunction = bindFunction\nTracer.prototype.bindEmitter = bindEmitter\nTracer.prototype.getOriginal = getOriginal\nTracer.prototype.getSegmentFromWrapped = getSegmentFromWrapped\nTracer.prototype.slice = argSlice\nTracer.prototype.wrapFunctionNoSegment = wrapFunctionNoSegment\nTracer.prototype.wrapFunctionFirstNoSegment = wrapFunctionFirstNoSegment\nTracer.prototype.wrapFunction = wrapFunction\nTracer.prototype.wrapFunctionLast = wrapFunctionLast\nTracer.prototype.wrapFunctionFirst = wrapFunctionFirst\nTracer.prototype.wrapSyncFunction = wrapSyncFunction\nTracer.prototype.wrapCallback = wrapCallback\n\nObject.defineProperty(Tracer.prototype, 'segment', {\n  get: function segmentGetter() {\n    return this._segment\n  },\n  set: function segmentSetter(segment) {\n    this._segment && this._segment.probe('Segment removed from tracer')\n    segment && segment.probe('Set tracer.segment')\n    return this._segment = segment\n  }\n})\n\nfunction getTransaction() {\n  if (this.segment && this.segment.transaction && this.segment.transaction.isActive()) {\n    return this.segment.transaction\n  }\n\n  return null\n}\n\nfunction getSegment() {\n  return this.segment\n}\n\nfunction createSegment(name, recorder, _parent) {\n  var parent = _parent || this.segment\n  if (!parent || !parent.transaction.isActive()) {\n    logger.trace({\n      hasParent: !!parent,\n      transactionActive: (parent && parent.transaction.isActive())\n    }, 'Not creating segment %s, no parent or active transaction available.', name)\n    return null\n  }\n  return parent.add(name, recorder)\n}\n\nfunction addSegment(name, recorder, parent, full, task) {\n  if (typeof task !== 'function') {\n    throw new Error('task must be a function')\n  }\n\n  var segment = this.createSegment(name, recorder, parent)\n\n  return this.bindFunction(task, segment, full)(segment)\n}\n\nfunction transactionProxy(handler) {\n  // if there's no handler, there's nothing to proxy.\n  if (typeof handler !== 'function') return handler\n\n  var tracer = this\n  var wrapped = function wrapTransactionInvocation() {\n    // don't nest transactions, reuse existing ones\n    var transaction = tracer.getTransaction()\n    if (transaction) {\n      if (transaction.traceStacks) {\n        var segment = tracer.segment\n        segment.probe('!!! Nested transaction creation !!!')\n        transaction.traceFlag = true // Will log the stacks when it ends.\n        logger.warn({\n          transaction: {id: transaction.id, name: transaction.getName()},\n          segment: segment.name\n        }, 'Active transaction when creating non-nested transaction')\n      }\n      return handler.apply(this, arguments)\n    }\n    transaction = new Transaction(tracer.agent)\n    return tracer.bindFunction(handler, transaction.trace.root).apply(this, arguments)\n  }\n\n  wrapped[ORIGINAL] = handler\n\n  return wrapped\n}\n\n\n// FLAG: custom_instrumentation\n/**\n * Use transactionNestProxy to wrap a closure that is a top-level handler that\n * is meant to start transactions. This wraps the first half of asynchronous\n * handlers. Use bindFunction to wrap handler callbacks. This detects to see\n * if there is an in play segment and uses that as the root instead of\n * transaction.trace.root.\n *\n * @param {Function} handler Generator to be proxied.\n * @returns {Function} Proxy.\n */\n\nfunction transactionNestProxy(type, handler) {\n  if (handler === undefined && typeof type === 'function') {\n    handler = type\n    type = undefined\n  }\n  // if there's no handler, there's nothing to proxy.\n  if (typeof handler !== 'function') return handler\n\n  var tracer = this\n  var wrapped = function wrapTransactionInvocation() {\n    // don't nest transactions, reuse existing ones\n    var transaction = tracer.getTransaction()\n    var segment = tracer.segment\n\n    var createNew = false\n\n    if (!transaction) {\n      createNew = true\n    } else if (type === 'web' && transaction.bgSegment) {\n      createNew = true\n    } else if (type === 'bg' && transaction.webSegment) {\n      createNew = true\n    }\n\n    if (createNew) {\n      transaction = new Transaction(tracer.agent)\n      segment = transaction.trace.root\n    }\n\n    return tracer.bindFunction(handler, segment).apply(this, arguments)\n  }\n\n  wrapped[ORIGINAL] = handler\n\n  return wrapped\n}\n\nfunction bindFunction(handler, segment, full) {\n  if (typeof handler !== 'function') {\n    return handler\n  }\n\n  var tracer = this\n  var active = typeof segment === 'undefined' ? tracer.segment : segment\n\n  wrapped[ORIGINAL] = handler[ORIGINAL] || handler\n  wrapped[SEGMENT] = active\n\n  return wrapped\n\n  function wrapped() {\n    var prev = tracer.segment\n    tracer.segment = active\n    if (active && full) segment.start()\n    try {\n      var result = handler.apply(this, arguments)\n    } catch (err) {\n      logger.trace(err, \"Error from wrapped function:\")\n\n      if (prev === null && process.domain != null) {\n        process.domain.__NR_transactionSegment = tracer.segment\n      }\n\n      throw err\n    } finally {\n      if (active && full) segment.touch()\n      tracer.segment = prev\n    }\n    return result\n  }\n}\n\nfunction getOriginal(fn) {\n  return fn && fn[ORIGINAL] ? fn[ORIGINAL] : fn\n}\n\nfunction getSegmentFromWrapped(fn) {\n  return fn && fn[SEGMENT] ? fn[SEGMENT] : null\n}\n\nfunction bindEmitter(emitter, segment) {\n  if (!emitter || !emitter.emit) return emitter\n\n  var tracer = this\n  var active = segment || this.segment\n  var emit = emitter.emit[ORIGINAL] || emitter.emit\n  emitter.emit = wrappedEmit\n  emitter.emit[ORIGINAL] = emit\n\n  return emitter\n\n  function wrappedEmit() {\n    return tracer.bindFunction(emit, active).apply(this, arguments)\n  }\n}\n\nfunction argSlice(args) {\n  /**\n   * Usefully nerfed version of slice for use in instrumentation. Way faster\n   * than using [].slice.call, and maybe putting it in here (instead of the\n   * same module context where it will be used) will make it faster by\n   * defeating inlining.\n   *\n   *   http://jsperf.com/array-slice-call-arguments-2\n   *\n   *  for untrustworthy benchmark numbers. Only useful for copying whole\n   *  arrays, and really only meant to be used with the arguments array like.\n   *\n   *  Also putting this comment inside the function in an effort to defeat\n   *  inlining.\n   *\n   */\n  var length = args.length\n  var array = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    array[i] = args[i]\n  }\n\n  return array\n}\n\nfunction wrapFunctionNoSegment(original, name, wrapper) {\n  if (typeof original !== 'function') return original\n\n  logger.trace('Wrapping function %s (no segment)', name || original.name || 'anonymous')\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    if (!tracer.getTransaction()) return original.apply(this, arguments)\n    var args = tracer.slice(arguments)\n\n    if (wrapper === undefined) {\n      var last = args.length - 1\n      var cb = args[last]\n      if (typeof cb === 'function') {\n        args[last] = tracer.bindFunction(cb)\n      }\n    } else {\n      args = wrapper(args)\n    }\n    return original.apply(this, args)\n  }\n}\n\nfunction wrapFunctionFirstNoSegment(original, name) {\n  if (typeof original !== 'function') return original\n\n  logger.trace('Wrapping function %s (no segment)', name || original.name || 'anonymous')\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    if (!tracer.getTransaction()) return original.apply(this, arguments)\n    var args = tracer.slice(arguments)\n    var cb = args[0]\n    if (typeof cb === 'function') {\n      args[0] = tracer.bindFunction(cb)\n    }\n    return original.apply(this, args)\n  }\n}\n\nfunction wrapFunctionLast(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name)\n    return original\n  }\n\n  logger.trace('Wrapping %s as a callback-last function', name)\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name)\n      return original.apply(this, arguments)\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id)\n    var args = tracer.slice(arguments)\n    var last = args.length - 1\n    var cb = args[last]\n    if (typeof cb !== 'function') return original.apply(this, arguments)\n    var child = tracer.createSegment(name, recorder)\n    args[last] = tracer.wrapCallback(cb, child, wrappedCallback)\n    child.start()\n    return tracer.bindFunction(original, child).apply(this, args)\n\n    function wrappedCallback() {\n      logger.trace('Ending \"%s\" segment for transaction %s.', name, transaction.id)\n      child.touch()\n      return cb.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapFunctionFirst(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name)\n    return original\n  }\n\n  logger.trace('Wrapping %s as a callback-first function', name)\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name)\n      return original.apply(this, arguments)\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id)\n    var args = tracer.slice(arguments)\n    var cb = args[0]\n    if (typeof cb !== 'function') return original.apply(this, arguments)\n    var child = tracer.createSegment(name, recorder)\n    args[0] = tracer.wrapCallback(cb, child, wrappedCallback)\n    child.start()\n    return tracer.bindFunction(original, child).apply(this, args)\n\n    function wrappedCallback() {\n      logger.trace('Ending \"%s\" segment for transaction %s.', name, transaction.id)\n      child.touch()\n      var result = cb.apply(this, arguments)\n      return result\n    }\n  }\n}\n\nfunction wrapFunction(name, recorder, original, wrapper, resp) {\n  if (typeof original !== 'function' || !wrapper) {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name)\n    return original\n  }\n\n  logger.trace('Wrapping %s using a custom wrapper', name)\n\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name)\n      return original.apply(this, arguments)\n    }\n\n    logger.trace('Creating \"%s\" segment for transaction %s.', name, transaction.id)\n\n    var child = tracer.createSegment(name, recorder)\n    var args = wrapper.call(this, child, tracer.slice(arguments), bind)\n    child.start()\n    var result = tracer.bindFunction(original, child).apply(this, args)\n    if (resp) result = resp.call(this, child, result, bind)\n    return result\n\n    function bind(fn) {\n      if (!fn) return fn\n      return tracer.wrapCallback(fn, child, function nrWrappedHandler() {\n        logger.trace('Touching \"%s\" segment for transaction %s.', name, transaction.id)\n        child.touch()\n        return fn.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction wrapSyncFunction(name, recorder, original) {\n  if (typeof original !== 'function') {\n    logger.trace('Not wrapping \"%s\" because it was not a function', name)\n    return original\n  }\n\n  logger.trace('Wrapping \"%s\" as a synchronous function', name)\n\n  var tracer = this\n\n  return wrappedFunction\n\n  function wrappedFunction() {\n    var transaction = tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('Not creating segment \"%s\" because no transaction was active', name)\n      return original.apply(this, arguments)\n    }\n    logger.trace('Creating \"%s\" sync segment for transaction %s.', name, transaction.id)\n    var child = tracer.createSegment(name, recorder)\n    if (child) child.async = false\n    return tracer.bindFunction(original, child, true).apply(this, arguments)\n  }\n}\n\nfunction wrapCallback(original, segment, wrapped) {\n  var tracer = this\n\n  if (typeof original !== 'function') return original\n\n  logger.trace(\n    'Wrapping callback for \"%s\" segment',\n    segment ? segment.name : 'unknown'\n  )\n\n  return tracer.bindFunction(function wrappedCallback() {\n    if (wrapped) wrapped[ORIGINAL] = original\n\n    var child = tracer.createSegment(\n      'Callback: ' + (original.name || 'anonymous'),\n      null,\n      segment\n    )\n\n    if (child) child.async = false\n\n    return tracer.bindFunction(wrapped || original, child, true).apply(this, arguments)\n  }, segment, false)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/transaction/tracer/index.js\n// module id = 186\n// module chunks = 0","'use strict'\n\nvar urltils = require('../util/urltils.js')\nvar Metrics = require('../metrics')\nvar Timer = require('../timer.js')\nvar Trace = require('./trace')\nvar NAMES = require('../metrics/names.js')\nvar hashes = require('../util/hashes')\nvar util = require('util')\nvar url = require('url')\nvar NameState = require('./name-state.js')\nvar logger = require('../logger').child({component: 'transaction'})\n\n/*\n *\n * CONSTANTS\n *\n */\nvar FROM_MILLIS = 1e-3\n/**\n * Bundle together the metrics and the trace segment for a single agent\n * transaction.\n *\n * @param {Object} agent The agent.\n */\nfunction Transaction(agent) {\n  if (!agent) throw new Error('every transaction must be bound to the agent')\n\n  this.traceFlag = false\n  if (agent.config.logging.diagnostics) {\n    this.traceStacks = []\n  } else {\n    this.traceStacks = null\n  }\n\n  this.agent = agent\n  this.metrics = new Metrics(\n    agent.config.apdex_t,\n    agent.mapper,\n    agent.metricNameNormalizer\n  )\n\n  agent.activeTransactions++\n\n  this.numSegments = 0\n\n  // This number needs to be unique so the previous method of picking 1337 then\n  // incrementing it no longer works. 1e17 should always result in a whole\n  // number, but just in case we floor it so we don't end up with decimals. Then\n  // we make it hex because other agents use a hex based transaction id.\n  this.id = Math.floor((Math.random() * 1e17)).toString(16)\n\n  this.trace = new Trace(this)\n  this.exceptions = []\n  this.userErrors = []\n  this.timer = new Timer()\n  this.timer.begin()\n\n  this._recorders = []\n  this._intrinsicAttributes = {}\n  this._partialName = null\n\n  // hidden class optimization\n  this.bgSegment = null\n  this.catResponseTime = 0\n  this.error = null\n  this.forceIgnore = null\n  this.forceName = null\n  this.ignore = false\n  this.incomingCatId = null\n  this.name = null\n  this.nameState = new NameState(null, null, null, null)\n  this.pathHashes = []\n  this.queueTime = 0\n  this.referringPathHash = null\n  this.referringTransactionGuid = null\n  this.invalidIncomingExternalTransaction = false\n  this.statusCode = null\n  this.syntheticsHeader = null\n  this.syntheticsData = null\n  this.url = null\n  this.parsedUrl = null\n  this.verb = null\n  this.webSegment = null\n\n  this.probe('Transaction created', {id: this.id})\n}\n\nTransaction.prototype.probe = function probe(action, extra) {\n  if (this.traceStacks) {\n    this.traceStacks.push({\n      stack: (new Error(action)).stack.split('\\n'),\n      extra: extra\n    })\n  }\n}\n\n/**\n * Add a clear API method for determining whether a transaction is web or\n * background.\n *\n * @returns {boolean} Whether this transaction has a URL.\n */\nTransaction.prototype.isWeb = function isWeb() {\n  return this.url ? true : false\n}\n\n/**\n * @return {bool} Is this transaction still alive?\n */\nTransaction.prototype.isActive = function isActive() {\n  return this.timer.isActive()\n}\n\n/**\n * Close out the current transaction and its associated trace. Remove any\n * instances of this transaction annotated onto the call stack.\n */\nTransaction.prototype.end = function end(done) {\n  if (!this.timer.isActive()) return\n  if (this.traceFlag) {\n    logger.warn(\n      {segment: {name: this.name, stacks: this.traceStacks}},\n      'Flagged transaction ended.'\n    )\n  }\n\n  var transaction = this\n\n  transaction.trace.end()\n  process.nextTick(function nextTickedEnd() {\n    // recorders must be run before the trace is collected\n    if (!transaction.ignore) {\n      transaction.record()\n    }\n\n    transaction.agent.emit('transactionFinished', transaction)\n    if (typeof done === 'function') {\n      done(transaction)\n    }\n  })\n\n  transaction.timer.end()\n}\n\n/**\n * For web transactions, this represents the time from when the request was received\n * to when response was sent.  For background transactions, it is equal to duration\n * of the transaction trace (until last segment ended).\n */\nTransaction.prototype.getResponseTimeInMillis = function getResponseTimeInMillis() {\n  if (this.isWeb()) {\n    return this.timer.getDurationInMillis()\n  }\n  return this.trace.getDurationInMillis()\n}\n\nTransaction.prototype.applyUserNamingRules = function applyUserNamingRules(requestUrl) {\n  // 1. user normalization rules (set in configuration)\n  var normalized = this.agent.userNormalizer.normalize(requestUrl)\n  if (normalized.ignore) {\n    this.ignore = true\n  }\n  if (normalized.matched) {\n    this._partialName = NAMES.NORMALIZED + normalized.value\n  }\n}\n\nTransaction.prototype.setPartialName = function setPartialName(name) {\n  this._partialName = name\n}\n\n/**\n * Sets the name of this transaction, figuring out along the way whether the\n * transaction should be ignored. Should run as late in the transaction's\n * lifetime as possible.\n *\n * Works entirely via side effects.\n *\n * @param {string} requestURL The URL to extract the name from.\n * @param {string} statusCode The HTTP status code from the response.\n */\nTransaction.prototype.setName = function setName(requestURL, statusCode) {\n  logger.trace({requestURL: requestURL, statusCode: statusCode, transactionId: this.id,\n    transactionName: this.name}, 'Setting transaction name')\n\n  this._partialName = this.nameState.getName()\n  this.url = urltils.scrub(requestURL)\n  this.statusCode = statusCode\n\n  // 1. name set by the api\n  if (this.forceName !== null) {\n    this._partialName = this.forceName\n  }\n\n  // 2. user normalization rules (set in configuration)\n  // can override transaction naming from API\n  this.applyUserNamingRules(this.url)\n\n  // 3. URL normalization rules (sent by server)\n  // Nothing has already set a name for this transaction, so normalize and\n  // potentially apply the URL backstop now. Only do so if no user rules\n  // matched.\n  if (!this._partialName) {\n    var normalized = this.agent.urlNormalizer.normalize(this.url)\n    if (normalized.ignore) {\n      this.ignore = true\n    }\n    this._partialName = normalized.value\n  }\n\n  // 4. transaction name normalization rules (sent by server)\n  var fullName = NAMES.WEB.RESPONSE_TIME + '/' + this._partialName\n  normalized = this.agent.transactionNameNormalizer.normalize(fullName)\n  if (normalized.ignore) {\n    this.ignore = true\n  }\n  this.name = normalized.value\n\n  // 5. transaction segment term normalizer\n  this.name = this.agent.txSegmentNormalizer.normalize(this.name).value\n\n  // Allow the API to explicitly set the ignored status.\n  if (this.forceIgnore !== null) {\n    this.ignore = this.forceIgnore\n  }\n\n  logger.trace({transactionId: this.id, transactionName: this.name},\n    'Finished setting transaction name')\n}\n\n\nTransaction.prototype.setBackgroundName = function setBackgroundName(name, group) {\n  this._partialName = group + NAMES.ACTION_DELIMITER + name\n\n  var fullName = NAMES.BACKGROUND.RESPONSE_TIME\n    + NAMES.ACTION_DELIMITER + this._partialName\n\n  // Transaction normalizers run on the full metric name, not the user facing\n  // transaction name.\n  var normalized = this.agent.transactionNameNormalizer.normalize(fullName)\n  if (normalized.ignore) {\n    this.ignore = true\n  }\n  this.name = normalized.value\n\n  if (this.forceIgnore !== null) {\n    this.ignore = this.forceIgnore\n  }\n}\n\n/**\n * Gets the transaction name safely.\n *\n * Gathering the transaction name for WebTransactions is risky complicated\n * business. OtherTransactions (aka background) are much simpler as they are\n * always fully specified by the user at creation time.\n *\n * This has the potential of causing the normalizers run extra times, which can\n * cause extra performance overhead. Once this is refactored we can make the\n * caching better and eliminate this extra overhead. Be mindful of if/when this\n * is called.\n */\nTransaction.prototype.getName = function getName() {\n  // Detect web transactions as they are more complex.\n  if (this.isWeb() && !this.name) {\n    // Save and restore the partial name, as some instrumentation relies on it\n    // not being set to detect if it should set the transaction name.\n    var tempPartialName = this._partialName\n    this.setName(this.url, this.statusCode)\n    this._partialName = tempPartialName\n  }\n  return this.name\n}\n\n/**\n * Returns the full URL of the transaction with query, search, or hash portions\n * removed. This is only applicable for web transactions.\n *\n * Caches to ._scrubbedUrl, pulls in from .parsedUrl if it is available,\n * otherwise it will parse .url, store it on .parsedUrl, then scrub the URL and\n * store it in the cache.\n *\n * Returns a string or undefined.\n */\nTransaction.prototype.getScrubbedUrl = function getScrubbedUrl() {\n  if (!this.isWeb()) return\n  if (this._scrubbedUrl) return this._scrubbedUrl\n\n  // If we don't have a parsedUrl, lets populate it from .url\n  if (!this.parsedUrl) {\n    // At time of writing .url should always be set by the time we get here\n    // because that is what .isWeb() checks against. In the future it may be\n    // instead checking a enum or other property so guard ourselves just in\n    // case.\n    if (!this.url) return\n    this.parsedUrl = url.parse(this.url)\n  }\n\n  var scrubbedParsedUrl = util._extend({}, this.parsedUrl)\n  scrubbedParsedUrl.search = null\n  scrubbedParsedUrl.query = null\n  scrubbedParsedUrl.href = null\n  scrubbedParsedUrl.path = null\n  scrubbedParsedUrl.hash = null\n\n  this._scrubbedUrl = url.format(scrubbedParsedUrl)\n\n  return this._scrubbedUrl\n}\n\n/**\n * The instrumentation associates metrics with the different kinds of trace\n * segments. The metrics recorders are dependent on the transaction name to\n * collect their scoped metrics, and so must wait for the transaction's\n * name to be finalized before the recording process. Segments are only\n * responsible for their own life cycle, so responsibility for understanding\n * when the transaction name has been finalized is handed off to the trace,\n * which for now defers running these recorders until the trace is ended.\n *\n * @param {Function} recorder The callback which records metrics. Takes a\n *                            single parameter, which is the transaction's\n *                            name.\n */\nTransaction.prototype.addRecorder = function addRecorder(recorder) {\n  this._recorders.push(recorder)\n}\n\n/**\n * Run the metrics recorders for this trace. If the transaction's name /\n * scope hasn't been set yet, the recorder will be passed an undefined name,\n * and should be written to handle this.\n */\nTransaction.prototype.record = function record() {\n  var name = this.name\n  for (var i = 0, l = this._recorders.length; i < l; ++i) {\n    this._recorders[i](name)\n  }\n}\n\n/**\n * Measure the duration of an operation named by a metric, optionally\n * belonging to a scope.\n *\n * @param {string} name The name of the metric to gather.\n * @param {string} scope (optional) Scope to which the metric is bound.\n * @param {number} duration The time taken by the operation, in milliseconds.\n * @param {number} exclusive The time exclusively taken by an operation, and\n *                           not its children.\n */\nTransaction.prototype.measure = function measure(name, scope, duration, exclusive) {\n  this.metrics.measureMilliseconds(name, scope, duration, exclusive)\n}\n\n/**\n * Based on the status code and the duration of a web transaction, either\n * mark the transaction as frustrating, or record its time for apdex purposes.\n *\n * @param {string} name     Metric name.\n * @param {number} duration Duration of the transaction, in milliseconds.\n * @param {number} keyApdex A key transaction apdexT, in milliseconds\n *                          (optional).\n */\nTransaction.prototype._setApdex = function _setApdex(name, duration, keyApdexInMillis) {\n  var apdexStats = this.metrics.getOrCreateApdexMetric(name, null, keyApdexInMillis)\n  if (urltils.isError(this.agent.config, this.statusCode)) {\n    apdexStats.incrementFrustrating()\n  } else {\n    apdexStats.recordValueInMillis(duration, keyApdexInMillis)\n  }\n}\n\n/**\n * Store first 10 unique path hashes calculated for a transaction.\n *\n * @param {string} pathHash Path hash\n */\nTransaction.prototype.pushPathHash = function pushPathHash(pathHash) {\n  if (this.pathHashes.length >= 10 || this.pathHashes.indexOf(pathHash) !== -1) return\n  this.pathHashes.unshift(pathHash)\n}\n\n/**\n * Return whether transaction spawned any outbound requests.\n */\nTransaction.prototype.includesOutboundRequests = function includesOutboundRequests() {\n  return this.pathHashes.length > 0\n}\n\n/**\n * Get unique previous path hashes for a transaction. Does not include\n * current path hash.\n */\nTransaction.prototype.alternatePathHashes = function alternatePathHashes() {\n  var curHash = hashes.calculatePathHash(\n    this.agent.config.applications()[0],\n    this.name || this._partialName || this.nameState.getName(),\n    this.referringPathHash\n  )\n  var altHashes = this.pathHashes.slice()\n  var curIndex = altHashes.indexOf(curHash)\n\n  if (curIndex !== -1) altHashes.splice(curIndex, 1)\n\n  return altHashes.length === 0 ? null : altHashes.sort().join(',')\n}\n\nTransaction.prototype.cleanup = function cleanup() {\n  if (this.trace) this.trace.cleanup()\n}\n\n/**\n * Associate an exception with the transaction.  When the transaction ends,\n * the exception will be collected along with the transaction details.\n *\n * @param {Error}   exception         The exception to be collected.\n * @param {object}  customParameters  Any custom parameters associated with\n *                                    the request (optional).\n * @param {number}  timestamp         The timestamp for when the exception occurred.\n */\nTransaction.prototype.addException = _addException\n\nfunction _addException(exception, customParameters, timestamp) {\n  this.exceptions.push([exception, customParameters, timestamp])\n}\n\n/**\n * Associate a user error (reported using the noticeError() API) with the transaction.\n * When the transaction ends, the exception will be collected along with the transaction\n * details.\n *\n * @param {Error}   exception         The exception to be collected.\n * @param {object}  customParameters  Any custom parameters associated with\n *                                    the request (optional).\n * @param {number}  timestamp         The timestamp for when the exception occurred.\n */\nTransaction.prototype.addUserError = _addUserError\n\nfunction _addUserError(exception, customParameters, timestamp) {\n  this.userErrors.push([exception, customParameters, timestamp])\n}\n\n/**\n * Returns true if an error happened during the transaction or if the transaction itself\n * is considered to be an error.\n */\nTransaction.prototype.hasErrors = function _hasErrors() {\n  var isErroredTransaction = urltils.isError(this.agent.config, this.statusCode)\n  var transactionHasExceptions = this.exceptions.length > 0\n  var transactionHasuserErrors = this.userErrors.length > 0\n  return (transactionHasExceptions || transactionHasuserErrors || isErroredTransaction)\n}\n\nTransaction.prototype.addAgentAttribute = function addAgentAttribute(key, value) {\n  if (this.agent.config.ignored_params.indexOf(key) === -1) {\n    this.trace.addParameter(key, value)\n  }\n}\n\n/**\n * Returns agent intrinsic attribute for this transaction.\n */\nTransaction.prototype.getIntrinsicAttributes = function getIntrinsicAttributes() {\n  if (!this._intrinsicAttributes.totalTime) {\n    var config = this.agent.config\n    this._intrinsicAttributes.totalTime =\n      this.trace.getTotalTimeDurationInMillis() * FROM_MILLIS\n\n    // FLAG: cat\n    if (config.feature_flag.cat) {\n      this._intrinsicAttributes.path_hash = hashes.calculatePathHash(\n        config.applications()[0],\n        this.name || this._partialName,\n        this.referringPathHash\n      )\n      this._intrinsicAttributes.trip_id = this.tripId || this.id\n      if (this.referringTransactionGuid) {\n        this._intrinsicAttributes.referring_transaction_guid =\n          this.referringTransactionGuid\n      }\n      if (config.cross_process_id) {\n        this._intrinsicAttributes.client_cross_process_id = config.cross_process_id\n      }\n    }\n\n    // FLAG: synthetics\n    if (config.feature_flag.synthetics) {\n      var data = this.syntheticsData\n\n      if (data) {\n        this._intrinsicAttributes.synthetics_resource_id = data.resourceId\n        this._intrinsicAttributes.synthetics_job_id = data.jobId\n        this._intrinsicAttributes.synthetics_monitor_id = data.monitorId\n      }\n    }\n  }\n  return util._extend({}, this._intrinsicAttributes)\n}\n\nmodule.exports = Transaction\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/transaction/index.js\n// module id = 187\n// module chunks = 0","'use strict'\n\nvar codec = require('../../util/codec')\nvar copy = require('../../util/copy')\nvar Segment = require('./segment')\nvar NAMES = require('../../metrics/names.js')\n\n/*\n *\n * CONSTANTS\n *\n */\nvar FROM_MILLIS = 1e-3\n\n/**\n * A Trace holds the root of the Segment graph and produces the final\n * serialization of the transaction trace.\n *\n * @param {Transaction} transaction The transaction bound to the trace.\n */\nfunction Trace(transaction) {\n  if (!transaction) throw new Error('All traces must be associated with a transaction.')\n\n  this.transaction = transaction\n\n  this.root = new Segment(transaction, 'ROOT')\n  this.root.start()\n\n  this.custom = {}\n  this.intrinsics = {}\n  this.segmentsSeen = 0\n  this.totalTimeCache = null\n\n  // hidden class optimization\n  this.parameters = {}\n\n  // sending displayName if set by user\n  var displayName = transaction.agent.config.getDisplayHost()\n  var hostName = transaction.agent.config.getHostnameSafe()\n  if (displayName !== hostName) {\n    this.parameters['host.displayName'] = displayName\n  }\n  this.domain = null\n}\n\n/**\n * End and close the current trace. Triggers metric recording for trace\n * segments that support recording.\n */\nTrace.prototype.end = function end() {\n  var segments = [this.root]\n\n  while (segments.length) {\n    var segment = segments.pop()\n    if (segment.timer.softEnd()) {\n      segment._updateRootTimer()\n      // timer.softEnd() returns true if the timer was ended prematurely, so\n      // in that case we can name the segment as truncated\n      segment.name = NAMES.TRUNCATED.PREFIX + segment.name\n    }\n    segments = segments.concat(segment.getChildren())\n  }\n}\n\n/**\n * Add a child to the list of segments.\n *\n * @param {string} childName Name for the new segment.\n * @returns {Segment} Newly-created Segment.\n */\nTrace.prototype.add = function add(childName, callback) {\n  return this.root.add(childName, callback)\n}\n\n/**\n * Explicitly set a trace's runtime instead of using it as a stopwatch.\n * (As a byproduct, stops the timer.)\n *\n * @param {int} duration Duration of this particular trace.\n * @param {int} startTimeInMillis (optional) Start of this trace.\n */\nTrace.prototype.setDurationInMillis = setDurationInMillis\n\nfunction setDurationInMillis(duration, startTimeInMillis) {\n  this.root.setDurationInMillis(duration, startTimeInMillis)\n}\n\n/**\n * @return {integer} The amount of time the trace took, in milliseconds.\n */\nTrace.prototype.getDurationInMillis = function getDurationInMillis() {\n  return this.root.getDurationInMillis()\n}\n\n/**\n * Trace parameters are used as agent attributes\n */\nTrace.prototype.addParameter = function addParameter(key, value) {\n  this.parameters[key] = value\n}\n\n/**\n * The duration of the transaction trace tree that only this level accounts\n * for.\n *\n * @return {integer} The amount of time the trace took, minus any child\n *                   traces, in milliseconds.\n */\nTrace.prototype.getExclusiveDurationInMillis = function getExclusiveDurationInMillis() {\n  return this.root.getExclusiveDurationInMillis()\n}\n\n\n/**\n * The duration of all segments in a transaction trace.  The root is not\n * accounted for, since it doesn't represent a unit of work.\n *\n * @return {integer} The sum of durations for all segments in a trace in\n *                   milliseconds\n */\nTrace.prototype.getTotalTimeDurationInMillis = function getTotalTimeDurationInMillis() {\n  if (this.totalTimeCache !== null) return this.totalTimeCache\n  if (this.root.children.length === 0) return 0\n  var segments = this.root.getChildren()\n  var totalTimeInMillis = 0\n\n  while (segments.length !== 0) {\n    var segment = segments.pop()\n    totalTimeInMillis += segment.getExclusiveDurationInMillis()\n    segments = segments.concat(segment.getChildren())\n  }\n\n  if (!this.transaction.isActive()) this.totalTimeCache = totalTimeInMillis\n  return totalTimeInMillis\n}\n\n/**\n * The serializer is asynchronous, so serialization is as well.\n *\n * The transaction trace sent to the collector is a nested set of arrays. The\n * outermost array has the following fields, in order:\n *\n * 0: start time of the trace, in milliseconds\n * 1: duration, in milliseconds\n * 2: the path, or root metric name\n * 3: the URL (fragment) for this trace\n * 4: an array of segment arrays, deflated and then base64 encoded\n * 5: FIXME: the guid for this transaction, used to correlate across\n *    transactions (for now, to correlate with RUM sessions)\n * 6: reserved for future use, specified to be null for now\n * 7: FIXME: RUM2 force persist flag\n *\n * In addition, there is a \"root node\" (not the same as the first child, which\n * is a node with the special name ROOT and contents otherwise identical to the\n * top-level segment of the actual trace) with the following fields:\n *\n * 0: start time IN SECONDS\n * 1: a dictionary containing request parameters\n * 2: a dictionary containing custom parameters (currently not user-modifiable)\n * 3: the transaction trace segments (including the aforementioned root node)\n * 4: FIXME: a dictionary containing \"parameter groups\" with special information\n *    related to this trace\n *\n * @param {Function} callback Called after serialization with either\n *                            an error (in the first parameter) or\n *                            the serialized transaction trace.\n */\nTrace.prototype.generateJSON = function generateJSON(callback) {\n  var attributes = {\n    agentAttributes: copy.shallow(this.parameters),\n    userAttributes: this.custom,\n    intrinsics: this.intrinsics\n  }\n  delete attributes.agentAttributes.request_uri\n\n  var rootNode = [\n    this.root.timer.start * FROM_MILLIS,\n    {}, // moved to agentAttributes\n    {\n      // hint to RPM for how to display this trace's segments\n      nr_flatten_leading: false\n    }, // moved to userAttributes\n    this.root.toJSON(),\n    attributes,\n    []  // FIXME: parameter groups\n  ]\n\n  var trace = this\n  if (!this.transaction.agent.config.simple_compression) {\n    codec.encode(rootNode, respond)\n  } else {\n    process.nextTick(respond.bind(null, null, rootNode))\n  }\n\n  function respond(err, data) {\n    if (err) {\n      return callback(err, null, null)\n    }\n\n    var syntheticsResourceId = null\n    // FLAG: synthetics not feature flagged here, but this will only get set if\n    // the flag is on.\n    if (trace.transaction.syntheticsData) {\n      syntheticsResourceId = trace.transaction.syntheticsData.resourceId\n    }\n\n    var json = [\n      trace.root.timer.start, // start\n      trace.transaction.getResponseTimeInMillis(), // response time\n      trace.transaction.name, // path\n      trace.transaction.url,  // uri\n      data,                   // encodedCompressedData\n      '',                     // guid\n      null,                   // reserved for future use\n      false,                  // forcePersist\n      null,                   // xraySessionId\n      syntheticsResourceId    // synthetics resource id\n    ]\n\n    return callback(null, json, trace)\n  }\n}\n\nmodule.exports = Trace\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/transaction/trace/index.js\n// module id = 188\n// module chunks = 0","'use strict'\n\nvar logger = require('../../logger').child({component: 'segment'})\nvar util = require('util')\nvar urltils = require('../../util/urltils.js')\nvar sumChildren = require('../../util/sum-children')\nvar Timer = require('../../timer')\n\n\nvar INSTANCE_UNKNOWN = 'unknown'\nvar STATE = {\n  EXTERNAL: 'EXTERNAL',\n  CALLBACK: 'CALLBACK'\n}\n\n/**\n * Initializes the segment and binds the recorder to itself, if provided.\n *\n * @constructor\n * @classdesc\n * TraceSegments are inserted to track instrumented function calls. Each one is\n * bound to a transaction, given a name (used only internally to the framework\n * for now), and has one or more children (that are also part of the same\n * transaction), as well as an associated timer.\n *\n * @param {Transaction} transaction\n *  The transaction to which this segment will be bound.\n *\n * @param {string} name\n *  Human-readable name for this segment (e.g. 'http', 'net', 'express',\n *  'mysql', etc).\n *\n * @param {?function} recorder\n *  Callback that takes a segment and a scope name as parameters (intended to be\n *  used to record metrics related to the segment).\n */\nfunction TraceSegment(transaction, name, recorder) {\n  if (!transaction) throw new Error('All segment must be associated with a transaction.')\n  if (!name) throw new Error('All segment must be named')\n\n  this.name = name\n  this.transaction = transaction\n\n  transaction.numSegments++\n  transaction.agent.totalActiveSegments++\n  transaction.agent.segmentsCreatedInHarvest++\n\n  if (recorder) {\n    transaction.addRecorder(recorder.bind(null, this))\n  }\n\n  this.parameters = {nr_exclusive_duration_millis: null}\n  this.children = []\n\n  this.timer = new Timer()\n\n  // hidden class optimization\n  this.partialName = null\n  this._exclusiveDuration = null\n  this._collect = true\n  this.host = null\n  this.port = null\n  this.state = STATE.EXTERNAL\n  this.async = true\n  this.ignore = false\n\n  this.probe('new TraceSegment')\n}\n\n/**\n * @param {string} host\n *  The name of the host of the database. This will be normalized if the string\n *  represents localhost.\n *\n * @param {string|number} port\n *  The database's port, path to unix socket, or id.\n *\n * @param {string|number|bool} database\n *  The name or ID of the database that was connected to. Or `false` if there is\n *  no database name (i.e. Redis has no databases, only hosts).\n */\nTraceSegment.prototype.captureDBInstanceAttributes =\nfunction captureDBInstanceAttributes(host, port, database) {\n  var config = this.transaction.agent.config\n  var dsTracerConf = config.datastore_tracer\n\n  // Add database name if provided and enabled.\n  if (database !== false && dsTracerConf.database_name_reporting.enabled) {\n    this.parameters.database_name =\n      typeof database === 'number' ? database : (database || INSTANCE_UNKNOWN)\n  }\n\n  // Add instance information if enabled.\n  if (dsTracerConf.instance_reporting.enabled) {\n    // Determine appropriate defaults for host and port.\n    port = port || INSTANCE_UNKNOWN\n    if (host && urltils.isLocalhost(host)) {\n      host = config.getHostnameSafe(host)\n    }\n    if (!host || host === 'UNKNOWN_BOX') { // Config's default name of a host.\n      host = INSTANCE_UNKNOWN\n    }\n    this.parameters.host = host\n    this.parameters.port_path_or_id = String(port)\n  }\n}\n\nTraceSegment.prototype.moveToCallbackState = function moveToCallbackState() {\n  this.state = STATE.CALLBACK\n}\n\nTraceSegment.prototype.isInCallbackState = function isInCallbackState() {\n  return this.state === STATE.CALLBACK\n}\n\nTraceSegment.prototype.probe = function probe(action) {\n  if (this.transaction.traceStacks) {\n    this.transaction.probe(action, {segment: this.name})\n  }\n}\n\n/**\n * Once a transaction is named, the web segment also needs to be updated to\n * match it (which implies this method must be called subsequent to\n * transaction.setName). To properly name apdex metrics during metric\n * recording, it's also necessary to copy the transaction's partial name. And\n * finally, marking the trace segment as being a web segment copies the\n * segment's parameters onto the transaction.\n *\n * @param {string} rawURL The URL, as it came in, for parameter extraction.\n */\nTraceSegment.prototype.markAsWeb = function markAsWeb(rawURL) {\n  var transaction = this.transaction\n\n  // transaction name and web segment name must match\n  this.name = transaction.name\n  // partialName is used to name apdex metrics when recording\n  this.partialName = transaction._partialName\n\n  var config = transaction.agent.config\n\n  // Copy params object so we can modify it before applying it\n  // multiple params places. It eventually runs through copyParameters\n  // so I'm not worried about `ignored_params` or `capture_params`.\n  var params = util._extend({}, this.parameters)\n\n  // This shouldn't be moved from the segment to the trace, so remove it.\n  delete params.nr_exclusive_duration_millis\n\n  // Because we are assured we have the URL here, lets grab query\n  // params. We want to opt for keeping the keys that are already on\n  // params, so we use copyParameters\n  urltils.copyParameters(config, urltils.parseParameters(rawURL), params)\n\n  urltils.copyParameters(config, params, this.parameters)\n  urltils.copyParameters(config, params, this.transaction.trace.parameters)\n}\n\n/**\n * A segment attached to something evented (such as a database\n * cursor) just finished an action, so set the timer to mark\n * the timer as having a stop time.\n */\nTraceSegment.prototype.touch = function touch() {\n  this.probe('Touched')\n  this.timer.touch()\n  this._updateRootTimer()\n}\n\nTraceSegment.prototype.overwriteDurationInMillis = overwriteDurationInMillis\nfunction overwriteDurationInMillis(duration, start) {\n  this.timer.overwriteDurationInMillis(duration, start)\n}\n\n\nTraceSegment.prototype.start = function start() {\n  this.timer.begin()\n}\n\n/**\n * Stop timing the related action.\n */\nTraceSegment.prototype.end = function end() {\n  if (!this.timer.isActive()) return\n  this.probe('Ended')\n  this.timer.end()\n  this._updateRootTimer()\n}\n\n/**\n * Helper to set the end of the root timer to this segment's root if it is later\n * in time.\n */\nTraceSegment.prototype._updateRootTimer = function _updateRootTimer() {\n  var root = this.transaction.trace.root\n  if (this.timer.endsAfter(root.timer)) {\n    var newDuration = (\n      this.timer.start +\n      this.getDurationInMillis() -\n      root.timer.start\n    )\n    root.overwriteDurationInMillis(newDuration)\n  }\n}\n\n/**\n * Test to see if underlying timer is still active\n *\n * @returns {boolean} true if no longer active, else false.\n */\nTraceSegment.prototype._isEnded = function _isEnded() {\n  return !this.timer.isActive() || this.timer.touched\n}\n\n/**\n * Add a new segment to a scope implicitly bounded by this segment.\n *\n * @param {string} childName New human-readable name for the segment.\n * @returns {TraceSegment} New nested TraceSegment.\n */\nTraceSegment.prototype.add = function add(childName, recorder) {\n  logger.trace('Adding segment %s to %s', childName, this.name)\n  var segment = new TraceSegment(this.transaction, childName, recorder)\n  var config = this.transaction.agent.config\n\n  if (this.transaction.trace.segmentsSeen++ >= config.max_trace_segments) {\n    segment._collect = false\n  }\n  this.children.push(segment)\n\n  if (config.debug && config.debug.double_linked_transactions) {\n    segment.parent = this\n  }\n\n  return segment\n}\n\n/**\n * Set the duration of the segment explicitly.\n *\n * @param {Number} duration Duration in milliseconds.\n */\nTraceSegment.prototype.setDurationInMillis = setDurationInMillis\n\nfunction setDurationInMillis(duration, start) {\n  this.timer.setDurationInMillis(duration, start)\n}\n\nTraceSegment.prototype.getDurationInMillis = function getDurationInMillis() {\n  return this.timer.getDurationInMillis()\n}\n\n/**\n * Only for testing!\n *\n * @param {number} duration Milliseconds of exclusive duration.\n */\nTraceSegment.prototype._setExclusiveDurationInMillis = _setExclusiveDurationInMillis\n\nfunction _setExclusiveDurationInMillis(duration) {\n  this._exclusiveDuration = duration\n}\n\n/**\n * The duration of the transaction trace tree that only this level accounts\n * for.\n *\n * @return {integer} The amount of time the trace took, minus any child\n *                   segments, in milliseconds.\n */\nTraceSegment.prototype.getExclusiveDurationInMillis = getExclusiveDurationInMillis\n\nfunction getExclusiveDurationInMillis() {\n  if (this._exclusiveDuration) return this._exclusiveDuration\n\n  var total = this.getDurationInMillis()\n  var end = this.timer.toRange()[1]\n\n  if (this.children.length > 0) {\n    // convert the list of start, duration pairs to start, end pairs\n    total -= sumChildren(this._getChildPairs(end), end)\n  }\n\n  return total\n}\n\nTraceSegment.prototype.getChildren = function getChildren() {\n  var children = []\n  for (var i = 0, len = this.children.length; i < len; ++i) {\n    if (!this.children[i].ignore) {\n      children.push(this.children[i])\n    }\n  }\n  return children\n}\n\n/**\n * Enumerate the timings of this segment's descendants.\n *\n * @param {Number} end The end of this segment, to keep the calculated\n *                     duration from exceeding the duration of the\n *                     parent. Defaults to Infinity.\n *\n * @returns {Array} Unsorted list of [start, end] pairs, with no pair\n *                  having an end greater than the passed in end time.\n */\nTraceSegment.prototype._getChildPairs = function _getChildPairs(end) {\n  // quick optimization\n  if (this.children.length < 1) return []\n  if (!end) end = Infinity\n\n  var children = this.getChildren()\n  var childPairs = []\n  while (children.length) {\n    var child = children.pop()\n    var pair = child.timer.toRange()\n\n    if (pair[0] >= end) continue\n\n    children = children.concat(child.getChildren())\n\n    pair[1] = Math.min(pair[1], end)\n    childPairs.push(pair)\n  }\n\n  return childPairs\n}\n\n/**\n * This is perhaps the most poorly-documented element of transaction traces:\n * what do each of the segment representations look like prior to encoding?\n * Spelunking in the code for the other agents has revealed that each child\n * node is an array with the following field in the following order:\n *\n * 0: entry timestamp relative to transaction start time\n * 1: exit timestamp\n * 2: metric name\n * 3: parameters as a name -> value JSON dictionary\n * 4: any child segments\n *\n * Other agents include further fields in this. I haven't gotten to the bottom\n * of all of them (and Ruby, of course, sends marshalled Ruby object), but\n * here's what I know so far:\n *\n * in Java:\n * 5: class name\n * 6: method name\n *\n * in Python:\n * 5: a \"label\"\n *\n * FIXME: I don't know if it makes sense to add custom fields for Node. TBD\n */\nTraceSegment.prototype.toJSON = function toJSON() {\n  var start = this.timer.startedRelativeTo(this.transaction.trace.root.timer)\n  var duration = this.getDurationInMillis()\n  if (!this.parameters.nr_exclusive_duration_millis) {\n    this.parameters.nr_exclusive_duration_millis = this.getExclusiveDurationInMillis()\n  }\n\n  var children = this.getChildren()\n  var childrenJson = []\n  for (var i = 0, len = children.length; i < len; i++) {\n    var child = children[i]\n    if (child._collect) {\n      childrenJson.push(child.toJSON())\n    }\n  }\n\n  return [\n    start,\n    start + duration,\n    this.name,\n    this.parameters,\n    childrenJson\n  ]\n}\n\nmodule.exports = TraceSegment\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/transaction/trace/segment.js\n// module id = 189\n// module chunks = 0","'use strict'\n\n/**\n * Given an ordered list of disjoint intervals and a new interval to fold into\n * it, determine if the new interval is a sub-interval (in which case it's\n * redundant), an overlapping interval (in which case, replace the most recent\n * interval on the list with an interval representing the union of the new and\n * last intervals), or otherwise (it's disjoint to what we already\n * have, in which case add it to the list). Meant to be used with\n * Array.reduce().\n *\n * Assumes the list being reduced is sorted by interval start time.\n *\n * @param {Array} accum  The accumulated list of reduced intervals.\n * @param {Array} newest A new pair of range start and end to compare to the\n*                        existing intervals.\n *\n * @return {Array} A list of intervals updated to include the new interval.\n */\n\nfunction sumChildren(pairs, parentEnd) {\n  if (!pairs.length) return 0\n\n  pairs.sort(function cb_sort(a, b) {\n    return a[0] - b[0]\n  })\n\n\n  var start = pairs[0][0]\n  var end = start\n  var diff = 0\n  var segmentEnd\n  var pair\n\n  for (var i = 0, l = pairs.length; i < l; ++i) {\n    pair = pairs[i]\n\n    if (pair[0] > parentEnd) break\n    segmentEnd = pair[1] > parentEnd ? parentEnd : pair[1]\n\n    if (pair[0] > end) {\n      diff += pair[0] - end\n      end = segmentEnd\n    } else if (segmentEnd > end) {\n      end = segmentEnd\n    }\n  }\n\n  return end - start - diff\n}\n\nmodule.exports = sumChildren\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/sum-children.js\n// module id = 190\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger.js').child({component: 'name-state'})\nvar arrayUtil = require('../util/arrays')\n\n\n/**\n * Manages transaction names using a stack of paths.\n *\n * @constructor\n */\nfunction NameState(prefix, verb, delimiter, path) {\n  this.setName(prefix, verb, delimiter, path)\n}\n\nNameState.prototype.setName = function setName(prefix, verb, delimiter, path) {\n  this.setPrefix(prefix)\n  this.verb = verb\n  this.delimiter = delimiter\n  this.pathStack = path ? [path] : []\n  logger.trace('setName called on name state, path stack now %j', this.pathStack)\n}\n\n/**\n * Sets the metric prefix (i.e. Expressjs).\n */\nNameState.prototype.setPrefix = function setPrefix(prefix) {\n  if (prefix === null) {\n    this.prefix = null\n    return\n  }\n  this.prefix = (prefix[prefix.length - 1] === '/') ?\n    prefix.substring(0, prefix.length - 1) : prefix\n}\n\n/**\n * Sets the HTTP verb (i.e. GET/POST/PUT)\n */\nNameState.prototype.setVerb = function setVerb(verb) {\n  this.verb = verb\n}\n\n/**\n * Sets the delimiter character used to separate the http verb from the path.\n */\nNameState.prototype.setDelimiter = function setDelimiter(delimiter) {\n  this.delimiter = delimiter\n}\n\n/**\n * Pushes a new path element onto the naming stack.\n */\nNameState.prototype.appendPath = function appendPath(path) {\n  if (path) {\n    var strPath = path instanceof RegExp ? path.source : String(path)\n    this.pathStack.push(strPath)\n    logger.trace('Appended %s to path stack', strPath)\n  }\n}\n\n/**\n * Pushes a new path element onto the naming stack if the stack is\n * empty.\n */\nNameState.prototype.appendPathIfEmpty = function appendPathIfEmpty(path) {\n  if (path && this.pathStack.length === 0) {\n    var strPath = path instanceof RegExp ? path.source : String(path)\n    this.pathStack.push(strPath)\n    logger.trace('Appended %s to path stack', strPath)\n  }\n}\n\n/**\n * Pops the last element off the name stack.\n *\n * If `path` is provided, the stack is popped back to the first element matching\n * `path`. If no element matches, the stack is left unchanged.\n *\n * @param {string} [path] - Optional. A path piece to pop back to.\n */\nNameState.prototype.popPath = function popPath(path) {\n  if (this.pathStack.length === 0) {\n    return\n  }\n\n  if (path) {\n    var idx = arrayUtil.findLastIndex(this.pathStack, function pathMatch(a) {\n      return a === path\n    })\n    if (idx !== -1) {\n      this.pathStack.splice(idx)\n    }\n  } else {\n    this.pathStack.pop()\n  }\n}\n\nNameState.prototype.getName = function getName() {\n  if (this.pathStack.length === 0) return null // nameState initialized but never set\n\n  var path = this.pathStack.join('/').replace(/[/]{2,}/g, '/')\n  if (path && path[0] !== '/') {\n    path = '/' + path\n  } // path now looks like /one/two/three\n\n  var verb = this.verb ? '/' + this.verb : ''\n\n  return (this.prefix || '') + verb + (this.delimiter || '') + path\n}\n\nNameState.prototype.reset = function reset() {\n  logger.trace('Reset called on name state, path stack was %j', this.pathStack)\n  this.prefix = null\n  this.verb = null\n  this.delimiter = null\n  this.pathStack = []\n}\n\nmodule.exports = NameState\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/transaction/name-state.js\n// module id = 191\n// module chunks = 0","'use strict'\n\n/**\n * This file includes all of the configuration variables used by the Node.js\n * module. If there's a configurable element of the module and it's not\n * described in here, there's been a terrible mistake.\n */\nexports.config = {\n  /**\n   * Array of application names.\n   *\n   * @env NEW_RELIC_APP_NAME\n   */\n  app_name: [],\n  /**\n   * The user's license key. Must be set by per-app configuration file.\n   *\n   * @env NEW_RELIC_LICENSE_KEY\n   */\n  license_key: '',\n  /**\n   * Hostname for the New Relic collector proxy.\n   *\n   * You shouldn't need to change this.\n   *\n   * @env NEW_RELIC_HOST\n   */\n  host: 'collector.newrelic.com',\n  /**\n   * The port on which the collector proxy will be listening.\n   *\n   * You shouldn't need to change this.\n   *\n   * @env NEW_RELIC_PORT\n   */\n  port: 443,\n  /**\n   * Whether or not to use SSL to connect to New Relic's servers.\n   *\n   * @env NEW_RELIC_USE_SSL\n   */\n  ssl: true,\n  /**\n   * Proxy url\n   *\n   * A proxy url can be used in place of setting\n   * proxy_host, proxy_port, proxy_user, and proxy_pass.\n   *\n   * e.g. http://user:pass@host:port/\n   *\n   * Setting proxy will override other proxy settings.\n   *\n   * @env NEW_RELIC_PROXY_URL\n   */\n  proxy: '',\n  /**\n   * Proxy host to use to connect to the internet.\n   *\n   * @env NEW_RELIC_PROXY_HOST\n   */\n  proxy_host: '',\n  /**\n   * Proxy port to use to connect to the internet.\n   *\n   * @env NEW_RELIC_PROXY_PORT\n   */\n  proxy_port: '',\n  /**\n   * Proxy user name when required.\n   *\n   * @env NEW_RELIC_PROXY_USER\n   */\n  proxy_user: '',\n  /**\n   * Proxy password when required.\n   *\n   * @env NEW_RELIC_PROXY_PASS\n   */\n  proxy_pass: '',\n  /**\n   * Custom SSL certificates\n   *\n   * If your proxy uses a custom SSL certificate, you can add the CA text to\n   * this array, one entry per certificate.\n   *\n   * The easiest way to do this is with `fs.readFileSync` e.g.\n   *\n   * certificates: [\n   *   require('fs').readFileSync('custom.crt', 'utf8') // don't forget the utf8\n   * ]\n   *\n   */\n  certificates: [],\n  /**\n   * You may want more control over how the module is configured and want to\n   * disallow the use of New Relic's server-side configuration. To do so, set\n   * this parameter to true. Some configuration information is required to make\n   * the module work properly with the rest of New Relic, but settings such as\n   * apdex_t and capture_params will not be override-able by New Relic with this\n   * setting in effect.\n   *\n   * @env NEW_RELIC_IGNORE_SERVER_CONFIGURATION\n   */\n  ignore_server_configuration: false,\n  /**\n   * Whether the module is enabled.\n   *\n   * @env NEW_RELIC_ENABLED\n   */\n  agent_enabled: true,\n  /**\n   * The default Apdex tolerating / threshold value for applications, in\n   * seconds. The default for Node is apdexT to 100 milliseconds, which is\n   * lower than New Relic standard, but Node.js applications tend to be more\n   * latency-sensitive than most.\n   *\n   * @env NEW_RELIC_APDEX\n   */\n  apdex_t: 0.100,\n  /**\n   * Whether to capture parameters in the request URL in slow transaction\n   * traces and error traces. Because this can pass sensitive data, it's\n   * disabled by default. If there are specific parameters you want ignored,\n   * use ignored_params.\n   *\n   * @env NEW_RELIC_CAPTURE_PARAMS\n   */\n  capture_params: false,\n  /**\n   * Array of parameters you don't want captured off request URLs in slow\n   * transaction traces and error traces.\n   *\n   * @env NEW_RELIC_IGNORED_PARAMS\n   */\n  ignored_params: [],\n  logging: {\n    /**\n     * Verbosity of the module's logging. This module uses bunyan\n     * (https://github.com/trentm/node-bunyan) for its logging, and as such the\n     * valid logging levels are 'fatal', 'error', 'warn', 'info', 'debug' and\n     * 'trace'. Logging at levels 'info' and higher is very terse. For support\n     * requests, attaching logs captured at 'trace' level are extremely helpful\n     * in chasing down bugs.\n     *\n     * @env NEW_RELIC_LOG_LEVEL\n     */\n    level: 'info',\n    /**\n     * Where to put the log file -- by default just uses process.cwd +\n     * 'newrelic_agent.log'. A special case is a filepath of 'stdout',\n     * in which case all logging will go to stdout, or 'stderr', in which\n     * case all logging will go to stderr.\n     *\n     * @env NEW_RELIC_LOG\n     */\n    filepath: require('path').join(process.cwd(), 'newrelic_agent.log'),\n    /**\n     * Whether to write to a log file at all\n     *\n     * @env NEW_RELIC_LOG_ENABLED\n     */\n    enabled: true,\n\n    /**\n     * Enables extra debugging at `warn` level. No need to enable except under\n     * specific debugging conditions.\n     */\n    diagnostics: false\n  },\n\n  audit_log: {\n\n    /**\n     * Enables logging of out bound traffic from the Agent to the Collector.\n     * This field is ignored if trace level logging is enabled.\n     * With trace logging, all traffic is logged.\n     *\n     * @env NEW_RELIC_AUDIT_LOG_ENABLED\n     */\n    enabled: false,\n\n    /**\n     * Specify which methods are logged. Used in conjuction with the audit_log flag\n     * If audit_log is enabled and this property is empty, all methods will be logged\n     * Otherwise, if the audit log is enabled, only the methods specified \n     * in the filter will be logged\n     * Methods include: error_data, metric_data, and analytic_event_data\n     *\n     * @env NEW_RELIC_AUDIT_LOG_ENDPOINTS\n     */\n    endpoints: []\n  },\n  /**\n   * Whether to collect & submit error traces to New Relic.\n   *\n   * @env NEW_RELIC_ERROR_COLLECTOR_ENABLED\n   */\n  error_collector: {\n    /**\n     * Disabling the error tracer just means that errors aren't collected\n     * and sent to New Relic -- it DOES NOT remove any instrumentation.\n     */\n    enabled: true,\n    /**\n     * List of HTTP error status codes the error tracer should disregard.\n     * Ignoring a status code means that the transaction is not renamed to\n     * match the code, and the request is not treated as an error by the error\n     * collector.\n     *\n     * Defaults to 404 NOT FOUND.\n     *\n     * @env NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES\n     */\n    ignore_status_codes: [404],\n    /**\n     * Whether error events are collected.\n     */\n    capture_events: true,\n    /**\n     * The agent will collect all error events up to this number per minute.\n     * If there are more than that, a statistical sampling will be collected.\n     * Currently this uses a reservoir sampling algorithm.\n     *\n     * By increasing this setting you are both increasing the memory\n     * requirements of the agent as well as increasing the payload to the New\n     * Relic servers. The memory concerns are something you should consider for\n     * your own server's sake. The payload of events is compressed, but if it\n     * grows too large the New Relic servers may reject it.\n     */\n    max_event_samples_stored: 100\n  },\n  /**\n   * Options regarding collecting system information. Used for system\n   * utilization based pricing scheme.\n   */\n  utilization: {\n    /**\n     * This flag dictates whether the agent attempts to reach out to AWS\n     * to get info about the vm the process is running on.\n     *\n     * @env NEW_RELIC_UTILIZATION_DETECT_AWS\n     */\n    detect_aws: true,\n    /**\n     * This flag dictates whether the agent attempts to reach out to AWS\n     * to get info about the container the process is running in.\n     *\n     * @env NEW_RELIC_UTILIZATION_DETECT_DOCKER\n     */\n    detect_docker: true\n  },\n  transaction_tracer: {\n    /**\n     * Whether to collect & submit slow transaction traces to New Relic. The\n     * instrumentation is loaded regardless of this setting, as it's necessary\n     * to gather metrics. Disable the agent to prevent the instrumentation from\n     * loading.\n     *\n     * @env NEW_RELIC_TRACER_ENABLED\n     */\n    enabled: true,\n    /**\n     * The duration at below which the slow transaction tracer should collect a\n     * transaction trace. If set to 'apdex_f', the threshold will be set to\n     * 4 * apdex_t, which with a default apdex_t value of 500 milliseconds will\n     * be 2 seconds.\n     *\n     * If a time is provided, it is set in seconds.\n     *\n     * @env NEW_RELIC_TRACER_THRESHOLD\n     */\n    transaction_threshold: 'apdex_f',\n    /**\n     * Increase this parameter to increase the diversity of the slow\n     * transaction traces recorded by your application over time. Confused?\n     * Read on.\n     *\n     * Transactions are named based on the request (see the README for the\n     * details of how requests are mapped to transactions), and top_n refers to\n     * the \"top n slowest transactions\" grouped by these names. The module will\n     * only replace a recorded trace with a new trace if the new trace is\n     * slower than the previous slowest trace of that name. The default value\n     * for this setting is 20, as the transaction trace view page also defaults\n     * to showing the 20 slowest transactions.\n     *\n     * If you want to record the absolute slowest transaction over the last\n     * minute, set top_n to 0 or 1. This used to be the default, and has a\n     * problem in that it will allow one very slow route to dominate your slow\n     * transaction traces.\n     *\n     * The module will always record at least 5 different slow transactions in\n     * the reporting periods after it starts up, and will reset its internal\n     * slow trace aggregator if no slow transactions have been recorded for the\n     * last 5 harvest cycles, restarting the aggregation process.\n     *\n     * @env NEW_RELIC_TRACER_TOP_N\n     */\n    top_n: 20,\n\n    /**\n     * This option affects both slow-queries and record_sql for transaction\n     * traces.  It can have one of 3 values: 'off', 'obfuscated' or 'raw'\n     * When it is 'off' no slow queries will be captured, and backtraces\n     * and sql will not be included in transaction traces.  If it is 'raw'\n     * or 'obfuscated' and other criteria (slow_sql.enabled etc) are met\n     * for a query. The raw or obfuscated sql will be included in the\n     * transaction trace and a slow query sample will be collected.\n     */\n    record_sql: 'off',\n\n    /**\n     * This option affects both slow-queries and record_sql for transaction\n     * traces.  This is the minimum duration a query must take (in ms) for it\n     * to be considered for for slow query and inclusion in transaction traces.\n     */\n    explain_threshold: 500\n  },\n  /**\n   * Whether to enable internal supportability metrics and diagnostics. You're\n   * welcome to turn these on, but they will probably be most useful to the\n   * New Relic node engineering team.\n   */\n  debug: {\n    /**\n     * Whether to collect and submit internal supportability metrics alongside\n     * application performance metrics.\n     *\n     * @env NEW_RELIC_DEBUG_METRICS\n     */\n    internal_metrics: false,\n    /**\n     * Traces the execution of the transaction tracer. Requires logging.level\n     * to be set to 'trace' to provide any useful output.\n     *\n     * WARNING: The tracer tracing data is likely only to be intelligible to a\n     * small number of people inside New Relic, so you should probably only\n     * enable tracer tracing if asked to by New Relic, because it will affect\n     * performance significantly.\n     *\n     * @env NEW_RELIC_DEBUG_TRACER\n     */\n    tracer_tracing: false\n  },\n  /**\n   * Rules for naming or ignoring transactions.\n   */\n  rules: {\n    /**\n     * A list of rules of the format {pattern: 'pattern', name: 'name'} for\n     * matching incoming request URLs and naming the associated New Relic\n     * transactions. Both pattern and name are required. Additional attributes\n     * are ignored. Patterns may have capture groups (following JavaScript\n     * conventions), and names will use $1-style replacement strings. See\n     * the documentation for addNamingRule for important caveats.\n     *\n     * @env NEW_RELIC_NAMING_RULES\n     */\n    name: [],\n    /**\n     * A list of patterns for matching incoming request URLs to be ignored by\n     * the agent. Patterns may be strings or regular expressions.\n     *\n     * By default, socket.io long-polling is ignored.\n     *\n     * @env NEW_RELIC_IGNORING_RULES\n     */\n    ignore: [\n      '^\\/socket\\.io\\/.*\\/xhr-polling/'\n    ]\n  },\n  /**\n   * By default, any transactions that are not affected by other bits of\n   * naming logic (the API, rules, or metric normalization rules) will\n   * have their names set to 'NormalizedUri/*'. Setting this value to\n   * false will set them instead to Uri/path/to/resource. Don't change\n   * this setting unless you understand the implications of New Relic's\n   * metric grouping issues and are confident your application isn't going\n   * to run afoul of them. Your application could end up getting black holed!\n   * Nobody wants that.\n   *\n   * @env NEW_RELIC_ENFORCE_BACKSTOP\n   */\n  enforce_backstop: true,\n  /**\n   * Browser Monitoring\n   *\n   * Browser monitoring lets you correlate transactions between the server and browser\n   * giving you accurate data on how long a page request takes, from request,\n   * through the server response, up until the actual page render completes.\n   */\n  browser_monitoring: {\n\n    /**\n     * Enable browser monitoring header generation.\n     *\n     * This does not auto-instrument, rather it enables the agent to generate headers.\n     * The newrelic module can generate the appropriate <script> header, but you must\n     * inject the header yourself, or use a module that does so.\n     *\n     * Usage:\n     *\n     *     var newrelic = require('newrelic');\n     *\n     *     router.get('/', function (req, res) {\n     *       var header = newrelic.getBrowserTimingHeader();\n     *       res.write(header)\n     *       // write the rest of the page\n     *     });\n     *\n     * This generates the <script>...</script> header necessary for Browser Monitoring\n     * This script must be manually injected into your templates, as high as possible\n     * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.\n     * Otherwise you may hurt IE!\n     *\n     * This method must be called _during_ a transaction, and must be called every\n     * time you want to generate the headers.\n     *\n     * Do *not* reuse the headers between users, or even between requests.\n     *\n     * @env NEW_RELIC_BROWSER_MONITOR_ENABLE\n     */\n    enable: true,\n\n    /**\n     * Request un-minified sources from the server.\n     *\n     * @env NEW_RELIC_BROWSER_MONITOR_DEBUG\n     */\n    debug: false\n  },\n  /**\n   * Transaction Events\n   *\n   * Transaction events are sent to New Relic Insights. This event data\n   * includes transaction timing, transaction name, and any custom parameters.\n   *\n   * Read more here: http://newrelic.com/insights\n   */\n  transaction_events: {\n    /**\n     * If this is disabled, the agent does not collect, nor try to send,\n     * analytic data.\n     */\n    enabled: true,\n\n    /**\n     * The agent will collect all events up to this number per minute. If\n     * there are more than that, a statistical sampling will be collected.\n     */\n    max_samples_per_minute: 10000,\n\n    /**\n     * This is used if the agent is unable to send events to the collector.\n     * The values from the previous harvest cycle will be merged into the next\n     * one with this option as the limit.\n     *\n     * This should be *greater* than max_samples_per_minute or you'll see odd\n     * behavior. You probably want at least double the value, but more is okay\n     * as long as you can handle the memory overhead.\n     */\n    max_samples_stored: 20000\n  },\n\n  /**\n   * Custom Insights Events\n   *\n   * Custom insights events are JSON object that are sent to New Relic\n   * Insights. You can tell the agent to send your custom events via the\n   * `newrelic.recordCustomEvent()` API. These events are sampled once the max\n   * reservoir size is reached. You can tune this setting below.\n   *\n   * Read more here: http://newrelic.com/insights\n   */\n  custom_insights_events: {\n    /**\n     * If this is disabled, the agent does not collect, nor try to send, custom\n     * event data.\n     */\n    enabled: true,\n    /**\n     * The agent will collect all events up to this number per minute. If there\n     * are more than that, a statistical sampling will be collected. Current\n     * this uses a reservoir sampling algorithm.\n     *\n     * By increasing this setting you are both increasing the memory\n     * requirements of the agent as well as increasing the payload to the New\n     * Relic servers. The memory concerns are something you should consider for\n     * your own server's sake. The payload of events is compressed, but if it\n     * grows too large the New Relic servers may reject it.\n     */\n    max_samples_stored: 1000\n  },\n  /**\n   * This is used to configure properties about the user's host name.\n   */\n  process_host: {\n     /**\n     * Configurable display name for hosts\n     *\n     * @env NEW_RELIC_PROCESS_HOST_DISPLAY_NAME\n     */\n    display_name: '',\n    /**\n     * ip address preference when creating hostnames\n     *\n     * @env NEW_RELIC_IPV_PREFERENCE\n     */\n    ipv_preference: '4'\n },\n\n\n  /**\n   * High Security\n   *\n   * High security mode (v2) is a setting which prevents any sensitive data from\n   * being sent to New Relic. The local setting must match the server setting.\n   * If there is a mismatch the agent will log a message and act as if it is\n   * disabled.\n   *\n   * Attributes of high security mode (when enabled):\n   *  * requires SSL\n   *  * does not allow capturing of http params\n   *  * does not allow custom params\n   *\n   * To read more see: https://docs.newrelic.com/docs/subscriptions/high-security\n   */\n  high_security: false,\n\n  /**\n   * Labels\n   *\n   * An object of label names and values that will be applied to the data sent\n   * from this agent. Both label names and label values have a maximum length of\n   * 255 characters. This object should contain at most 64 labels.\n   */\n  labels: {},\n\n  /**\n   * These options control behavior for slow queries, but do not affect sql\n   * nodes in transaction traces.\n   * slow_sql.enabled enables and disables slow_sql recording\n   * slow_sql.max_samples sets the maximum number of slow query samples that\n   * will be collected in a single harvest cycle.\n   */\n   slow_sql: {\n    enabled: false,\n    max_samples: 10\n  },\n\n  /**\n   * Controls behavior of datastore instance metrics.\n   *\n   * @property {bool} [instance_reporting.enabled=true]\n   *  Enables reporting the host and port/path/id of database servers. Default\n   *  is `true`.\n   *\n   * @property {bool} [database_name_reporting.enabled=true]\n   *  Enables reporting of database/schema names. Default is `true`.\n   */\n  datastore_tracer: {\n    instance_reporting: {enabled: true},\n    database_name_reporting: {enabled: true}\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/config.default.js\n// module id = 192\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger').child({component: 'parse_sql'})\nvar StatementMatcher = require('./statement-matcher')\nvar ParsedStatement = require('./parsed-statement')\nvar stringifySync = require('../util/safe-json').stringifySync\n\n\nvar OPERATIONS = [\n  new StatementMatcher('select', /^\\s*select[\\S\\s]*from[\\s\\[]+([^\\]\\s,)(;]*).*/gi),\n  new StatementMatcher('update', /^\\s*update\\s+([^\\s,;]*).*/gi),\n  new StatementMatcher('insert', /^\\s*insert(?:\\s+ignore)?\\s+into\\s+([^\\s(,;]*).*/gi),\n  new StatementMatcher('delete', /^\\s*delete\\s+from\\s+([^\\s,(;]*).*/gi)\n]\nvar COMMENT_PATTERN = /\\/\\\\*.*?\\\\*\\//\n\n// This must be called syncronously after the initial db call for backtraces to\n// work correctly\n\nmodule.exports = function parseSql(type, sql) {\n  // Sometimes we get an object here from MySQL. We have been unable to\n  // reproduce it, so we'll just log what that object is and return a statement\n  // type of `other`.\n  if (typeof sql === 'object' && sql.sql !== undefined) sql = sql.sql\n  if (typeof sql !== 'string') {\n    logger.trace(\n      'parseSQL got an a non-string sql that looks like: %s',\n      stringifySync(sql)\n    )\n    return new ParsedStatement(type, 'other', null, sql)\n  }\n\n  sql = sql.replace(COMMENT_PATTERN, '').trim()\n\n\n  var parsedStatement\n\n  for (var i = 0, l = OPERATIONS.length; i < l; i++) {\n    parsedStatement = OPERATIONS[i].getParsedStatement(type, sql)\n    if (parsedStatement) {\n      return parsedStatement\n    }\n  }\n\n  return new ParsedStatement(type, 'other', null, sql)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/db/parse-sql.js\n// module id = 193\n// module chunks = 0","'use strict'\n\nvar ParsedStatement = require('./parsed-statement')\n\n\nfunction StatementMatcher(operation, operationPattern) {\n  this.operation = operation\n  this.operationPattern = operationPattern\n}\n\nStatementMatcher.prototype.getParsedStatement = function getParsedStatement(type, sql) {\n  this.operationPattern.lastIndex = 0\n\n  var match = new RegExp(\"^\\\\s*\" + this.operation, \"ig\").test(sql)\n  if (match) {\n    var queryMatch = this.operationPattern.exec(sql)\n    var model = queryMatch ? queryMatch[1] : 'unknown'\n\n    return new ParsedStatement(type, this.operation, model, sql)\n  }\n}\n\nmodule.exports = StatementMatcher\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/db/statement-matcher.js\n// module id = 194\n// module chunks = 0","'use strict'\n\nvar DB = require('../metrics/names').DB\nvar ALL = require('../metrics/names').ALL\n\nfunction ParsedStatement(type, operation, model, raw) {\n  this.type = type\n  this.operation = operation\n  this.model = model\n  this.trace = null\n  this.raw = ''\n\n  if (typeof raw === 'string') {\n    this.trace = new Error()\n    this.raw = raw\n  }\n}\n\nParsedStatement.prototype.recordMetrics = function recordMetrics(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n  var type = transaction.isWeb() ? DB.WEB : DB.OTHER\n  var thisTypeSlash = this.type + '/'\n  var operation = DB.OPERATION + '/' + thisTypeSlash + this.operation\n\n  // Rollups\n  transaction.measure(operation, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + type, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + thisTypeSlash + type, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + thisTypeSlash + ALL, null, duration, exclusive)\n  transaction.measure(DB.ALL, null, duration, exclusive)\n\n  // If we can parse the SQL statement, create a 'statement' metric, and use it\n  // as the scoped metric for transaction breakdowns. Otherwise, skip the\n  // 'statement' metric and use the 'operation' metric as the scoped metric for\n  // transaction breakdowns.\n  if (this.model) {\n    var model = DB.STATEMENT + '/' + thisTypeSlash + this.model + '/' + this.operation\n    transaction.measure(model, null, duration, exclusive)\n    if (scope) transaction.measure(model, scope, duration, exclusive)\n  } else if (scope) {\n    transaction.measure(operation, scope, duration, exclusive)\n  }\n\n  // This recorder is side-effectful Because we are depending on the recorder\n  // setting the transaction name, recorders must always be run before generating\n  // the final transaction trace\n  segment.name = model || operation\n\n  // Datastore instance metrics.\n  if (segment.parameters.hasOwnProperty('host') &&\n      segment.parameters.hasOwnProperty('port_path_or_id')) {\n    var instanceName = DB.INSTANCE + '/' + thisTypeSlash + segment.parameters.host +\n      '/' + segment.parameters.port_path_or_id\n    transaction.measure(instanceName, null, duration, exclusive)\n  }\n\n  if (this.raw) {\n    transaction.agent.queries.addQuery(\n      segment,\n      this.type.toLowerCase(),\n      this.raw,\n      this.trace\n    )\n  }\n}\n\nmodule.exports = ParsedStatement\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/db/parsed-statement.js\n// module id = 195\n// module chunks = 0","'use strict'\n\nmodule.exports.extractDatabaseChangeFromUse = extractDatabaseChangeFromUse\n\nfunction extractDatabaseChangeFromUse(sql) {\n  // The character ranges for this were pulled from\n  // http://dev.mysql.com/doc/refman/5.7/en/identifiers.html\n  var match = /^\\s*use[^\\w`]+([\\w$_\\u0080-\\uFFFF]+|`[^`]+`)[\\s;]*$/i.exec(sql)\n  return match && match[1] || null\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/db/util.js\n// module id = 196\n// module chunks = 0","'use strict'\n\nvar promInit = require('./promise')\n\nvar BLUEBIRD_SPEC = {\n  name: 'bluebird',\n  constructor: 'Promise',\n  $proto: {\n    then: ['then', 'done', 'spread', 'all', 'asCallback', 'nodeify', 'finally', 'lastly'],\n    catch: ['catch', 'caught', 'error'],\n\n    // _resolveFromResolver is in bluebird 2.x\n    // _execute is in bluebird 3.x\n    executor: ['_execute', '_resolveFromResolver']\n  },\n  $static: {\n    cast: [\n      'resolve', 'fullfilled', 'cast', 'reject', 'rejected', 'fromNode',\n      'fromCallback', 'all'\n    ]\n  }\n}\n\nmodule.exports = function initialize(agent, bluebird) {\n  promInit(agent, bluebird, BLUEBIRD_SPEC)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/bluebird.js\n// module id = 197\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger')\nvar util = require('util')\nvar shimmer = require('../shimmer')\n\n\n/**\n * @namespace Library.Spec\n *\n * @property {string} name\n *  The name of this promise library.\n *\n * @property {?string} constructor\n *  Optional. The name of the property that is the Promise constructor. Default\n *  is to use the library itself as the Promise constructor.\n *\n * @property {?bool} executor\n *  Optional. If true, the Promise constructor itself will be wrapped for the\n *  executor. If false then `_proto`, `_static`, or `_library` must have an\n *  `executor` field whose value is the name of the executor function. Default\n *  is false.\n *\n * @property {Library.Spec.Mapping} $proto\n *  The mapping for Promise instance method concepts (i.e. `then`). These are\n *  mapped on the Promise class' prototype.\n *\n * @property {Library.Spec.Mapping} $static\n *  The mapping for Promise static method concepts (i.e. `all`, `race`). These\n *  are mapped on the Promise class itself.\n *\n * @property {?Library.Spec.Mapping} $library\n *  The mapping for library-level static method concepts (i.e. `fcall`, `when`).\n *  These are mapped on the library containing the Promise class. NOTE: in most\n *  promise implementations, the Promise class is itself the library thus this\n *  property is unnecessary.\n */\n\n/**\n * @namespace Library.Spec.Mapping\n *\n * A mapping of promise concepts (i.e. `then`) to this library's implementation\n * name(s) (i.e. `[\"then\", \"chain\"]`). Each value can by either a single string\n * or an array of strings if the concept exists under multiple keys. If any\n * given concept doesn't exist in this library, it is simply skipped.\n *\n * @property {array} $copy\n *  An array of properties or methods to just directly copy without wrapping.\n *  This field only matters when `Library.Spec.executor` is `true`.\n *\n * @property {string|array} executor\n *\n *\n * @property {string|array} then\n *\n *\n * @property {string|array} all\n *\n *\n * @property {string|array} race\n *\n *\n * @property {string|array} resolve\n *  Indicates methods to wrap which are resolve factories. This method only\n *  requires wrapping if the library doesn't use an executor internally to\n *  implement it.\n *\n * @property {string|array} reject\n *  Indicates methods to wrap which are reject factories. Like `resolve`, this\n *  method only requires wrapping if the library doesn't use an executor\n *  internally to implement it.\n */\n\n/**\n * Instruments a promise library.\n *\n * @param {Agent}         agent   - The New Relic APM agent.\n * @param {function}      library - The promise library.\n * @param {?Library.Spec} spec    - Spec for this promise library mapping.\n */\nmodule.exports = function initialize(agent, library, spec) {\n  // Wrap library-level methods.\n  wrapStaticMethods(library, spec.name, spec.$library)\n\n  // Wrap prototype methods.\n  var Promise = library[spec.constructor]\n  wrapPrototype(Promise.prototype)\n  wrapStaticMethods(Promise, spec.constructor, spec.$static)\n\n  // See if we are wrapping the class itself.\n  if (spec.executor) {\n    shimmer.wrapMethod(library, spec.name, spec.constructor, wrapPromise)\n  }\n\n  /**\n   * Wraps the Promise constructor as the executor.\n   */\n  function wrapPromise() {\n    // Copy all unwrapped properties over.\n    if (spec.$static && spec.$static.$copy) {\n      spec.$static.$copy.forEach(function copyKeys(key) {\n        if (!wrappedPromise[key]) {\n          wrappedPromise[key] = Promise[key]\n        }\n      })\n    }\n\n    // Inherit to pass `instanceof` checks.\n    util.inherits(wrappedPromise, Promise)\n\n    // Make the wrapper.\n    return wrappedPromise\n    function wrappedPromise(executor) {\n      if (!(this instanceof wrappedPromise)) {\n        return Promise(executor) // eslint-disable-line new-cap\n      }\n\n      if (typeof executor !== 'function') {\n        return new Promise(executor)\n      }\n\n      var context = {\n        promise: null,\n        self: null,\n        args: null\n      }\n\n      var executorName = (executor.name || '<anonymous>')\n      var promise = new Promise(wrapExecutorContext(context))\n      context.promise = promise\n      promise.__NR_segment = _createSegment('Promise ' + executorName)\n\n      try {\n        // Must run after promise is defined so that `__NR_wrapper` can be set.\n        executor.apply(context.self, context.args)\n      } catch (e) {\n        context.args[1](e)\n      }\n\n      // The Promise must be created using the \"real\" Promise constructor (using\n      // normal Promise.apply(this) method does not work). But the prototype\n      // chain must include the wrappedPromise.prototype, V8's promise\n      // implementation uses promise.constructor to create new Promises for\n      // calls to `then`, `chain` and `catch` which allows these Promises to\n      // also be instrumented.\n      promise.__proto__ = wrappedPromise.prototype  // eslint-disable-line no-proto\n\n      return promise\n    }\n  }\n\n  function wrapPrototype(PromiseProto, name) {\n    // Don't wrap the proto if there is no spec for it.\n    if (!spec.$proto) {\n      return\n    }\n\n    name = name || (spec.constructor + '.prototype')\n\n    // Wrap up instance methods.\n    _safeWrap(PromiseProto, name, spec.$proto.executor, wrapExecutorCaller)\n    _safeWrap(PromiseProto, name, spec.$proto.then, wrapThen)\n    _safeWrap(PromiseProto, name, spec.$proto.catch, wrapCatch)\n  }\n\n  function wrapStaticMethods(lib, name, staticSpec) {\n    // Don't bother with empty specs.\n    if (!staticSpec) {\n      return\n    }\n\n    _safeWrap(lib, name, staticSpec.cast, wrapCast)\n  }\n\n  function wrapExecutorCaller(caller) {\n    return function wrappedExecutorCaller(executor) {\n      if (!(this instanceof Promise)) {\n        return caller.apply(this, arguments)\n      }\n\n      var context = {\n        promise: this,\n        self: null,\n        args: null\n      }\n      if (!this.__NR_segment) {\n        var executorName = executor.name || '<anonymous>'\n        this.__NR_segment = _createSegment('Promise ' + executorName)\n      }\n      var args = [].slice.call(arguments)\n      args[0] = wrapExecutorContext(context, this.__NR_segment)\n      var ret = caller.apply(this, args)\n\n      // Bluebird catches executor errors and auto-rejects when it catches them,\n      // thus we need to do so as well.\n      //\n      // When adding new libraries, make sure to check that they behave the same\n      // way. We may need to enhance the promise spec to handle this variance.\n      try {\n        executor.apply(context.self, context.args)\n      } catch (e) {\n        context.args[1](e)\n      }\n      return ret\n    }\n  }\n\n  /**\n   * Creates a function which will export the context and arguments of its\n   * execution.\n   *\n   * @param {object} context - The object to export the execution context with.\n   *\n   * @return {function} A function which, when executed, will add its context\n   *  and arguments to the `context` parameter.\n   */\n  function wrapExecutorContext(context, segment) {\n    return function contextExporter(resolve, reject) {\n      segment = segment || agent.tracer.segment\n      context.self = this\n      context.args = [].slice.call(arguments)\n      context.args[0] = wrappedResolve\n      context.args[1] = wrappedReject\n\n      // These wrappers create a function that can be passed a function and an\n      // argument to call as a continuation from the resolve or reject.\n      function wrappedResolve(val) {\n        var promise = context.promise\n        if (promise) {\n          linkChain(promise, promise.__NR_segment || segment, true)\n          if (promise.__NR_segment) {\n            promise.__NR_segment.touch()\n          }\n        }\n        return resolve(val)\n      }\n\n      function wrappedReject(val) {\n        var promise = context.promise\n        if (promise) {\n          linkChain(promise, promise.__NR_segment || segment, false)\n          if (promise.__NR_segment) {\n            promise.__NR_segment.touch()\n          }\n        }\n        return reject(val)\n      }\n    }\n  }\n\n  /**\n   * Brings the transaction through a promise to `then`ed continuations.\n   *\n   * @param {Promise}   ctx   The `this` argument for `fn`.\n   * @param {Function}  fn    The handler function\n   * @param {string}    name  The name function that added this link (i.e. then).\n   * @param {Promise}   next  Promise returned from calling `then`\n   * @param {Array}     args  Arguments passed into the `then` handler.\n   * @return {*} The value returned from the `then`ed function.\n   */\n  function linkTransaction(ctx, fn, name, next, args) {\n    if (!next) {\n      return fn.apply(ctx, args)\n    }\n\n    // next needs to have a wrapper function even if the callback throws.\n    try {\n      if (!next.__NR_segment) {\n        var segmentName = 'Promise#' + name + ' ' + (fn.name || '<anonymous>')\n        next.__NR_segment = _createSegment(segmentName)\n      }\n      var segment = next.__NR_segment\n      var result = agent.tracer.bindFunction(fn, segment, true).apply(ctx, args)\n    } finally {\n      if (result instanceof Promise && result !== next) {\n        linkChain(next, segment, null, function proxyWrapper() {\n          if (segment) {\n            segment.touch()\n          }\n          var link = result.__NR_wrapper\n          if (!link) {\n            link = agent.tracer.bindFunction(linkTransaction, segment, true)\n          }\n          return link.apply(this, arguments)\n        })\n      } else {\n        // If we have a result, we know we didn't reject and can bound linking\n        // to just the next resolve handler.\n        //                                          resolved : unknown\n        linkChain(next, segment, result !== undefined ? true : null)\n      }\n    }\n    return result\n  }\n\n  /**\n   * If the promise isn't already bound, this will bind it to the given segment.\n   *\n   * @param {Promise}       promise - The promise to link with the segment.\n   * @param {TraceSegment}  segment - The segment to link the promise with.\n   */\n  function bindLink(promise, segment) {\n    if (!promise.__NR_wrapper) {\n      promise.__NR_wrapper = agent.tracer.bindFunction(linkTransaction, segment, true)\n    }\n  }\n\n  /**\n   * Walks the promise chain, linking each one to the given segment.\n   *\n   * @param {Promise} promise\n   *  The first promise in the chain to link with the segment.\n   *\n   * @param {TraceSegment} segment\n   *  The segment to link the chain with.\n   *\n   * @param {?bool} [resolved]\n   *  Flag indicating if we only need to wrap down to the next resolve handler.\n   *  If true, linking will stop after the first resolve handler is found.\n   *\n   * @param {Function} [wrapper]\n   *  The wrapper to use for the linking. If not provided then `linkTransaction`\n   *  will be used as the wrapper.\n   */\n  function linkChain(promise, segment, resolved, wrapper) {\n    if (!wrapper) {\n      wrapper = agent.tracer.bindFunction(linkTransaction, segment, true)\n    }\n\n    var next = promise\n    while (next instanceof Promise) {\n      _tryAssignWrapper(next, wrapper)\n\n      // If we resolved and this is the resolve handler, stop linking here.\n      if (resolved && next.__NR_resolveHandler) {\n        break\n      }\n\n      // Unfortunately we can't preemptively stop for reject since some Promise\n      // libraries support long jumps on rejection according to error class.\n      // Thanks bluebird!\n\n      // Break when there is an infinite loop.\n      if (next.__NR_nextPromise === next) {\n        break\n      }\n      next = next.__NR_nextPromise\n    }\n  }\n\n  /**\n   * Creates a wrapper for `Promise#then` that extends the transaction context.\n   *\n   * @return {function} A wrapped version of `Promise#then`.\n   */\n  function wrapThen(then, name) {\n    return _wrapThen(then, name, true)\n  }\n\n  /**\n   * Creates a wrapper for `Promise#catch` that extends the transaction context.\n   *\n   * @return {function} A wrapped version of `Promise#catch`.\n   */\n  function wrapCatch(cach, name) {\n    return _wrapThen(cach, name, false)\n  }\n\n  /**\n   * Creates a wrapper for promise chain extending methods.\n   *\n   * @param {function} then\n   *  The function we are to wrap as a chain extender.\n   *\n   * @param {bool} useAllParams\n   *  When true, all parameters which are functions will be wrapped. Otherwise,\n   *  only the last parameter will be wrapped.\n   *\n   * @return {function} A wrapped version of the function.\n   */\n  function _wrapThen(then, name, useAllParams) {\n    // Don't wrap non-functions.\n    if (!(then instanceof Function) || then.name === '__NR_wrappedThen') {\n      return then\n    }\n\n    return function __NR_wrappedThen() {\n      if (!(this instanceof Promise)) {\n        return then.apply(this, arguments)\n      }\n\n      var thenSegment = agent.tracer.getSegment()\n      var promise = this\n\n      // Wrap up the arguments and execute the real then.\n      var hasResolve = false\n      var args = [].map.call(arguments, wrapHandler)\n      var next = then.apply(this, args)\n\n      // Make sure we got a promise and then return it.\n      if (next instanceof Promise && next !== promise) {\n        promise.__NR_resolveHandler = hasResolve\n        promise.__NR_nextPromise = next\n      }\n      return next\n\n      // Wrap callbacks (success, error) so that the callbacks will be called as\n      // a continuations of the accept or reject call using the __asl__wrapper\n      // created above.\n      function wrapHandler(fn, i, arr) {\n        if (\n          !(fn instanceof Function) ||              // Not a function\n          fn.name === '__NR_wrappedThenHandler' ||  // Already wrapped\n          (!useAllParams && i !== (arr.length - 1)) // Don't want all and not last\n        ) {\n          return fn\n        }\n\n        hasResolve = (hasResolve || (i === 0))\n\n        return function __NR_wrappedThenHandler() {\n          // Even though success/error handlers should have just one argument\n          // (value or error), internal implementations could be passing in more\n          // arguments.\n          if (!promise.__NR_wrapper) {\n            // The currently running segment is the least likely to be the\n            // correct one when working with Bluebird due to the way it queues\n            // all promise resolutions and executes them all at once.\n            //\n            // An option may be to prioritize the current segment, but compare\n            // its transaction ID to the transaction ID of the `thenSegment`. If\n            // they are the same, use the current segment, otherwise use the\n            // `thenSegment`. I'd prefer to wait for the simpler method to be\n            // proven invalid.\n            var segment =\n              promise.__NR_segment || thenSegment || agent.tracer.getSegment()\n            if (segment) {\n              bindLink(promise, segment)\n            } else {\n              return fn.apply(this, arguments)\n            }\n          }\n\n          // invoke linkTransaction()\n          return promise.__NR_wrapper(this, fn, name, next, arguments, promise)\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates a wrapper around the static `Promise` factory method.\n   */\n  function wrapCast(cast, name) {\n    if (!(cast instanceof Function) || cast.name === '__NR_wrappedCast') {\n      return cast\n    }\n\n    var CAST_SEGMENT_NAME = 'Promise.' + name\n    return function __NR_wrappedCast() {\n      var segment = _createSegment(CAST_SEGMENT_NAME)\n      var prom = cast.apply(this, arguments)\n      if (segment) {\n        bindLink(prom, segment)\n      }\n      return prom\n    }\n  }\n\n  function _createSegment(name, parent) {\n    return agent.config.feature_flag.promise_segments === true\n      ? agent.tracer.createSegment(name, null, parent)\n      : (parent || agent.tracer.getSegment())\n  }\n}\n\n/**\n * Performs a `wrapMethod` if and only if `methods` is truthy and has a length\n * greater than zero.\n *\n * @param {object}        obj     - The source of the methods to wrap.\n * @param {string}        name    - The name of this source.\n * @param {string|array}  methods - The names of the methods to wrap.\n * @param {function}      wrapper - The function which wraps the methods.\n */\nfunction _safeWrap(obj, name, methods, wrapper) {\n  if (methods && methods.length) {\n    shimmer.wrapMethod(obj, name, methods, wrapper)\n  }\n}\n\n/**\n * Attempts to add the given wrapper to the promise.\n *\n * This can fail if `prom` has been sealed.\n */\nfunction _tryAssignWrapper(prom, wrapper) {\n  try {\n    prom.__NR_wrapper = wrapper\n  } catch (err) {\n    logger.info({err: err}, 'Failed to add wrapper to promise')\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/promise.js\n// module id = 198\n// module chunks = 0","'use strict'\n\nvar path = require('path')\nvar fs = require('fs')\nvar logger = require('./logger').child({component: 'shimmer'})\nvar INSTRUMENTATION = require('./instrumentations')()\n\n/*\n *\n * CONSTANTS\n *\n */\n\nvar CORE_INSTRUMENTATION = {\n  child_process: 'child_process.js',\n  crypto: 'crypto.js',\n  domain: 'domain.js',\n  dns: 'dns.js',\n  fs: 'fs.js',\n  http: 'http.js',\n  https: 'http.js',\n  net: 'net.js',\n  timers: 'timers.js',\n  zlib: 'zlib.js'\n}\n\n/**\n * Unwrapping is only likely to be used by test code, and is a fairly drastic\n * maneuver, but it should be pretty safe if there's a desire to reboot the\n * agent in flight.\n *\n * All of the wrapped methods are tracked in this variable and used by unwrapAll\n * below.\n */\nvar instrumented = []\n\n/**\n * All instrumentation files must export the same interface: a single\n * initialization function that takes the agent and the module to be\n * instrumented.\n */\nfunction instrument(agent, shortName, fileName, nodule, moduleName) {\n  var fullPath = path.resolve(fileName)\n  if (!fs.existsSync(fileName)) {\n    return logger.warn(\n      'Tried to load instrumentation from %s, but file does not exist',\n      fullPath\n    )\n  }\n  try {\n    require(fileName)(agent, nodule, moduleName)\n  } catch (error) {\n    logger.warn(\n      error,\n      'Failed to instrument module %s using %s',\n      path.basename(shortName, '.js'),\n      fullPath\n    )\n  }\n}\n\nfunction _postLoad(agent, nodule, name) {\n  var instrumentation\n  var base = path.basename(name)\n\n  // to allow for instrumenting both 'pg' and 'pg.js'.\n  if (name === 'pg.js') {\n    instrumentation = 'pg'\n  } if (name === 'mysql2') {\n    // mysql2 (https://github.com/sidorares/node-mysql2) is a drop in replacement for\n    // mysql which conforms to the existing mysql API. If we see mysql2, treat it as\n    // mysql\n    instrumentation = 'mysql'\n  } else {\n    instrumentation = base\n  }\n\n  // necessary to prevent instrument() from causing an infinite loop\n  if (INSTRUMENTATION.indexOf(instrumentation) !== -1) {\n    logger.trace('Instrumenting %s.', base)\n    var filename = path.join(__dirname, 'instrumentation', instrumentation + '.js')\n    instrument(agent, base, filename, nodule)\n  }\n\n  return nodule\n}\n\nvar shimmer = module.exports = {\n  /**\n   * If debug isn't false, the agent will retain references to wrapped methods\n   * for the entire lifetime of the agent. Some instrumentation depends on\n   * wrapping functions on individual objects, and this will cause the agent\n   * to retain references to a large number of dead objects.\n   */\n  debug: false,\n\n  /**\n   * Detects if the given function has already been wrapped.\n   *\n   * @param {function} fn - The function to look for a wrapper on.\n   *\n   * @return {bool} True if `fn` exists and has an attached original, else false.\n   */\n  isWrapped: function isWrapped(fn) {\n    return !!(fn && fn.__NR_original)\n  },\n\n  /**\n   * Don't throw, but do log and bail out if wrapping fails.\n   *\n   * Provide an escape hatch by creating a closure around the original method\n   * and object / module wrapped into a helper function that will restore the\n   * original function / method. See Sinon for a systematic use of this\n   * pattern.\n   *\n   * @param {object} nodule Class or module containing the function to wrap.\n   * @param {object} noduleName Human-readable module / Class name. More\n   *                            helpful than you'd think.\n   * @param {string} methods One or more names of methods or functions to extract\n   *                         and wrap.\n   * @param {function} wrapper A generator that, when called, returns a\n   *                           wrapped version of the original function.\n   */\n  wrapMethod: function wrapMethod(nodule, noduleName, methods, wrapper) {\n    if (!methods) {\n      return logger.warn(new Error(),\n                         \"Must include a method name to wrap. Called from:\")\n    }\n\n    if (!noduleName) noduleName = '[unknown]'\n    if (!Array.isArray(methods)) methods = [methods]\n\n    methods.forEach(function cb_forEach(method) {\n      var fqmn = noduleName + '.' + method\n\n      if (!nodule) return logger.debug(\"Can't wrap %s from nonexistent object.\",\n                                       fqmn)\n      if (!wrapper) return logger.debug(\"Can't wrap %s without a wrapper generator.\",\n                                        fqmn)\n\n      var original = nodule[method]\n\n      if (!original) return logger.trace(\"%s not defined, so not wrapping.\", fqmn)\n      if (original.__NR_unwrap) return logger.debug(\"%s already wrapped by agent.\", fqmn)\n\n      var wrapped = wrapper(original, method)\n      wrapped.__NR_original = original\n      wrapped.__NR_unwrap = function __NR_unwrap() {\n        nodule[method] = original\n        logger.trace(\"Removed instrumentation from %s.\", fqmn)\n      }\n\n      nodule[method] = wrapped\n      if (shimmer.debug) instrumented.push(wrapped)\n      logger.trace(\"Instrumented %s.\", fqmn)\n    })\n  },\n\n  /**\n   * Sometimes you gotta do some crazy stuff to get the job done. Instead of using\n   * regular monkeypatching, wrapDeprecated allows you to pass in a getter and setter\n   * and then uses defineProperty to replace the original property with an\n   * accessor. Note that responsibility for unwrapping is not handled by this\n   * function.\n   *\n   * @param {object}   nodule     Class or module containing the property to\n   *                              wrap.\n   * @param {object}   noduleName Human-readable module / Class name. More\n   *                              helpful than you'd think.\n   * @param {string}   property   The property to replace with the accessor.\n   * @param {function} options    Optional getter and setter to use for the accessor.\n   *\n   * @returns {object} The original value of the property.\n   */\n  wrapDeprecated: function wrapDeprecated(nodule, noduleName, property, options) {\n    if (!property) {\n      logger.warn(new Error(), \"Must include a function name to wrap. Called from:\")\n      return\n    }\n\n    if (!noduleName) noduleName = '[unknown]'\n\n    var fqmn = noduleName + '.' + property\n    if (!nodule) {\n      logger.debug(\"Can't wrap %s from nonexistent object.\", fqmn)\n      return\n    }\n\n    var original = nodule[property]\n    if (!original) {\n      logger.trace(\"%s not defined, so not wrapping.\", fqmn)\n      return\n    }\n\n    delete nodule[property]\n\n    var descriptor = {\n      configurable: true,\n      enumerable: true\n    }\n    if (options.get) descriptor.get = options.get\n    if (options.set) descriptor.set = options.set\n    Object.defineProperty(nodule, property, descriptor)\n    logger.trace(\"Instrumented %s.\", fqmn)\n\n    if (shimmer.debug) {\n      instrumented.push({\n        __NR_unwrap: function unwrapDeprecated() {\n          delete nodule[property]\n          nodule[property] = original\n        }\n      })\n    }\n\n    return original\n  },\n\n  unwrapMethod: function unwrapMethod(nodule, noduleName, method) {\n    if (!noduleName) noduleName = '[unknown]'\n    if (!method) return logger.debug(\"Must include a method name to unwrap. \" +\n                                     \"Called from: %s\", new Error().stack)\n\n    var fqmn = noduleName + '.' + method\n\n    if (!nodule) return logger.debug(\"Can't unwrap %s from nonexistent object.\",\n                                     fqmn)\n    var wrapped = nodule[method]\n\n    // keep instrumented up to date\n    var pos = instrumented.indexOf(wrapped)\n    if (pos !== -1) instrumented.splice(pos, 1)\n\n    if (!wrapped) return logger.debug(\"%s not defined, so not unwrapping.\", fqmn)\n    if (!wrapped.__NR_unwrap) return logger.debug(\"%s isn't unwrappable.\", fqmn)\n\n    wrapped.__NR_unwrap()\n  },\n\n  unwrapAll: function unwrapAll() {\n    instrumented.forEach(function cb_forEach(wrapper) {\n      wrapper.__NR_unwrap()\n    })\n    instrumented = []\n  },\n\n  /**\n   * Patch the module.load function so that we see modules loading and\n   * have an opportunity to patch them with instrumentation.\n   */\n  patchModule: function patchModule(agent) {\n    logger.trace(\"Wrapping module loader.\")\n    var Module = require('module')\n\n    shimmer.wrapMethod(Module, 'Module', '_load', function cb_wrapMethod(load) {\n      return function cls_wrapMethod(file) {\n        return _postLoad(agent, load.apply(this, arguments), file)\n      }\n    })\n  },\n\n  unpatchModule: function unpatchModule() {\n    logger.trace(\"Unwrapping to previous module loader.\")\n    var Module = require('module')\n\n    shimmer.unwrapMethod(Module, 'Module', '_load')\n  },\n\n  bootstrapInstrumentation: function bootstrapInstrumentation(agent) {\n    var globalsFilepath = path.join(__dirname, 'instrumentation', 'core', 'globals.js')\n    instrument(agent, 'globals', globalsFilepath, global)\n\n    Object.keys(CORE_INSTRUMENTATION).forEach(function cb_forEach(mojule) {\n      var filename = CORE_INSTRUMENTATION[mojule]\n      var filepath = path.join(__dirname, 'instrumentation/core', filename)\n      var uninstrumented\n\n      try {\n        uninstrumented = require(mojule)\n      } catch (err) {\n        logger.trace(\n          'Could not load core module %s got error %s',\n          mojule,\n          err\n        )\n      }\n\n      instrument(agent, filename, filepath, uninstrumented, mojule)\n    })\n  },\n\n  /**\n   * NOT FOR USE IN PRODUCTION CODE\n   *\n   * If an instrumented module has a dependency on another instrumented module,\n   * and multiple tests are being run in a single test suite with their own\n   * setup and teardown between tests, it's possible transitive dependencies\n   * will be unwrapped in the module cache in-place (which needs to happen to\n   * prevent stale closures from channeling instrumentation data to incorrect\n   * agents, but which means the transitive dependencies won't get re-wrapped\n   * the next time the parent module is required).\n   *\n   * Since this only applies in test code, it's not worth the drastic\n   * monkeypatching to Module necessary to walk the list of child modules and\n   * re-wrap them.\n   *\n   * Use this to re-apply any applicable instrumentation.\n   */\n  reinstrument: function reinstrument(agent, modulePath) {\n    return _postLoad(agent, require(modulePath), modulePath)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/shimmer.js\n// module id = 199\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer')\nvar CASSANDRA = require('../metrics/names').CASSANDRA\nvar parseSql = require('../db/parse-sql')\n\nmodule.exports = function initialize(agent, cassandra) {\n  var tracer = agent.tracer\n  var proto = cassandra.Client.prototype\n\n  shimmer.wrapMethod(proto, 'Cassandra.Client.prototype', ['_innerExecute'], wrapExec)\n  shimmer.wrapMethod(proto, 'Cassandra.Client.prototype', ['batch'], wrapBatch)\n\n  shimmer.wrapMethod(\n    proto,\n    'Cassandra.Client.prototype',\n    ['connect'],\n    tracer.wrapFunctionLast.bind(tracer, CASSANDRA.OPERATION + '/connect', null)\n  )\n\n  shimmer.wrapMethod(\n    proto,\n    'Cassandra.Client.prototype',\n    ['shutdown'],\n    tracer.wrapFunctionLast.bind(tracer, CASSANDRA.OPERATION + '/shutdown', null)\n  )\n\n  function wrapExec(original) {\n    return tracer.wrapFunction(\n      CASSANDRA.STATEMENT + 'Unknown',\n      null,\n      original,\n      wrappedExec\n    )\n\n    function wrappedExec(segment, args, bind) {\n      var ps = parseSql(CASSANDRA.PREFIX, args[0])\n\n      var model = (ps.model || 'unknown')\n      if (this.keyspace && model.indexOf('.') === -1) model = this.keyspace + '.' + model\n      segment.name = CASSANDRA.STATEMENT + model + '/' + ps.operation\n\n      segment.transaction.addRecorder(ps.recordMetrics.bind(ps, segment))\n      var last = args.length - 1\n      args[last] = bind(args[last])\n      return args\n    }\n  }\n\n  function wrapBatch(original) {\n    return tracer.wrapFunction(\n      CASSANDRA.STATEMENT + 'Unknown',\n      null,\n      original,\n      wrappedBatch\n    )\n\n    function wrappedBatch(segment, args, bind) {\n      var sql = (args[0] && args[0][0]) || ''\n      if (sql.query) sql = sql.query\n      var ps = parseSql(CASSANDRA.PREFIX, sql)\n\n      var model = (ps.model || 'unknown')\n      if (this.keyspace && model.indexOf('.') === -1) model = this.keyspace + '.' + model\n      segment.name = CASSANDRA.STATEMENT + model + '/' + ps.operation + '/batch'\n\n      segment.transaction.addRecorder(ps.recordMetrics.bind(ps, segment))\n      var last = args.length - 1\n      args[last] = bind(args[last])\n      return args\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/cassandra-driver.js\n// module id = 200\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer')\nvar logger = require('../logger').child({component: 'connect'})\n\n\n/*\n *\n * CONSTANTS\n *\n */\n\nvar ORIGINAL = '__NR_original'\nvar RESERVED = [ // http://es5.github.io/#x7.6.1.2\n  // always (how would these even get here?)\n  'class', 'enum', 'extends', 'super', 'const', 'export', 'import',\n  // strict\n  'implements', 'let', 'private', 'public', 'yield', 'interface',\n  'package', 'protected', 'static'\n]\n\n/**\n * ES5 strict mode disallows some identifiers that are allowed in non-strict\n * code. Mangle function names that are on that list of keywords so they're\n * non-objectionable in strict mode (which is currently enabled everywhere\n * inside the agent, as well as at many customer sites).\n *\n * If you really need to crawl your Express apps middleware stack, change\n * your test to use name.indexOf('whatever') === 0 as the predicate instead\n * of name === 'whatever'. It's a little slower, but you shouldn't be doing\n * that anyway.\n *\n * @param {string} name The candidate function name\n *\n * @returns {string} A safe (potentially mangled) function name.\n */\nfunction mangle(name) {\n  var parts = name.split(' ')\n  name = parts[parts.length - 1]\n\n  if (RESERVED.indexOf(name) !== -1) return name + '_'\n\n  return name\n}\n\nmodule.exports = function initialize(agent, connect) {\n  var tracer = agent.tracer\n\n  var interceptor = {\n    route: '',\n    handle: function sentinel(error, req, res, next) {\n      if (error) {\n        var transaction = agent.tracer.getTransaction()\n        agent.errors.add(transaction, error)\n      }\n\n      return next(error)\n    }\n  }\n\n  /**\n   * Problem:\n   *\n   * 1. Connect determines whether middleware functions are error handlers by\n   *    testing their arity. Not cool.\n   * 2. Downstream Express users rely upon being able to iterate over their\n   *    middleware stack to find specific middleware functions. Sorta less\n   *    uncool, but still a pain.\n   *\n   * Solution:\n   *\n   * Use eval. This once. For this one specific purpose. Not anywhere else for\n   * any reason.\n   */\n  function wrapHandle(__NR_handle) {\n    // jshint -W061\n    var arglist\n    var name = ''\n\n\n    // reiterated: testing function arity is stupid\n    switch (__NR_handle.length) {\n      case 2:\n        arglist = '(req, res)'\n        break\n\n      case 3:\n        arglist = '(req, res, next)'\n        break\n\n      // don't break other error handlers\n      case 4:\n        arglist = '(err, req, res, next)'\n        break\n\n      default:\n        arglist = '()'\n    }\n\n    if (__NR_handle.name) name = mangle(__NR_handle.name)\n\n    // leave this function anonymous\n    // it's connect madness\n    /* eslint-disable func-names */\n    var template = function() {\n      var args = tracer.slice(arguments)\n      var last = args.length - 1\n\n\n      if (typeof args[last] === 'function') {\n        args[last] = tracer.bindFunction(args[last])\n      }\n\n      __NR_handle.apply(this, args)\n    }\n    /* eslint-enable func-names */\n\n    // I am a bad person and this makes me feel bad.\n    // We use eval because we need to insert the function with a specific name to\n    // allow for lookup.\n    /* eslint-disable no-eval */\n    var wrapped = eval(\n      '(function(){return function ' + name + arglist +\n      template.toString().substring(11) + '}())'\n    )\n    /* eslint-enable no-eval */\n    wrapped[ORIGINAL] = __NR_handle\n\n    return wrapped\n  }\n\n  function wrapUse(use) {\n    return function cls_wrapUse() {\n      if (!this.stack) return use.apply(this, arguments)\n\n      this.stack = this.stack.filter(function cb_filter(m) {\n        return m !== interceptor\n      })\n\n      /* We allow `use` to go through the arguments so it can reject bad things\n       * for us so we don't have to also do argument type checking.\n       */\n      var app = use.apply(this, arguments)\n\n      // wrap most recently added unwrapped handler\n      var top = this.stack.pop()\n      if (top) {\n          if (top.handle &&\n              typeof top.handle === 'function' &&\n              !top.handle[ORIGINAL]) {\n            top.handle = wrapHandle(top.handle)\n          }\n          this.stack.push(top)\n      }\n\n      /* Give the error tracer a better chance of intercepting errors by\n       * putting it before the first error handler (a middleware that takes 4\n       * parameters, in Connects world). Error handlers tend to be placed\n       * towards the end of the middleware chain and sometimes don't pass\n       * errors along. Don't just put the interceptor at the beginning because\n       * we want to allow as many middleware functions to execute as possible\n       * before the interceptor is run, to increase error coverage.\n       *\n       * NOTE: This is heuristic, and works because interceptor propagates\n       *       errors instead of terminating the middleware chain.\n       *       Ignores routes.\n       */\n      var spliced = false\n      for (var i = 0; i < this.stack.length; i++) {\n        var middleware = this.stack[i]\n        // Check to see if it is an error handler middleware\n        if (middleware &&\n            middleware.handle &&\n            middleware.handle.length === 4) {\n          this.stack.splice(i, 0, interceptor)\n          spliced = true\n          break\n        }\n      }\n      if (!spliced) this.stack.push(interceptor)\n\n      // don't break chaining\n      return app\n    }\n  }\n\n  /**\n   * Connect 1 and 2 are very different animals, but like Express, it mostly\n   * comes down to factoring.\n   */\n  var version = connect && connect.version && connect.version[0]\n  switch (version) {\n    case '1':\n      shimmer.wrapMethod(connect && connect.HTTPServer && connect.HTTPServer.prototype,\n                         'connect.HTTPServer.prototype',\n                         'use',\n                         wrapUse)\n      break\n\n    case '2':\n      shimmer.wrapMethod(connect && connect.proto,\n                         'connect.proto',\n                         'use',\n                         wrapUse)\n      break\n\n    default:\n      logger.debug(\"Unrecognized version %s of Connect detected; not instrumenting.\",\n                   version)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/connect.js\n// module id = 201\n// module chunks = 0","'use strict'\n\nvar wrap = require('../../shimmer').wrapMethod\n\nmodule.exports = initialize\n\nfunction initialize(agent, childProcess) {\n  var methods = ['exec', 'execFile']\n\n  wrap(childProcess, 'childProcess', methods, wrapMethod)\n\n  function wrapMethod(fn, method) {\n    return agent.tracer.wrapFunctionLast('child_process.' + method, null, fn)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/child_process.js\n// module id = 202\n// module chunks = 0","'use strict'\n\nvar wrap = require('../../shimmer').wrapMethod\n\nmodule.exports = initialize\n\nfunction initialize(agent, crypto) {\n  wrap(crypto, 'crypto', ['pbkdf2', 'randomBytes', 'pseudoRandomBytes'], wrapCryptoMethod)\n\n  function wrapCryptoMethod(fn, method) {\n    return agent.tracer.wrapFunctionLast('crypto.' + method, null, wrappedCrypto)\n\n    function wrappedCrypto() {\n      return fn.apply(this, arguments)\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/crypto.js\n// module id = 203\n// module chunks = 0","'use strict'\n\nvar wrap = require('../../shimmer').wrapMethod\n\nmodule.exports = initialize\n\nfunction initialize(agent, dns) {\n  var methods = [\n    'lookup',\n    'resolve',\n    'resolve4',\n    'resolve6',\n    'resolveCname',\n    'resolveMx',\n    'resolveNaptr',\n    'resolveNs',\n    'resolvePtr',\n    'resolveSrv',\n    'resolveTxt',\n    'reverse'\n  ]\n\n  wrap(dns, 'dns', methods, wrapDns)\n\n  function wrapDns(fn, method) {\n    return agent.tracer.wrapFunctionLast('dns.' + method, null, fn)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/dns.js\n// module id = 204\n// module chunks = 0","'use strict'\n\nvar wrap = require('../../shimmer').wrapMethod\n\nmodule.exports = initialize\n\nfunction initialize(agent, domain) {\n  var proto = domain.Domain.prototype\n  wrap(\n    proto,\n    'domain.Domain.prototype',\n    'emit',\n    wrapEmit\n  )\n\n  function wrapEmit(original) {\n    return function wrappedEmit(ev) {\n      var shouldRestoreContext = ev === 'error' &&\n          agent.tracer.segment === null &&\n          this.__NR_transactionSegment\n\n      if (shouldRestoreContext) {\n        agent.tracer.segment = this.__NR_transactionSegment\n      }\n\n      var result = original.apply(this, arguments)\n\n      if (shouldRestoreContext) {\n        agent.tracer.segment = null\n        this.__NR_transactionSegment = null\n      }\n\n      return result\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/domain.js\n// module id = 205\n// module chunks = 0","'use strict'\n\nvar record = require('../../metrics/recorders/generic.js')\nvar NAMES = require('../../metrics/names.js')\nvar wrap = require('../../shimmer').wrapMethod\n\nmodule.exports = initialize\n\nfunction initialize(agent, fs) {\n  var methods = [\n    'rename',\n    'truncate',\n    'chown',\n    'lchown',\n    'fchown',\n    'chmod',\n    'lchmod',\n    'fchmod',\n    'stat',\n    'lstat',\n    'fstat',\n    'link',\n    'symlink',\n    'readlink',\n    'realpath',\n    'unlink',\n    'rmdir',\n    'mkdir',\n    'mkdtemp',\n    'readdir',\n    'close',\n    'open',\n    'utimes',\n    'futimes',\n    'fsync',\n    'readFile',\n    'writeFile',\n    'appendFile',\n    'exists',\n    'ftruncate'\n  ]\n\n  var uninstrumented = [\n    'write',\n    'read'\n  ]\n\n  wrap(fs, 'fs', methods, segment)\n  wrap(fs, 'fs', uninstrumented, agent.tracer.wrapFunctionNoSegment.bind(agent.tracer))\n  wrap(fs, 'fs', ['watch'], wrapWatch)\n  wrap(fs, 'fs', ['watchFile'], wrapWatchFile)\n\n  function segment(fn, method) {\n    return agent.tracer.wrapFunctionLast(NAMES.FS.PREFIX + method, record, fn)\n  }\n\n  function wrapWatch(fn) {\n    return function wrappedWatch() {\n      var args = agent.tracer.slice(arguments)\n      var last = args.length - 1\n\n      if (typeof args[last] === 'function') {\n        var cb = args[last]\n        args[last] = agent.tracer.bindFunction(cb)\n      }\n\n      return agent.tracer.bindEmitter(fn.apply(this, args))\n    }\n  }\n\n  function wrapWatchFile(fn) {\n    return function wrappedWatchFile() {\n      var args = agent.tracer.slice(arguments)\n      var last = args.length - 1\n\n      if (typeof args[last] === 'function') {\n        var cb = args[last]\n        args[last] = agent.tracer.bindFunction(cb)\n        // allow unwatchFile to work despite cb being wrapped\n        args[last].listener = cb\n      }\n\n      return fn.apply(this, args)\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/fs.js\n// module id = 206\n// module chunks = 0","'use strict'\n\nfunction record(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n\n\n  if (scope) transaction.measure(segment.name, scope, duration, exclusive)\n\n  transaction.measure(segment.name, null, duration, exclusive)\n}\n\nmodule.exports = record\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/generic.js\n// module id = 207\n// module chunks = 0","'use strict'\n\nvar events = require('events')\nvar wrap = require('../../shimmer').wrapMethod\nvar promInit = require('../promise')\n\nmodule.exports = initialize\n\n/**\n * The spec for the native `Promise` class.\n */\nvar STATIC_PROMISE_METHODS = ['accept', 'all', 'defer', 'race', 'reject', 'resolve']\nvar NATIVE_PROMISE_SPEC = {\n  name: 'global',\n  constructor: 'Promise',\n  executor: true,\n  $proto: {\n    then: ['then', 'chain'],\n    catch: ['catch']\n  },\n  $static: {\n    $copy: STATIC_PROMISE_METHODS,\n    cast: STATIC_PROMISE_METHODS\n  }\n}\n\nfunction initialize(agent) {\n  // Add handler for uncaught/fatal exceptions to record them.\n  // _fatalException is an undocumented feature of domains, introduced in\n  // Node.js v0.8. We use _fatalException when possible because wrapping it will\n  // not potentially change the behavior of the server.\n  if (process._fatalException) {\n    wrap(process, 'process', '_fatalException', function wrapper(original) {\n      return function wrappedFatalException(error) {\n        // Only record the error if we are not currently within an instrumented\n        // domain.\n        if (!process.domain) {\n          agent.errors.add(null, error)\n          agent.tracer.segment = null\n        }\n        return original.apply(this, arguments)\n      }\n    })\n  } else {\n    wrap(\n      process,\n      'process',\n      'emit',\n      function wrapEmit(original) {\n        return function wrappedEmit(ev, error) {\n          if (ev === 'uncaughtException' && error && !process.domain) {\n            agent.errors.add(null, error)\n            agent.tracer.segment = null\n          }\n\n          return original.apply(this, arguments)\n        }\n      }\n    )\n  }\n\n  // Add a handler for unhandled promise rejections.\n  process.on('unhandledRejection', function __NR_unhandledRejectionHandler(err, promise) {\n    // If we're the only listener for this event, report the error.\n    if (listenerCount(process, 'unhandledRejection') < 2) {\n      var transaction = promise.__NR_segment && promise.__NR_segment.transaction\n      agent.errors.add(transaction, err)\n    }\n  })\n\n  promInit(agent, global, NATIVE_PROMISE_SPEC)\n}\n\nfunction listenerCount(emitter, evnt) {\n  if (events.EventEmitter.listenerCount) {\n    return events.EventEmitter.listenerCount(emitter, evnt)\n  }\n  return emitter.listeners(evnt).length\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/globals.js\n// module id = 208\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../../shimmer.js')\nvar logger = require('../../logger').child({component: 'http'})\nvar recordWeb = require('../../metrics/recorders/http.js')\nvar hashes = require('../../util/hashes.js')\nvar cat = require('../../util/cat.js')\nvar instrumentOutbound = require('../../transaction/tracer/instrumentation/outbound.js')\nvar util = require('util')\nvar url = require('url')\nvar semver = require('semver')\n\nvar NAMES = require('../../metrics/names.js')\n\n/*\n *\n * CONSTANTS\n *\n */\nvar NR_CONNECTION_PROP = '__NR__connection'\nvar DEFAULT_HOST = 'localhost'\nvar DEFAULT_PORT = 80\nvar REQUEST_HEADER = 'x-request-start'\nvar QUEUE_HEADER = 'x-queue-start'\nvar NEWRELIC_ID_HEADER = 'x-newrelic-id'\nvar NEWRELIC_APP_DATA_HEADER = 'x-newrelic-app-data'\nvar NEWRELIC_TRANSACTION_HEADER = 'x-newrelic-transaction'\nvar NEWRELIC_SYNTHETICS_HEADER = 'x-newrelic-synthetics'\nvar CONTENT_LENGTH_REGEX = /^Content-Length$/i\n\n\n// For incoming requests this instrumentation functions by wrapping\n// `http.createServer` and `http.Server#addListener`. The former merely sets the\n// agent dispatcher to 'http' and the latter wraps any event handlers bound to\n// `request`.\n//\n// The `request` event listener wrapper creates a transaction proxy which will\n// start a new transaction whenever a new request comes in. It also scans the\n// headers of the incoming request looking for CAT and synthetics headers.\n\nfunction wrapListener(agent, listener) {\n  if (!listener) {\n    logger.debug('No request listener defined, not wrapping.')\n    return listener\n  }\n\n  var tracer = agent.tracer\n  var serverPort = null\n\n  return tracer.transactionProxy(function wrappedHandler(request, response) {\n    var transaction = tracer.getTransaction()\n    if (!transaction) return listener.apply(this, arguments)\n\n    transaction.nameState.setPrefix(NAMES.NODEJS.PREFIX)\n\n    var collectedRequestHeaders = [\n      'accept',\n      'contentLength',\n      'contentType',\n      'referer',\n      'host'\n    ]\n\n    if (request) {\n      for (var i = 0; i < collectedRequestHeaders.length; i++) {\n        var headerKey = collectedRequestHeaders[i]\n        var header = request.headers[headerKey.toLowerCase()]\n        if (header !== undefined) {\n          // If any more processing of the headers is required consider refactoring this.\n          if (headerKey === 'referer') {\n            var queryParamIndex = header.indexOf('?')\n            if (queryParamIndex !== -1) {\n              header = header.substring(0, queryParamIndex)\n            }\n          }\n\n          var attributeName = 'request.headers.' + headerKey\n          transaction.addAgentAttribute(attributeName, header)\n        }\n      }\n\n      if (request.method !== undefined) {\n        transaction.addAgentAttribute('request.method', request.method)\n      }\n      if (request.headers['user-agent'] !== undefined) {\n          transaction.addAgentAttribute('request.headers.userAgent',\n              request.headers['user-agent'])\n      }\n    }\n\n    // Create the transaction segment using the request URL for now. Once a\n    // better name can be determined this segment will be renamed to that.\n    var segment = tracer.createSegment(request.url, recordWeb)\n    segment.start()\n\n    if (agent.config.feature_flag.custom_instrumentation) {\n      transaction.webSegment = segment\n    }\n\n    /* Needed for Connect and Express middleware that monkeypatch request\n     * and response via listeners.\n     */\n    tracer.bindEmitter(request, segment)\n    tracer.bindEmitter(response, segment)\n\n    // the error tracer needs a URL for tracing, even though naming overwrites\n    transaction.parsedUrl = url.parse(request.url, true)\n    transaction.url = transaction.parsedUrl.pathname\n    transaction.verb = request.method\n\n    // URL is sent as an agent attribute with transaction events\n    if (agent.config.feature_flag.send_request_uri_attribute) {\n      transaction.addAgentAttribute('request_uri', transaction.url)\n    }\n\n    // store the port on which this transaction runs\n    if (this.address instanceof Function) {\n      var address = this.address()\n      if (address) {\n        serverPort = address.port\n      }\n    }\n    transaction.port = serverPort\n\n    // need to set any config-driven names early for RUM\n    logger.trace({url: request.url, transaction: transaction.id},\n      'Applying user naming rules for RUM.')\n    transaction.applyUserNamingRules(request.url)\n\n    /**\n     * Calculate Queue Time\n     *\n     * Queue time is provided by certain providers by stamping the request\n     * header with the time the request arrived at the router.\n     *\n     * Units for queue time are\n     */\n    var qtime = request.headers[REQUEST_HEADER] || request.headers[QUEUE_HEADER]\n    if (qtime) {\n      var split = qtime.split('=')\n      if (split.length > 1) {\n        qtime = split[1]\n      }\n\n      var start = parseFloat(qtime)\n\n      if (isNaN(start)) {\n        logger.warn('Queue time header parsed as NaN (' + qtime + ')')\n      } else {\n        // nano seconds\n        if (start > 1e18) start = start / 1e6\n        // micro seconds\n        else if (start > 1e15) start = start / 1e3\n        // seconds\n        else if (start < 1e12) start = start * 1e3\n\n        transaction.queueTime = Date.now() - start\n      }\n    }\n    if (agent.config.feature_flag.cat) {\n      var encKey = agent.config.encoding_key\n      var incomingCatId = request.headers[NEWRELIC_ID_HEADER]\n      var obfTransaction = request.headers[NEWRELIC_TRANSACTION_HEADER]\n      var synthHeader = request.headers[NEWRELIC_SYNTHETICS_HEADER]\n      if (encKey) {\n        cat.handleCatHeaders(incomingCatId, obfTransaction, encKey, transaction)\n        if (transaction.incomingCatId) {\n          logger.trace('Got inbound request CAT headers in transaction %s',\n            transaction.id)\n        }\n        if (synthHeader && agent.config.trusted_account_ids) {\n          handleSyntheticsHeader(\n            synthHeader,\n            encKey,\n            agent.config.trusted_account_ids,\n            transaction\n          )\n        }\n      }\n    }\n\n    function instrumentedFinish() {\n      // Remove listeners so this doesn't get called twice.\n      response.removeListener('finish', instrumentedFinish)\n      request.removeListener('aborted', instrumentedFinish)\n\n      // Naming must happen before the segment and transaction are ended,\n      // because metrics recording depends on naming's side effects.\n      transaction.setName(transaction.parsedUrl, response.statusCode)\n\n      if (response) {\n        if (response.statusCode !== undefined) {\n          var statusCode = response.statusCode\n          if (typeof statusCode.toString === 'function') {\n            var responseCode = statusCode.toString()\n            if (typeof responseCode === 'string') {\n              transaction.addAgentAttribute('httpResponseCode', responseCode)\n            }\n          }\n\n          var responseStatus = parseInt(statusCode, 10)\n          if (!isNaN(responseStatus)) {\n            transaction.addAgentAttribute('response.status', responseStatus)\n          }\n        }\n        if (response.statusMessage !== undefined) {\n          transaction.addAgentAttribute('httpResponseMessage', response.statusMessage)\n        }\n\n        var contentLength = response.getHeader('content-length')\n        if (contentLength) {\n          transaction.addAgentAttribute(\n            'response.headers.contentLength',\n            parseInt(contentLength, 10)\n          )\n        }\n\n        var contentType = response.getHeader('content-type')\n        if (contentType) {\n          transaction.addAgentAttribute(\n            'response.headers.contentType',\n            contentType\n          )\n        }\n      }\n      // This should be the last thing called before the web segment finishes.\n      segment.markAsWeb(transaction.parsedUrl)\n      segment.end()\n      transaction.end()\n    }\n    response.once('finish', instrumentedFinish)\n    request.once('aborted', instrumentedFinish)\n\n    return tracer.bindFunction(listener, segment).apply(this, arguments)\n  })\n}\n\n// FLAG: cat this wont be used unless cat is enabled, see below where we\n// actually do the shimmer stuff if you'd like to verify.\nfunction wrapWriteHead(agent, writeHead) {\n  return function wrappedWriteHead() {\n    var transaction = agent.tracer.getTransaction()\n    if (!transaction) {\n      logger.trace('No transaction - not adding response CAT headers')\n      return writeHead.apply(this, arguments)\n    }\n    // FLAG: synthetics\n    if (agent.config.feature_flag.synthetics && transaction.syntheticsHeader) {\n      this.setHeader(NEWRELIC_SYNTHETICS_HEADER, transaction.syntheticsHeader)\n    }\n\n    if (!transaction.incomingCatId) {\n      logger.trace('No incoming CAT ID - not adding response CAT headers')\n      return writeHead.apply(this, arguments)\n    }\n\n    if (!agent.config.trusted_account_ids) {\n      logger.trace('No account IDs defined in config.trusted_account_ids - ' +\n        'not adding response CAT headers')\n      return writeHead.apply(this, arguments)\n    }\n\n    var accountId = transaction.incomingCatId.split('#')[0]\n    accountId = parseInt(accountId, 10)\n    if (agent.config.trusted_account_ids.indexOf(accountId) === -1) {\n      logger.trace('Request from untrusted CAT header account id: %s - ' +\n        'not adding response CAT headers', accountId)\n      return writeHead.apply(this, arguments)\n    }\n\n    // Not sure this could ever happen, but should guard against it anyway\n    // otherwise exception we blow up the user's app.\n    if (!agent.config.cross_process_id || !agent.config.encoding_key) {\n      logger.trace(\n        'Managed to have agent.config.trusted_account_ids but not cross_process_id ' +\n          '(%s) or encoding_key (%s) - not adding response CAT headers',\n        agent.config.cross_process_id,\n        agent.config.encoding_key\n      )\n      return writeHead.apply(this, arguments)\n    }\n\n    // -1 means no content length header was sent. We should only send this\n    // value in the appData if the header is set.\n    var contentLength = -1\n    var new_headers = arguments[arguments.length - 1]\n\n    if (typeof new_headers === 'object') {\n      for (var header in new_headers) {  // jshint ignore: line\n        if (CONTENT_LENGTH_REGEX.test(header)) {\n          contentLength = new_headers[header]\n          break\n        }\n      }\n    }\n\n    if (contentLength === -1 && this._headers) {\n      // JSHint complains about ownProperty stuff, but since we are looking\n      // for a specific name that doesn't matter so I'm disabling it.\n      // Outbound headers can be capitalized in any way, use regex instead\n      // of direct lookup.\n      for (var userHeader in this._headers) {  // jshint ignore: line\n        if (CONTENT_LENGTH_REGEX.test(userHeader)) {\n          contentLength = this._headers[userHeader]\n          break\n        }\n      }\n    }\n    // Stored on the tx so we can push a metric with this time instead of\n    // actual duration.\n    transaction.catResponseTime = transaction.timer.getDurationInMillis()\n\n    var appData\n    var txName = transaction.name || transaction.nameState.getName() || ''\n\n    try {\n      if (txName) {\n        txName = NAMES.WEB.RESPONSE_TIME + '/' + txName\n      }\n\n      appData = JSON.stringify([\n        agent.config.cross_process_id, // cross_process_id\n        txName, // transaction name\n        transaction.queueTime / 1000, // queue time (s)\n        transaction.catResponseTime / 1000, // response time (s)\n        contentLength, // content length (if content-length header is also being sent)\n        transaction.id, // TransactionGuid\n        false // force a transaction trace to be recorded\n      ])\n    } catch (err) {\n      logger.trace(err, 'Failed to serialize transaction: %s - ' +\n          'not adding CAT response headers',\n        txName)\n      return writeHead.apply(this, arguments)\n    }\n\n    var encKey = agent.config.encoding_key\n    var obfAppData = hashes.obfuscateNameUsingKey(appData, encKey)\n    this.setHeader(NEWRELIC_APP_DATA_HEADER, obfAppData)\n    logger.trace('Added outbound response CAT headers in transaction %s', transaction.id)\n\n    return writeHead.apply(this, arguments)\n  }\n}\n\nfunction wrapRequest(agent, request) {\n  // TODO: early return in the !transaction || internalOnly case\n  return function wrappedRequest(options) {\n    var tracer = agent.tracer\n    var transaction = tracer.getTransaction()\n    var outboundHeaders = {}\n    var args = tracer.slice(arguments)\n    var context = this\n    var needsHeaders = false\n\n    // don't pollute metrics and calls with NR connections\n    var internalOnly = options && options[NR_CONNECTION_PROP]\n\n    if (internalOnly) options[NR_CONNECTION_PROP] = undefined\n\n    if (transaction && !internalOnly && agent.config.encoding_key) {\n      // FLAG: synthetics\n      if (agent.config.feature_flag.synthetics && transaction.syntheticsHeader) {\n        outboundHeaders[NEWRELIC_SYNTHETICS_HEADER] = transaction.syntheticsHeader\n      }\n\n      // FLAG: cat\n      if (agent.config.feature_flag.cat) {\n        if (agent.config.obfuscatedId) {\n          outboundHeaders[NEWRELIC_ID_HEADER] = agent.config.obfuscatedId\n        }\n\n        var pathHash = hashes.calculatePathHash(\n          agent.config.applications()[0],\n          transaction.name || transaction.nameState.getName() || '',\n          transaction.referringPathHash\n        )\n        transaction.pushPathHash(pathHash)\n        var txData = [\n          transaction.id,\n          false,\n          transaction.tripId || transaction.id,\n          pathHash\n        ]\n        try {\n          txData = JSON.stringify(txData)\n          var txHeader = hashes.obfuscateNameUsingKey(txData, agent.config.encoding_key)\n          outboundHeaders[NEWRELIC_TRANSACTION_HEADER] = txHeader\n          logger.trace('Added outbound request CAT headers in transaction %s',\n            transaction.id)\n        } catch (err) {\n          logger.trace(err, 'Failed to serialize outbound response header')\n        }\n      }\n    }\n\n    var headers = Object.keys(outboundHeaders)\n    var i, l\n    if (transaction && !internalOnly) {\n      if (util.isArray(options.headers)) {\n        options = util._extend({}, options)\n        options.headers = options.headers.slice()\n        args[0] = options\n        for (i = 0, l = headers.length; i < l; ++i) {\n          options.headers.push([headers[i], outboundHeaders[headers[i]]])\n        }\n      } else if (typeof options === 'object' &&\n                 options.headers && options.headers.expect) {\n        options = util._extend({}, options)\n        options.headers = util._extend({}, options.headers)\n        options.headers = util._extend(options.headers, outboundHeaders)\n        args[0] = options\n      } else {\n        needsHeaders = true\n      }\n\n      var request_url = options\n      // If the request options are a string, parse it as a URL object.\n      if (typeof options === 'string') {\n        request_url = url.parse(options)\n      }\n      // hostname & port logic pulled directly from node's 0.10 lib/http.js\n      var hostname = request_url.hostname || request_url.host || DEFAULT_HOST\n      var port = request_url.port || request_url.defaultPort || DEFAULT_PORT\n      return instrumentOutbound(agent, hostname, port, makeRequest)\n    }\n\n    return makeRequest()\n\n    function makeRequest() {\n      var requested = request.apply(context, args)\n      if (!needsHeaders) return requested\n\n      try {\n        for (i = 0, l = headers.length; i < l; ++i) {\n          requested.setHeader(headers[i], outboundHeaders[headers[i]])\n        }\n      } catch (err) {\n        if (options && options.headers && typeof options.headers === 'object') {\n          logger.warn(\n            'Could not set cat header, header written with: ',\n            Object.keys(options.headers)\n          )\n        } else {\n          logger.warn('Could not set cat header, header already written')\n        }\n      }\n\n      return requested\n    }\n  }\n}\n\nfunction wrapLegacyRequest(agent, request) {\n  return function wrappedLegacyRequest(method, path, headers) {\n    var makeRequest = request.bind(this, method, path, headers)\n\n    if (agent.tracer.getTransaction()) {\n      return instrumentOutbound(agent, this.host, this.port, makeRequest)\n    }\n\n    return makeRequest()\n  }\n}\n\nfunction wrapLegacyClient(agent, proto) {\n  shimmer.wrapMethod(\n    proto,\n    'http.Client.prototype',\n    'request',\n    wrapLegacyRequest.bind(null, agent)\n  )\n}\n\nmodule.exports = function initialize(agent, http, moduleName) {\n  // FIXME: will this ever not be called?\n  shimmer.wrapMethod(http, 'http', 'createServer', function cb_wrapMethod(createServer) {\n    return function setDispatcher(requestListener) { // eslint-disable-line no-unused-vars\n      agent.environment.setDispatcher('http')\n      return createServer.apply(this, arguments)\n    }\n  })\n\n  /**\n   * It's not a great idea to monkeypatch EventEmitter methods given how hot\n   * they are, but this method is simple and works with all versions of\n   * node supported by the module.\n   */\n  shimmer.wrapMethod(\n    http && http.Server && http.Server.prototype,\n    'http.Server.prototype',\n    ['on', 'addListener'],\n    function cb_wrapMethod(addListener) {\n      return function cls_wrapMethod(type, listener) {\n        if (type === 'request' && listener instanceof Function) {\n          return addListener.call(this, type, wrapListener(agent, listener))\n        }\n\n        return addListener.apply(this, arguments)\n      }\n    }\n  )\n\n\n  // FLAG: cat\n  if (agent.config.feature_flag.cat) {\n    shimmer.wrapMethod(http && http.ServerResponse && http.ServerResponse.prototype,\n                       'http.ServerResponse.prototype',\n                       'writeHead',\n                       wrapWriteHead.bind(null, agent))\n  }\n\n  /**\n   * As of node 0.8, http.request() is the right way to originate outbound\n   * requests.\n   */\n  if (http && http.Agent && http.Agent.prototype && http.Agent.prototype.request) {\n    // Node 0.11+ always uses an Agent.\n    shimmer.wrapMethod(\n      http.Agent.prototype,\n      'http.Agent.prototype',\n      'request',\n      wrapRequest.bind(null, agent)\n    )\n  } else if (moduleName !== 'https' || semver.satisfies(process.version, '<=0.10.x')) {\n    shimmer.wrapMethod(\n      http,\n      'http',\n      'request',\n      wrapRequest.bind(null, agent)\n    )\n  }\n\n  // http.Client is deprecated, but still in use\n  var DeprecatedClient, deprecatedCreateClient\n  function clearGetters() {\n    if (DeprecatedClient) {\n      delete http.Client\n      http.Client = DeprecatedClient\n    }\n    if (deprecatedCreateClient) {\n      delete http.createClient\n      http.createClient = deprecatedCreateClient\n    }\n  }\n\n  DeprecatedClient = shimmer.wrapDeprecated(\n    http,\n    'http',\n    'Client',\n    {\n      get: function get() {\n        var example = new DeprecatedClient(80, 'localhost')\n        wrapLegacyClient(agent, example.constructor.prototype)\n        clearGetters()\n\n        return DeprecatedClient\n      },\n      set: function set(NewClient) {\n        DeprecatedClient = NewClient\n      }\n    }\n  )\n\n  deprecatedCreateClient = shimmer.wrapDeprecated(\n    http,\n    'http',\n    'createClient',\n    {\n      get: function get() {\n        var example = deprecatedCreateClient(80, 'localhost')\n        wrapLegacyClient(agent, example.constructor.prototype)\n        clearGetters()\n\n        return deprecatedCreateClient\n      },\n      set: function set(newCreateClient) {\n        deprecatedCreateClient = newCreateClient\n      }\n    }\n  )\n}\n\n/**\n * Take the X-NewRelic-Synthetics header and apply any appropriate data to the\n * transaction for later use. This is the gate keeper for attributes being\n * added onto the transaction object for synthetics.\n *\n * @param {string} header - The raw X-NewRelic-Synthetics header\n * @param {string} encKey - Encoding key handed down from the server\n * @param {Array} trustedIds - Array of accounts to trust the header from.\n * @param {Transaction} transaction - Where the synthetics data is attached to.\n */\nfunction handleSyntheticsHeader(header, encKey, trustedIds, transaction) {\n  var synthData = parseSyntheticsHeader(header, encKey, trustedIds)\n  if (!synthData) {\n    return\n  }\n\n  transaction.syntheticsData = synthData\n  transaction.syntheticsHeader = header\n}\n\n/**\n * Parse out and verify the the pieces of the X-NewRelic-Synthetics header.\n *\n * @param {string} header - The raw X-NewRelic-Synthetics header\n * @param {string} encKey - Encoding key handed down from the server\n * @param {Array} trustedIds - Array of accounts to trust the header from.\n * @return {Object or null} - On successful parse and verification an object of\n *                            synthetics data is returned, otherwise null is\n *                            returned.\n */\nfunction parseSyntheticsHeader(header, encKey, trustedIds) {\n  // Eagerly declare this object because we know what it should look like and\n  // can use that for header verification.\n  var parsedData = {\n    version: null,\n    accountId: null,\n    resourceId: null,\n    jobId: null,\n    monitorId: null\n  }\n  var synthData = null\n  try {\n    synthData = JSON.parse(\n      hashes.deobfuscateNameUsingKey(header, encKey)\n    )\n  } catch (e) {\n    logger.trace(e, 'Got unparsable synthetics header: %s', header)\n    return\n  }\n\n  if (!util.isArray(synthData)) {\n    logger.trace(\n      'Synthetics data is not an array: %s (%s)',\n      synthData,\n      typeof synthData\n    )\n    return\n  }\n\n\n  if (synthData.length < Object.keys(parsedData).length) {\n    logger.trace(\n      'Synthetics header length is %s, expected at least %s',\n      synthData.length,\n      Object.keys(parsedData).length\n    )\n  }\n\n  parsedData.version = synthData[0]\n  if (parsedData.version !== 1) {\n    logger.trace(\n      'Synthetics header version is not 1, got: %s (%s)',\n      parsedData.version,\n      synthData\n    )\n    return\n  }\n\n  parsedData.accountId = synthData[1]\n  if (parsedData.accountId) {\n    if (trustedIds.indexOf(parsedData.accountId) === -1) {\n      logger.trace(\n        'Synthetics header account ID is not in trusted account IDs: %s (%s)',\n        parsedData.accountId,\n        trustedIds\n      )\n      return\n    }\n  } else {\n    logger.trace('Synthetics header account ID missing.')\n    return\n  }\n\n  parsedData.resourceId = synthData[2]\n  if (!parsedData.resourceId) {\n    logger.trace('Synthetics resource ID is missing.')\n    return\n  }\n\n  parsedData.jobId = synthData[3]\n  if (!parsedData.jobId) {\n    logger.trace('Synthetics job ID is missing.')\n  }\n\n  parsedData.monitorId = synthData[4]\n  if (!parsedData.monitorId) {\n    logger.trace('Synthetics monitor ID is missing.')\n  }\n\n  return parsedData\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/http.js\n// module id = 209\n// module chunks = 0","'use strict'\n\nvar NAMES = require('../../metrics/names.js')\n\n// CONSTANTS\nvar TO_MILLIS = 1e3\n\nfunction recordWeb(segment, scope) {\n  // in web metrics, scope is required\n  if (!scope) return\n\n  var transaction = segment.transaction\n  // if there was a nested webTransaction use its recorder instead\n  if (transaction.webSegment && segment !== transaction.webSegment) return\n\n  var duration = segment.getDurationInMillis()\n  var totalTime = transaction.trace.getTotalTimeDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var partial = segment.partialName\n  var config = segment.transaction.agent.config\n  // named / key transaction support requires per-name apdexT\n  var keyApdexInMillis = config.web_transactions_apdex[scope] * TO_MILLIS || 0\n\n  transaction.measure(NAMES.WEB.RESPONSE_TIME, null, duration, exclusive)\n  transaction.measure(NAMES.WEB.TOTAL_TIME, null, totalTime, exclusive)\n  transaction.measure(NAMES.HTTP, null, duration, exclusive)\n  transaction.measure(scope, null, duration, exclusive)\n  transaction.measure(NAMES.WEB.TOTAL_TIME + '/' + partial, null, totalTime, exclusive)\n\n  if (transaction.queueTime > 0) {\n    transaction.measure(NAMES.QUEUETIME, null, transaction.queueTime)\n  }\n\n  if (transaction.incomingCatId) {\n    transaction.measure(\n        NAMES.CLIENT_APPLICATION + '/' + transaction.incomingCatId + \"/all\",\n        null,\n        transaction.catResponseTime\n      )\n  }\n  transaction._setApdex(NAMES.APDEX + '/' + partial, duration, keyApdexInMillis)\n  transaction._setApdex(NAMES.APDEX, duration, keyApdexInMillis)\n}\n\nmodule.exports = recordWeb\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/http.js\n// module id = 210\n// module chunks = 0","'use strict'\n\nvar util = require('util')\nvar hashes = require('./hashes')\nvar logger = require('../logger').child({component: 'cat'})\n\nmodule.exports.handleCatHeaders = handleCatHeaders\nmodule.exports.parsedHeadersToTrans = parsedHeadersToTrans\n\nfunction handleCatHeaders(incomingCatId, obfTransaction, encKey, transaction) {\n  var parsedCatId = null\n  if (incomingCatId) {\n    parsedCatId = hashes.deobfuscateNameUsingKey(\n      incomingCatId,\n      encKey\n    )\n  }\n\n  var externalTrans = null\n  if (obfTransaction) {\n    try {\n      externalTrans = JSON.parse(\n        hashes.deobfuscateNameUsingKey(obfTransaction, encKey)\n      )\n    } catch (e) {\n      logger.trace(\n        'Got an unparsable CAT header x-newrelic-transaction: %s',\n        obfTransaction\n      )\n    }\n  }\n\n  parsedHeadersToTrans(parsedCatId, externalTrans, transaction)\n}\n\nfunction parsedHeadersToTrans(parsedCatId, externalTrans, transaction) {\n  if (typeof parsedCatId === 'string') {\n    transaction.incomingCatId = parsedCatId\n  }\n\n  if (util.isArray(externalTrans)) {\n    transaction.referringTransactionGuid = externalTrans[0]\n    if (typeof externalTrans[2] === 'string') {\n      transaction.tripId = externalTrans[2]\n    } else if (externalTrans[2]) {\n      transaction.invalidIncomingExternalTransaction = true\n    }\n\n    if (_isValidReferringHash(externalTrans[3])) {\n      transaction.referringPathHash = externalTrans[3]\n    } else if (externalTrans[3]) {\n      transaction.invalidIncomingExternalTransaction = true\n    }\n  }\n}\n\nfunction _isValidReferringHash(hash) {\n  return (typeof hash === 'string')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/util/cat.js\n// module id = 211\n// module chunks = 0","'use strict'\n\nvar recordExternal = require('../../../metrics/recorders/http_external.js')\nvar NAMES = require('../../../metrics/names.js')\nvar urltils = require('../../../util/urltils.js')\nvar hashes = require('../../../util/hashes')\nvar logger = require('../../../logger').child({component: 'outbound'})\n\nvar DEFAULT_PORT = 80\n\nfunction instrumentOutbound(agent, hostname, port, makeRequest) {\n  if (!hostname) throw new Error('hostname must be defined!')\n  if (!port || port < 1) throw new Error('port must be defined!')\n  if (port && port !== DEFAULT_PORT) hostname = hostname + ':' + port\n\n  var transaction = agent.tracer.getTransaction()\n  var name = NAMES.EXTERNAL.PREFIX + hostname\n\n  return agent.tracer.addSegment(\n    name,\n    recordExternal(hostname, 'http'),\n    null,\n    false,\n    instrumentRequest\n  )\n\n  function instrumentRequest(segment) {\n    var request = makeRequest()\n    segment.start()\n    segment.name += urltils.scrub(request.path)\n\n    var params = urltils.parseParameters(request.path)\n    urltils.copyParameters(agent.config, params, segment.parameters)\n\n    // may trace errors multiple times, make that the error tracer's problem\n    request.once('error', function handleError(error) {\n      segment.end()\n\n      var hasListener = (\n        (Array.isArray(request._events.error) && request._events.error.length)\n        || (!Array.isArray(request._events.error) && request._events.error)\n      )\n\n      if (hasListener) {\n        logger.trace(\n          error,\n          'Not capturing outbound error because user has already handled it.'\n        )\n        return\n      }\n\n      /* we should be calling request.emit('error', error) here. We currently\n       * do not do this because the agent has historically swallowed these\n       * errors, re enabling them may cause unexpected errors to buble up in\n       * code that depends on this behavior.\n       */\n      logger.trace(\n        error,\n        'Captured outbound error on behalf of the user (normally an uncaught exception).'\n      )\n      agent.errors.add(transaction, error)\n    })\n\n    // Pop off the listeners so we can make sure our response handler happens\n    // first. This is to prevent a case where the transaction ends before our\n    // response handler has had a chance to pull data it needs for segment\n    // metrics.\n    var existingListeners = request.listeners('response').slice()\n    request.removeAllListeners('response')\n\n    request.on('response', function handle_response(res) {\n      // FLAG: cat\n      if (agent.config.feature_flag.cat) {\n        pullCatHeaders(\n          agent.config,\n          segment,\n          hostname,\n          res.headers['x-newrelic-app-data']\n        )\n      }\n      agent.tracer.bindEmitter(res)\n      res.on('end', segment.end.bind(segment))\n    })\n\n    // Push the listeners we popped off back onto the event. See above for\n    // explanation of why.\n    for (var i = 0; i < existingListeners.length; i++) {\n      request.on('response', existingListeners[i])\n    }\n\n    // ensure listeners are evaluated in correct transactional scope\n    agent.tracer.bindEmitter(request)\n    return request\n  }\n}\n\nfunction pullCatHeaders(config, segment, host, obfAppData) {\n  if (!config.encoding_key) {\n    logger.trace('config.encoding_key is not set - not parsing response CAT headers')\n    return\n  }\n\n  if (!config.trusted_account_ids) {\n    logger.trace('config.trusted_account_ids is not set - not parsing response ' +\n      'CAT headers')\n    return\n  }\n\n  // is our downstream request CAT-aware?\n  if (!obfAppData) {\n    logger.trace('Got no CAT app data in response header x-newrelic-app-data')\n  } else {\n    var appData = null\n    try {\n      appData = JSON.parse(hashes.deobfuscateNameUsingKey(obfAppData,\n                                                          config.encoding_key))\n    } catch (e) {\n      logger.warn('Got an unparsable CAT header x-newrelic-app-data: %s', obfAppData)\n      return\n    }\n    // Make sure it is a trusted account\n    if (appData.length && typeof appData[0] === 'string') {\n      var accountId = appData[0].split('#')[0]\n      accountId = parseInt(accountId, 10)\n      if (config.trusted_account_ids.indexOf(accountId) === -1) {\n        logger.trace('Response from untrusted CAT header account id: %s', accountId)\n      } else {\n        segment.catId = appData[0]\n        segment.catTransaction = appData[1]\n        segment.name = NAMES.EXTERNAL.TRANSACTION + host + '/' +\n                       segment.catId + '/' + segment.catTransaction\n        if (appData.length >= 6) {\n          segment.parameters.transaction_guid = appData[5]\n        }\n        logger.trace('Got inbound response CAT headers in transaction %s',\n          segment.transaction.id)\n      }\n    }\n  }\n}\n\nmodule.exports = instrumentOutbound\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/transaction/tracer/instrumentation/outbound.js\n// module id = 212\n// module chunks = 0","'use strict'\n\nvar EXTERNAL = require('../../metrics/names').EXTERNAL\n\n\nfunction recordExternal(host, library) {\n  if (!host) {\n    throw new Error(\n      'External request metrics need to be associated with a host. ' +\n      'Not measuring.'\n    )\n  }\n\n  return function cls_recordExternal(segment, scope) {\n    var duration = segment.getDurationInMillis()\n    var exclusive = segment.getExclusiveDurationInMillis()\n    var transaction = segment.transaction\n    var metricName = EXTERNAL.PREFIX + host + '/' + library\n    var rollupType = transaction.isWeb() ? EXTERNAL.WEB : EXTERNAL.OTHER\n    var rollupHost = EXTERNAL.PREFIX + host + '/all'\n\n    if (segment.catId && segment.catTransaction) {\n      transaction.measure(\n        EXTERNAL.APP + host + '/' + segment.catId + '/all',\n        null,\n        duration,\n        exclusive\n      )\n\n      transaction.measure(\n        EXTERNAL.TRANSACTION + host + '/' + segment.catId + '/' + segment.catTransaction,\n        null,\n        duration,\n        exclusive\n      )\n\n      // This CAT metric replaces scoped External/{host}/{method}\n      if (scope) {\n        transaction.measure(\n          EXTERNAL.TRANSACTION + host + '/' + segment.catId +\n            '/' + segment.catTransaction,\n          scope,\n          duration,\n          exclusive\n        )\n      }\n    } else if (scope) {\n      transaction.measure(metricName, scope, duration, exclusive)\n    }\n\n    transaction.measure(metricName, null, duration, exclusive)\n    transaction.measure(rollupType, null, duration, exclusive)\n    transaction.measure(rollupHost, null, duration, exclusive)\n    transaction.measure(EXTERNAL.ALL, null, duration, exclusive)\n  }\n}\n\nmodule.exports = recordExternal\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/http_external.js\n// module id = 213\n// module chunks = 0","exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return compare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/~/semver/semver.js\n// module id = 214\n// module chunks = 0","'use strict'\n\nvar wrap = require('../../shimmer').wrapMethod\n\nmodule.exports = initialize\n\nfunction initialize(agent, net) {\n  wrap(net.Server.prototype, 'net.Server.prototype', '_listen2', wrapListen2)\n  wrap(net.Socket.prototype, 'net.Socket.prototype', 'connect', wrapConnect)\n\n  function wrapListen2(original) {\n    return function wrappedListen2() {\n      var segment = agent.tracer.getSegment()\n      var emit = this.emit\n\n      if (!segment || !emit) return original.apply(this, arguments)\n\n      this.emit = wrappedEmit\n\n      return original.apply(this, arguments)\n\n      function wrappedEmit(ev, socket) {\n        if (ev !== 'connection' || !socket || !socket._handle) {\n          return emit.apply(this, arguments)\n        }\n\n        var child = agent.tracer.createSegment('net.Server.onconnection', null, segment)\n\n        if (socket._handle.onread) {\n          socket._handle.onread = agent.tracer.bindFunction(socket._handle.onread, child)\n        }\n\n        return agent.tracer.bindFunction(emit, child, true).apply(this, arguments)\n      }\n    }\n  }\n\n  function wrapConnect(original) {\n    return function connectWrapper() {\n      if (!agent.getTransaction()) return original.apply(this, arguments)\n      var socket = this\n      var args = normalizeConnectArgs(arguments)\n      return agent.tracer.addSegment(\n        'net.Socket.connect',\n        null,\n        null,\n        true,\n        wrappedConnect\n      )\n\n      function wrappedConnect(child) {\n        if (args[1]) args[1] = agent.tracer.bindFunction(args[1], child)\n        var result = original.apply(socket, args)\n        if (socket._handle) {\n          socket._handle.onread = agent.tracer.bindFunction(socket._handle.onread, child)\n        }\n        agent.tracer.bindEmitter(socket, child)\n        return result\n      }\n    }\n  }\n}\n\n// taken from node master on 2013/10/30\nfunction normalizeConnectArgs(args) {\n  var options = {}\n\n  function toNumber(x) {\n    return (x = Number(x)) >= 0 ? x : false\n  }\n  if (typeof args[0] === 'object' && args[0] !== null) {\n    // connect(options, [cb])\n    options = args[0]\n  } else if (typeof args[0] === 'string' && toNumber(args[0]) === false) {\n    // connect(path, [cb]);\n    options.path = args[0]\n  } else {\n    // connect(port, [host], [cb])\n    options.port = args[0]\n    if (typeof args[1] === 'string') {\n      options.host = args[1]\n    }\n  }\n\n  var cb = args[args.length - 1]\n  return typeof cb === 'function' ? [options, cb] : [options]\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/net.js\n// module id = 215\n// module chunks = 0","'use strict'\n\nvar wrap = require('../../shimmer').wrapMethod\nvar semver = require('semver')\n\nmodule.exports = initialize\n\nfunction initialize(agent, timers) {\n  // As of iojs 1.6.3 all timers are on the global object, and do\n  // not need a require('timers') call to access them\n  if (timers !== global && semver.satisfies(process.version, '>=1.6.3') &&\n      global.setTimeout && !global.setTimeout.__NR_original) {\n    initialize(agent, global)\n  }\n\n  var processMethods = ['nextTick', '_nextDomainTick', '_tickDomainCallback']\n\n  wrap(process, 'process', processMethods, function bindProcess(original, method) {\n    return agent.tracer.wrapFunctionFirstNoSegment(original, method)\n  })\n\n  var asynchronizers = [\n    'setTimeout',\n    'setInterval'\n  ]\n\n  wrap(timers, 'timers', asynchronizers, function wrapTimers(original, method) {\n    return agent.tracer.wrapFunctionFirst('timers.' + method, null, original)\n  })\n\n  // We don't want to create segments for setImmediate calls, as the\n  // object allocation may incur too much overhead in some situations\n  var uninstrumented = [\n    'setImmediate'\n  ]\n\n  wrap(timers, 'timers', uninstrumented, function wrapUninstrumented(original, method) {\n    return agent.tracer.wrapFunctionFirstNoSegment(original, method)\n  })\n\n  var clearTimeouts = ['clearTimeout']\n\n  wrap(timers, 'timers', clearTimeouts, function wrapClear(original) {\n    return function wrappedClear(timer) {\n      var segment\n      if (timer && timer._onTimeout) {\n        segment = agent.tracer.getSegmentFromWrapped(timer._onTimeout)\n        timer._onTimeout = agent.tracer.getOriginal(timer._onTimeout)\n      }\n\n      if (timer && timer._onImmediate) {\n        timer._onImmediate = agent.tracer.getOriginal(timer._onImmediate)\n      }\n\n      if (segment) segment.ignore = true\n\n      return original.apply(this, arguments)\n    }\n  })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/timers.js\n// module id = 216\n// module chunks = 0","'use strict'\n\nvar wrap = require('../../shimmer').wrapMethod\n\nmodule.exports = initialize\n\nvar methods = [\n  'deflate',\n  'deflateRaw',\n  'gzip',\n  'gunzip',\n  'inflate',\n  'inflateRaw',\n  'unzip'\n]\n\nfunction initialize(agent, zlib) {\n  var noSegment = agent.tracer.wrapFunctionNoSegment.bind(agent.tracer)\n  if (zlib.Deflate && zlib.Deflate.prototype) {\n    var proto = Object.getPrototypeOf(zlib.Deflate.prototype)\n    if (proto._transform) {\n      // streams2\n      wrap(proto, 'zlib', '_transform', noSegment)\n    } else if (proto.write && proto.flush && proto.end) {\n      // plain ol' streams\n      wrap(proto, 'zlib', ['write', 'flush', 'end'], noSegment)\n    }\n  }\n\n  wrap(zlib, 'zlib', methods, segment)\n\n  function segment(fn, method) {\n    return agent.tracer.wrapFunctionLast('zlib.' + method, null, fn)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/core/zlib.js\n// module id = 217\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer')\nvar logger = require('../logger.js').child({component: 'director'})\nvar NAMES = require('../metrics/names.js')\n\nfunction nameTransaction(segment, partialName, res) {\n  if (!segment) return logger.error(\"No New Relic context to set Director route name on.\")\n  if (!partialName) return logger.error(\"No partialName to use for naming.\")\n  if (res.finished) return // no need to update transaction name if response has ended\n\n  var transaction = segment.transaction\n  var nameState = transaction.nameState\n\n  if (res.__NR_directored) { // not first route\n    nameState.pathStack.pop() // replace latest path name, preserving the last path name\n  }\n  nameState.appendPath(partialName)\n\n  nameState.setVerb(transaction.verb)\n  nameState.setDelimiter(NAMES.ACTION_DELIMITER) \n  res.__NR_directored = true\n}\n\nmodule.exports = function initialize(agent, director) {\n  var tracer = agent.tracer\n\n  shimmer.wrapMethod(\n    director.Router.prototype,\n    'director.Router.prototype',\n    'mount',\n    function wrapMount(mount) {\n      return function wrappedMount(routes, path) {\n        if (!routes) {\n          return mount.call(this, routes, path)\n        }\n\n        Object.keys(director.http.methods).forEach(function wrapMethod(methodKey) {\n          var method = director.http.methods[methodKey]\n          if (routes[method]) { // method exists as attribute\n            var route = routes[method] // wrapping associated cb function\n            routes[method] = createWrapped(method, path, route)\n          }\n        })\n\n        function createWrapped(method, path, route) {\n          if (route.__NR_original) {\n            route = route.__NR_original\n          } \n\n          var wrapped = function wrappedRoute() {\n            var transaction = tracer.getTransaction()\n            if (!transaction) {\n              return route.apply(this, arguments)\n            }\n\n            var response = this.res // hang directored attr, and check if res is finished\n\n            var pathName = path.join('/')\n            var partialName = pathName\n            var segment = tracer.createSegment('Function/' + (route.name || \"anonymous\"))\n            \n            nameTransaction(tracer.segment, partialName, response)\n            return tracer.bindFunction(route, segment, true).apply(this, arguments)\n          }\n\n          wrapped.__NR_original = route\n          return wrapped\n        }\n\n        return mount.call(this, routes, path)\n      }\n    }\n  )\n\n  shimmer.wrapMethod(\n    director.Router.prototype,\n    'director.Router.prototype',\n    ['on', 'route'],\n    function wrapOn(on) {\n      return function wrappedOn(method, path, route) {\n        // if we are handed unexpected argument types pass them through\n        // and let director handle the error case\n        if (!route) {\n          return on.call(this, method, path, route)\n        }\n\n        var partialName = this.scope.join('/') + path\n\n        if (route.__NR_original) {\n          route = route.__NR_original\n        } \n\n        var wrapped = function wrappedRoute() {\n          var transaction = tracer.getTransaction()\n          if (!transaction) {\n            return route.apply(this, arguments)\n          }\n\n          var response = this.res // hang directored attr, and check if res is finished\n\n          var segment = tracer.createSegment('Function/' + (route.name || \"anonymous\"))\n          nameTransaction(tracer.segment, partialName, response)\n          return tracer.bindFunction(route, segment, true).apply(this, arguments)\n        }\n\n        wrapped.__NR_original = route\n\n        return on.call(this, method, path, wrapped)\n      }\n    }\n  )\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/director.js\n// module id = 218\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer.js')\nvar urltils = require('../util/urltils.js')\nvar logger = require('../logger.js').child({component: 'express'})\nvar record = require('../metrics/recorders/generic.js')\nvar middlewareRecorder = require('../metrics/recorders/express.js')\nvar NAMES = require('../metrics/names.js')\n\nvar express2 = require('./express/express-2.js')\nvar ensurePartialName = require('./express/common.js').ensurePartialName\n\nvar VIEW = NAMES.VIEW\nvar ORIGINAL = '__NR_original'\nvar RESERVED = [ // http://es5.github.io/#x7.6.1.2\n  // always (how would these even get here?)\n  'class', 'enum', 'extends', 'super', 'const', 'export', 'import',\n  // strict\n  'implements', 'let', 'private', 'public', 'yield', 'interface',\n  'package', 'protected', 'static'\n]\n\n/**\n * ES5 strict mode disallows some identifiers that are allowed in non-strict\n * code. Mangle function names that are on that list of keywords so they're\n * non-objectionable in strict mode (which is currently enabled everywhere\n * inside the agent, as well as at many customer sites).\n *\n * If you really need to crawl your Express apps middleware stack, change\n * your test to use name.indexOf('whatever') === 0 as the predicate instead\n * of name === 'whatever'. It's a little slower, but you shouldn't be doing\n * that anyway.\n *\n * @param {string} name The candidate function name\n *\n * @returns {string} A safe (potentially mangled) function name.\n */\nfunction mangle(name) {\n  var parts = name.split(' ')\n  name = parts[parts.length - 1]\n\n  if (RESERVED.indexOf(name) !== -1) return name + '_'\n\n  return name\n}\n\n\nfunction generateMiddlewarePath(routerStack, layer) {\n  var res = ''\n  for (var i = 0; i < routerStack.length; ++i) {\n    appendToPath(routerStack[i].path)\n  }\n\n  if (layer && layer.handle && layer.handle.__NR_path) {\n    appendToPath(layer.handle.__NR_path)\n    if (res[res.length - 1] === '/') {\n      res = res.substr(0, res.length - 1)\n    }\n  }\n\n  return res || '/'\n\n  function appendToPath(path) {\n    if (!path) return\n\n    var resTrailingSlash = res[res.length - 1] === '/'\n    if (path[0] === '/') {\n      path = path.substr(1)\n    }\n\n    if (resTrailingSlash) {\n      res += path\n    } else {\n      res += '/' + path\n    }\n  }\n}\n\n\nvar transactionInfoById = {}\nfunction onTransactionFinished(transaction) {\n  delete transactionInfoById[transaction.id]\n}\n\nmodule.exports = function initialize(agent, express) {\n  var tracer = agent.tracer\n\n  var registered =\n    agent.listeners('transactionFinished')\n    .indexOf(onTransactionFinished) !== -1\n\n  if (!registered) {\n    agent.on('transactionFinished', onTransactionFinished)\n  }\n\n  function setDispatcher(app) {\n    return function wrappedCreateServer() {\n      agent.environment.setDispatcher('express')\n      agent.environment.setFramework('express')\n\n      return app.apply(this, arguments)\n    }\n  }\n\n  /**\n   * This needs to be kept up to date with Express to ensure that it's using\n   * the same logic to decide where the callback is hiding.\n   */\n  function wrapRender(version, render) {\n    /* jshint maxparams:5 */ // follow Express as closely as possible\n    return function cls_wrapRender(view, options, cb, parent, sub) {\n      logger.trace(\"Rendering Express %d view %s.\", version, view)\n      if (!tracer.getTransaction()) {\n        logger.trace(\n          'Express %d view %s rendered outside transaction, not measuring.',\n          version,\n          view\n        )\n        return render.apply(this, arguments)\n      }\n\n      var name = VIEW.PREFIX + view + VIEW.RENDER\n      var segment = tracer.createSegment(name, record)\n      var wrapped\n\n\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n\n      if (cb === null || cb === undefined) {\n        /* CAUTION: Need this to generate a metric, but adding a callback\n         * changes Express's control flow.\n         */\n        wrapped = tracer.bindFunction(function syntheticCallback(err, rendered) {\n          if (err) {\n            segment.end()\n            logger.trace(err,\n                         \"Express %d rendering for metric %s failed for transaction %s:\",\n                         version,\n                         name,\n                         segment.transaction.id)\n\n            return this.req.next(err)\n          }\n\n          segment.end()\n          var returned = this.send(rendered)\n\n          logger.trace(\"Rendered Express %d view with metric %s for transaction %s.\",\n                       version,\n                       name,\n                       segment.transaction.id)\n\n          return returned\n        }.bind(this))\n      } else {\n        wrapped = tracer.bindFunction(function renderWrapper() {\n          segment.end()\n          var returned = cb.apply(this, arguments)\n\n          return returned\n        }, segment)\n      }\n\n      return render.call(this, view, options, wrapped, parent, sub)\n    }\n  }\n\n\n  // wrap express.Router.process_params() in order to get to the Layer class, which\n  // we need to wrap\n  function wrapProcessParams(version, process_params) {\n    return function cls_wrapProcessParams(layer) {\n      var transaction = tracer.getTransaction()\n      if (!transaction) {\n        logger.trace(\n          'Express %d router called outside transaction (wrapProcessParams).',\n          version\n        )\n        return process_params.apply(this, arguments)\n      }\n\n      // process_params is the first place (I think) where we have access to a Layer\n      // instance.  Layer is basically the interface for (req, res, next) - could be\n      // a container for actual route handler, or an instance of Router, or an instance\n      // of an Express sub-app.\n      // Layers are called in the order they are defined.  The method\n      // Layer.handle_request(req, res, next) is the method called in the chain.\n      // If we wrap it, we know exactly when each handler in the chain is called. Based on\n      // that we can build the path from nested route handlers.\n      if (layer) {\n        if (layer.constructor) {\n          var layerProto = layer.constructor.prototype\n          if (\n            layerProto.handle_request &&\n            !shimmer.isWrapped(layerProto.handle_request)\n          ) {\n            shimmer.wrapMethod(layerProto,\n                              'express.Layer',\n                              'handle_request',\n                              wrapLayerHandleRequest)\n          }\n          if (\n            layerProto.handle_error &&\n            !shimmer.isWrapped(layerProto.handle_error)\n          ) {\n            shimmer.wrapMethod(layerProto,\n                              'express.Layer',\n                              'handle_error',\n                              wrapLayerHandleError)\n          }\n        }\n      }\n\n      function wrapLayerHandleError(handleError) {\n        return function wrappedLayerHandleError(error, req, res, next) {\n          var parent = tracer.segment\n          if (!parent) {\n            return handleError.apply(this, arguments)\n          }\n\n          var transaction = parent.transaction\n\n          if (!transaction.isActive()) {\n            return handleError.apply(this, arguments)\n          }\n\n          var transactionInfo = getTransactionInfo(transaction)\n\n          if (agent.config.feature_flag.express_segments) {\n            var handlerName = (this.handle.name || 'anonymous')\n            if (this.handle.length === 4) {\n              var prefix = NAMES.EXPRESS.ERROR_HANDLER\n              var segment = tracer.createSegment(prefix + handlerName, record)\n\n              logger.trace(\n                'Creating segment for middleware %s. Transaction id: %s, name: %s',\n                segment.name,\n                transaction.id,\n                transaction.nameState.getName()\n\n              )\n\n              if (segment) {\n                segment.start()\n              }\n            }\n\n            transactionInfo.lastMiddlewareSegment = segment\n          }\n\n          if (next) {\n            arguments[3] = endErrorHandlerRecorder\n          }\n\n          this.__NR_parent = parent\n\n          handleError.apply(this, arguments)\n\n          function endErrorHandlerRecorder() {\n            if (parent.transaction.isActive()) {\n              tracer.segment = parent\n            }\n\n            if (agent.config.feature_flag.express_segments) {\n              if (segment && segment.transaction.isActive()) {\n                segment.end()\n              }\n            }\n            next.apply(this, arguments)\n          }\n        }\n      }\n\n      function wrapLayerHandleRequest(handleRequest) {\n        return function wrappedLayerHandleRequest(req, res, next) {\n          var segment\n          var parent = tracer.getSegment()\n          if (!parent) {\n            return handleRequest.apply(this, arguments)\n          }\n\n          var transaction = parent.transaction\n          var transactionInfo = getTransactionInfo(transaction)\n\n          if (!transaction.isActive()) {\n            return handleRequest.apply(this, arguments)\n          }\n\n          var isErrorHandler = (this.handle.length === 4)\n          var isMountedApp = (this.name === 'mounted_app' ||\n                              (this.handle != null && this.handle.lazyrouter != null))\n          var isRouter = (this.handle[ORIGINAL] != null && this.handle[ORIGINAL].stack) ||\n                          this.handle.stack != null\n          var isRoute = (this.route != null)\n          var stack = (this.handle &&\n                        (this.handle[ORIGINAL] && this.handle[ORIGINAL].stack) ||\n                          this.handle.stack) ||\n                      (this.route && this.route.stack)\n\n          var routerStack = transactionInfo.routerStack\n          if (agent.config.feature_flag.express_segments) {\n            var parentSegment\n            if (routerStack.length > 0) {\n              parentSegment = routerStack[routerStack.length - 1].segment\n            }\n\n            if (!isErrorHandler) {\n              var segmentName\n              var recorder\n\n              if (isMountedApp) {\n                segmentName = NAMES.EXPRESS.PREFIX + 'Mounted App: ' +\n                  this.handle.__NR_path\n              } else if (isRouter) {\n                segmentName = NAMES.EXPRESS.PREFIX + 'Router: '\n                if (this.handle.__NR_path) {\n                  segmentName += this.handle.__NR_path\n                } else {\n                  segmentName += '/'\n                }\n              } else if (isRoute) {\n                segmentName = NAMES.EXPRESS.PREFIX + 'Route Path: ' +\n                  this.handle.__NR_path\n              } else {\n                var middlewareName = (this.handle.name || 'anonymous')\n                segmentName = NAMES.EXPRESS.MIDDLEWARE + middlewareName\n                var middlewarePath = generateMiddlewarePath(routerStack, this)\n                recorder = middlewareRecorder.bind(null, middlewarePath)\n              }\n\n              segment = tracer.createSegment(segmentName, recorder, parentSegment)\n\n              logger.trace(\n                'Creating segment for middleware %s. Transaction id: %s, name: %s',\n                segment.name,\n                transaction.id,\n                transaction.nameState.getName()\n              )\n\n              tracer.segment = segment\n              segment.start()\n            }\n          }\n          // END FEATURE FLAG\n\n          if (isRouter || isRoute) {\n            routerStack.push({\n              length: stack.length,\n              path: this.handle.__NR_path,\n              segment: segment\n            })\n          } else if (isMountedApp) {\n            routerStack.push({\n              length: null,\n              path: this.handle.__NR_path,\n              segment: segment\n            })\n          } else {\n            transactionInfo.lastMiddlewareSegment = segment\n          }\n\n          // call cleanup before next middleware function in order to restore\n          // transaction.partialName\n          if (next) {\n            arguments[2] = cleanup\n          }\n\n          this.__NR_parent = parent\n\n          return handleRequest.apply(this, arguments)\n\n          function cleanup() {\n            var parentRouter\n            if (!transactionInfo.responded && routerStack.length > 0) {\n              parentRouter = routerStack[routerStack.length - 1]\n              if (isMountedApp || isRouter || isRoute) {\n                routerStack.pop()\n              }\n            }\n\n            // end current middleware segment\n            if (agent.config.feature_flag.express_segments) {\n              if (segment) {\n                segment.end()\n              }\n\n              if (parentRouter) {\n                parentRouter.segment.touch()\n              }\n            }\n\n            // restore previous segment\n            if (parent.transaction.isActive()) {\n              tracer.segment = parent\n            }\n\n            next.apply(this, arguments)\n          }\n        }\n      }\n\n      return process_params.apply(this, arguments)\n    }\n  }\n\n  /**\n   * Problem:\n   *\n   * 1. Express determines whether middleware functions are error handlers by\n   *    testing their arity. Not cool.\n   * 2. Downstream Express users rely upon being able to iterate over their\n   *    middleware stack to find specific middleware functions. Sorta less\n   *    uncool, but still a pain.\n   *\n   * Solution:\n   *\n   * Use eval. This once. For this one specific purpose. Not anywhere else for\n   * any reason.\n   */\n  function wrapHandle(__NR_handle, path) {\n    var name = ''\n    var arglist\n\n    // reiterated: testing function arity is stupid\n    switch (__NR_handle.length) {\n      case 2:\n        arglist = '(req, res)'\n        break\n\n      case 3:\n        arglist = '(req, res, next)'\n        break\n\n      // don't break other error handlers\n      case 4:\n        arglist = '(err, req, res, next)'\n        break\n\n      default:\n        arglist = '()'\n    }\n\n    if (__NR_handle.name) name = mangle(__NR_handle.name)\n\n    // All closure scope variables used in templates must be passed\n    // in as formal arguments to the wrapped function constructor\n\n    /* eslint-disable func-names */\n    /* eslint-disable no-undef */\n    var routerTemplate = function() {\n      return wrappedHandle.call(layer, path, __NR_handle, [].slice.call(arguments))\n    }\n    /* eslint-enable no-undef */\n    /* eslint-enable func-names */\n\n    // I am a bad person and this makes me feel bad.\n    // We use eval because we need to insert the function with a specific\n    // name to allow for lookup.\n    /* eslint-disable no-new-func */\n    var wrapped = new Function(\n      'tracer', '__NR_handle', 'wrappedHandle', 'path', 'layer',\n      'return function ' + name + arglist + routerTemplate.toString().substring(11)\n    )(tracer, __NR_handle, wrappedHandle, path, this)\n    /* eslint-enable no-new-func */\n\n    wrapped[ORIGINAL] = __NR_handle\n\n    // pull the attributes from the original handle up to the wrapped one\n    var handleKeys = Object.keys(__NR_handle)\n    for (var i = 0; i < handleKeys.length; i++) {\n      var key = handleKeys[i]\n      wrapped[key] = __NR_handle[key]\n    }\n\n    wrapped.__NR_path = path\n    return wrapped\n  }\n\n  function wrapMiddlewareStack(route, original) {\n    return function cls_wrapMiddlewareStack() {\n      /* We allow `use` to go through the arguments so it can reject bad things\n       * for us so we don't have to also do argument type checking.\n       */\n\n      var app = original.apply(this, arguments)\n      var path = typeof arguments[0] === 'string' ? arguments[0] : '/'\n      if (arguments[0] instanceof RegExp) {\n        path = arguments[0].toString()\n      }\n\n      /* Express adds routes to the same stack as middleware. We need to wrap\n       * that adder too but we only want to wrap the middleware that are\n       * added, not the Router.\n       */\n      // wrap most recently added unwrapped handler\n      var i = this.stack.length\n      var top\n      /* eslint-disable no-cond-assign */\n      while (top = this.stack[--i]) {\n        if (!top.handle || typeof top.handle !== 'function' || top.handle[ORIGINAL]) {\n          break\n        }\n\n        top.handle = wrapHandle.call(top, top.handle, path)\n      }\n      /* eslint-enable no-cond-assign */\n\n      return app\n    }\n  }\n\n  function wrappedHandle(path, handle, args) {\n    var transaction = agent.tracer.getTransaction()\n\n    if (!transaction) {\n      logger.trace(\n        'Express %d handle for path %s called outside transaction (wrappedHandle).',\n        version,\n        path\n      )\n      return handle.apply(this, args)\n    }\n\n    var isErrorHandler = handle.length === 4\n    var transactionInfo = getTransactionInfo(transaction)\n\n    var req = args[0]\n    var isRouter = this.handle[ORIGINAL] != null && this.handle[ORIGINAL].stack ||\n                   this.handle.stack != null\n    var isRoute = this.route != null\n    var segment = this.__NR_parent || tracer.getSegment()\n\n    if (req && segment && (isRoute || isRouter)) {\n      if (req.params) {\n        // Express 4.3.0 changed where params live. On newer versions of Express\n        // params should be populated, on older it shouldn't be.\n        urltils.copyParameters(\n          transaction.agent.config,\n          req.params,\n          segment.parameters\n        )\n      }\n    }\n\n    if (!transactionInfo.error || transactionInfo.errorHandled) {\n      ensurePartialName(transaction)\n      transaction.nameState.appendPath(path)\n    }\n\n    // Update the namestate if we have a callback that we can unwind with.\n    var last = args.length - 1\n    var cb = args[last]\n\n    if (cb instanceof Function) {\n      if (isErrorHandler && transactionInfo.error) {\n        transactionInfo.errorHandled = true\n      }\n\n      args[last] = function wrappedHandleCallback(err) {\n        // if an error is passed to the next function, we do not want\n        // to mutate the name path so the transaction will be named\n        // after the location the error was generated.\n        if (err && err !== 'route') {\n          transactionInfo.error = err\n        } else if (!transactionInfo.responded) {\n          transaction.nameState.popPath(path)\n          transaction.nameState.appendPathIfEmpty('/')\n        }\n        return cb.apply(this, arguments)\n      }\n    }\n\n    // wrap res.end to mark the transaction as responded\n    var res = args[1]\n\n    if (res && res.end && !res.end[ORIGINAL]) {\n      var oldEnd = res.end\n\n      res.end = function wrappedEnd() {\n        // end the current middleware segment\n        if (transactionInfo.lastMiddlewareSegment) {\n          transactionInfo.lastMiddlewareSegment.end()\n        }\n\n        // end all router segments\n        var routerStack = transactionInfo.routerStack\n        if (routerStack.length > 0) {\n          for (var i = (routerStack.length - 1); i >= 0; i--) {\n            if (routerStack[i].segment) {\n              routerStack[i].segment.end()\n            }\n          }\n        }\n        transactionInfo.responded = true\n\n        var err = transactionInfo.error\n        var errHandled = transactionInfo.errorHandled\n        var isHttpError = urltils.isError(agent.config, this.statusCode)\n        // report error if it was not handled by an error handler, or when\n        // the status code is an HTTP error (more useful to report the actual error\n        // than a generic HTTP status error)\n        if (err && (!errHandled || isHttpError)) {\n          agent.errors.add(transaction, err)\n        }\n\n        logger.trace(\n          'res.end called, transaction id: %s, name: %s.',\n          transaction.id,\n          transaction.nameState.getName()\n        )\n\n        return oldEnd.apply(res, arguments)\n      }\n\n      res.end[ORIGINAL] = oldEnd\n    }\n\n\n    return handle.apply(this, args)\n  }\n\n  function wrapParamware(param) {\n    return function wrappedParam(paramName, fn) {\n      if (fn instanceof Function && typeof paramName === 'string') {\n        return param.call(this, paramName, paramwareWrapper)\n      }\n      return param.apply(this, arguments)\n\n      /* eslint-disable no-unused-vars */\n      function paramwareWrapper(req, res, next, value, name) {\n        /* eslint-enable no-unused-vars */\n        // Make sure we are correct about which parameter is the callback and\n        // that we have a transaction which is currently active!\n        var transaction = tracer.getTransaction()\n        if (!(next instanceof Function && transaction)) {\n          return fn.apply(this, arguments)\n        }\n\n        // Create the param handler segment.\n        transaction.nameState.appendPath('[param handler :' + paramName + ']')\n        var transactionInfo = getTransactionInfo(transaction)\n        var middlewarePath = generateMiddlewarePath(transactionInfo.routerStack, this)\n        var recorder = middlewareRecorder.bind(null, middlewarePath)\n        var segmentName = NAMES.EXPRESS.PREFIX + 'Param Handler: ' + paramName\n        var segment = tracer.createSegment(segmentName, recorder)\n\n        // Out of an excess of caution, make sure the segment was actually\n        // created. In theory since we have an active transaction this should\n        // not fail, but I don't trust anything anymore.\n        if (!segment) {\n          return fn.apply(this, arguments)\n        }\n        transactionInfo.lastMiddlewareSegment = segment\n\n        // Wrap next with some cleanup.\n        var args = tracer.slice(arguments)\n        args[2] = tracer.bindFunction(function wrappedNext() {\n          segment.touch()\n          transaction.nameState.popPath()\n          return next.apply(this, arguments)\n        }, segment)\n\n        // Call the paramware.\n        segment.start()\n        return tracer.bindFunction(fn, segment).apply(this, args)\n      }\n    }\n  }\n\n  function getTransactionInfo(transaction) {\n    if (!transactionInfoById[transaction.id]) {\n      transactionInfoById[transaction.id] = {\n        // since Layer.handleRequest isn't scoped to a transaction we need to\n        // track the transaction state outside in these maps.\n\n        // routerStacks is transaction.id -> a stack of the last seen routers\n        // and their segments. this is for reconstructing the call tree while\n        // we traverse using next\n        routerStack: [],\n\n        // if a handler responds asynchronously and calls next synchronously,\n        // which is the usual case, we will incorrectly name the segment as a\n        // middleware rather than a responder.  this tracks whether a response\n        // has gone out for the transaction yet.\n        responded: false,\n\n        // we don't want to send errors that a user is handling themselves, so\n        // we stash the errors we see for a transaction till we know they\n        // aren't handling it themselves\n        error: null,\n\n        // if we see an error handler in the middleware tree we consider the\n        // error handled\n        errorHandled: false,\n\n        // when res.end() is called from a middleware handler, we need to end\n        // the middleware segment that contains it\n        lastMiddlewareSegment: null\n      }\n    }\n    return transactionInfoById[transaction.id]\n  }\n\n  /**\n   * Major versions of express have very different factoring,\n   * even though the core instrumentation is the same.\n   */\n  var version = express && express.version && express.version[0]\n\n  /* TJ decided he didn't want to deal with the hassle of updating a\n   * version field. Thanks, TJ!\n   */\n  if (!version && express && express.application &&\n      express.application.init && express.response &&\n      express.response.render && express.Router &&\n      express.Router.prototype.matchRequest) {\n    version = '3'\n  } else if (!version && express && express.application &&\n           express.application.init && express.response &&\n           express.response.render && express.Router &&\n           express.Router.process_params && express.application.del) {\n    version = '4'\n  } else if (!version && express && express.application &&\n             !express.application.del) {\n    version = '5'\n  }\n\n  switch (version) {\n    case '2':\n      /* Express 2 doesn't directly expose its Router constructor, so create an\n       * app and grab the constructor off it. Do it before instrumenting\n       * createServer so the agent doesn't automatically set the dispatcher\n       * to Express.\n       */\n      var oneoff = express.createServer()\n      var Router = oneoff.routes.constructor\n\n\n      shimmer.wrapMethod(express,\n                         'express',\n                         'createServer',\n                         setDispatcher)\n\n      /* Express 2 squirts its functionality directly onto http.ServerResponse,\n       * leaving no clean way to wrap its functionality without pulling in the\n       * http module ourselves.\n       */\n      var http = require('http')\n      shimmer.wrapMethod(http.ServerResponse.prototype,\n                         'http.ServerResponse.prototype',\n                         'render',\n                         wrapRender.bind(null, 2))\n\n      shimmer.wrapMethod(Router.prototype,\n                         'Router.prototype',\n                         '_match',\n                         express2.wrapMatchRequest.bind(null, tracer, 2))\n      break\n\n    case '3':\n      shimmer.wrapMethod(express.application,\n                         'express.application',\n                         'init',\n                         setDispatcher)\n\n      shimmer.wrapMethod(express.response,\n                         'express.response',\n                         'render',\n                         wrapRender.bind(null, 3))\n\n      shimmer.wrapMethod(express.Router.prototype,\n                         'express.Router.prototype',\n                         'matchRequest',\n                         express2.wrapMatchRequest.bind(null, tracer, 3))\n\n      shimmer.wrapMethod(express.Router,\n                         'express.Router',\n                         'param',\n                         wrapParamware)\n      break\n\n    case '4':\n      shimmer.wrapMethod(express.application,\n                         'express.application',\n                         'init',\n                         setDispatcher)\n\n      shimmer.wrapMethod(express.response,\n                         'express.response',\n                         'render',\n                         wrapRender.bind(null, 4))\n\n      shimmer.wrapMethod(express.Router,\n                         'express.Router',\n                         'process_params',\n                         wrapProcessParams.bind(null, 4))\n\n      shimmer.wrapMethod(express.Router,\n                         'express.Router',\n                         'use',\n                         wrapMiddlewareStack.bind(null, false))\n\n      shimmer.wrapMethod(express.Router,\n                         'express.Router',\n                         'route',\n                         wrapMiddlewareStack.bind(null, true))\n\n      shimmer.wrapMethod(express.Router,\n                         'express.Router',\n                         'param',\n                         wrapParamware)\n\n      break\n    case '5':\n      // FLAG: express5 instrumentation\n      if (agent.config.feature_flag.express5) {\n        shimmer.wrapMethod(express.application,\n                          'express.application',\n                          'init',\n                          setDispatcher)\n\n        shimmer.wrapMethod(express.response,\n                          'express.response',\n                          'render',\n                          wrapRender.bind(null, 5))\n\n        shimmer.wrapMethod(express.Router.prototype,\n                          'express.Router.prototype',\n                          'process_params',\n                          wrapProcessParams.bind(null, 5))\n\n        shimmer.wrapMethod(express.Router.prototype,\n                          'express.Router.prototype',\n                          'use',\n                          wrapMiddlewareStack.bind(null, false))\n\n        shimmer.wrapMethod(express.Router.prototype,\n                          'express.Router.prototype',\n                          'route',\n                          wrapMiddlewareStack.bind(null, true))\n\n        shimmer.wrapMethod(express.Router,\n                           'express.Router',\n                           'param',\n                           wrapParamware)\n      }\n      break\n    default:\n      logger.warn(\"Unrecognized version %s of Express detected; not instrumenting\",\n                  version)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/express.js\n// module id = 219\n// module chunks = 0","'use strict'\n\nfunction record(path, segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n\n  var metricName = segment.name + '/' + path\n\n  if (scope) transaction.measure(metricName, scope, duration, exclusive)\n\n  transaction.measure(metricName, null, duration, exclusive)\n}\n\nmodule.exports = record\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/express.js\n// module id = 220\n// module chunks = 0","'use strict'\n\nvar logger = require('../../logger.js').child({component: 'express'})\nvar urltils = require('../../util/urltils.js')\nvar ensurePartialName = require('./common.js').ensurePartialName\nvar NAMES = require('../../metrics/names.js')\n\n\nmodule.exports.wrapMatchRequest = wrapMatchRequest\n\n\nfunction wrapMatchRequest(tracer, version, original) {\n  return function cls_wrapMatchRequest() {\n    if (!tracer.getTransaction()) {\n      logger.trace(\n        'Express %d router called outside transaction (wrapMatchRequest).',\n        version\n      )\n      return original.apply(this, arguments)\n    }\n    var route = original.apply(this, arguments)\n\n    nameFromRoute(tracer.getSegment(), route)\n    return route\n  }\n}\n\nfunction nameFromRoute(segment, route, params, append) {\n  if (!segment) return logger.error(\"No New Relic context to set Express route name on.\")\n  if (!route) return logger.debug(\"No Express route to use for naming.\")\n\n  params = route.params\n\n  var trans = segment.transaction\n  var path = route.path || route.regexp\n\n  if (!path) return logger.debug({route: route}, \"No path found on Express route.\")\n\n  // when route is a regexp, route.path will be a regexp\n  if (path instanceof RegExp) path = path.source\n\n  urltils.copyParameters(trans.agent.config, params, segment.parameters)\n\n  if (append) {\n    ensurePartialName(trans)\n    trans.nameState.appendPath(path)\n  } else {\n    trans.nameState.setName(\n      NAMES.EXPRESS.PREFIX, \n      trans.verb, \n      NAMES.ACTION_DELIMITER,\n      path\n    )\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/express/express-2.js\n// module id = 221\n// module chunks = 0","'use strict'\n\nvar NAMES = require('../../metrics/names.js')\n\n\nmodule.exports.ensurePartialName = ensurePartialName\n\n\n// Ensures that partialName begins with the express prefix\n// http instrumentation will set partialName before passing the request off to express\nfunction ensurePartialName(trans) {\n  if (trans.nameState.getName() == null ||\n      trans.nameState.prefix !== NAMES.EXPRESS.PREFIX) {\n    trans.nameState.setPrefix(NAMES.EXPRESS.PREFIX)\n    trans.nameState.setVerb(trans.verb)\n    trans.nameState.setDelimiter(NAMES.ACTION_DELIMITER)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/express/common.js\n// module id = 222\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer')\n\n\nmodule.exports = function initialize(agent, generic) {\n  shimmer.wrapMethod(generic, 'generic-pool', 'Pool', function cb_wrapMethod(Pool) {\n    return function cls_wrapMethod() {\n      var pooler = Pool.apply(this, arguments)\n\n      shimmer.wrapMethod(pooler, 'Pool', 'acquire', function cb_wrapMethod(acquire) {\n        return function propagateTransactionThroughPool(callback, priority) {\n          if (typeof callback === 'function') {\n            /* See adjustCallback in generic-pool.js for the motivation behind\n             * this grotesque hack. Tl;dr: depending on Function.length is evil.\n             */\n            var proxied = agent.tracer.bindFunction(callback)\n            switch (callback.length) {\n              case 2:\n                callback = function moveAlongNothingToSeeHere(error, client) {\n                  return proxied.call(this, error, client)\n                }\n                break\n              case 1:\n                callback = function moveAlongNothingToSeeHere(client) {\n                  return proxied.call(this, client)\n                }\n                break\n              default:\n                callback = proxied\n            }\n          }\n\n          return acquire.call(this, callback, priority)\n        }\n      })\n\n      return pooler\n    }\n  })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/generic-pool.js\n// module id = 223\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer.js')\nvar urltils = require('../util/urltils.js')\nvar logger = require('../logger.js').child({component: 'hapi'})\nvar record = require('../metrics/recorders/generic.js')\nvar NAMES = require('../metrics/names.js')\nvar VIEW = NAMES.VIEW\n\n\nfunction nameFromRequest(segment, request) {\n  if (!segment) return logger.error(\"No New Relic context to set Hapi route name on.\")\n  if (!request) return logger.debug(\"No Hapi request to use for naming.\")\n\n  var transaction = segment.transaction\n  var path = request.route && request.route.path\n\n\n  if (!path) return logger.debug({request: request}, \"No path found on Hapi route.\")\n\n  urltils.copyParameters(transaction.agent.config, request.params, segment.parameters)\n\n  transaction.nameState.setName(NAMES.HAPI.PREFIX, transaction.verb, \n      NAMES.ACTION_DELIMITER, path)\n}\n\nfunction setDispatcher(agent) {\n  agent.environment.setDispatcher('hapi')\n  agent.environment.setFramework('hapi')\n}\n\nmodule.exports = function initialize(agent, hapi) {\n  if (!agent) return logger.error(\"Hapi instrumentation bootstrapped without agent\")\n  if (!hapi) return logger.error(\"Hapi instrumentation applied without module\")\n\n  var tracer = agent.tracer\n\n  function wrapRender(render) {\n    return function wrappedRender(filename, context, options, callback) {\n      var wrapped = callback\n\n      // FIXME: this is going to be the most recent segment, which may not be right\n      var segment = tracer.getSegment()\n      if (segment && callback) {\n        wrapped = tracer.bindFunction(function cb_bindFunction() {\n          segment.end()\n\n          return callback.apply(this, arguments)\n        })\n      }\n\n      return render.call(this, filename, context, options, wrapped)\n    }\n  }\n\n  function wrapStart(start) {\n    return function wrappedStart() {\n      setDispatcher(agent)\n\n      /* The patched module loader doesn't access the filesystem itself, so\n       * lazily apply the patch to Views.prototype.render only once a Views\n       * object has been assigned as the view manager.\n       */\n      if (this._views) {\n        logger.debug('Hapi view manager set; instrumenting render.')\n        var proto = this._views.constructor.prototype\n        shimmer.wrapMethod(proto, 'hapi.Views.prototype', 'render', wrapRender)\n      }\n\n      return start.apply(this, arguments)\n    }\n  }\n\n  function wrapViews(views) {\n    return function wrappedViews() {\n      var returned = views.apply(this, arguments)\n\n      /* The patched module loader doesn't access the filesystem itself, so\n       * lazily apply the patch to Views.prototype.render only once a Views\n       * object has been assigned as the view manager.\n       */\n      if (this._views) {\n        var proto = this._views.constructor.prototype\n        shimmer.wrapMethod(proto, 'hapi.Views.prototype', 'render', wrapRender)\n      } else {\n        logger.warn('Hapi view manager set without manager actually being created.')\n      }\n\n      return returned\n    }\n  }\n\n  function wrapReplyView(reply) {\n    reply.view = tracer.wrapFunction(VIEW.PREFIX, record, reply.view, wrapper)\n\n    function wrapper(segment, args) {\n      segment.name = VIEW.PREFIX + args[0] + VIEW.RENDER\n      return args\n    }\n  }\n\n  function wrapHandler(handler) {\n    return function cls_wrapHandler(request, reply) {\n      if (!tracer.getTransaction()) {\n        logger.trace(\"Hapi route handler called outside transaction.\")\n        return handler.apply(this, arguments)\n      }\n\n      nameFromRequest(tracer.getSegment(), request)\n      if (reply && reply.view) wrapReplyView(reply)\n\n      return handler.apply(this, arguments)\n    }\n  }\n\n  /**\n   * Compare the before and after state of the router and apply the route wrapper\n   * to the new routes.\n   *\n   * @param  {object} before - State of the router before the new routes were added.\n   * @param  {object} after - State of the router after the new routes were added.\n   * @param  {string} vhost - If the user is letting hapi route its vhosts, use\n   *                          it in logging for debugging.\n   * @param  {function} visit  - Function used to wrap up the new routes.\n   */\n  function tableVisitor(before, after, vhost, visit) {\n    if (!vhost) vhost = '*'\n\n    if (after) {\n      Object.keys(after).forEach(function cb_forEach(method) {\n        var beforeHandlers = before && before[method]\n        var afterHandlers = after[method]\n        // hapi 8 nested routes a little deeper.\n        if (afterHandlers.routes) {\n          afterHandlers = afterHandlers.routes\n        }\n        for (var i = 0; i < afterHandlers.length; i++) {\n          var route = afterHandlers[i]\n          logger.debug('Instrumented hapi route [host %s] %s %s',\n                       vhost, method, route.path)\n          if (!beforeHandlers || beforeHandlers.indexOf(route) === -1) {\n            // hapi@6.9.0 started nesting the route handler 1 layer deeper\n            if (route.route) {\n              route = route.route\n            }\n\n            if (route.settings && route.settings.handler) {\n              route.settings.handler = visit(route.settings.handler)\n            } else {\n              logger.warn(\n                'Could not find handler to instrument for hapi route [host %s] %s %s',\n                vhost,\n                method,\n                route.path\n              )\n            }\n          }\n        }\n      })\n    }\n  }\n\n  /**\n   * This is pretty slow but only happens at route add time so optimizing it\n   * is of limited benefit. It is also moderately complex so lets go through\n   * what it does:\n   *\n   * 1. Gather the state of the router into `before*` variables.\n   * 2. Apply the new route(s) that are being added (which could be an array of\n   *    routes, and cover a number of different methods).\n   * 3. Get the new state of the router.\n   * 4. Pass it all to the table vistor which applies the route wrapper to all\n   *    the of individual routes that were just added.\n   */\n  function wrapRoute(_route) {\n    return function wrappedRoute(configs, env) {\n      var server = this\n\n      var router = server._router\n      if (!router) return logger.warn(\"no router found on hapi server\")\n\n      var vhosts = router.vhosts\n      var beforeHosts = {}\n      if (vhosts) {\n        logger.debug(\"capturing vhosts on hapi router\")\n\n        Object.keys(vhosts).forEach(function cb_forEach(host) {\n          beforeHosts[host] = {}\n          Object.keys(vhosts[host]).forEach(function cb_forEach(method) {\n            var routes = vhosts[host][method]\n            // hapi 8 nested routes a little deeper.\n            if (routes && routes.routes) {\n              routes = routes.routes\n            }\n            beforeHosts[host][method] = routes.slice()\n          })\n        })\n      }\n\n      var symbol\n      if (typeof router.table === 'function') {\n      // hapi 2: router.table -> router.routes & router.table is a function\n        symbol = 'routes'\n      } else {\n      // hapi 1: when vhosts aren't used, router.table contains the routes\n        symbol = 'table'\n      }\n\n      var table = router[symbol]\n      var beforeTable = {}\n      if (table) {\n        Object.keys(table).forEach(function cb_forEach(method) {\n          // hapi 8 nested routes a little deeper.\n          var routes = table[method]\n          if (routes.routes) {\n            routes = routes.routes\n          }\n          beforeTable[method] = routes.slice()\n        })\n      }\n\n      var returned = _route.call(this, configs, env)\n\n      vhosts = router.vhosts\n      if (vhosts) {\n        Object.keys(vhosts).forEach(function cb_forEach(host) {\n          tableVisitor(beforeHosts[host], vhosts[host], host, wrapHandler)\n        })\n      }\n\n      // Object could have been switched out, make sure to get a fresh one.\n      table = router[symbol]\n      if (table) tableVisitor(beforeTable, table, undefined, wrapHandler)\n\n      return returned\n    }\n  }\n\n  function wrapCreateServer(createServer) {\n    return function createServerWrapper() {\n      var server = createServer.apply(this, arguments)\n      shimServerPrototype(\n        server.constructor.prototype,\n        'hapi.Server.constructor.prototype'\n      )\n      // Now that we have instrumented the server prototype, un-instrument\n      // createServer as it serves no purpose.\n      shimmer.unwrapMethod(hapi, 'hapi', 'createServer')\n      return server\n    }\n  }\n\n  function shimServerPrototype(proto, name) {\n    shimmer.wrapMethod(proto, name, 'start', wrapStart)\n    shimmer.wrapMethod(proto, name, 'views', wrapViews)\n    shimmer.wrapMethod(proto, name, '_route', wrapRoute)\n  }\n\n  function wrapConnection(connection) {\n    return function wrappedConnection() {\n      setDispatcher(agent)\n      // Server.prototype returns a connection object\n      var plugin = connection.apply(this, arguments)\n\n      // Defensive against the possiblity that there isn't a connection for some\n      // reason.\n      if (plugin && plugin.connections && plugin.connections.length > 0) {\n        shimmer.wrapMethod(\n          plugin.connections[0].constructor.prototype,\n          'hapi.Connection.constructor.prototype',\n          '_route',\n          wrapRoute\n        )\n\n        shimmer.wrapMethod(\n          plugin.connections[0].server._replier.constructor.prototype,\n          'hapi.Connection.server._replier.constructor.prototype',\n          'interface',\n          wrapInterface\n        )\n\n        // Unwrap connection now that we've managed to patch the prototype\n        shimmer.unwrapMethod(\n          hapi.Server.prototype,\n          'hapi.Server.prototype',\n          'connection'\n        )\n      }\n\n      return plugin\n    }\n  }\n\n  function wrapInterface(replier) {\n    return function wrappedInterface() {\n      var reply = replier.apply(this, arguments)\n      shimmer.wrapMethod(\n        reply,\n        'hapi.Reply',\n        'response',\n        wrapResponse\n      )\n      return reply\n    }\n  }\n\n  function wrapResponse(response) {\n    return function wrappedResponse() {\n      var segment = agent.tracer.getSegment()\n      if (segment) segment.touch()\n      return response.apply(this, arguments)\n    }\n  }\n\n  var proto = hapi && hapi.Server && hapi.Server.prototype\n  if (proto && proto.start && proto.views && proto._route) { // Hapi 1 - 7.1.1\n    shimServerPrototype(proto, 'hapi.Server.prototype')\n  } else if (proto && Object.keys(proto).length === 0) { // Hapi 7.2 - 7.5.2\n    // This gets removed on first invocation as it is just used to patch a\n    // deeper prototype.\n    shimmer.wrapMethod(hapi, 'hapi', 'createServer', wrapCreateServer)\n  } else if (proto && proto.start && proto.route && proto.connection) { // Hapi 8+\n    shimmer.wrapMethod(proto, 'hapi.Server.prototype', 'connection', wrapConnection)\n  } else { // Some unknown future or hacked up version\n    logger.warn('hapi Server constructor not found; can\\'t instrument')\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/hapi.js\n// module id = 224\n// module chunks = 0","'use strict'\n\nvar stringifySync = require('../util/safe-json').stringifySync\nvar shimmer = require('../shimmer')\nvar urltils = require('../util/urltils.js')\nvar recordRedis = require('../metrics/recorders/redis.js')\nvar REDIS = require('../metrics/names').REDIS\n\n\nmodule.exports = function initialize(agent, redis) {\n  var tracer = agent.tracer\n\n  shimmer.wrapMethod(\n    redis && redis.prototype,\n    'redis.prototype',\n    'sendCommand',\n    function wrapSendCommand(original) {\n      return tracer.wrapFunction(\n        REDIS.OPERATION + 'Unknown',\n        recordRedis,\n        original,\n        wrapper\n      )\n    }\n  )\n\n  function wrapper(segment, args) {\n    var command = args[0]\n\n    var keys = command.args\n    segment.name = REDIS.OPERATION + (command.name || 'unknown')\n    if (keys && typeof keys !== 'function') {\n      urltils.copyParameters(agent.config,\n        {key: stringifySync(keys[0], 'Unknown')}, segment.parameters)\n    }\n\n    // capture connection info for datastore instance metric\n    segment.port = this.connector.options.port\n    segment.host = this.connector.options.host\n\n    // record duration when promise resolves\n    command.promise.finally(function cb_resolved() {\n      segment.touch()\n    })\n\n    return args\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/ioredis.js\n// module id = 225\n// module chunks = 0","'use strict'\n\nvar NAMES = require('../names')\nvar DB = NAMES.DB\nvar REDIS = NAMES.REDIS\n\n\nfunction recordRedis(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n  var type = transaction.isWeb() ? DB.WEB : DB.OTHER\n  var operation = segment.name\n\n\n  if (scope) transaction.measure(operation, scope, duration, exclusive)\n\n  transaction.measure(operation, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + type, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + REDIS.PREFIX + '/' + type, null, duration, exclusive)\n  transaction.measure(DB.ALL, null, duration, exclusive)\n  transaction.measure(REDIS.ALL, null, duration, exclusive)\n\n  // Datastore instance metrics.\n  if (segment.parameters.hasOwnProperty('host') &&\n      segment.parameters.hasOwnProperty('port_path_or_id')) {\n    var instanceName =\n      DB.INSTANCE + '/' + REDIS.PREFIX + '/' + segment.parameters.host + '/' +\n      segment.parameters.port_path_or_id\n    transaction.measure(instanceName, null, duration, exclusive)\n  }\n}\n// disabled until metric explosions can be handled by server\n/*\n  if (segment.port > 0) {\n  var hostname = segment.host || 'localhost'\n  var location = hostname + ':' + segment.port\n  var instance = DB.INSTANCE + '/' + REDIS.PREFIX + '/' + location\n\n  transaction.measure(instance, null, duration, exclusive)\n  }\n*/\n\n\nmodule.exports = recordRedis\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/redis.js\n// module id = 226\n// module chunks = 0","'use strict'\n\nvar stringifySync = require('../util/safe-json').stringifySync\nvar shimmer = require('../shimmer.js')\nvar urltils = require('../util/urltils.js')\nvar recordMemcache = require('../metrics/recorders/memcached.js')\nvar MEMCACHE = require('../metrics/names.js').MEMCACHE\n\nfunction wrapKeys(metacall) {\n  if (metacall.key) {\n    return [metacall.key]\n  } else if (metacall.multi) {\n    return metacall.command.split(' ').slice(1)\n  }\n\n  return []\n}\n\n/**\n * Thanks to Hernan Silberman!\n *\n * instrument the memcached driver to intercept calls and keep stats on them.\n */\nmodule.exports = function initialize(agent, memcached) {\n  var tracer = agent.tracer\n\n  shimmer.wrapMethod(\n    memcached && memcached.prototype,\n    'memcached.prototype',\n    'command',\n    function commandWrapper(original) {\n      return tracer.wrapFunction(\n        MEMCACHE.OPERATION + 'Unknown',\n        recordMemcache,\n        original,\n        wrapCommand\n      )\n    }\n  )\n\n  function wrapCommand(segment, args, bind) {\n    // The `command` method takes two arguments: a query generator and a server\n    // address. The query generator returns a simple object describing the\n    // memcached call. The server parameter is only provided for multi-calls.\n    // When not provided, it can be derived from the key being interacted with.\n    var metacall = args[0]()\n    var server = args[1]\n    var keys = wrapKeys(metacall)\n    segment.name = MEMCACHE.OPERATION + (metacall.type || 'Unknown')\n\n    // Capture connection info for datastore instance metric.\n    var location = null\n    if (typeof server === 'string') {\n      location = server.split(':')\n    } else if (this.HashRing && this.HashRing.get && metacall.key) {\n      location = this.HashRing.get(metacall.key).split(':')\n    }\n    if (location) {\n      segment.captureDBInstanceAttributes(location[0], location[1], false)\n    }\n\n    urltils.copyParameters(\n      agent.config,\n      {\n        key: stringifySync(keys[0], 'Unknown')\n      },\n      segment.parameters\n    )\n\n    /* Memcache call description includes a callback to apply when the\n     * operation is concluded. Wrap that to trace the duration of the\n     * operation.\n     */\n    shimmer.wrapMethod(\n      metacall,\n      'metacall',\n      'callback',\n      function wrapMetacallCallback(callback) {\n        return bind(callback, true, true)\n      }\n    )\n\n    // rewrap the metacall for the command object\n    args[0] = function rewrapped() {\n      return metacall\n    }\n\n    // finally, execute the original command\n    return args\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/memcached.js\n// module id = 227\n// module chunks = 0","'use strict'\n\nvar NAMES = require('../names')\nvar DB = NAMES.DB\nvar MEMCACHE = NAMES.MEMCACHE\n\n\nfunction recordMemcache(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n  var type = transaction.isWeb() ? DB.WEB : DB.OTHER\n  var operation = segment.name\n\n\n  if (scope) transaction.measure(operation, scope, duration, exclusive)\n\n  transaction.measure(operation, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + type, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + MEMCACHE.PREFIX + '/' + type, null, duration, exclusive)\n  transaction.measure(DB.ALL, null, duration, exclusive)\n  transaction.measure(MEMCACHE.ALL, null, duration, exclusive)\n\n  // Datastore instance metrics.\n  if (segment.parameters.hasOwnProperty('host') &&\n      segment.parameters.hasOwnProperty('port_path_or_id')) {\n    var instanceName =\n      DB.INSTANCE + '/' + MEMCACHE.PREFIX + '/' + segment.parameters.host + '/' +\n      segment.parameters.port_path_or_id\n    transaction.measure(instanceName, null, duration, exclusive)\n  }\n}\n// disabled until metric explosions can be handled by server\n/*\n  if (segment.port > 0) {\n  var hostname = segment.host || 'localhost'\n  var location = hostname + ':' + segment.port\n  var instance = DB.INSTANCE + '/' + MEMCACHE.PREFIX + '/' + location\n\n  transaction.measure(instance, null, duration, exclusive)\n  }\n*/\n\n\nmodule.exports = recordMemcache\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/memcached.js\n// module id = 228\n// module chunks = 0","'use strict'\n\nvar ParsedStatement = require('../db/parsed-statement')\nvar shimmer = require('../shimmer')\nvar logger = require('../logger').child({component: 'mongodb'})\nvar MONGODB = require('../metrics/names').MONGODB\n\nvar MONGO_SEGMENT_RE = /^Datastore\\/(?:statement|operation)\\/MongoDB\\//\n\n// legacy endpoint enumerations\nvar DB_OPS = [\n  'addUser',\n  'authenticate',\n  'collection',\n  'collectionNames',\n  'collections',\n  'command',\n  'createCollection',\n  'createIndex',\n  'cursorInfo',\n  'dereference',\n  'dropCollection',\n  'dropDatabase',\n  'dropIndex',\n  'ensureIndex',\n  'eval',\n  'executeDbAdminCommand',\n  'indexInformation',\n  'logout',\n  'open',\n  'reIndex',\n  'removeUser',\n  'renameCollection',\n  'stats',\n  '_executeInsertCommand',\n  '_executeQueryCommand'\n]\n\nvar COLLECTION_OPS = [\n  'aggregate',\n  'bulkWrite',\n  'count',\n  'createIndex',\n  'deleteMany',\n  'deleteOne',\n  'distinct',\n  'drop',\n  'dropAllIndexes',\n  'dropIndex',\n  'ensureIndex',\n  'findAndModify',\n  'findAndRemove',\n  'findOne',\n  'findOneAndDelete',\n  'findOneAndReplace',\n  'findOneAndUpdate',\n  'geoHaystackSearch',\n  'geoNear',\n  'group',\n  'indexes',\n  'indexExists',\n  'indexInformation',\n  'insert',\n  'insertMany',\n  'insertOne',\n  'isCapped',\n  'mapReduce',\n  'options',\n  'parallelCollectionScan',\n  'reIndex',\n  'remove',\n  'rename',\n  'replaceOne',\n  'save',\n  'stats',\n  'update',\n  'updateMany',\n  'updateOne'\n]\n\nvar GRID_OPS = [\n  'put',\n  'get',\n  'delete'\n]\n\nvar CURSOR_OPS = [\n  'nextObject',\n  'next',\n  'toArray',\n  'count',\n  'explain'\n]\n\nmodule.exports = initialize\n\nfunction initialize(agent, mongodb) {\n  if (!mongodb) return\n  var tracer = agent.tracer\n  var moduleNameToWrapFunction = {\n    'GridStore': wrapGrid,\n    'OrderedBulkOperation': wrapQuery,\n    'UnorderedBulkOperation': wrapQuery,\n    'CommandCursor': wrapQuery,\n    'AggregationCursor': wrapQuery,\n    'Cursor': wrapQuery,\n    'Collection': wrapQuery,\n    'Db': wrapDb\n  }\n\n  function instrumentModules(err, instrumentations) {\n    if (err) {\n      logger.trace('Unable to instrument mongo using the apm api due to error: %s', err)\n      // fallback to legacy instrumentation?\n      return\n    }\n    instrumentations.forEach(instrumentModule)\n  }\n\n  function applyInstrumentation(objectName, object, instrumentation) {\n    var methods = instrumentation.methods\n    var methodOptions = instrumentation.options\n    if (methodOptions.callback) {\n      for (var j = 0; j < methods.length; j++) {\n        var method = methods[j]\n\n        var wrapFunction\n        if (method === 'each') {\n          wrapFunction = wrapEach\n        } else {\n          wrapFunction = moduleNameToWrapFunction[objectName]\n        }\n\n        if (wrapFunction) {\n          shimmer.wrapMethod(\n            object.prototype,\n            'mongodb.' + objectName + '.' + method,\n            method,\n            wrapFunction\n          )\n        } else {\n          logger.trace('No wrapping method found for %s', objectName)\n        }\n      }\n    }\n  }\n\n  function instrumentModule(module) {\n    var object = module.obj\n    var instrumentations = module.instrumentations\n    for (var i = 0; i < instrumentations.length; i++) {\n      applyInstrumentation(module.name, object, instrumentations[i])\n    }\n  }\n\n  // instrument using the apm api\n  if (mongodb.instrument) {\n    var instrumenter = mongodb.instrument({}, instrumentModules)\n    instrumenter.on('started', function onMongoEventStarted(evnt) {\n      // This assumes that this `started` event is fired _after_ our wrapper\n      // starts and creates the segment. We perform a check of the segment name\n      // out of an excess of caution.\n      var segment = tracer.getSegment()\n      var connId = evnt.connectionId\n      if (connId && segment && MONGO_SEGMENT_RE.test(segment.name)) {\n        logger.trace('Adding db instance attributes to segment %j', segment.name)\n        // Mongo sticks the path to the domain socket in the \"host\" slot, but we\n        // want it in the \"port\", so if we have a domain socket we need to change\n        // the order of our parameters.\n        if (connId.domainSocket) {\n          segment.captureDBInstanceAttributes('localhost', connId.host, evnt.databaseName)\n        } else {\n          segment.captureDBInstanceAttributes(connId.host, connId.port, evnt.databaseName)\n        }\n      } else {\n        logger.trace(\n          'Not adding db instance metric attributes to segment %j',\n          segment && segment.name\n        )\n      }\n    })\n    return\n  }\n\n  // fallback to legacy enumerations\n  if (mongodb.Cursor && mongodb.Cursor.prototype) {\n    // should wrapup stream aswell\n    shimmer.wrapMethod(\n      mongodb.Cursor.prototype,\n      'mongodb.Cursor.prototype',\n      CURSOR_OPS,\n      wrapQuery\n    )\n\n    shimmer.wrapMethod(\n      mongodb.Cursor.prototype,\n      'mongodb.Cursor.prototype',\n      'each',\n      wrapEach\n    )\n  }\n\n  if (mongodb.Collection && mongodb.Collection.prototype) {\n    shimmer.wrapMethod(\n      mongodb.Collection.prototype,\n      'mongodb.Cursor.prototype',\n      COLLECTION_OPS,\n      wrapQuery\n    )\n  }\n\n  if (mongodb.Grid && mongodb.Grid.prototype) {\n    shimmer.wrapMethod(\n      mongodb.Grid.prototype,\n      'mongodb.Grid.prototype',\n      GRID_OPS,\n      wrapGrid\n    )\n  }\n\n  if (mongodb.Db && mongodb.Db.prototype) {\n    for (var i = 0, l = DB_OPS.length; i < l; ++i) {\n      shimmer.wrapMethod(\n        mongodb.Db.prototype,\n        'mongodb.Db.prototype',\n        DB_OPS[i],\n        wrapDb\n      )\n    }\n\n    shimmer.wrapMethod(mongodb.Db, 'mongodb.Db', 'connect', wrapDb)\n  }\n\n  function wrapOp(original, name, wrapper) {\n    return function wrapped() {\n      var args = tracer.slice(arguments)\n      var last = args.length - 1\n      var callback = typeof args[last] === 'function' ? args[last] : null\n      var transaction = tracer.getTransaction()\n      var collection = this.collectionName || 'unknown'\n\n      if (this.collection && this.collection.collectionName) {\n        collection = this.collection.collectionName\n      } else if (this.s && this.s.name) {\n        collection = this.s.name || collection\n      } else if (this.ns) {\n        collection = this.ns.split(/\\./)[1] || collection\n      }\n\n      if (!callback) {\n        logger.trace(\n          'Not tracing MongoDB %s.%s(); no callback.',\n          collection,\n          name\n        )\n\n        return original.apply(this, args)\n      } else if (!transaction) {\n        logger.trace(\n          'Not tracing MongoDB %s.%s(); no New Relic transaction.',\n          collection,\n          name\n        )\n\n        return original.apply(this, args)\n      } else if (inMongoSegment(tracer)) {\n        logger.trace(\n          'Not tracing MongoDB %s.%s(); Already in a mongo segment',\n           collection,\n           name\n        )\n\n        return original.apply(this, args)\n      }\n\n      return wrapper.call(this, args, last, collection)\n    }\n  }\n\n  function wrapQuery(original, opName) {\n    return wrapOp(original, opName, function wrappedQuery(args, last, collection) {\n      var segment = addMongoStatement(tracer, collection, opName)\n      var callback = args[last]\n\n      logger.trace(\n        'Tracing MongoDB %s.%s().',\n        collection,\n        opName\n      )\n\n      // capture configuration information if available\n      captureInstanceAttributes(segment, this)\n\n      args[last] = tracer.wrapCallback(callback, segment, function wrappedCallback() {\n        segment.touch()\n        logger.trace('Tracing MongoDB %s.%s() ended.', collection, opName)\n        return callback.apply(this, arguments)\n      })\n\n      return tracer.bindFunction(original, segment).apply(this, args)\n    })\n  }\n\n  function wrapEach(original, opName) {\n    return wrapOp(original, opName, function wrappedEach(args, last, collectionName) {\n      var segment = addMongoStatement(tracer, collectionName, opName)\n      var callbackBatch = null\n      var callback = args[last]\n      var collection = this\n\n      logger.trace('Tracing MongoDB %s.%s().', collection, opName)\n\n      // capture configuration information if available\n      captureInstanceAttributes(segment, this)\n\n      args[args.length - 1] = wrappedCallback\n\n      return tracer.bindFunction(original, segment).apply(this, args)\n\n      function wrappedCallback(err, item) {\n        segment.touch()\n\n        if (err || item === null) {\n          logger.trace('Tracing MongoDB %s.%s(%s) ended.', collection, opName)\n        }\n\n        if (!callbackBatch) {\n          callbackBatch = tracer.wrapCallback(\n            callback,\n            segment,\n            function wrapBatch() {\n              if (!collection.items || !collection.items.length) {\n                callbackBatch = null\n              }\n              return callback.apply(this, arguments)\n            }\n          )\n        }\n\n        return callbackBatch.apply(this, arguments)\n      }\n    })\n  }\n\n  function wrapGrid(original, opName) {\n    return wrapOp(original, opName, function wrappedGridOp(args, last) {\n      var name = MONGODB.OPERATION + 'GridFS-' + opName\n      var callback = args[last]\n      var grid = this\n\n      // TODO: should look into adding a recorder for this\n      return tracer.addSegment(name, null, null, false, segmentWrapper)\n\n      function segmentWrapper(segment) {\n        args[last] = tracer.wrapCallback(callback, segment, nrCallbackWrap)\n\n        return original.apply(grid, args)\n\n        function nrCallbackWrap() {\n          segment.touch()\n          logger.trace('Tracing MongoDB Grid.%s() ended.', opName)\n          return callback.apply(this, arguments)\n        }\n      }\n    })\n  }\n\n  function wrapDb(original, opName) {\n    return wrapOp(original, opName, function wrappedGridOp(args, last) {\n      var name = MONGODB.OPERATION + opName\n      var callback = args[last]\n      var db = this\n\n      // TODO: should look into adding a recorder for this\n\n      return tracer.addSegment(name, null, null, false, segmentWrapper)\n\n      function segmentWrapper(segment) {\n        args[last] = tracer.wrapCallback(callback, segment, nrCallbackWrap)\n        return tracer.bindFunction(original, segment).apply(db, args)\n\n        function nrCallbackWrap() {\n          segment.touch()\n          logger.trace('Tracing MongoDB %s() ended.', opName)\n          return callback.apply(this, arguments)\n        }\n      }\n    })\n  }\n}\n\n\nvar MONGO_RE = new RegExp(\n  '^(?:' + MONGODB.STATEMENT + ')|(?:' + MONGODB.OPERATION + ')'\n)\nfunction inMongoSegment(tracer) {\n  return MONGO_RE.test(tracer.getSegment().name)\n}\n\nfunction addMongoStatement(tracer, collection, opName) {\n  var statement = new ParsedStatement(MONGODB.PREFIX, opName, collection)\n  var recorder = statement.recordMetrics.bind(statement)\n  var name = MONGODB.STATEMENT + collection + '/' + opName\n\n  var segment = tracer.createSegment(name, recorder)\n  segment.start()\n  return segment\n}\n\nfunction captureInstanceAttributes(segment, obj) {\n  if (obj.db && obj.db.serverConfig) {\n    logger.trace('Adding datastore instance attributes from obj.db.serverConfig')\n    var databaseName = (\n      obj.db.serverConfig.db || obj.db.serverConfig.dbInstance || {}\n    ).databaseName\n    doCapture(obj.db.serverConfig, databaseName)\n  } else {\n    logger.trace('Could not find datastore instance attributes.')\n  }\n\n  function doCapture(conf, database) {\n    var host = conf.host\n    var port = conf.port\n\n    // If using a domain socket, mongo stores the path as the host name, but we\n    // pass it through the port value.\n    if (conf.socketOptions && conf.socketOptions.domainSocket) {\n      port = host\n      host = 'localhost'\n    }\n\n    segment.captureDBInstanceAttributes(host, port, database)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/mongodb.js\n// module id = 229\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger').child({component: 'mysql'})\nvar shimmer = require('../shimmer')\nvar parseSql = require('../db/parse-sql')\nvar MYSQL = require('../metrics/names').MYSQL\nvar dbutil = require('../db/util')\n\n\nmodule.exports = function initialize(agent, mysql) {\n  var tracer = agent.tracer\n\n  function wrapQueriable(queriable, name, poolQuery) {\n    // may not always be a queriable object, but anything with a .query\n    // you should pass the appropriate name in for shimmer\n    if (!queriable) {\n      return\n    }\n\n    shimmer.wrapMethod(\n      queriable,\n      name,\n      'query',\n      function nrQueryWrapper(original) {\n        return tracer.wrapFunction(\n          poolQuery ? 'MySQL pool.query' : MYSQL.STATEMENT + 'Unknown',\n          null,\n          original,\n          cb_wrapMethod,      // wrap arguments\n          bindStreamingEvents // wrap return value\n        )\n      }\n    )\n\n    // we bind the streaming event emitters to track the query's\n    // progress update the query's segment.\n    function bindStreamingEvents(segment, queryObject) {\n      if (queryObject && queryObject.emit) {\n        queryObject.emit = tracer.bindFunction(queryObject.emit, segment, true)\n      }\n      return queryObject\n    }\n    var databaseName = null\n\n    function cb_wrapMethod(segment, args, bind) {\n      var sqlString = ''\n\n      // This is just a massive argument hunt\n      // because you can call .query in many ways.\n      //\n      // You should populate `userCallback` after this block with a callback.\n      // Optionally you may populate `queryVals` and `sqlString`.\n      // The value in `sqlString` will show up in the UI\n      var vargs = []\n\n      if (args.length === 1 && typeof args[0] === 'object') {\n        // .query(query)\n        // query query is a Query object and contains ._callback and .sql\n        args[0]._callback = bind(args[0]._callback)\n        sqlString = args[0].sql\n        vargs.push(args[0])\n      } else if (args.length === 1) {\n        // either .query(callback) or .query(sql)\n        // in the latter case we rely on the streaming interface\n        if (typeof args[0] !== 'function') {\n          sqlString = args[0].sql\n          vargs.push(args[0])\n        } else {\n          vargs.push(bind(args[0]))\n        }\n      } else if (args.length === 2) {\n        // .query(sql, callback) or .query(sql, values)\n        // in the latter case we rely on the streaming interface\n        vargs.push(sqlString = args[0])\n        if (typeof args[1] !== 'function') {\n          vargs.push(args[1])\n        } else {\n          vargs.push(bind(args[1]))\n        }\n      } else {\n        // .query(sql, values, callback) or unknown\n        // in the latter case, we just omit measuring\n        vargs.push(sqlString = args[0])\n        vargs.push(args[1])\n        if (typeof args[2] !== 'function') {\n          vargs.push(args[2])\n          vargs.push(segment.touch.bind(segment))\n        } else {\n          vargs.push(bind(args[2]))\n        }\n      }\n\n\n      // name the metric\n      if (!poolQuery) {\n        var ps = parseSql(MYSQL.PREFIX, sqlString)\n        var model = ps.model\n        var operation = ps.operation\n\n        var segmentName = MYSQL.STATEMENT + (model || 'unknown') + '/' + operation\n        logger.trace(\n          'capturing mysql query in %s. model: %s, Operation: %s',\n          name,\n          model,\n          operation\n        )\n\n        // we will end the segment in onEnd above\n        tracer.getTransaction().addRecorder(ps.recordMetrics.bind(ps, segment))\n        segment.name = segmentName\n\n        if (queriable.config && queriable.config.connectionConfig) {\n          var queryConfig = queriable.config.connectionConfig\n        } else if (queriable.config) {\n          var queryConfig = queriable.config\n        }\n\n        if (queryConfig) {\n          databaseName = databaseName || queryConfig.database\n\n          if (queryConfig.socketPath) {\n            // in the unix domain socket case we force the host to be\n            // localhost\n            segment.captureDBInstanceAttributes(\n              'localhost',\n              queryConfig.socketPath,\n              databaseName\n            )\n          } else {\n            segment.captureDBInstanceAttributes(\n              queryConfig.host,\n              queryConfig.port,\n              databaseName\n            )\n          }\n        } else {\n          logger.trace('No query config detected, not collecting db instance data')\n        }\n\n        databaseName = dbutil.extractDatabaseChangeFromUse(sqlString) || databaseName\n      }\n\n      return vargs\n    }\n  }\n\n  function getVargs(args) {\n    var callback\n\n    var vargs = []\n\n    switch (args.length) {\n      case 1:\n        callback = args[0]\n        break\n      case 2:\n        vargs.push(args[0])\n        callback = args[1]\n        break\n      default:\n        vargs.push(args[0])\n        vargs.push(args[1])\n        callback = args[2]\n        break\n    }\n\n    logger.trace({args: args, vargs: vargs}, 'parsed getConnection arguments')\n\n    return {\n      vargs: vargs,\n      callback: callback\n    }\n  }\n\n  function getConnectionHandler(dbObject, getConnectionMethod) {\n    return function wrap_getConnection() { // getConnection\n      var args = getVargs(arguments)\n      var getConnectionCallback\n\n      // let's verify that we actually have a callback,\n      // otherwise we should just pass on wrapping it\n      //\n      // TODO: test case where no callback is supplied\n      var isCallback = args.callback && typeof args.callback === 'function'\n\n      // The mysql module has internal retry logic that will call\n      // getConnection again with our wrapped callback.\n      // We should avoid re-wrapping the callback when possible,\n      // although nothing bad happens when we fail this, it just\n      // makes stack traces a little better in errors.\n      if (!isCallback || !args.callback.__NR_original_callback) {\n        var proxiedCallback = tracer.bindFunction(args.callback)\n        getConnectionCallback = function getConnectionCallback(err, connection) {\n          // we need to patch the connection objects .query method\n          wrapQueriable(connection, 'connection')\n          proxiedCallback(err, connection)\n        }\n        // tag so we can avoid re-wrapping\n        getConnectionCallback.__NR_original_callback = args.callback\n      } else {\n        // the connection is already wrapped\n        logger.trace('getConnection callback already wrapped')\n        getConnectionCallback = args.callback\n      }\n\n      args.vargs.push(getConnectionCallback)\n\n      return getConnectionMethod.apply(dbObject, args.vargs)\n    }\n  }\n\n  // FIXME: need a more general way of differentiating between driver versions\n  if (mysql && mysql.createConnection) {\n    // congratulations, you have node-mysql 2.0\n\n    shimmer.wrapMethod(mysql, 'mysql.prototype', 'createPoolCluster',\n    function cb_wrapMethod(createPoolCluster) {\n      // this is generally called outside of a transaction,\n      // so we don't need/care about preserving\n      // the continuation, but we do need to patch the returned object\n      return function not_in_transaction() {\n        var poolCluster = createPoolCluster.apply(mysql, arguments)\n\n        shimmer.wrapMethod(poolCluster, 'poolCluster', 'of',\n        function cb_wrapMethod(of) {\n          return function nrWrappedMethod() {\n            var ofCluster = of.apply(poolCluster, arguments)\n\n            shimmer.wrapMethod(ofCluster, 'poolCluster', 'getConnection',\n            function cb_wrapMethod(getConnection) {\n              return getConnectionHandler(ofCluster, getConnection)\n            })\n\n            return ofCluster\n          }\n        })\n\n        shimmer.wrapMethod(poolCluster, 'poolCluster', 'getConnection',\n        function cb_wrapMethod(getConnection) {\n          return getConnectionHandler(poolCluster, getConnection)\n        })\n\n        return poolCluster\n      }\n    })\n\n    shimmer.wrapMethod(mysql, 'mysql', 'createPool',\n    function cb_wrapMethod(createPool) {\n      return function cb_wrapFunction() {\n        var pool = createPool.apply(mysql, arguments)\n\n        shimmer.wrapMethod(pool, 'pool', 'getConnection',\n        function cb_wrapMethod(getConnection) {\n          return getConnectionHandler(pool, getConnection)\n        })\n\n        // patch the pools .query method\n        wrapQueriable(pool, 'pool', true)\n\n        return pool\n      }\n    })\n\n    shimmer.wrapMethod(\n      mysql,\n      'mysql',\n      'createConnection',\n      function cb_wrapMethod(createConnection) {\n        return function wrappedCreateConnection() {\n          var connection = createConnection.apply(this, arguments)\n          wrapQueriable(connection, 'connection')\n          return connection\n        }\n      }\n    )\n  } else if (mysql && mysql.Client) {\n    // congratulations, you have node-mysql 0.9\n    shimmer.wrapMethod(\n      mysql && mysql.Client && mysql.Client.prototype,\n      'mysql.Client.prototype',\n      'query',\n      function nrQueryWrapper(original) {\n        return tracer.wrapFunction(\n          MYSQL.STATEMENT + 'Unknown',\n          null,\n          original,\n          wrapQuery09\n        )\n      }\n    )\n  }\n\n  var databaseName09 = null\n  function wrapQuery09(segment, args, bind) {\n    var transaction = tracer.getTransaction()\n\n    var sqlString = args[0]\n    var ps = parseSql(MYSQL.PREFIX, sqlString)\n    transaction.addRecorder(ps.recordMetrics.bind(ps, segment))\n    segment.name = MYSQL.STATEMENT + (ps.model || 'unknown') + '/' + ps.operation\n\n\n    // capture connection info for datastore instance metric\n    databaseName09 = databaseName09 || this.database\n    if (this.socketPath) {\n      // in the unix domain socket case we force the host to be\n      // localhost\n      segment.captureDBInstanceAttributes(\n        agent.config.getHostnameSafe(),\n        this.socketPath,\n        databaseName09\n      )\n    } else {\n      segment.captureDBInstanceAttributes(\n        this.host,\n        this.port,\n        databaseName09\n      )\n    }\n    databaseName09 = dbutil.extractDatabaseChangeFromUse(sqlString) || databaseName09\n\n    // find and wrap the callback\n    if (args.length > 1 && typeof args[args.length - 1] === 'function') {\n      args[args.length - 1] = bind(args[args.length - 1])\n    }\n\n    // FIXME: need to grab error events as well, as they're also emitted on\n    // the client\n\n    return args\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/mysql.js\n// module id = 230\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer')\nvar record = require('../metrics/recorders/cassandra.js')\nvar CASSANDRA = require('../metrics/names').CASSANDRA\n\nvar INSTRUMENTED_OPERATIONS = [\n  'execute',\n  'executeAsPrepared',\n  'executeBatch'\n]\n\nmodule.exports = function initialize(agent, cassandracql) {\n  var tracer = agent.tracer\n\n  INSTRUMENTED_OPERATIONS.forEach(function cb_forEach(operation) {\n    shimmer.wrapMethod(\n      cassandracql && cassandracql.Client && cassandracql.Client.prototype,\n      'node-cassandra-cql.Client.prototype',\n      operation,\n      function wrapOperation(original) {\n        return tracer.wrapFunction(\n          CASSANDRA.OPERATION + operation,\n          record,\n          original,\n          wrapper\n        )\n      }\n    )\n\n    function wrapper(segment, args, bind) {\n      var position = args.length - 1\n      var last = args[position]\n\n      // capture connection info for datastore instance metric\n      segment.port = this.port\n      segment.host = this.host\n\n      if (typeof last === 'function') {\n        args[position] = bind(last, true, true)\n      } else if (Array.isArray(last) && typeof last[last.length - 1] === 'function') {\n        last[last.length - 1] = tracer.bindFunction(\n          bind(last[last.length - 1], true, true)\n        )\n      } else { // let's shove a callback in there for fun\n        args.push(bind(null, null))\n      }\n\n      return args\n    }\n  })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/node-cassandra-cql.js\n// module id = 231\n// module chunks = 0","'use strict'\n\nvar NAMES = require('../names')\nvar DB = NAMES.DB\nvar CASSANDRA = NAMES.CASSANDRA\n\n\nfunction record(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n  var type = transaction.isWeb() ? DB.WEB : DB.OTHER\n  var operation = segment.name\n\n\n  if (scope) transaction.measure(operation, scope, duration, exclusive)\n\n  transaction.measure(operation, null, duration, exclusive)\n  transaction.measure(DB.PREFIX + type, null, duration, exclusive)\n  transaction.measure(DB.ALL, null, duration, exclusive)\n  transaction.measure(\n    DB.PREFIX + CASSANDRA.PREFIX + '/' + type,\n    null,\n    duration,\n    exclusive\n  )\n  transaction.measure(CASSANDRA.ALL, null, duration, exclusive)\n}\n// disabled until metric explosions can be handled by server\n/*\n  if (segment.port > 0) {\n  var hostname = segment.host || 'localhost'\n  var location = hostname + ':' + segment.port\n  var instance = DB.INSTANCE + '/' + CASSANDRA.PREFIX + '/' + location\n\n  transaction.measure(instance, null, duration, exclusive)\n  }\n*/\n\nmodule.exports = record\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/cassandra.js\n// module id = 232\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger').child({component: 'oracle'})\nvar shimmer = require('../shimmer')\nvar parseSql = require('../db/parse-sql')\nvar ORACLE = require('../metrics/names').ORACLE\n\nmodule.exports = function initialize(agent, oracle) {\n  var tracer = agent.tracer\n  var wrapped = false\n\n  logger.trace('wrapping oracle.connect and oracle.connectSync')\n\n  shimmer.wrapMethod(oracle, 'Oracle', 'connect', function cb_wrapMethod(connect) {\n    return function wrappedConnect(connectData, cb) {\n      return connect.call(\n        this,\n        connectData,\n        tracer.bindFunction(wrapConnection)\n      )\n\n      function wrapConnection(err, connection) {\n        if (!err) ensureConnectionWrapped(connection)\n        return cb(err, connection)\n      }\n    }\n  })\n\n  shimmer.wrapMethod(oracle, 'Oracle', 'connectSync', function wrapSyncConnect(connect) {\n    return function wrappedSyncConnect() {\n      var connection = connect.apply(this, arguments)\n      ensureConnectionWrapped(connection)\n      return connection\n    }\n  })\n\n  function ensureConnectionWrapped(connection) {\n    // return early in case called from an async connect after wrapping\n    if (wrapped) return\n    logger.trace('wrapping oracle connection prototype')\n    wrapped = true\n\n    oracle.connectSync.__NR_unwrap()\n    oracle.connect.__NR_unwrap()\n    shimmer.wrapMethod(oracle, 'Oracle', 'connect', function wrapMethod(connect) {\n      return tracer.wrapFunctionNoSegment(connect, 'connect')\n    })\n\n    var proto = Object.getPrototypeOf(connection)\n    wrapConnectionExecute(proto, tracer)\n    wrapConnectionPrepare(proto, tracer)\n\n    shimmer.wrapMethod(proto, 'Oracle', 'reader', function wrapMethod(createReader) {\n      return function wrappedConnect(sql) {\n        var reader = createReader.apply(this, arguments)\n        wrapReader(reader, tracer, sql)\n        return reader\n      }\n    })\n  }\n}\n\nfunction wrapConnectionExecute(connection, tracer) {\n  shimmer.wrapMethod(connection, 'Oracle.connection', 'execute', wrapExecute)\n\n  function wrapExecute(execute) {\n    return tracer.wrapFunction(ORACLE.STATEMENT + 'other/', null, execute, wrappedExecute)\n  }\n\n  function wrappedExecute(segment, args, bind) {\n    var ps = parseSql(ORACLE.PREFIX, args[0])\n    var model = ps.model\n    var operation = ps.operation\n\n    segment.name = ORACLE.STATEMENT + model + '/Connection.execute/' + operation\n    logger.trace(\n      'capturing oracle query. model: %s, Operation: %s',\n      model,\n      operation\n    )\n\n    segment.transaction.addRecorder(ps.recordMetrics.bind(ps, segment))\n    args[2] = bind(args[2])\n    return args\n  }\n}\n\nfunction wrapReader(reader, tracer, sql) {\n  var ps = parseSql(ORACLE.PREFIX, sql)\n  shimmer.wrapMethod(reader, 'Oracle.Reader', 'nextRow', wrapNextRow)\n  shimmer.wrapMethod(reader, 'Oracle.Reader', 'nextRows', wrapNextRows)\n\n  function wrapNextRow(nextRow) {\n    return tracer.wrapFunctionLast(\n      ORACLE.STATEMENT + ps.model + '/Reader.nextRow/' + ps.operation,\n      ps.recordMetrics.bind(ps),\n      nextRow\n    )\n  }\n\n  function wrapNextRows(nextRows) {\n    return tracer.wrapFunctionLast(\n      ORACLE.STATEMENT + ps.model + '/Reader.nextRows/' + ps.operation,\n      ps.recordMetrics.bind(ps),\n      nextRows\n    )\n  }\n}\n\nfunction wrapConnectionPrepare(connection, tracer) {\n  shimmer.wrapMethod(connection, 'Oracle.connection', 'prepare', wrapPrepare)\n\n  function wrapPrepare(prepare) {\n    return function wrappedPrepare(sql) {\n      var ps = parseSql(ORACLE.PREFIX, sql)\n      var prepared = prepare.apply(this, arguments)\n      shimmer.wrapMethod(prepared, 'Oracle', 'execute', wrapExecute)\n      return prepared\n\n      function wrapExecute(execute) {\n        return tracer.wrapFunctionLast(\n          ORACLE.STATEMENT + ps.model + '/Statement.execute/' + ps.operation,\n          ps.recordMetrics.bind(ps),\n          execute\n        )\n      }\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/oracle.js\n// module id = 233\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer')\nvar logger = require('../logger').child({component: 'pg'})\nvar parseSql = require('../db/parse-sql')\nvar POSTGRES = require('../metrics/names').POSTGRES\nvar util = require('util')\n\n\n// Adds a segment\n// The `config` argument is either a statement string template or a pg statement\n// config object with a `text` property holding the statement string template.\nfunction initializeSegment(tracer, segment, client, config) {\n  var statement\n  if (config && (typeof config === 'string' || config instanceof String)) {\n    statement = config\n  } else if (config && config.text) {\n    statement = config.text\n  } else {\n    // Won't be matched by parser, but should be handled properly\n    statement = 'Other'\n  }\n\n  var ps = parseSql(POSTGRES.PREFIX, statement)\n  var model = ps.model\n  var operation = ps.operation\n\n  segment.name = POSTGRES.STATEMENT + (model || 'other') + '/' + operation\n  segment.captureDBInstanceAttributes(client.host, client.port, client.database)\n\n  logger.trace(\n    'capturing postgresql query. model: %s, operation: %s',\n    model,\n    operation\n  )\n\n  tracer.getTransaction().addRecorder(ps.recordMetrics.bind(ps, segment))\n}\n\nmodule.exports = function initialize(agent, pgsql) {\n  if (!pgsql) return\n\n  var tracer = agent.tracer\n\n  // allows for native wrapping to not happen if not necessary\n  // when env var is true\n\n  if (process.env.NODE_PG_FORCE_NATIVE) {\n    return instrumentPGNative('pg', pgsql)\n  }\n\n  // The pg module defines \"native\" getter which sets up the native client lazily\n  // (only when called).  We replace the getter, so that we can instrument the native\n  // client.  The original getter replaces itself with the instance of the native\n  // client, so only instrument if the getter exists (otherwise assume already\n  // instrumented).\n  var origGetter = pgsql.__lookupGetter__('native')\n  if (origGetter) {\n    delete pgsql.native\n    pgsql.__defineGetter__('native', function getNative() {\n      var temp = origGetter()\n      instrumentPGNative('pg.native', temp)\n      return temp\n    })\n  }\n\n  // wrapping for native\n  function instrumentPGNative(eng, pg) {\n    shimmer.wrapMethod(pg, 'pg', 'Client', wrapClient)\n    shimmer.wrapMethod(pg.pools, 'pg.pools', 'Client', wrapClient)\n    shimmer.wrapMethod(pg, 'pg', 'Pool', wrapPool)\n\n    function newApply(Cls) {\n      return new (Cls.bind.apply(Cls, arguments))()\n    }\n\n    function wrapPool(Pool) {\n      if (shimmer.isWrapped(Pool)) {\n        return Pool\n      }\n\n      util.inherits(WrappedPool, Pool)\n      WrappedPool.__NR_original = Pool\n      return WrappedPool\n\n      /* eslint-disable no-unused-vars */\n      function WrappedPool(options, Client) {\n        /* eslint-enable no-unused-vars */\n        if (!(this instanceof WrappedPool)) {\n          return newApply(WrappedPool, arguments)\n        }\n\n        Pool.apply(this, arguments)\n        this.Client = wrapClient(this.Client)\n      }\n    }\n\n    function wrapClient(Client) {\n      if (shimmer.isWrapped(Client)) {\n        return Client\n      }\n\n      util.inherits(WrappedClient, Client)\n      Object.keys(Client).forEach(function forEachClientKey(k) {\n        WrappedClient[k] = Client[k]\n      })\n      WrappedClient.__NR_original = Client\n      return WrappedClient\n\n      // -------------------------------------------------------------------- //\n\n      /* eslint-disable no-unused-vars */\n      function WrappedClient(options) {\n        /* eslint-enable no-unused-vars */\n        // NOTE:  This is an instance of PG's `Client` class, _not_ its\n        //        `Connection` class. This is an important distinction as the\n        //        latter does not have the host/port/database meta data.\n\n        // Apply the constructor. JavaScript really needs a better way to do this.\n        // This logic is the same as `newApply`, however for some reason `newApply`\n        // does not work on Node v0.8 or v0.10. For `WrappedPool` this doesn't\n        // matter since the versions of PG it is in don't support those ancient\n        // versions of Node either, but here we must do it ourselves.\n        var args = tracer.slice(arguments)\n        args.unshift(Client) // `unshift` === `push_front`\n        var client = new (Client.bind.apply(Client, args))()\n\n        // Wrap the methods we care about.\n        shimmer.wrapMethod(client, 'Client', 'connect', wrapConnect)\n        shimmer.wrapMethod(client, 'Client', 'query', wrapNativeQuery)\n        return client\n      }\n\n      function wrapConnect(connect) {\n        return function wrappedConnect(callback) {\n          if (typeof callback === 'function') {\n            callback = tracer.bindFunction(callback)\n          }\n          return connect.call(this, callback)\n        }\n      }\n\n      function wrapNativeQuery(original) {\n        return tracer.wrapFunction(\n          POSTGRES.STATEMENT + 'Unknown',\n          null,\n          original,\n          nativeQueryWrapper,\n          nativeResponseWrapper\n        )\n      }\n\n      function nativeQueryWrapper(segment, args, bindCallback) {\n        initializeSegment(tracer, segment, this, args[0])\n\n        var pos = args.length - 1\n        var last = args[pos]\n\n        // Proxy callback in case they start new segments\n        args[pos] = bindCallback(last)\n\n        return args\n      }\n\n      function nativeResponseWrapper(segment, result, bindCallback) {\n        // Wrap end and error events too, in case they start new segments\n        // within them. Use end and error events to end segments.\n        result.on('error', end)\n        result.on('end', end)\n\n        function end() {\n          segment.touch()\n          logger.trace(\n            'postgres command trace segment ended by event for transaction %s.',\n            segment.transaction.id\n          )\n        }\n\n        // TODO: Maybe .on and .addListener shouldn't be different\n        // Proxy events too, in case they start new segments within handlers\n        shimmer.wrapMethod(result, 'query.on', 'on', function queryOnWrapper(on) {\n          return function queryOnWrapped() {\n            if (arguments[1]) {\n              if (arguments[0] !== 'row') {\n                arguments[1] = bindCallback(arguments[1])\n              } else {\n                arguments[1] = tracer.bindFunction(arguments[1], segment, true)\n              }\n            }\n            return on.apply(this, arguments)\n          }\n        })\n\n        shimmer.wrapMethod(\n          result,\n          'query.addListener',\n          'addListener',\n          queryAddListenerWrapper\n        )\n\n        function queryAddListenerWrapper(addL) {\n          return function queryAddListenerWrapped() {\n            if (arguments[1]) {\n              if (arguments[0] !== 'row') {\n                arguments[1] = bindCallback(arguments[1])\n              } else {\n                arguments[1] = tracer.bindFunction(arguments[1], segment, true)\n              }\n            }\n            addL.apply(this, arguments)\n          }\n        }\n\n        return result\n      }\n    }\n  }\n\n  // wrapping for JS\n  shimmer.wrapMethod(\n    pgsql && pgsql.Client && pgsql.Client.prototype,\n    'pg.Client.prototype',\n    'query',\n    wrapQuery\n  )\n\n  function wrapQuery(original) {\n    return tracer.wrapFunction(\n      POSTGRES.STATEMENT + 'Unknown',\n      null,\n      original,\n      queryWrapper,\n      responseWrapper\n    )\n  }\n\n  function queryWrapper(segment, args, bindCallback) {\n    var position = args.length - 1\n    var last = args[position]\n\n    initializeSegment(tracer, segment, this, args[0])\n\n    // Proxy callbacks in case they start new segments\n    if (typeof last === 'function') {\n      args[position] = bindCallback(last, true, true)\n    } else if (Array.isArray(last) && typeof last[last.length - 1] === 'function') {\n      var callback = last[last.length - 1]\n      last[last.length - 1] = bindCallback(callback)\n    }\n\n    return args\n  }\n\n  function responseWrapper(segment, query, bindCallback) {\n    // Use end and error events to end segments\n    query.on('error', end)\n    query.on('end', end)\n\n    function end() {\n      segment.end()\n      logger.trace(\n        'postgres command trace segment ended by event for transaction %s.',\n        segment.transaction.id\n      )\n    }\n\n    // Proxy events too, in case they start new segments within handlers\n    shimmer.wrapMethod(query, 'query.on', 'on', function queryOnWrapper(on) {\n      return function queryOnWrapped() {\n        if (arguments[1]) {\n          if (arguments[0] !== 'row') {\n            arguments[1] = bindCallback(arguments[1])\n          } else {\n            arguments[1] = tracer.bindFunction(arguments[1], segment, true)\n          }\n        }\n        return on.apply(this, arguments)\n      }\n    })\n\n    shimmer.wrapMethod(query, 'query.addListener', 'addListener', addListenerWrapper)\n\n    function addListenerWrapper(addL) {\n      return function wrappedAddListener() {\n        if (arguments[1]) {\n          if (arguments[0] !== 'row') {\n            arguments[1] = bindCallback(arguments[1])\n          } else {\n            arguments[1] = tracer.bindFunction(arguments[1], segment, true)\n          }\n        }\n        addL.apply(this, arguments)\n      }\n    }\n\n    return query\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/pg.js\n// module id = 234\n// module chunks = 0","'use strict'\n\nvar wrap = require('../shimmer').wrapMethod\n\nmodule.exports = initialize\n\nfunction initialize(agent, Q) {\n  function wrapUninstrumented(original, method) {\n    return agent.tracer.wrapFunctionFirstNoSegment(original, method)\n  }\n\n  if (Q.nextTick) {\n    // The wrap() call for nextTick wipes the sub-function.  Save a reference\n    // now so it can be restored later\n    var savedRunAfter = Q.nextTick.runAfter\n\n    wrap(Q, 'Q', 'nextTick', wrapUninstrumented)\n\n    if (savedRunAfter) {\n      Q.nextTick.runAfter = savedRunAfter\n      wrap(Q.nextTick, 'Q.nextTick', 'runAfter', wrapUninstrumented)\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/q.js\n// module id = 235\n// module chunks = 0","'use strict'\n\nvar logger = require('../logger').child({component: 'redis'})\nvar stringifySync = require('../util/safe-json').stringifySync\nvar shimmer = require('../shimmer')\nvar urltils = require('../util/urltils.js')\nvar recordRedis = require('../metrics/recorders/redis.js')\nvar REDIS = require('../metrics/names').REDIS\n\n\nmodule.exports = function initialize(agent, redis) {\n  var tracer = agent.tracer\n\n  var redisPrototype = redis && redis.RedisClient && redis.RedisClient.prototype\n  if (redisPrototype) {\n    if (redisPrototype.internal_send_command) {\n      shimmer.wrapMethod(\n        redisPrototype,\n        'redis.RedisClient.prototype',\n        'internal_send_command',\n        function wrapSendCommand(original) {\n          return tracer.wrapFunction(\n            REDIS.OPERATION + 'Unknown',\n            recordRedis,\n            original,\n            internalSendCommandWrapper\n          )\n        }\n      )\n    } else {\n      shimmer.wrapMethod(\n        redisPrototype,\n        'redis.RedisClient.prototype',\n        'send_command',\n        function wrapSendCommand(original) {\n          return tracer.wrapFunction(\n            REDIS.OPERATION + 'Unknown',\n            recordRedis,\n            original,\n            sendCommandWrapper\n          )\n        }\n      )\n    }\n  }\n\n  function sendCommandWrapper(segment, args, bind) {\n    var position = args.length - 1\n    var keys = args[1]\n    var last = args[position]\n\n    segment.name = REDIS.OPERATION + (args[0] || 'unknown')\n\n    if (keys && typeof keys !== 'function') {\n      urltils.copyParameters(agent.config,\n        {key: stringifySync(keys[0], 'Unknown')}, segment.parameters)\n    }\n\n    // capture connection info for datastore instance metric\n    captureInstanceAttributes(segment, this)\n\n    if (typeof last === 'function') {\n      args[position] = bind(last, true, true)\n    } else if (Array.isArray(last) && typeof last[last.length - 1] === 'function') {\n      last[last.length - 1] = bind(last[last.length - 1], true, true)\n    } else { // let's shove a callback in there for fun\n      args.push(bind(null, true, true))\n    }\n\n    return args\n  }\n\n  function internalSendCommandWrapper(segment, args, bind) {\n    var keys = args[0].args\n    var command = args[0].command\n    args[0].callback = bind(args[0].callback, true, true)\n\n    segment.name = REDIS.OPERATION + (command || 'unknown')\n\n    if (keys && typeof keys !== 'function') {\n      urltils.copyParameters(agent.config,\n        {key: stringifySync(keys[0], 'Unknown')}, segment.parameters)\n    }\n\n    // capture connection info for datastore instance metric\n    captureInstanceAttributes(segment, this)\n\n    return args\n  }\n}\n\nfunction captureInstanceAttributes(segment, client) {\n  if (client.hasOwnProperty('port') && client.hasOwnProperty('host')) {\n    // for redis <=0.11\n    doCapture(client)\n  } else if (client.hasOwnProperty('connection_options')) {\n    // for redis 2.4.0 - 2.6.2\n    doCapture(client.connection_options)\n  } else if (client.hasOwnProperty('connectionOption')) {\n    // for redis 0.12 - 2.2.5\n    doCapture(client.connectionOption)\n  } else if (client.hasOwnProperty('options')) {\n    // for redis 2.3.0 - 2.3.1\n    doCapture(client.options)\n  } else {\n    logger.debug('Could not access instance attributes on connection.')\n  }\n\n  function doCapture(opts) {\n    var db = (client.hasOwnProperty('selected_db') ? client.selected_db : opts.db) || 0\n\n    segment.captureDBInstanceAttributes(\n      opts.host || 'localhost',\n      opts.path || opts.port || '6379',\n      db\n    )\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/redis.js\n// module id = 236\n// module chunks = 0","'use strict'\n\nvar shimmer = require('../shimmer')\nvar logger = require('../logger.js').child({component: 'restify'})\nvar urltils = require('../util/urltils.js')\nvar NAMES = require('../metrics/names.js')\n\n\nfunction nameFromRoute(segment, route, context) {\n  if (!segment) return logger.error(\"No New Relic context to set Restify route name on.\")\n  if (!route) return logger.error(\"No Restify route to use for naming.\")\n\n  var transaction = segment.transaction\n  var path = (route.spec && (route.spec.path || route.spec.name)) || route.name\n\n\n  var params = context || route.params\n  if (params) {\n    urltils.copyParameters(transaction.agent.config, params, segment.parameters)\n  }\n\n  if (!path) return logger.warn({route: route}, \"No path found on Restify route.\")\n\n  // when route is a regexp, route.spec.path will be a regexp\n  if (path instanceof RegExp) path = path.source\n\n  transaction.nameState.setName(NAMES.RESTIFY.PREFIX, transaction.verb, \n      NAMES.ACTION_DELIMITER, path)\n}\n\nmodule.exports = function initialize(agent, restify) {\n  /* Restify doesn't directly expose its Router constructor. We need to wait\n   * until a server is created, and then grab the constructor off of it.\n   *\n   * Unfortunately, we can't create a server ourselves as doing so causes\n   * Restify's req.query extension to override express' req.query extension of\n   * IncomingMessage. This is an issue if an app uses express for serving while\n   * using Restify only for client-side REST requests.\n   */\n  shimmer.wrapMethod(\n    restify,\n    'restify',\n    'createServer',\n    function cb_wrapMethod(createServer) {\n      return function wrappedCreateServer() {\n        agent.environment.setDispatcher('restify')\n        agent.environment.setFramework('restify')\n\n        var server = createServer.apply(this, arguments)\n        var Router = server.router.constructor\n\n        /* Now that we have created a server, we have access to the Router\n         * constructor and can instrument it.\n         */\n        shimmer.wrapMethod(\n          Router.prototype,\n          'Router.prototype',\n          'find',\n          function cb_wrapMethod(find) {\n            return function wrappedFind(req, res, callback) {\n              var tracer = agent.tracer\n\n              if (!tracer.getTransaction()) {\n                logger.trace(\"Restify router invoked outside transaction.\")\n                return find.apply(this, arguments)\n              }\n\n              var wrapped = function wrappedRoute(error, route, context) {\n                nameFromRoute(tracer.getSegment(), route, context)\n                return callback(error, route, context)\n              }\n\n              return find.call(this, req, res, wrapped)\n            }\n          }\n        )\n\n        return server\n      }\n    }\n  )\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/instrumentation/restify.js\n// module id = 237\n// module chunks = 0","'use strict'\n\nvar NAMES = require('../names')\n\nfunction record(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n  var name = NAMES.CUSTOM + NAMES.ACTION_DELIMITER + segment.name\n\n  if (scope) transaction.measure(name, scope, duration, exclusive)\n\n  transaction.measure(name, null, duration, exclusive)\n}\n\nmodule.exports = record\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/custom.js\n// module id = 238\n// module chunks = 0","'use strict'\n\nvar NAMES = require('../../metrics/names.js')\n\nfunction recordBackground(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var totalTime = segment.transaction.trace.getTotalTimeDurationInMillis()\n  var transaction = segment.transaction\n  var group = segment.partialName\n  var name = group + '/' + segment.name\n\n  if (scope) {\n    transaction.measure(scope, null, duration, exclusive)\n    transaction.measure(\n      NAMES.BACKGROUND.TOTAL_TIME + '/' + name,\n      null,\n      totalTime,\n      exclusive\n    )\n  }\n  // rollup for background total time doesn't have `/all` where the response\n  // time version does.\n  transaction.measure(\n    NAMES.BACKGROUND.RESPONSE_TIME + '/all',\n    null,\n    duration,\n    exclusive\n  )\n  transaction.measure(NAMES.BACKGROUND.TOTAL_TIME, null, totalTime, exclusive)\n}\n\nmodule.exports = recordBackground\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/lib/metrics/recorders/other.js\n// module id = 239\n// module chunks = 0","'use strict'\n\nvar util = require('util')\nvar logger = require('./lib/logger').child({component: 'api'})\nvar NAMES = require('./lib/metrics/names')\nvar recordWeb = require('./lib/metrics/recorders/http.js')\nvar recordBackground = require('./lib/metrics/recorders/other.js')\nvar customRecorder = require('./lib/metrics/recorders/custom')\nvar hashes = require('./lib/util/hashes')\nvar stringify = require('json-stringify-safe')\n\n\n/*\n *\n * CONSTANTS\n *\n */\nvar RUM_STUB = \"<script type='text/javascript'>window.NREUM||(NREUM={});\" +\n                \"NREUM.info = %s; %s</script>\"\n\n// these messages are used in the _gracefail() method below in getBrowserTimingHeader\nvar RUM_ISSUES = [\n  'NREUM: no browser monitoring headers generated; disabled',\n  'NREUM: transaction missing while generating browser monitoring headers',\n  'NREUM: config.browser_monitoring missing, something is probably wrong',\n  'NREUM: browser_monitoring headers need a transaction name',\n  'NREUM: browser_monitoring requires valid application_id',\n  'NREUM: browser_monitoring requires valid browser_key',\n  'NREUM: browser_monitoring requires js_agent_loader script',\n  'NREUM: browser_monitoring disabled by browser_monitoring.loader config'\n]\n\n// can't overwrite internal parameters or all heck will break loose\nvar CUSTOM_BLACKLIST = [\n  'nr_flatten_leading'\n]\n\nvar CUSTOM_EVENT_TYPE_REGEX = /^[a-zA-Z0-9:_ ]+$/\n\n/**\n * The exported New Relic API. This contains all of the functions meant to be\n * used by New Relic customers. For now, that means transaction naming.\n */\nfunction API(agent) {\n  this.agent = agent\n}\n\n/**\n * Give the current transaction a custom name. Overrides any New Relic naming\n * rules set in configuration or from New Relic's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. New\n * Relic transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name The name you want to give the web request in the New\n *                      Relic UI. Will be prefixed with 'Custom/' when sent.\n */\nAPI.prototype.setTransactionName = function setTransactionName(name) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setTransactionName'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting name to '%s'.\", name)\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\"Must include name in setTransactionName call for URL %s.\",\n                   transaction.url)\n    } else {\n      logger.error(\"Must include name in setTransactionName call.\")\n    }\n\n    return\n  }\n\n  transaction.forceName = NAMES.CUSTOM + '/' + name\n}\n\n/**\n * Give the current transaction a name based on your own idea of what\n * constitutes a controller in your Node application. Also allows you to\n * optionally specify the action being invoked on the controller. If the action\n * is omitted, then the API will default to using the HTTP method used in the\n * request (e.g. GET, POST, DELETE). Overrides any New Relic naming rules set\n * in configuration or from New Relic's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. New\n * Relic transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name   The name you want to give the controller in the New\n *                        Relic UI. Will be prefixed with 'Controller/' when\n *                        sent.\n * @param {string} action The action being invoked on the controller. Defaults\n *                        to the HTTP method used for the request.\n */\nAPI.prototype.setControllerName = function setControllerName(name, action) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setControllerName'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting controller to %s.\", name)\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\"Must include name in setControllerName call for URL %s.\",\n                   transaction.url)\n    } else {\n      logger.error(\"Must include name in setControllerName call.\")\n    }\n\n    return\n  }\n\n  action = action || transaction.verb || 'GET'\n  transaction.forceName = NAMES.CONTROLLER + '/' + name + '/' + action\n}\n\n/**\n * Add a custom parameter to the current transaction. Some parameters are\n * reserved (see CUSTOM_BLACKLIST for the current, very short list), and\n * as with most API methods, this must be called in the context of an\n * active transaction. Most recently set value wins.\n *\n * @param {string} name  The name you want displayed in the RPM UI.\n * @param {string} value The value you want displayed. Must be serializable.\n */\nAPI.prototype.addCustomParameter = function addCustomParameter(name, value) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addCustomParameter'\n  )\n  metric.incrementCallCount()\n\n  // If high security mode is on, custom params are disabled.\n  if (this.agent.config.high_security === true) {\n    logger.warnOnce(\n      \"Custom params\",\n      \"Custom parameters are disabled by high security mode.\"\n    )\n    return false\n  }\n\n  var ignored = this.agent.config.ignored_params || []\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found for custom parameters.\")\n  }\n\n  var trace = transaction.trace\n  if (!trace.custom) {\n    return logger.warn(\n      \"Couldn't add parameter %s to nonexistent custom parameters.\",\n      name\n    )\n  }\n\n  if (CUSTOM_BLACKLIST.indexOf(name) !== -1) {\n    return logger.warn(\"Not overwriting value of NR-only parameter %s.\", name)\n  }\n\n  if (ignored.indexOf(name) !== -1) {\n    return logger.warn(\"Not setting ignored parameter name %s.\", name)\n  }\n\n  if (name in trace.custom) {\n    logger.debug(\n      \"Changing custom parameter %s from %s to %s.\",\n      name,\n      trace.custom[name],\n      value\n    )\n  }\n\n  trace.custom[name] = value\n}\n\n/**\n * Adds all custom parameters in an object to the current transaction.\n *\n * See documentation for newrelic.addCustomParameter for more information on\n * setting custom parameters.\n *\n * An example of setting a custom parameter object:\n *\n *    newrelic.addCustomParameters({test: 'value', test2: 'value2'});\n *\n * @param {object} [params]\n * @param {string} [params.KEY] The name you want displayed in the RPM UI.\n * @param {string} [params.KEY.VALUE] The value you want displayed. Must be serializable.\n */\nAPI.prototype.addCustomParameters = function addCustomParameters(params) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addCustomParameters'\n  )\n  metric.incrementCallCount()\n\n  for (var key in params) {\n    if (!params.hasOwnProperty(key)) {\n      continue\n    }\n\n    this.addCustomParameter(key, params[key])\n  }\n}\n\n/**\n * Tell the tracer whether to ignore the current transaction. The most common\n * use for this will be to mark a transaction as ignored (maybe it's handling\n * a websocket polling channel, or maybe it's an external call you don't care\n * is slow), but it's also useful when you want a transaction that would\n * otherwise be ignored due to URL or transaction name normalization rules\n * to *not* be ignored.\n *\n * @param {boolean} ignored Ignore, or don't ignore, the current transaction.\n */\nAPI.prototype.setIgnoreTransaction = function setIgnoreTransaction(ignored) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setIgnoreTransaction'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found to ignore.\")\n  }\n\n  transaction.forceIgnore = ignored\n}\n\n/**\n * Send errors to New Relic that you've already handled yourself. Should\n * be an Error or one of its subtypes, but the API will handle strings\n * and objects that have an attached .message or .stack property.\n *\n * @param {Error}  error            The error to be traced.\n * @param {object} customParameters Any custom parameters to be displayed in\n *                                  the New Relic UI.\n */\nAPI.prototype.noticeError = function noticeError(error, customParameters) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/noticeError'\n  )\n  metric.incrementCallCount()\n\n\n  if (typeof error === 'string') error = new Error(error)\n  var transaction = this.agent.tracer.getTransaction()\n\n  this.agent.errors.addUserError(transaction, error, customParameters)\n}\n\n/**\n * If the URL for a transaction matches the provided pattern, name the\n * transaction with the provided name. If there are capture groups in the\n * pattern (which is a standard JavaScript regular expression, and can be\n * passed as either a RegExp or a string), then the substring matches ($1, $2,\n * etc.) are replaced in the name string. BE CAREFUL WHEN USING SUBSTITUTION.\n * If the replacement substrings are highly variable (i.e. are identifiers,\n * GUIDs, or timestamps), the rule will generate too many metrics and\n * potentially get your application blacklisted by New Relic.\n *\n * An example of a good rule with replacements:\n *\n *   newrelic.addNamingRule('^/storefront/(v[1-5])/(item|category|tag)',\n *                          'CommerceAPI/$1/$2')\n *\n * An example of a bad rule with replacements:\n *\n *   newrelic.addNamingRule('^/item/([0-9a-f]+)', 'Item/$1')\n *\n * Keep in mind that the original URL and any query parameters will be sent\n * along with the request, so slow transactions will still be identifiable.\n *\n * Naming rules can not be removed once added. They can also be added via the\n * agent's configuration. See configuration documentation for details.\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} name    The name to use for the transaction.\n */\nAPI.prototype.addNamingRule = function addNamingRule(pattern, name) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addNamingRule'\n  )\n  metric.incrementCallCount()\n\n\n  if (!name) return logger.error(\"Simple naming rules require a replacement name.\")\n\n  this.agent.userNormalizer.addSimple(pattern, '/' + name)\n}\n\n/**\n * If the URL for a transaction matches the provided pattern, ignore the\n * transaction attached to that URL. Useful for filtering socket.io connections\n * and other long-polling requests out of your agents to keep them from\n * distorting an app's apdex or mean response time. Pattern may be a (standard\n * JavaScript) RegExp or a string.\n *\n * Example:\n *\n *   newrelic.addIgnoringRule('^/socket\\\\.io/')\n *\n * @param {RegExp} pattern The pattern to ignore.\n */\nAPI.prototype.addIgnoringRule = function addIgnoringRule(pattern) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addIgnoringRule'\n  )\n  metric.incrementCallCount()\n\n  if (!pattern) return logger.error(\"Must include a URL pattern to ignore.\")\n\n  this.agent.userNormalizer.addSimple(pattern, null)\n}\n\n/**\n * Get the <script>...</script> header necessary for Browser Monitoring\n * This script must be manually injected into your templates, as high as possible\n * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.\n * Otherwise you may hurt IE!\n *\n * This method must be called _during_ a transaction, and must be called every\n * time you want to generate the headers.\n *\n * Do *not* reuse the headers between users, or even between requests.\n *\n * @returns {string} the <script> header to be injected\n */\nAPI.prototype.getBrowserTimingHeader = function getBrowserTimingHeader() {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/getBrowserTimingHeader'\n  )\n  metric.incrementCallCount()\n\n  var config = this.agent.config\n\n  /* Gracefully fail.\n   *\n   * Output an HTML comment and log a warning the comment is meant to be\n   * innocuous to the end user.\n   */\n  function _gracefail(num) {\n    logger.warn(RUM_ISSUES[num])\n    return '<!-- NREUM: (' + num + ') -->'\n  }\n\n  var browser_monitoring = config.browser_monitoring\n\n  // config.browser_monitoring should always exist, but we don't want the agent to bail\n  // here if something goes wrong\n  if (!browser_monitoring) return _gracefail(2)\n\n  /* Can control header generation with configuration this setting is only\n   * available in the newrelic.js config file, it is not ever set by the\n   * server.\n   */\n  if (!browser_monitoring.enable) return _gracefail(0)\n\n  var trans = this.agent.getTransaction()\n\n  // bail gracefully outside a transaction\n  if (!trans) return _gracefail(1)\n\n  var name = trans.getName()\n\n  /* If we're in an unnamed transaction, add a friendly warning this is to\n   * avoid people going crazy, trying to figure out why browser monitoring is\n   * not working when they're missing a transaction name.\n   */\n  if (!name) return _gracefail(3)\n\n  var time = trans.timer.getDurationInMillis()\n\n  /*\n   * Only the first 13 chars of the license should be used for hashing with\n   * the transaction name.\n   */\n  var key = config.license_key.substr(0, 13)\n  var appid = config.application_id\n\n  /* This is only going to work if the agent has successfully handshaked with\n   * the collector. If the networks is bad, or there is no license key set in\n   * newrelis.js, there will be no application_id set.  We bail instead of\n   * outputting null/undefined configuration values.\n   */\n  if (!appid) return _gracefail(4)\n\n  /* If there is no browser_key, the server has likely decided to disable\n   * browser monitoring.\n   */\n  var licenseKey = browser_monitoring.browser_key\n  if (!licenseKey) return _gracefail(5)\n\n  /* If there is no agent_loader script, there is no point\n   * in setting the rum data\n   */\n  var js_agent_loader = browser_monitoring.js_agent_loader\n  if (!js_agent_loader) return _gracefail(6)\n\n  /* If rum is enabled, but then later disabled on the server,\n   * this is the only parameter that gets updated.\n   *\n   * This condition should only be met if rum is disabled during\n   * the lifetime of an application, and it should be picked up\n   * on the next ForceRestart by the collector.\n   */\n  var loader = browser_monitoring.loader\n  if (loader === 'none') return _gracefail(7)\n\n  // This hash gets written directly into the browser.\n  var rum_hash = {\n    agent: browser_monitoring.js_agent_file,\n    beacon: browser_monitoring.beacon,\n    errorBeacon: browser_monitoring.error_beacon,\n    licenseKey: licenseKey,\n    applicationID: appid,\n    applicationTime: time,\n    transactionName: hashes.obfuscateNameUsingKey(name, key),\n    queueTime: trans.queueTime,\n    ttGuid: trans.id,\n\n    // we don't use these parameters yet\n    agentToken: null\n  }\n\n  // if debugging, do pretty format of JSON\n  var tabs = config.browser_monitoring.debug ? 2 : 0\n  var json = JSON.stringify(rum_hash, null, tabs)\n\n\n  // the complete header to be written to the browser\n  var out = util.format(\n    RUM_STUB,\n    json,\n    js_agent_loader\n  )\n\n  logger.trace('generating RUM header', out)\n\n  return out\n}\n\n/**\n * This creates a new tracer with the passed in name. It then wraps the\n * callback and binds it to the current transaction and segment so any further\n * custom instrumentation as well as auto instrumentation will also be able to\n * find the current transaction and segment.\n */\nAPI.prototype.createTracer = function createTracer(name, callback) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/createTracer'\n  )\n  metric.incrementCallCount()\n\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return callback\n  }\n\n  var fail = false\n  if (!name) {\n    logger.warn('createTracer called without a name')\n    fail = true\n  }\n\n  if (typeof callback !== 'function') {\n    logger.warn('createTracer called with a callback arg that is not a function')\n    fail = true\n  }\n\n  if (fail) {\n    // If name is undefined but callback is defined we should make a best effort\n    // to return it so things don't crash.\n    return callback\n  }\n\n  var tracer = this.agent.tracer\n  var txn = tracer.getTransaction()\n  if (!txn) {\n    logger.debug(\n      'createTracer called with %s (%s) outside of a transaction, ' +\n        'unable to create tracer.',\n      name,\n      callback && callback.name\n    )\n    return callback\n  }\n\n  logger.debug(\n    'creating tracer %s (%s) on transaction %s.',\n    name,\n    callback && callback.name,\n    txn.id\n  )\n\n  var segment = tracer.createSegment(name, customRecorder)\n  segment.start()\n  return tracer.bindFunction(callback, segment, true)\n}\n\n/**\n * Creates a function that represents a web transaction. It does not start the\n * transaction automatically - the returned function needs to be invoked to start it.\n * Inside the handler function, the transaction must be ended by calling endTransaction().\n *\n * @example\n * var newrelic = require('newrelic')\n * var transaction = newrelic.createWebTransaction('/some/url/path', function() {\n *   // do some work\n *   newrelic.endTransaction()\n * })\n *\n * @param {string}    url       The URL of the transaction.  It is used to name and group\n                                related transactions in APM, so it should be a generic\n                                name and not iclude any variable parameters.\n * @param {Function}  handle    Function that represents the transaction work.\n */\nAPI.prototype.createWebTransaction = function createWebTransaction(url, handle) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/createWebTransaction'\n  )\n  metric.incrementCallCount()\n\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return handle\n  }\n\n  var fail = false\n  if (!url) {\n    logger.warn('createWebTransaction called without an url')\n    fail = true\n  }\n\n  if (typeof handle !== 'function') {\n    logger.warn('createWebTransaction called with a handle arg that is not a function')\n    fail = true\n  }\n\n  if (fail) {\n    // If name is undefined but handle is defined we should make a best effort\n    // to return it so things don't crash.\n    return handle\n  }\n\n  logger.debug(\n    'creating web transaction generator %s (%s).',\n    url,\n    handle && handle.name\n  )\n\n  var tracer = this.agent.tracer\n\n  return tracer.transactionNestProxy('web', function createWebSegment() {\n    var tx = tracer.getTransaction()\n\n    logger.debug(\n      'creating web transaction %s (%s) with transaction id: %s',\n      url,\n      handle && handle.name,\n      tx.id\n    )\n    tx.nameState.setName(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url)\n    tx.url = url\n    tx.applyUserNamingRules(tx.url)\n    tx.webSegment = tracer.createSegment(url, recordWeb)\n    tx.webSegment.start()\n\n    return tracer.bindFunction(handle, tx.webSegment).apply(this, arguments)\n  })\n}\n\n/**\n * Creates a function that represents a background transaction. It does not start the\n * transaction automatically - the returned function needs to be invoked to start it.\n * Inside the handler function, the transaction must be ended by calling endTransaction().\n *\n * @example\n * var newrelic = require('newrelic')\n * var transaction = newrelic.createBackgroundTransaction('myTransaction', function() {\n *   // do some work\n *   newrelic.endTransaction()\n * })\n *\n * @param {string}    name      The name of the transaction.  It is used to name and group\n                                related transactions in APM, so it should be a generic\n                                name and not iclude any variable parameters.\n * @param {string}    [group]   Optional, used for grouping background transactions in\n *                              APM.  For more information see:\n *                              https://docs.newrelic.com/docs/apm/applications-menu/monitoring/transactions-page#txn-type-dropdown\n * @param {Function}  handle    Function that represents the background work.\n */\nAPI.prototype.createBackgroundTransaction = createBackgroundTransaction\n\nfunction createBackgroundTransaction(name, group, handle) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/createBackgroundTransaction'\n  )\n  metric.incrementCallCount()\n\n  if (handle === undefined && typeof group === 'function') {\n    handle = group\n    group = 'Nodejs'\n  }\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return handle\n  }\n\n  var fail = false\n  if (!name) {\n    logger.warn('createBackgroundTransaction called without an url')\n    fail = true\n  }\n\n  if (typeof handle !== 'function') {\n    logger.warn(\n      'createBackgroundTransaction called with a handle arg that is not a function'\n    )\n    fail = true\n  }\n\n  if (fail) {\n    // If name is undefined but handle is defined we should make a best effort\n    // to return it so things don't crash.\n    return handle\n  }\n\n  logger.debug(\n    'creating background transaction generator %s:%s (%s)',\n    name,\n    group,\n    handle && handle.name\n  )\n\n  var tracer = this.agent.tracer\n\n  return tracer.transactionNestProxy('bg', function createBackgroundSegment() {\n    var tx = tracer.getTransaction()\n\n    logger.debug(\n      'creating background transaction %s:%s (%s) with transaction id: %s',\n      name,\n      group,\n      handle && handle.name,\n      tx.id\n    )\n\n    tx.setBackgroundName(name, group)\n    tx.bgSegment = tracer.createSegment(name, recordBackground)\n    tx.bgSegment.partialName = group\n    tx.bgSegment.start()\n\n    return tracer.bindFunction(handle, tx.bgSegment).apply(this, arguments)\n  })\n}\n\nAPI.prototype.endTransaction = function endTransaction() {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/endTransaction'\n  )\n  metric.incrementCallCount()\n\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return\n  }\n\n  var tracer = this.agent.tracer\n  var tx = tracer.getTransaction()\n\n  if (tx) {\n    if (tx.webSegment) {\n      tx.setName(tx.url, 0)\n      tx.webSegment.markAsWeb(tx.url)\n      tx.webSegment.end()\n    } else if (tx.bgSegment) {\n      tx.bgSegment.end()\n    }\n    logger.debug('ending transaction with id: %s and name: %s', tx.id, tx.name)\n    tx.end()\n  } else {\n    logger.debug('endTransaction() called while not in a transaction.')\n  }\n}\n\nAPI.prototype.recordMetric = function recordMetric(name, value) {\n  var supportMetric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/recordMetric'\n  )\n  supportMetric.incrementCallCount()\n\n  // FLAG: custom_metrics\n  if (!this.agent.config.feature_flag.custom_metrics) {\n    return\n  }\n\n  if (typeof name !== 'string') {\n    logger.warn('Metric name must be a string')\n    return\n  }\n\n  var metric = this.agent.metrics.getOrCreateMetric(name)\n\n  if (typeof value === 'number') {\n    metric.recordValue(value)\n    return\n  }\n\n  if (typeof value !== 'object') {\n    logger.warn('Metric value must be either a number, or a metric object')\n    return\n  }\n\n  var stats = {}\n  var required = ['count', 'total', 'min', 'max', 'sumOfSquares']\n  var keyMap = {count: 'callCount'}\n\n  for (var i = 0, l = required.length; i < l; ++i) {\n    if (typeof value[required[i]] !== 'number') {\n      logger.warn('Metric object must include ' + required[i] + ' as a number')\n      return\n    }\n\n    var key = keyMap[required[i]] || required[i]\n    stats[key] = value[required[i]]\n  }\n\n  if (typeof value.totalExclusive === 'number') {\n    stats.totalExclusive = value.totalExclusive\n  } else {\n    stats.totalExclusive = value.total\n  }\n\n  metric.merge(stats)\n}\n\nAPI.prototype.incrementMetric = function incrementMetric(name, value) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/incrementMetric'\n  )\n  metric.incrementCallCount()\n\n  // FLAG: custom_metrics\n  if (!this.agent.config.feature_flag.custom_metrics) {\n    return\n  }\n\n  if (!value && value !== 0) {\n    value = 1\n  }\n\n  if (typeof value !== 'number' || value % 1 !== 0) {\n    logger.warn('Metric Increment value must be an integer')\n    return\n  }\n\n  this.recordMetric(name, {\n    count: value,\n    total: 0,\n    min: 0,\n    max: 0,\n    sumOfSquares: 0\n  })\n}\n\nAPI.prototype.recordCustomEvent = function recordCustomEvent(eventType, attributes) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/recordCustomEvent'\n  )\n  metric.incrementCallCount()\n\n  if (!this.agent.config.custom_insights_events.enabled) {\n    return\n  }\n  // Check all the arguments before bailing to give maximum information in a\n  // single invocation.\n  var fail = false\n\n  if (!eventType || typeof eventType !== 'string') {\n    logger.warn(\n      'recordCustomEvent requires a string for its first argument, got %s (%s)',\n      stringify(eventType),\n      typeof eventType\n    )\n    fail = true\n  } else if (!CUSTOM_EVENT_TYPE_REGEX.test(eventType)) {\n    logger.warn(\n      'recordCustomEvent eventType of %s is invalid, it must match /%s/',\n      eventType,\n      CUSTOM_EVENT_TYPE_REGEX.source\n    )\n    fail = true\n  } else if (eventType.length > 255) {\n    logger.warn(\n      'recordCustomEvent eventType must have a length less than 256, got %s (%s)',\n      eventType,\n      eventType.length\n    )\n    fail = true\n  }\n  // If they don't pass an attributes object, or the attributes argument is not\n  // an object, or if it is an object and but is actually an array, log a\n  // warning and set the fail bit.\n  if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n    logger.warn(\n      'recordCustomEvent requires an object for its second argument, got %s (%s)',\n      stringify(attributes),\n      typeof attributes\n    )\n    fail = true\n  } else if (_checkKeyLength(attributes, 255)) {\n    fail = true\n  }\n\n  if (fail) {\n    return\n  }\n\n  var instrinics = {\n    type: eventType,\n    timestamp: Date.now()\n  }\n\n  this.agent.customEvents.add([instrinics, attributes])\n}\n\n/**\n * Shuts down the agent.\n *\n * @param {object}  [options]                           object with shut down options\n * @param {boolean} [options.collectPendingData=false]  If true, the agent will send any\n *                                                      pending data to the collector\n *                                                      before shutting down.\n * @param {number}  [options.timeout]                   time in ms to wait before\n *                                                      shutting down\n * @param {function} [callback]                         callback function that runs when\n *                                                      agent stopped\n */\nAPI.prototype.shutdown = function shutdown(options, cb) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/shutdown'\n  )\n  metric.incrementCallCount()\n\n  var callback = cb\n  if (!callback) {\n    if (typeof options === 'function') {\n      callback = options\n    } else {\n      callback = function noop() {}\n    }\n  }\n\n  var agent = this.agent\n\n  function cb_harvest(error) {\n    if (error) {\n      logger.error(\n        error,\n        'An error occurred while running last harvest before shutdown.'\n      )\n    }\n    agent.stop(callback)\n  }\n\n  if (options && options.collectPendingData && agent._state !== 'started') {\n    if (typeof options.timeout === 'number') {\n      var shutdownTimeout = setTimeout(function shutdownTimeout() {\n        agent.stop(callback)\n      }, options.timeout)\n      // timer.unref only in 0.9+\n      if (shutdownTimeout.unref) {\n        shutdownTimeout.unref()\n      }\n    } else if (options.timeout) {\n      logger.warn(\n        'options.timeout should be of type \"number\". Got %s',\n        typeof options.timeout\n      )\n    }\n\n    agent.on('started', function shutdownHarvest() {\n      agent.harvest(cb_harvest)\n    })\n    agent.on('errored', function logShutdownError(error) {\n      agent.stop(callback)\n      if (error) {\n        logger.error(\n          error,\n          'The agent encountered an error after calling shutdown.'\n        )\n      }\n    })\n  } else if (options && options.collectPendingData) {\n    agent.harvest(cb_harvest)\n  } else {\n    agent.stop(callback)\n  }\n}\n\nfunction _checkKeyLength(object, maxLength) {\n  var keys = Object.keys(object)\n  var badKey = false\n  var len = keys.length\n  var key = '' // init to string because gotta go fast\n  for (var i = 0; i < len; i++) {\n    key = keys[i]\n    if (key.length > maxLength) {\n      logger.warn(\n        'recordCustomEvent requires keys to be less than 256 chars got %s (%s)',\n        key,\n        key.length\n      )\n      badKey = true\n    }\n  }\n  return badKey\n}\n\nmodule.exports = API\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/api.js\n// module id = 241\n// module chunks = 0","'use strict'\n\nvar logger = require('./lib/logger.js')\nvar RealAPI = require('./api.js')\n\n\n/* eslint-disable no-eval */\nfunction stubFunction(name) {\n  return eval(\"(function () {return function \" + name + \"() {\" +\n              \"logger.debug('Not calling \" + name + \" because New Relic is disabled.');\" +\n              \"}}())\")\n}\n/* eslint-enable no-eval */\n\nfunction Stub() {}\n\nvar keys = Object.keys(RealAPI.prototype)\nvar length = keys.length\n\n\n/* This way the stub API doesn't have to be updated in lockstep with the regular\n * API.\n */\nfor (var i = 0; i < length; i++) {\n  var functionName = keys[i]\n  Stub.prototype[functionName] = stubFunction(functionName)\n}\n\nStub.prototype.createTracer = createTracer\nStub.prototype.createWebTransaction = createWebTransaction\nStub.prototype.createBackgroundTransaction = createBackgroundTransaction\nStub.prototype.getBrowserTimingHeader = getBrowserTimingHeader\nStub.prototype.shutdown = shutdown\n\n// This code gets injected into HTML templates\n// and we don't want it to return undefined/null.\nfunction getBrowserTimingHeader() {\n  logger.debug('Not calling getBrowserTimingHeader because New Relic is disabled.')\n  return ''\n}\n\n// Normally the following 3 calls return a wrapped callback, instead we\n// should just return the callback in its unwrapped state.\nfunction createTracer(name, callback) {\n  logger.debug('Not calling createTracer because New Relic is disabled.')\n  return callback\n}\n\nfunction createWebTransaction(url, callback) {\n  logger.debug('Not calling createWebTransaction because New Relic is disabled.')\n  return callback\n}\n\nfunction createBackgroundTransaction(name, group, callback) {\n  logger.debug('Not calling createBackgroundTransaction because New Relic is disabled.')\n  return (callback === undefined) ? group : callback\n}\n\n// Normally the following call executes callback asynchronously\nfunction shutdown(options, cb) {\n  logger.debug('Not calling shutdown because New Relic is disabled.')\n  \n  var callback = cb\n  if (!callback) {\n    if (typeof options === 'function') {\n      callback = options\n    } else {\n      callback = new Function()\n    }\n  }\n  \n  process.nextTick(callback)\n}\n\nmodule.exports = Stub\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/newrelic/stub_api.js\n// module id = 242\n// module chunks = 0"],"sourceRoot":""}